{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * @learncard/auth-types\n *\n * Provider-agnostic interfaces for authentication and key derivation.\n * This package has zero dependencies and contains only TypeScript types\n * plus the AuthSessionError class.\n *\n * Both @learncard/sss-key-manager and learn-card-base import from here,\n * ensuring a single canonical source for abstract interfaces without\n * coupling consumers to any specific implementation.\n */\n\n// ---------------------------------------------------------------------------\n// Auth Session Error\n// ---------------------------------------------------------------------------\n\n/**\n * Typed error for auth session issues.\n * Auth providers should throw this (instead of generic Error) when the\n * session is expired, revoked, or missing so the coordinator can\n * distinguish \"not logged in\" from \"unexpected failure\".\n */\nexport class AuthSessionError extends Error {\n    constructor(\n        message: string,\n        public readonly reason: 'expired' | 'no_session' | 'revoked' | 'network'\n    ) {\n        super(message);\n        this.name = 'AuthSessionError';\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Auth Provider\n// ---------------------------------------------------------------------------\n\n/**\n * Auth provider identifier. Known values: 'firebase', 'supertokens', 'keycloak', 'oidc'.\n * Use any string to support custom auth providers without modifying this type.\n */\nexport type AuthProviderType = string;\n\nexport interface AuthUser {\n    id: string;\n    email?: string;\n    phone?: string;\n    providerType: AuthProviderType;\n\n    /** Account creation timestamp (when available from the auth provider) */\n    createdAt?: Date;\n}\n\n/**\n * Abstract auth provider interface.\n * Implementations wrap a specific auth SDK (Firebase, Supertokens, etc.)\n * and expose a uniform API to the coordinator.\n */\nexport interface AuthProvider {\n    getIdToken(): Promise<string>;\n    getCurrentUser(): Promise<AuthUser | null>;\n    getProviderType(): AuthProviderType;\n    signOut(): Promise<void>;\n}\n\n// ---------------------------------------------------------------------------\n// Recovery (generic)\n// ---------------------------------------------------------------------------\n\n/**\n * Recovery method metadata returned by the server.\n * The `type` is a string so strategies can define their own method types\n * without modifying this interface.\n */\nexport interface RecoveryMethodInfo {\n    type: string;\n    createdAt: Date;\n    credentialId?: string;\n}\n\n/**\n * Generic result of a successful recovery execution.\n * All strategies must produce a private key + DID.\n */\nexport interface RecoveryResult {\n    privateKey: string;\n    did: string;\n}\n\n// ---------------------------------------------------------------------------\n// Server Key Status\n// ---------------------------------------------------------------------------\n\n/**\n * Server key status returned by the strategy's fetchServerKeyStatus.\n * The strategy owns the server shape \u2014 different strategies may\n * have fundamentally different server payloads.\n */\nexport interface ServerKeyStatus {\n    exists: boolean;\n    needsMigration: boolean;\n    primaryDid: string | null;\n    recoveryMethods: RecoveryMethodInfo[];\n    authShare: string | null;\n}\n\n// ---------------------------------------------------------------------------\n// Key Derivation Strategy (generic)\n// ---------------------------------------------------------------------------\n\n/**\n * Key Derivation Strategy\n *\n * Abstract interface for different key derivation implementations.\n * Used by AuthCoordinator to delegate key operations.\n *\n * The strategy owns:\n * - Local key storage\n * - Key splitting and reconstruction\n * - Server communication for remote key components\n * - Recovery method execution and setup\n * - Storage cleanup knowledge\n *\n * Type parameters allow each strategy to define its own recovery shapes:\n * - TRecoveryInput: what the user provides to recover (e.g., password, passkey)\n * - TRecoverySetupInput: what the user provides to set up a recovery method\n * - TRecoverySetupResult: what setup returns (e.g., generated phrase, credential ID)\n *\n * @example\n * // SSS strategy with specific recovery types:\n * type SSSStrategy = KeyDerivationStrategy<SSSRecoveryInput, SSSRecoverySetupInput, SSSRecoverySetupResult>;\n *\n * // Simple strategy with no recovery:\n * type SimpleStrategy = KeyDerivationStrategy<never, never, never>;\n */\nexport interface KeyDerivationStrategy<\n    TRecoveryInput = unknown,\n    TRecoverySetupInput = unknown,\n    TRecoverySetupResult = unknown,\n> {\n    readonly name: string;\n\n    // --- Key lifecycle ---\n\n    /** Check if there's a local key component (e.g., device share) */\n    hasLocalKey(): Promise<boolean>;\n\n    /** Get the local key component */\n    getLocalKey(): Promise<string | null>;\n\n    /** Store a local key component */\n    storeLocalKey(key: string): Promise<void>;\n\n    /** Clear all local key data */\n    clearLocalKeys(): Promise<void>;\n\n    /** Split a private key into shares/components */\n    splitKey(privateKey: string): Promise<{ localKey: string; remoteKey: string }>;\n\n    /** Reconstruct private key from components */\n    reconstructKey(localKey: string, remoteKey: string): Promise<string>;\n\n    /** Verify that stored keys can reconstruct the expected DID */\n    verifyKeys?(\n        localKey: string,\n        remoteKey: string,\n        expectedDid: string,\n        didFromPrivateKey: (pk: string) => Promise<string>\n    ): Promise<boolean>;\n\n    // --- Server communication ---\n\n    /** Fetch the server-side key status for the authenticated user */\n    fetchServerKeyStatus(token: string, providerType: AuthProviderType): Promise<ServerKeyStatus>;\n\n    /** Store the remote key component on the server */\n    storeAuthShare(token: string, providerType: AuthProviderType, remoteKey: string, did: string, didAuthVp?: string): Promise<void>;\n\n    /** Mark migration complete on the server (optional \u2014 only needed for migration-capable strategies) */\n    markMigrated?(token: string, providerType: AuthProviderType, didAuthVp?: string): Promise<void>;\n\n    // --- Recovery ---\n\n    /** Execute a recovery flow and return the recovered private key + DID */\n    executeRecovery(params: {\n        token: string;\n        providerType: AuthProviderType;\n        input: TRecoveryInput;\n        /** Optional: validate the reconstructed key's DID before rotating shares */\n        didFromPrivateKey?: (privateKey: string) => Promise<string>;\n        /** Optional: sign a DID-Auth VP JWT for server write operations */\n        signDidAuthVp?: (privateKey: string) => Promise<string>;\n    }): Promise<RecoveryResult>;\n\n    /** Set up a new recovery method */\n    setupRecoveryMethod?(params: {\n        token: string;\n        providerType: AuthProviderType;\n        privateKey: string;\n        input: TRecoverySetupInput;\n        authUser?: AuthUser;\n        /** Optional: sign a DID-Auth VP JWT for server write operations */\n        signDidAuthVp?: (privateKey: string) => Promise<string>;\n    }): Promise<TRecoverySetupResult>;\n\n    /** Get configured recovery methods for the authenticated user */\n    getAvailableRecoveryMethods?(token: string, providerType: AuthProviderType): Promise<RecoveryMethodInfo[]>;\n\n    // --- Email backup ---\n\n    /**\n     * Send a backup share to the user's email for fail-safe recovery.\n     * Called by the coordinator after key setup or migration.\n     * Implementation should be fire-and-forget (non-fatal on failure).\n     *\n     * @param token - Auth token for server communication\n     * @param providerType - Auth provider type\n     * @param privateKey - The private key to derive the email share from\n     * @param email - Destination email address\n     */\n    sendEmailBackupShare?(\n        token: string,\n        providerType: AuthProviderType,\n        privateKey: string,\n        email: string\n    ): Promise<void>;\n\n    // --- User scoping ---\n\n    /**\n     * Inform the strategy which user is active so it can scope local storage\n     * (e.g., device shares) per-user. Called by the coordinator after\n     * authentication, before any local-key operations.\n     *\n     * Strategies that don't need per-user scoping can omit this method.\n     *\n     * @param userId - Stable, unique identifier for the authenticated user\n     *                 (e.g., Firebase UID). Must NOT change across sessions.\n     */\n    setActiveUser?(userId: string): void;\n\n    // --- Cleanup ---\n\n    /** Return storage keys (e.g., IndexedDB database names) that should be preserved during logout */\n    getPreservedStorageKeys(): string[];\n\n    /** Strategy-specific cleanup beyond clearLocalKeys (optional) */\n    cleanup?(): Promise<void>;\n}\n"],
  "mappings": ";;;;AAsBO,IAAM,mBAAN,cAA+B,MAAM;AAAA,EACxC,YACI,SACgB,QAClB;AACE,UAAM,OAAO;AAFG;AAGhB,SAAK,OAAO;AAAA,EAChB;AAAA,EA7BJ,OAsB4C;AAAA;AAAA;AAQ5C;",
  "names": []
}
