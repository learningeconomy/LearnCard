{
  "version": 3,
  "sources": ["../src/index.ts", "../src/types.ts", "../src/plugin.ts"],
  "sourcesContent": ["export { openBadgeV2Plugin } from './plugin';\nexport * from './types';\n", "import { Plugin } from '@learncard/core';\nimport { VC } from '@learncard/types';\nimport { VCPluginMethods } from '@learncard/vc-plugin';\n\nexport type OpenBadgeV2PluginMethods = {\n    /**\n     * Wrap a legacy OpenBadge v2.0 assertion (object or URL) into a self-issued VC\n     */\n    wrapOpenBadgeV2: (obv2Assertion: object | string) => Promise<VC>;\n};\n\nexport type OpenBadgeV2Plugin = Plugin<'OpenBadgeV2', any, OpenBadgeV2PluginMethods, 'id', VCPluginMethods>;\n\nexport const OBV2_WRAPPER_CONTEXT_URL = 'https://docs.learncard.com/wrappers/obv2/1.0.0.json';\n\nexport type RequiresVC = VCPluginMethods;\n", "import { LearnCard } from '@learncard/core';\nimport { UnsignedVC, VC } from '@learncard/types';\nimport { VCPluginMethods } from '@learncard/vc-plugin';\n\nimport {\n    OpenBadgeV2Plugin,\n    OpenBadgeV2PluginMethods,\n    OBV2_WRAPPER_CONTEXT_URL,\n} from './types';\n\nconst VC_V2_CONTEXT = 'https://www.w3.org/ns/credentials/v2';\n\nconst isUrl = (value: string): boolean =>\n    /^(https?:)?\\/\\//i.test(value) || value.startsWith('ipfs://') || value.startsWith('ipns://');\n\nasync function getObv2Assertion(input: object | string): Promise<Record<string, any>> {\n    if (typeof input === 'string') {\n        // Treat string as URL. If it looks like raw JSON, try to parse for developer ergonomics\n        const trimmed = input.trim();\n        if (!isUrl(trimmed) && (trimmed.startsWith('{') || trimmed.startsWith('['))) {\n            try {\n                return JSON.parse(trimmed);\n            } catch (e) {\n                throw new Error('wrapOpenBadgeV2: Provided string is not a valid URL or JSON');\n            }\n        }\n\n        const res = await fetch(trimmed);\n        if (!res.ok) throw new Error(`wrapOpenBadgeV2: Failed to fetch OBv2 assertion: ${res.status}`);\n\n        return await res.json();\n    }\n\n    return input as Record<string, any>;\n}\n\nfunction validateObv2(obv2: Record<string, any>): void {\n    if (!obv2 || typeof obv2 !== 'object') throw new Error('wrapOpenBadgeV2: Missing assertion');\n\n    const id = obv2.id;\n    if (typeof id !== 'string' || !id.length) throw new Error('wrapOpenBadgeV2: assertion.id is required');\n\n    const t = obv2.type;\n    const hasAssertionType =\n        (typeof t === 'string' && t === 'Assertion') ||\n        (Array.isArray(t) && t.includes('Assertion'));\n    if (!hasAssertionType) throw new Error(\"wrapOpenBadgeV2: assertion.type must include 'Assertion'\");\n\n    if (!obv2.issuedOn || typeof obv2.issuedOn !== 'string') {\n        throw new Error('wrapOpenBadgeV2: assertion.issuedOn (string) is required');\n    }\n}\n\nexport const openBadgeV2Plugin = (\n    learnCard: LearnCard<any, 'id', VCPluginMethods>\n): OpenBadgeV2Plugin => ({\n    name: 'OpenBadgeV2',\n    displayName: 'OpenBadge v2 Wrapper',\n    description: 'Wrap legacy OpenBadge v2.0 assertions into self-issued Verifiable Credentials',\n    methods: {\n        wrapOpenBadgeV2: async (\n            _learnCard,\n            obv2Assertion: object | string\n        ): Promise<VC> => {\n            const issuerDid = learnCard.id.did();\n\n            const obv2 = await getObv2Assertion(obv2Assertion);\n            validateObv2(obv2);\n\n            const unsigned: UnsignedVC = {\n                '@context': [VC_V2_CONTEXT, OBV2_WRAPPER_CONTEXT_URL],\n                id: `urn:uuid:${crypto.randomUUID()}`,\n                type: ['VerifiableCredential', 'LegacyOpenBadgeCredential'],\n                issuer: issuerDid,\n                validFrom: new Date().toISOString(),\n                credentialSubject: {\n                    id: issuerDid,\n                    legacyAssertion: obv2,\n                },\n            };\n\n            return learnCard.invoke.issueCredential(unsigned, { proofPurpose: 'assertionMethod' });\n        },\n    },\n});\n"],
  "mappings": "4dAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,8BAAAE,EAAA,sBAAAC,IAAA,eAAAC,EAAAJ,GCaO,IAAMK,EAA2B,sDCHxC,IAAMC,EAAgB,uCAEhBC,EAAQC,EAACC,GACX,mBAAmB,KAAKA,CAAK,GAAKA,EAAM,WAAW,SAAS,GAAKA,EAAM,WAAW,SAAS,EADjF,SAGd,eAAeC,EAAiBC,EAAsD,CAClF,GAAI,OAAOA,GAAU,SAAU,CAE3B,IAAMC,EAAUD,EAAM,KAAK,EAC3B,GAAI,CAACJ,EAAMK,CAAO,IAAMA,EAAQ,WAAW,GAAG,GAAKA,EAAQ,WAAW,GAAG,GACrE,GAAI,CACA,OAAO,KAAK,MAAMA,CAAO,CAC7B,MAAE,CACE,MAAM,IAAI,MAAM,6DAA6D,CACjF,CAGJ,IAAMC,EAAM,MAAM,MAAMD,CAAO,EAC/B,GAAI,CAACC,EAAI,GAAI,MAAM,IAAI,MAAM,oDAAoDA,EAAI,QAAQ,EAE7F,OAAO,MAAMA,EAAI,KAAK,CAC1B,CAEA,OAAOF,CACX,CAnBeH,EAAAE,EAAA,oBAqBf,SAASI,EAAaC,EAAiC,CACnD,GAAI,CAACA,GAAQ,OAAOA,GAAS,SAAU,MAAM,IAAI,MAAM,oCAAoC,EAE3F,IAAMC,EAAKD,EAAK,GAChB,GAAI,OAAOC,GAAO,UAAY,CAACA,EAAG,OAAQ,MAAM,IAAI,MAAM,2CAA2C,EAErG,IAAM,EAAID,EAAK,KAIf,GAAI,EAFC,OAAO,GAAM,UAAY,IAAM,aAC/B,MAAM,QAAQ,CAAC,GAAK,EAAE,SAAS,WAAW,GACxB,MAAM,IAAI,MAAM,0DAA0D,EAEjG,GAAI,CAACA,EAAK,UAAY,OAAOA,EAAK,UAAa,SAC3C,MAAM,IAAI,MAAM,0DAA0D,CAElF,CAfSP,EAAAM,EAAA,gBAiBF,IAAMG,EAAoBT,EAC7BU,IACqB,CACrB,KAAM,cACN,YAAa,uBACb,YAAa,gFACb,QAAS,CACL,gBAAiB,MACbC,EACAC,IACc,CACd,IAAMC,EAAYH,EAAU,GAAG,IAAI,EAE7BH,EAAO,MAAML,EAAiBU,CAAa,EACjDN,EAAaC,CAAI,EAEjB,IAAMO,EAAuB,CACzB,WAAY,CAAChB,EAAeiB,CAAwB,EACpD,GAAI,YAAY,OAAO,WAAW,IAClC,KAAM,CAAC,uBAAwB,2BAA2B,EAC1D,OAAQF,EACR,UAAW,IAAI,KAAK,EAAE,YAAY,EAClC,kBAAmB,CACf,GAAIA,EACJ,gBAAiBN,CACrB,CACJ,EAEA,OAAOG,EAAU,OAAO,gBAAgBI,EAAU,CAAE,aAAc,iBAAkB,CAAC,CACzF,CACJ,CACJ,GA/BiC",
  "names": ["src_exports", "__export", "OBV2_WRAPPER_CONTEXT_URL", "openBadgeV2Plugin", "__toCommonJS", "OBV2_WRAPPER_CONTEXT_URL", "VC_V2_CONTEXT", "isUrl", "__name", "value", "getObv2Assertion", "input", "trimmed", "res", "validateObv2", "obv2", "id", "openBadgeV2Plugin", "learnCard", "_learnCard", "obv2Assertion", "issuerDid", "unsigned", "OBV2_WRAPPER_CONTEXT_URL"]
}
