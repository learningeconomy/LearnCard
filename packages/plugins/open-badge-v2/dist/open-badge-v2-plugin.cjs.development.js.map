{
  "version": 3,
  "sources": ["../src/index.ts", "../src/types.ts", "../src/plugin.ts"],
  "sourcesContent": ["export { openBadgeV2Plugin } from './plugin';\nexport * from './types';\n", "import { Plugin } from '@learncard/core';\nimport { VC } from '@learncard/types';\nimport { VCPluginMethods } from '@learncard/vc-plugin';\n\nexport type OpenBadgeV2PluginMethods = {\n    /**\n     * Wrap a legacy OpenBadge v2.0 assertion (object or URL) into a self-issued VC\n     */\n    wrapOpenBadgeV2: (obv2Assertion: object | string) => Promise<VC>;\n};\n\nexport type OpenBadgeV2Plugin = Plugin<'OpenBadgeV2', any, OpenBadgeV2PluginMethods, 'id', VCPluginMethods>;\n\nexport const OBV2_WRAPPER_CONTEXT_URL = 'https://docs.learncard.com/wrappers/obv2/1.0.0.json';\n\nexport type RequiresVC = VCPluginMethods;\n", "import { LearnCard } from '@learncard/core';\nimport { UnsignedVC, VC } from '@learncard/types';\nimport { VCPluginMethods } from '@learncard/vc-plugin';\n\nimport {\n    OpenBadgeV2Plugin,\n    OpenBadgeV2PluginMethods,\n    OBV2_WRAPPER_CONTEXT_URL,\n} from './types';\n\nconst VC_V2_CONTEXT = 'https://www.w3.org/ns/credentials/v2';\n\nconst isUrl = (value: string): boolean =>\n    /^(https?:)?\\/\\//i.test(value) || value.startsWith('ipfs://') || value.startsWith('ipns://');\n\nasync function getObv2Assertion(input: object | string): Promise<Record<string, any>> {\n    if (typeof input === 'string') {\n        // Treat string as URL. If it looks like raw JSON, try to parse for developer ergonomics\n        const trimmed = input.trim();\n        if (!isUrl(trimmed) && (trimmed.startsWith('{') || trimmed.startsWith('['))) {\n            try {\n                return JSON.parse(trimmed);\n            } catch (e) {\n                throw new Error('wrapOpenBadgeV2: Provided string is not a valid URL or JSON');\n            }\n        }\n\n        const res = await fetch(trimmed);\n        if (!res.ok) throw new Error(`wrapOpenBadgeV2: Failed to fetch OBv2 assertion: ${res.status}`);\n\n        return await res.json();\n    }\n\n    return input as Record<string, any>;\n}\n\nfunction validateObv2(obv2: Record<string, any>): void {\n    if (!obv2 || typeof obv2 !== 'object') throw new Error('wrapOpenBadgeV2: Missing assertion');\n\n    const id = obv2.id;\n    if (typeof id !== 'string' || !id.length) throw new Error('wrapOpenBadgeV2: assertion.id is required');\n\n    const t = obv2.type;\n    const hasAssertionType =\n        (typeof t === 'string' && t === 'Assertion') ||\n        (Array.isArray(t) && t.includes('Assertion'));\n    if (!hasAssertionType) throw new Error(\"wrapOpenBadgeV2: assertion.type must include 'Assertion'\");\n\n    if (!obv2.issuedOn || typeof obv2.issuedOn !== 'string') {\n        throw new Error('wrapOpenBadgeV2: assertion.issuedOn (string) is required');\n    }\n}\n\nexport const openBadgeV2Plugin = (\n    learnCard: LearnCard<any, 'id', VCPluginMethods>\n): OpenBadgeV2Plugin => ({\n    name: 'OpenBadgeV2',\n    displayName: 'OpenBadge v2 Wrapper',\n    description: 'Wrap legacy OpenBadge v2.0 assertions into self-issued Verifiable Credentials',\n    methods: {\n        wrapOpenBadgeV2: async (\n            _learnCard,\n            obv2Assertion: object | string\n        ): Promise<VC> => {\n            const issuerDid = learnCard.id.did();\n\n            const obv2 = await getObv2Assertion(obv2Assertion);\n            validateObv2(obv2);\n\n            const unsigned: UnsignedVC = {\n                '@context': [VC_V2_CONTEXT, OBV2_WRAPPER_CONTEXT_URL],\n                id: `urn:uuid:${crypto.randomUUID()}`,\n                type: ['VerifiableCredential', 'LegacyOpenBadgeCredential'],\n                issuer: issuerDid,\n                validFrom: new Date().toISOString(),\n                credentialSubject: {\n                    id: issuerDid,\n                    legacyAssertion: obv2,\n                },\n            };\n\n            return learnCard.invoke.issueCredential(unsigned, { proofPurpose: 'assertionMethod' });\n        },\n    },\n});\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACaO,IAAM,2BAA2B;;;ACHxC,IAAM,gBAAgB;AAEtB,IAAM,QAAQ,wBAAC,UACX,mBAAmB,KAAK,KAAK,KAAK,MAAM,WAAW,SAAS,KAAK,MAAM,WAAW,SAAS,GADjF;AAGd,eAAe,iBAAiB,OAAsD;AAClF,MAAI,OAAO,UAAU,UAAU;AAE3B,UAAM,UAAU,MAAM,KAAK;AAC3B,QAAI,CAAC,MAAM,OAAO,MAAM,QAAQ,WAAW,GAAG,KAAK,QAAQ,WAAW,GAAG,IAAI;AACzE,UAAI;AACA,eAAO,KAAK,MAAM,OAAO;AAAA,MAC7B,SAAS,GAAP;AACE,cAAM,IAAI,MAAM,6DAA6D;AAAA,MACjF;AAAA,IACJ;AAEA,UAAM,MAAM,MAAM,MAAM,OAAO;AAC/B,QAAI,CAAC,IAAI;AAAI,YAAM,IAAI,MAAM,oDAAoD,IAAI,QAAQ;AAE7F,WAAO,MAAM,IAAI,KAAK;AAAA,EAC1B;AAEA,SAAO;AACX;AAnBe;AAqBf,SAAS,aAAa,MAAiC;AACnD,MAAI,CAAC,QAAQ,OAAO,SAAS;AAAU,UAAM,IAAI,MAAM,oCAAoC;AAE3F,QAAM,KAAK,KAAK;AAChB,MAAI,OAAO,OAAO,YAAY,CAAC,GAAG;AAAQ,UAAM,IAAI,MAAM,2CAA2C;AAErG,QAAM,IAAI,KAAK;AACf,QAAM,mBACD,OAAO,MAAM,YAAY,MAAM,eAC/B,MAAM,QAAQ,CAAC,KAAK,EAAE,SAAS,WAAW;AAC/C,MAAI,CAAC;AAAkB,UAAM,IAAI,MAAM,0DAA0D;AAEjG,MAAI,CAAC,KAAK,YAAY,OAAO,KAAK,aAAa,UAAU;AACrD,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC9E;AACJ;AAfS;AAiBF,IAAM,oBAAoB,wBAC7B,eACqB;AAAA,EACrB,MAAM;AAAA,EACN,aAAa;AAAA,EACb,aAAa;AAAA,EACb,SAAS;AAAA,IACL,iBAAiB,OACb,YACA,kBACc;AACd,YAAM,YAAY,UAAU,GAAG,IAAI;AAEnC,YAAM,OAAO,MAAM,iBAAiB,aAAa;AACjD,mBAAa,IAAI;AAEjB,YAAM,WAAuB;AAAA,QACzB,YAAY,CAAC,eAAe,wBAAwB;AAAA,QACpD,IAAI,YAAY,OAAO,WAAW;AAAA,QAClC,MAAM,CAAC,wBAAwB,2BAA2B;AAAA,QAC1D,QAAQ;AAAA,QACR,WAAW,IAAI,KAAK,EAAE,YAAY;AAAA,QAClC,mBAAmB;AAAA,UACf,IAAI;AAAA,UACJ,iBAAiB;AAAA,QACrB;AAAA,MACJ;AAEA,aAAO,UAAU,OAAO,gBAAgB,UAAU,EAAE,cAAc,kBAAkB,CAAC;AAAA,IACzF;AAAA,EACJ;AACJ,IA/BiC;",
  "names": []
}
