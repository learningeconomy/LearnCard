"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key3 of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to, key3) && key3 !== except)
        __defProp(to, key3, { get: () => from4[key3], enumerable: !(desc = __getOwnPropDesc(from4, key3)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// ../../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    __name(pd, "pd");
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    __name(setCancelFlag, "setCancelFlag");
    function Event2(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i3 = 0; i3 < keys.length; ++i3) {
        const key3 = keys[i3];
        if (!(key3 in this)) {
          Object.defineProperty(this, key3, defineRedirectDescriptor(key3));
        }
      }
    }
    __name(Event2, "Event");
    Event2.prototype = {
      get type() {
        return pd(this).event.type;
      },
      get target() {
        return pd(this).eventTarget;
      },
      get currentTarget() {
        return pd(this).currentTarget;
      },
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      get NONE() {
        return 0;
      },
      get CAPTURING_PHASE() {
        return 1;
      },
      get AT_TARGET() {
        return 2;
      },
      get BUBBLING_PHASE() {
        return 3;
      },
      get eventPhase() {
        return pd(this).eventPhase;
      },
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      preventDefault() {
        setCancelFlag(pd(this));
      },
      get defaultPrevented() {
        return pd(this).canceled;
      },
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      get timeStamp() {
        return pd(this).timeStamp;
      },
      get srcElement() {
        return pd(this).eventTarget;
      },
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      initEvent() {
      }
    };
    Object.defineProperty(Event2.prototype, "constructor", {
      value: Event2,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event2.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event2);
    }
    function defineRedirectDescriptor(key3) {
      return {
        get() {
          return pd(this).event[key3];
        },
        set(value) {
          pd(this).event[key3] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    __name(defineRedirectDescriptor, "defineRedirectDescriptor");
    function defineCallDescriptor(key3) {
      return {
        value() {
          const event = pd(this).event;
          return event[key3].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    __name(defineCallDescriptor, "defineCallDescriptor");
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      __name(CustomEvent, "CustomEvent");
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i3 = 0; i3 < keys.length; ++i3) {
        const key3 = keys[i3];
        if (!(key3 in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key3);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key3,
            isFunc ? defineCallDescriptor(key3) : defineRedirectDescriptor(key3)
          );
        }
      }
      return CustomEvent;
    }
    __name(defineWrapper, "defineWrapper");
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event2;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    __name(getWrapper, "getWrapper");
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    __name(wrapEvent, "wrapEvent");
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    __name(isStopped, "isStopped");
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    __name(setEventPhase, "setEventPhase");
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    __name(setCurrentTarget, "setCurrentTarget");
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    __name(setPassiveListener, "setPassiveListener");
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x2) {
      return x2 !== null && typeof x2 === "object";
    }
    __name(isObject, "isObject");
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    __name(getListeners, "getListeners");
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener2) {
          if (typeof listener2 !== "function" && !isObject(listener2)) {
            listener2 = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener2 !== null) {
            const newNode = {
              listener: listener2,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    __name(defineEventAttributeDescriptor, "defineEventAttributeDescriptor");
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    __name(defineEventAttribute, "defineEventAttribute");
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      __name(CustomEventTarget, "CustomEventTarget");
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i3 = 0; i3 < eventNames.length; ++i3) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i3]);
      }
      return CustomEventTarget;
    }
    __name(defineCustomEventTarget, "defineCustomEventTarget");
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i3 = 0; i3 < arguments.length; ++i3) {
          types[i3] = arguments[i3];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    __name(EventTarget, "EventTarget");
    EventTarget.prototype = {
      addEventListener(eventName, listener2, options) {
        if (listener2 == null) {
          return;
        }
        if (typeof listener2 !== "function" && !isObject(listener2)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener: listener2,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener2 && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      removeEventListener(eventName, listener2, options) {
        if (listener2 == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener2 && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal2 = class extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    __name(AbortSignal2, "AbortSignal");
    eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    __name(createAbortSignal, "createAbortSignal");
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    __name(abortSignal, "abortSignal");
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController3 = class {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    };
    __name(AbortController3, "AbortController");
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    __name(getSignal, "getSignal");
    Object.defineProperties(AbortController3.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController3.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController3;
    exports.AbortSignal = AbortSignal2;
    exports.default = AbortController3;
    module2.exports = AbortController3;
    module2.exports.AbortController = module2.exports["default"] = AbortController3;
    module2.exports.AbortSignal = AbortSignal2;
  }
});

// ../../../node_modules/.pnpm/cross-fetch@3.1.5/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "../../../node_modules/.pnpm/cross-fetch@3.1.5/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      __name(F, "F");
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        __name(isDataView, "isDataView");
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name3) {
          if (typeof name3 !== "string") {
            name3 = String(name3);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name3)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name3.toLowerCase();
        }
        __name(normalizeName, "normalizeName");
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        __name(normalizeValue, "normalizeValue");
        function iteratorFor(items) {
          var iterator2 = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator2[Symbol.iterator] = function() {
              return iterator2;
            };
          }
          return iterator2;
        }
        __name(iteratorFor, "iteratorFor");
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name3) {
              this.append(name3, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name3) {
              this.append(name3, headers[name3]);
            }, this);
          }
        }
        __name(Headers2, "Headers");
        Headers2.prototype.append = function(name3, value) {
          name3 = normalizeName(name3);
          value = normalizeValue(value);
          var oldValue = this.map[name3];
          this.map[name3] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name3) {
          delete this.map[normalizeName(name3)];
        };
        Headers2.prototype.get = function(name3) {
          name3 = normalizeName(name3);
          return this.has(name3) ? this.map[name3] : null;
        };
        Headers2.prototype.has = function(name3) {
          return this.map.hasOwnProperty(normalizeName(name3));
        };
        Headers2.prototype.set = function(name3, value) {
          this.map[normalizeName(name3)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name3 in this.map) {
            if (this.map.hasOwnProperty(name3)) {
              callback.call(thisArg, this.map[name3], name3, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name3) {
            items.push(name3);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name3) {
            items.push([name3, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        __name(consumed, "consumed");
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        __name(fileReaderReady, "fileReaderReady");
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        __name(readBlobAsArrayBuffer, "readBlobAsArrayBuffer");
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        __name(readBlobAsText, "readBlobAsText");
        function readArrayBufferAsText(buf2) {
          var view = new Uint8Array(buf2);
          var chars = new Array(view.length);
          for (var i3 = 0; i3 < view.length; i3++) {
            chars[i3] = String.fromCharCode(view[i3]);
          }
          return chars.join("");
        }
        __name(readArrayBufferAsText, "readArrayBufferAsText");
        function bufferClone(buf2) {
          if (buf2.slice) {
            return buf2.slice(0);
          } else {
            var view = new Uint8Array(buf2.byteLength);
            view.set(new Uint8Array(buf2));
            return view.buffer;
          }
        }
        __name(bufferClone, "bufferClone");
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode13);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        __name(Body, "Body");
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        __name(normalizeMethod, "normalizeMethod");
        function Request2(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        __name(Request2, "Request");
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode13(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name3 = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name3), decodeURIComponent(value));
            }
          });
          return form;
        }
        __name(decode13, "decode");
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key3 = parts.shift().trim();
            if (key3) {
              var value = parts.join(":").trim();
              headers.append(key3, value);
            }
          });
          return headers;
        }
        __name(parseHeaders, "parseHeaders");
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        __name(Response2, "Response");
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name3) {
            this.message = message;
            this.name = name3;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init4) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init4);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            __name(abortXhr, "abortXhr");
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response2(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name3) {
              xhr.setRequestHeader(name3, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        __name(fetch3, "fetch");
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers2;
          self2.Request = Request2;
          self2.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// (disabled):../../../node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "(disabled):../../../node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js"() {
  }
});

// ../../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js"(exports, module2) {
    (function(module3, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      __name(assert3, "assert");
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = /* @__PURE__ */ __name(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      __name(inherits, "inherits");
      function BN4(number, base4, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base4 === "le" || base4 === "be") {
            endian = base4;
            base4 = 10;
          }
          this._init(number || 0, base4 || 10, endian || "be");
        }
      }
      __name(BN4, "BN");
      if (typeof module3 === "object") {
        module3.exports = BN4;
      } else {
        exports2.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e2) {
      }
      BN4.isBN = /* @__PURE__ */ __name(function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      }, "isBN");
      BN4.max = /* @__PURE__ */ __name(function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, "max");
      BN4.min = /* @__PURE__ */ __name(function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, "min");
      BN4.prototype._init = /* @__PURE__ */ __name(function init4(number, base4, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base4, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base4, endian);
        }
        if (base4 === "hex") {
          base4 = 16;
        }
        assert3(base4 === (base4 | 0) && base4 >= 2 && base4 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base4 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base4, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base4, endian);
            }
          }
        }
      }, "init");
      BN4.prototype._initNumber = /* @__PURE__ */ __name(function _initNumber(number, base4, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base4, endian);
      }, "_initNumber");
      BN4.prototype._initArray = /* @__PURE__ */ __name(function _initArray(number, base4, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j, w2;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j = 0; i3 >= 0; i3 -= 3) {
            w2 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j = 0; i3 < number.length; i3 += 3) {
            w2 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      }, "_initArray");
      function parseHex4Bits(string2, index) {
        var c2 = string2.charCodeAt(index);
        if (c2 >= 48 && c2 <= 57) {
          return c2 - 48;
        } else if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          assert3(false, "Invalid character in " + string2);
        }
      }
      __name(parseHex4Bits, "parseHex4Bits");
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      __name(parseHexByte, "parseHexByte");
      BN4.prototype._parseHex = /* @__PURE__ */ __name(function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var off = 0;
        var j = 0;
        var w2;
        if (endian === "be") {
          for (i3 = number.length - 1; i3 >= start; i3 -= 2) {
            w2 = parseHexByte(number, start, i3) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number.length; i3 += 2) {
            w2 = parseHexByte(number, start, i3) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      }, "_parseHex");
      function parseBase(str, start, end, mul4) {
        var r2 = 0;
        var b2 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c2 = str.charCodeAt(i3) - 48;
          r2 *= mul4;
          if (c2 >= 49) {
            b2 = c2 - 49 + 10;
          } else if (c2 >= 17) {
            b2 = c2 - 17 + 10;
          } else {
            b2 = c2;
          }
          assert3(c2 >= 0 && b2 < mul4, "Invalid character");
          r2 += b2;
        }
        return r2;
      }
      __name(parseBase, "parseBase");
      BN4.prototype._parseBase = /* @__PURE__ */ __name(function _parseBase(number, base4, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base4) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base4 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base4);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base4);
          for (i3 = 0; i3 < mod2; i3++) {
            pow *= base4;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      }, "_parseBase");
      BN4.prototype.copy = /* @__PURE__ */ __name(function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      }, "copy");
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      __name(move, "move");
      BN4.prototype._move = /* @__PURE__ */ __name(function _move(dest) {
        move(dest, this);
      }, "_move");
      BN4.prototype.clone = /* @__PURE__ */ __name(function clone() {
        var r2 = new BN4(null);
        this.copy(r2);
        return r2;
      }, "clone");
      BN4.prototype._expand = /* @__PURE__ */ __name(function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      }, "_expand");
      BN4.prototype._strip = /* @__PURE__ */ __name(function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      }, "strip");
      BN4.prototype._normSign = /* @__PURE__ */ __name(function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      }, "_normSign");
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN4.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect5;
        } catch (e2) {
          BN4.prototype.inspect = inspect5;
        }
      } else {
        BN4.prototype.inspect = inspect5;
      }
      function inspect5() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      __name(inspect5, "inspect");
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = /* @__PURE__ */ __name(function toString6(base4, padding2) {
        base4 = base4 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base4 === 16 || base4 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w2 = this.words[i3];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base4 === (base4 | 0) && base4 >= 2 && base4 <= 36) {
          var groupSize = groupSizes[base4];
          var groupBase = groupBases[base4];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modrn(groupBase).toString(base4);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      }, "toString");
      BN4.prototype.toNumber = /* @__PURE__ */ __name(function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      }, "toNumber");
      BN4.prototype.toJSON = /* @__PURE__ */ __name(function toJSON3() {
        return this.toString(16, 2);
      }, "toJSON");
      if (Buffer2) {
        BN4.prototype.toBuffer = /* @__PURE__ */ __name(function toBuffer(endian, length2) {
          return this.toArrayLike(Buffer2, endian, length2);
        }, "toBuffer");
      }
      BN4.prototype.toArray = /* @__PURE__ */ __name(function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      }, "toArray");
      var allocate = /* @__PURE__ */ __name(function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      }, "allocate");
      BN4.prototype.toArrayLike = /* @__PURE__ */ __name(function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      }, "toArrayLike");
      BN4.prototype._toArrayLikeLE = /* @__PURE__ */ __name(function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
          var word = this.words[i3] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      }, "_toArrayLikeLE");
      BN4.prototype._toArrayLikeBE = /* @__PURE__ */ __name(function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
          var word = this.words[i3] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      }, "_toArrayLikeBE");
      if (Math.clz32) {
        BN4.prototype._countBits = /* @__PURE__ */ __name(function _countBits(w2) {
          return 32 - Math.clz32(w2);
        }, "_countBits");
      } else {
        BN4.prototype._countBits = /* @__PURE__ */ __name(function _countBits(w2) {
          var t2 = w2;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        }, "_countBits");
      }
      BN4.prototype._zeroBits = /* @__PURE__ */ __name(function _zeroBits(w2) {
        if (w2 === 0)
          return 26;
        var t2 = w2;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      }, "_zeroBits");
      BN4.prototype.bitLength = /* @__PURE__ */ __name(function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      }, "bitLength");
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = num.words[off] >>> wbit & 1;
        }
        return w2;
      }
      __name(toBitArray, "toBitArray");
      BN4.prototype.zeroBits = /* @__PURE__ */ __name(function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b2 = this._zeroBits(this.words[i3]);
          r2 += b2;
          if (b2 !== 26)
            break;
        }
        return r2;
      }, "zeroBits");
      BN4.prototype.byteLength = /* @__PURE__ */ __name(function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, "byteLength");
      BN4.prototype.toTwos = /* @__PURE__ */ __name(function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      }, "toTwos");
      BN4.prototype.fromTwos = /* @__PURE__ */ __name(function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      }, "fromTwos");
      BN4.prototype.isNeg = /* @__PURE__ */ __name(function isNeg() {
        return this.negative !== 0;
      }, "isNeg");
      BN4.prototype.neg = /* @__PURE__ */ __name(function neg4() {
        return this.clone().ineg();
      }, "neg");
      BN4.prototype.ineg = /* @__PURE__ */ __name(function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      }, "ineg");
      BN4.prototype.iuor = /* @__PURE__ */ __name(function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this._strip();
      }, "iuor");
      BN4.prototype.ior = /* @__PURE__ */ __name(function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      }, "ior");
      BN4.prototype.or = /* @__PURE__ */ __name(function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, "or");
      BN4.prototype.uor = /* @__PURE__ */ __name(function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, "uor");
      BN4.prototype.iuand = /* @__PURE__ */ __name(function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i3 = 0; i3 < b2.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b2.length;
        return this._strip();
      }, "iuand");
      BN4.prototype.iand = /* @__PURE__ */ __name(function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      }, "iand");
      BN4.prototype.and = /* @__PURE__ */ __name(function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, "and");
      BN4.prototype.uand = /* @__PURE__ */ __name(function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, "uand");
      BN4.prototype.iuxor = /* @__PURE__ */ __name(function iuxor(num) {
        var a3;
        var b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        for (var i3 = 0; i3 < b2.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b2.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this._strip();
      }, "iuxor");
      BN4.prototype.ixor = /* @__PURE__ */ __name(function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }, "ixor");
      BN4.prototype.xor = /* @__PURE__ */ __name(function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, "xor");
      BN4.prototype.uxor = /* @__PURE__ */ __name(function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, "uxor");
      BN4.prototype.inotn = /* @__PURE__ */ __name(function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      }, "inotn");
      BN4.prototype.notn = /* @__PURE__ */ __name(function notn(width) {
        return this.clone().inotn(width);
      }, "notn");
      BN4.prototype.setn = /* @__PURE__ */ __name(function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      }, "setn");
      BN4.prototype.iadd = /* @__PURE__ */ __name(function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a3, b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b2.length; i3++) {
          r2 = (a3.words[i3] | 0) + (b2.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r2 = (a3.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      }, "iadd");
      BN4.prototype.add = /* @__PURE__ */ __name(function add4(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, "add");
      BN4.prototype.isub = /* @__PURE__ */ __name(function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b2;
        if (cmp > 0) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b2.length; i3++) {
          r2 = (a3.words[i3] | 0) - (b2.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r2 = (a3.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this._strip();
      }, "isub");
      BN4.prototype.sub = /* @__PURE__ */ __name(function sub(num) {
        return this.clone().isub(num);
      }, "sub");
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a3 * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i3 = k2 - j | 0;
            a3 = self2.words[i3] | 0;
            b2 = num.words[j] | 0;
            r2 = a3 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      __name(smallMulTo, "smallMulTo");
      var comb10MulTo = /* @__PURE__ */ __name(function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c2 !== 0) {
          o[19] = c2;
          out.length++;
        }
        return out;
      }, "comb10MulTo");
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i3 = k2 - j;
            var a3 = self2.words[i3] | 0;
            var b2 = num.words[j] | 0;
            var r2 = a3 * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      __name(bigMulTo, "bigMulTo");
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      __name(jumboMulTo, "jumboMulTo");
      BN4.prototype.mulTo = /* @__PURE__ */ __name(function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      }, "mulTo");
      function FFTM(x2, y3) {
        this.x = x2;
        this.y = y3;
      }
      __name(FFTM, "FFTM");
      FFTM.prototype.makeRBT = /* @__PURE__ */ __name(function makeRBT(N10) {
        var t2 = new Array(N10);
        var l = BN4.prototype._countBits(N10) - 1;
        for (var i3 = 0; i3 < N10; i3++) {
          t2[i3] = this.revBin(i3, l, N10);
        }
        return t2;
      }, "makeRBT");
      FFTM.prototype.revBin = /* @__PURE__ */ __name(function revBin(x2, l, N10) {
        if (x2 === 0 || x2 === N10 - 1)
          return x2;
        var rb = 0;
        for (var i3 = 0; i3 < l; i3++) {
          rb |= (x2 & 1) << l - i3 - 1;
          x2 >>= 1;
        }
        return rb;
      }, "revBin");
      FFTM.prototype.permute = /* @__PURE__ */ __name(function permute(rbt, rws, iws, rtws, itws, N10) {
        for (var i3 = 0; i3 < N10; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      }, "permute");
      FFTM.prototype.transform = /* @__PURE__ */ __name(function transform(rws, iws, rtws, itws, N10, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N10);
        for (var s3 = 1; s3 < N10; s3 <<= 1) {
          var l = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N10; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s3; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s3];
              var io = itws[p + j + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s3] = re - ro;
              itws[p + j + s3] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      }, "transform");
      FFTM.prototype.guessLen13b = /* @__PURE__ */ __name(function guessLen13b(n, m3) {
        var N10 = Math.max(m3, n) | 1;
        var odd = N10 & 1;
        var i3 = 0;
        for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      }, "guessLen13b");
      FFTM.prototype.conjugate = /* @__PURE__ */ __name(function conjugate(rws, iws, N10) {
        if (N10 <= 1)
          return;
        for (var i3 = 0; i3 < N10 / 2; i3++) {
          var t2 = rws[i3];
          rws[i3] = rws[N10 - i3 - 1];
          rws[N10 - i3 - 1] = t2;
          t2 = iws[i3];
          iws[i3] = -iws[N10 - i3 - 1];
          iws[N10 - i3 - 1] = -t2;
        }
      }, "conjugate");
      FFTM.prototype.normalize13b = /* @__PURE__ */ __name(function normalize13b(ws, N10) {
        var carry = 0;
        for (var i3 = 0; i3 < N10 / 2; i3++) {
          var w2 = Math.round(ws[2 * i3 + 1] / N10) * 8192 + Math.round(ws[2 * i3] / N10) + carry;
          ws[i3] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      }, "normalize13b");
      FFTM.prototype.convert13b = /* @__PURE__ */ __name(function convert13b(ws, len, rws, N10) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N10; ++i3) {
          rws[i3] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      }, "convert13b");
      FFTM.prototype.stub = /* @__PURE__ */ __name(function stub(N10) {
        var ph = new Array(N10);
        for (var i3 = 0; i3 < N10; i3++) {
          ph[i3] = 0;
        }
        return ph;
      }, "stub");
      FFTM.prototype.mulp = /* @__PURE__ */ __name(function mulp(x2, y3, out) {
        var N10 = 2 * this.guessLen13b(x2.length, y3.length);
        var rbt = this.makeRBT(N10);
        var _ = this.stub(N10);
        var rws = new Array(N10);
        var rwst = new Array(N10);
        var iwst = new Array(N10);
        var nrws = new Array(N10);
        var nrwst = new Array(N10);
        var niwst = new Array(N10);
        var rmws = out.words;
        rmws.length = N10;
        this.convert13b(x2.words, x2.length, rws, N10);
        this.convert13b(y3.words, y3.length, nrws, N10);
        this.transform(rws, _, rwst, iwst, N10, rbt);
        this.transform(nrws, _, nrwst, niwst, N10, rbt);
        for (var i3 = 0; i3 < N10; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N10);
        this.transform(rwst, iwst, rmws, _, N10, rbt);
        this.conjugate(rmws, _, N10);
        this.normalize13b(rmws, N10);
        out.negative = x2.negative ^ y3.negative;
        out.length = x2.length + y3.length;
        return out._strip();
      }, "mulp");
      BN4.prototype.mul = /* @__PURE__ */ __name(function mul4(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }, "mul");
      BN4.prototype.mulf = /* @__PURE__ */ __name(function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }, "mulf");
      BN4.prototype.imul = /* @__PURE__ */ __name(function imul(num) {
        return this.clone().mulTo(num, this);
      }, "imul");
      BN4.prototype.imuln = /* @__PURE__ */ __name(function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w2 = (this.words[i3] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      }, "imuln");
      BN4.prototype.muln = /* @__PURE__ */ __name(function muln(num) {
        return this.clone().imuln(num);
      }, "muln");
      BN4.prototype.sqr = /* @__PURE__ */ __name(function sqr() {
        return this.mul(this);
      }, "sqr");
      BN4.prototype.isqr = /* @__PURE__ */ __name(function isqr() {
        return this.imul(this.clone());
      }, "isqr");
      BN4.prototype.pow = /* @__PURE__ */ __name(function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0)
          return new BN4(1);
        var res = this;
        for (var i3 = 0; i3 < w2.length; i3++, res = res.sqr()) {
          if (w2[i3] !== 0)
            break;
        }
        if (++i3 < w2.length) {
          for (var q2 = res.sqr(); i3 < w2.length; i3++, q2 = q2.sqr()) {
            if (w2[i3] === 0)
              continue;
            res = res.mul(q2);
          }
        }
        return res;
      }, "pow");
      BN4.prototype.iushln = /* @__PURE__ */ __name(function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s3 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i3;
        if (r2 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c2 = (this.words[i3] | 0) - newCarry << r2;
            this.words[i3] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s3] = this.words[i3];
          }
          for (i3 = 0; i3 < s3; i3++) {
            this.words[i3] = 0;
          }
          this.length += s3;
        }
        return this._strip();
      }, "iushln");
      BN4.prototype.ishln = /* @__PURE__ */ __name(function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      }, "ishln");
      BN4.prototype.iushrn = /* @__PURE__ */ __name(function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r2 = bits % 26;
        var s3 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h3 -= s3;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i3 = 0; i3 < s3; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      }, "iushrn");
      BN4.prototype.ishrn = /* @__PURE__ */ __name(function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }, "ishrn");
      BN4.prototype.shln = /* @__PURE__ */ __name(function shln(bits) {
        return this.clone().ishln(bits);
      }, "shln");
      BN4.prototype.ushln = /* @__PURE__ */ __name(function ushln(bits) {
        return this.clone().iushln(bits);
      }, "ushln");
      BN4.prototype.shrn = /* @__PURE__ */ __name(function shrn(bits) {
        return this.clone().ishrn(bits);
      }, "shrn");
      BN4.prototype.ushrn = /* @__PURE__ */ __name(function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, "ushrn");
      BN4.prototype.testn = /* @__PURE__ */ __name(function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s3 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s3)
          return false;
        var w2 = this.words[s3];
        return !!(w2 & q2);
      }, "testn");
      BN4.prototype.imaskn = /* @__PURE__ */ __name(function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s3 = (bits - r2) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r2 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      }, "imaskn");
      BN4.prototype.maskn = /* @__PURE__ */ __name(function maskn(bits) {
        return this.clone().imaskn(bits);
      }, "maskn");
      BN4.prototype.iaddn = /* @__PURE__ */ __name(function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      }, "iaddn");
      BN4.prototype._iaddn = /* @__PURE__ */ __name(function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      }, "_iaddn");
      BN4.prototype.isubn = /* @__PURE__ */ __name(function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this._strip();
      }, "isubn");
      BN4.prototype.addn = /* @__PURE__ */ __name(function addn(num) {
        return this.clone().iaddn(num);
      }, "addn");
      BN4.prototype.subn = /* @__PURE__ */ __name(function subn(num) {
        return this.clone().isubn(num);
      }, "subn");
      BN4.prototype.iabs = /* @__PURE__ */ __name(function iabs() {
        this.negative = 0;
        return this;
      }, "iabs");
      BN4.prototype.abs = /* @__PURE__ */ __name(function abs2() {
        return this.clone().iabs();
      }, "abs");
      BN4.prototype._ishlnsubmul = /* @__PURE__ */ __name(function _ishlnsubmul(num, mul4, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w2 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul4;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w2 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w2 = (this.words[i3 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i3 + shift] = w2 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w2 = -(this.words[i3] | 0) + carry;
          carry = w2 >> 26;
          this.words[i3] = w2 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      }, "_ishlnsubmul");
      BN4.prototype._wordDiv = /* @__PURE__ */ __name(function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a3.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m3 = a3.length - b2.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN4(null);
          q2.length = m3 + 1;
          q2.words = new Array(q2.length);
          for (var i3 = 0; i3 < q2.length; i3++) {
            q2.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b2, 1, m3);
        if (diff.negative === 0) {
          a3 = diff;
          if (q2) {
            q2.words[m3] = 1;
          }
        }
        for (var j = m3 - 1; j >= 0; j--) {
          var qj = (a3.words[b2.length + j] | 0) * 67108864 + (a3.words[b2.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b2, qj, j);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b2, 1, j);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j] = qj;
          }
        }
        if (q2) {
          q2._strip();
        }
        a3._strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a3
        };
      }, "_wordDiv");
      BN4.prototype.divmod = /* @__PURE__ */ __name(function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      }, "divmod");
      BN4.prototype.div = /* @__PURE__ */ __name(function div(num) {
        return this.divmod(num, "div", false).div;
      }, "div");
      BN4.prototype.mod = /* @__PURE__ */ __name(function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      }, "mod");
      BN4.prototype.umod = /* @__PURE__ */ __name(function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, "umod");
      BN4.prototype.divRound = /* @__PURE__ */ __name(function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, "divRound");
      BN4.prototype.modrn = /* @__PURE__ */ __name(function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p * acc + (this.words[i3] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      }, "modrn");
      BN4.prototype.modn = /* @__PURE__ */ __name(function modn(num) {
        return this.modrn(num);
      }, "modn");
      BN4.prototype.idivn = /* @__PURE__ */ __name(function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w2 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w2 / num | 0;
          carry = w2 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      }, "idivn");
      BN4.prototype.divn = /* @__PURE__ */ __name(function divn(num) {
        return this.clone().idivn(num);
      }, "divn");
      BN4.prototype.egcd = /* @__PURE__ */ __name(function egcd(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var x2 = this;
        var y3 = p.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p);
        } else {
          x2 = x2.clone();
        }
        var A = new BN4(1);
        var B2 = new BN4(0);
        var C = new BN4(0);
        var D2 = new BN4(1);
        var g2 = 0;
        while (x2.isEven() && y3.isEven()) {
          x2.iushrn(1);
          y3.iushrn(1);
          ++g2;
        }
        var yp = y3.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i3 = 0, im = 1; (x2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x2.iushrn(i3);
            while (i3-- > 0) {
              if (A.isOdd() || B2.isOdd()) {
                A.iadd(yp);
                B2.isub(xp);
              }
              A.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y3.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y3.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D2.isOdd()) {
                C.iadd(yp);
                D2.isub(xp);
              }
              C.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y3) >= 0) {
            x2.isub(y3);
            A.isub(C);
            B2.isub(D2);
          } else {
            y3.isub(x2);
            C.isub(A);
            D2.isub(B2);
          }
        }
        return {
          a: C,
          b: D2,
          gcd: y3.iushln(g2)
        };
      }, "egcd");
      BN4.prototype._invmp = /* @__PURE__ */ __name(function _invmp(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var a3 = this;
        var b2 = p.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN4(1);
        var x2 = new BN4(0);
        var delta = b2.clone();
        while (a3.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b2.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a3.cmp(b2) >= 0) {
            a3.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a3);
            x2.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      }, "_invmp");
      BN4.prototype.gcd = /* @__PURE__ */ __name(function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b2 = num.clone();
        a3.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a3.isEven() && b2.isEven(); shift++) {
          a3.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a3.cmp(b2);
          if (r2 < 0) {
            var t2 = a3;
            a3 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a3.isub(b2);
        } while (true);
        return b2.iushln(shift);
      }, "gcd");
      BN4.prototype.invm = /* @__PURE__ */ __name(function invm(num) {
        return this.egcd(num).a.umod(num);
      }, "invm");
      BN4.prototype.isEven = /* @__PURE__ */ __name(function isEven() {
        return (this.words[0] & 1) === 0;
      }, "isEven");
      BN4.prototype.isOdd = /* @__PURE__ */ __name(function isOdd() {
        return (this.words[0] & 1) === 1;
      }, "isOdd");
      BN4.prototype.andln = /* @__PURE__ */ __name(function andln(num) {
        return this.words[0] & num;
      }, "andln");
      BN4.prototype.bincn = /* @__PURE__ */ __name(function bincn(bit) {
        assert3(typeof bit === "number");
        var r2 = bit % 26;
        var s3 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q2;
          return this;
        }
        var carry = q2;
        for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
          var w2 = this.words[i3] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i3] = w2;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      }, "bincn");
      BN4.prototype.isZero = /* @__PURE__ */ __name(function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, "isZero");
      BN4.prototype.cmpn = /* @__PURE__ */ __name(function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmpn");
      BN4.prototype.cmp = /* @__PURE__ */ __name(function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmp");
      BN4.prototype.ucmp = /* @__PURE__ */ __name(function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b2 = num.words[i3] | 0;
          if (a3 === b2)
            continue;
          if (a3 < b2) {
            res = -1;
          } else if (a3 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      }, "ucmp");
      BN4.prototype.gtn = /* @__PURE__ */ __name(function gtn(num) {
        return this.cmpn(num) === 1;
      }, "gtn");
      BN4.prototype.gt = /* @__PURE__ */ __name(function gt(num) {
        return this.cmp(num) === 1;
      }, "gt");
      BN4.prototype.gten = /* @__PURE__ */ __name(function gten(num) {
        return this.cmpn(num) >= 0;
      }, "gten");
      BN4.prototype.gte = /* @__PURE__ */ __name(function gte(num) {
        return this.cmp(num) >= 0;
      }, "gte");
      BN4.prototype.ltn = /* @__PURE__ */ __name(function ltn(num) {
        return this.cmpn(num) === -1;
      }, "ltn");
      BN4.prototype.lt = /* @__PURE__ */ __name(function lt(num) {
        return this.cmp(num) === -1;
      }, "lt");
      BN4.prototype.lten = /* @__PURE__ */ __name(function lten(num) {
        return this.cmpn(num) <= 0;
      }, "lten");
      BN4.prototype.lte = /* @__PURE__ */ __name(function lte(num) {
        return this.cmp(num) <= 0;
      }, "lte");
      BN4.prototype.eqn = /* @__PURE__ */ __name(function eqn(num) {
        return this.cmpn(num) === 0;
      }, "eqn");
      BN4.prototype.eq = /* @__PURE__ */ __name(function eq5(num) {
        return this.cmp(num) === 0;
      }, "eq");
      BN4.red = /* @__PURE__ */ __name(function red(num) {
        return new Red(num);
      }, "red");
      BN4.prototype.toRed = /* @__PURE__ */ __name(function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      }, "toRed");
      BN4.prototype.fromRed = /* @__PURE__ */ __name(function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      }, "fromRed");
      BN4.prototype._forceRed = /* @__PURE__ */ __name(function _forceRed(ctx) {
        this.red = ctx;
        return this;
      }, "_forceRed");
      BN4.prototype.forceRed = /* @__PURE__ */ __name(function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      }, "forceRed");
      BN4.prototype.redAdd = /* @__PURE__ */ __name(function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      }, "redAdd");
      BN4.prototype.redIAdd = /* @__PURE__ */ __name(function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      }, "redIAdd");
      BN4.prototype.redSub = /* @__PURE__ */ __name(function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      }, "redSub");
      BN4.prototype.redISub = /* @__PURE__ */ __name(function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      }, "redISub");
      BN4.prototype.redShl = /* @__PURE__ */ __name(function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      }, "redShl");
      BN4.prototype.redMul = /* @__PURE__ */ __name(function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      }, "redMul");
      BN4.prototype.redIMul = /* @__PURE__ */ __name(function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      }, "redIMul");
      BN4.prototype.redSqr = /* @__PURE__ */ __name(function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      }, "redSqr");
      BN4.prototype.redISqr = /* @__PURE__ */ __name(function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      }, "redISqr");
      BN4.prototype.redSqrt = /* @__PURE__ */ __name(function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      }, "redSqrt");
      BN4.prototype.redInvm = /* @__PURE__ */ __name(function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      }, "redInvm");
      BN4.prototype.redNeg = /* @__PURE__ */ __name(function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      }, "redNeg");
      BN4.prototype.redPow = /* @__PURE__ */ __name(function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      }, "redPow");
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name3, p) {
        this.name = name3;
        this.p = new BN4(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      __name(MPrime, "MPrime");
      MPrime.prototype._tmp = /* @__PURE__ */ __name(function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      }, "_tmp");
      MPrime.prototype.ireduce = /* @__PURE__ */ __name(function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      }, "ireduce");
      MPrime.prototype.split = /* @__PURE__ */ __name(function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, "split");
      MPrime.prototype.imulK = /* @__PURE__ */ __name(function imulK(num) {
        return num.imul(this.k);
      }, "imulK");
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      __name(K256, "K256");
      inherits(K256, MPrime);
      K256.prototype.split = /* @__PURE__ */ __name(function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      }, "split");
      K256.prototype.imulK = /* @__PURE__ */ __name(function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w2 = num.words[i3] | 0;
          lo += w2 * 977;
          num.words[i3] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      }, "imulK");
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      __name(P224, "P224");
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      __name(P192, "P192");
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      __name(P25519, "P25519");
      inherits(P25519, MPrime);
      P25519.prototype.imulK = /* @__PURE__ */ __name(function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      }, "imulK");
      BN4._prime = /* @__PURE__ */ __name(function prime(name3) {
        if (primes[name3])
          return primes[name3];
        var prime2;
        if (name3 === "k256") {
          prime2 = new K256();
        } else if (name3 === "p224") {
          prime2 = new P224();
        } else if (name3 === "p192") {
          prime2 = new P192();
        } else if (name3 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name3);
        }
        primes[name3] = prime2;
        return prime2;
      }, "prime");
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN4._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      __name(Red, "Red");
      Red.prototype._verify1 = /* @__PURE__ */ __name(function _verify1(a3) {
        assert3(a3.negative === 0, "red works only with positives");
        assert3(a3.red, "red works only with red numbers");
      }, "_verify1");
      Red.prototype._verify2 = /* @__PURE__ */ __name(function _verify2(a3, b2) {
        assert3((a3.negative | b2.negative) === 0, "red works only with positives");
        assert3(
          a3.red && a3.red === b2.red,
          "red works only with red numbers"
        );
      }, "_verify2");
      Red.prototype.imod = /* @__PURE__ */ __name(function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        move(a3, a3.umod(this.m)._forceRed(this));
        return a3;
      }, "imod");
      Red.prototype.neg = /* @__PURE__ */ __name(function neg4(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      }, "neg");
      Red.prototype.add = /* @__PURE__ */ __name(function add4(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      }, "add");
      Red.prototype.iadd = /* @__PURE__ */ __name(function iadd(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      }, "iadd");
      Red.prototype.sub = /* @__PURE__ */ __name(function sub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      }, "sub");
      Red.prototype.isub = /* @__PURE__ */ __name(function isub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      }, "isub");
      Red.prototype.shl = /* @__PURE__ */ __name(function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      }, "shl");
      Red.prototype.imul = /* @__PURE__ */ __name(function imul(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.imul(b2));
      }, "imul");
      Red.prototype.mul = /* @__PURE__ */ __name(function mul4(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.mul(b2));
      }, "mul");
      Red.prototype.isqr = /* @__PURE__ */ __name(function isqr(a3) {
        return this.imul(a3, a3.clone());
      }, "isqr");
      Red.prototype.sqr = /* @__PURE__ */ __name(function sqr(a3) {
        return this.mul(a3, a3);
      }, "sqr");
      Red.prototype.sqrt = /* @__PURE__ */ __name(function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q2 = this.m.subn(1);
        var s3 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s3++;
          q2.iushrn(1);
        }
        assert3(!q2.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN4(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c2 = this.pow(z2, q2);
        var r2 = this.pow(a3, q2.addn(1).iushrn(1));
        var t2 = this.pow(a3, q2);
        var m3 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert3(i3 < m3);
          var b2 = this.pow(c2, new BN4(1).iushln(m3 - i3 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m3 = i3;
        }
        return r2;
      }, "sqrt");
      Red.prototype.invm = /* @__PURE__ */ __name(function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      }, "invm");
      Red.prototype.pow = /* @__PURE__ */ __name(function pow(a3, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      }, "pow");
      Red.prototype.convertTo = /* @__PURE__ */ __name(function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      }, "convertTo");
      Red.prototype.convertFrom = /* @__PURE__ */ __name(function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }, "convertFrom");
      BN4.mont = /* @__PURE__ */ __name(function mont(num) {
        return new Mont(num);
      }, "mont");
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      __name(Mont, "Mont");
      inherits(Mont, Red);
      Mont.prototype.convertTo = /* @__PURE__ */ __name(function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, "convertTo");
      Mont.prototype.convertFrom = /* @__PURE__ */ __name(function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      }, "convertFrom");
      Mont.prototype.imul = /* @__PURE__ */ __name(function imul(a3, b2) {
        if (a3.isZero() || b2.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t2 = a3.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      }, "imul");
      Mont.prototype.mul = /* @__PURE__ */ __name(function mul4(a3, b2) {
        if (a3.isZero() || b2.isZero())
          return new BN4(0)._forceRed(this);
        var t2 = a3.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      }, "mul");
      Mont.prototype.invm = /* @__PURE__ */ __name(function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      }, "invm");
    })(typeof module2 === "undefined" || module2, exports);
  }
});

// ../../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "../../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js"(exports, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = /* @__PURE__ */ __name(function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
        };
      }, "createOutputMethod");
      var createShakeOutputMethod = /* @__PURE__ */ __name(function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
        };
      }, "createShakeOutputMethod");
      var createCshakeOutputMethod = /* @__PURE__ */ __name(function(bits2, padding2, outputType) {
        return function(message, outputBits, n, s3) {
          return methods["cshake" + bits2].update(message, outputBits, n, s3)[outputType]();
        };
      }, "createCshakeOutputMethod");
      var createKmacOutputMethod = /* @__PURE__ */ __name(function(bits2, padding2, outputType) {
        return function(key3, message, outputBits, s3) {
          return methods["kmac" + bits2].update(key3, message, outputBits, s3)[outputType]();
        };
      }, "createKmacOutputMethod");
      var createOutputMethods = /* @__PURE__ */ __name(function(method, createMethod2, bits2, padding2) {
        for (var i4 = 0; i4 < OUTPUT_TYPES.length; ++i4) {
          var type = OUTPUT_TYPES[i4];
          method[type] = createMethod2(bits2, padding2, type);
        }
        return method;
      }, "createOutputMethods");
      var createMethod = /* @__PURE__ */ __name(function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      }, "createMethod");
      var createShakeMethod = /* @__PURE__ */ __name(function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      }, "createShakeMethod");
      var createCshakeMethod = /* @__PURE__ */ __name(function(bits2, padding2) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n, s3) {
          if (!n && !s3) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding2, outputBits).bytepad([n, s3], w2);
          }
        };
        method.update = function(message, outputBits, n, s3) {
          return method.create(outputBits, n, s3).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      }, "createCshakeMethod");
      var createKmacMethod = /* @__PURE__ */ __name(function(bits2, padding2) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key3, outputBits, s3) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s3], w2).bytepad([key3], w2);
        };
        method.update = function(key3, message, outputBits, s3) {
          return method.create(key3, outputBits, s3).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      }, "createKmacMethod");
      var algorithms2 = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i3 = 0; i3 < algorithms2.length; ++i3) {
        var algorithm = algorithms2[i3];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i4 = 0; i4 < 50; ++i4) {
          this.s[i4] = 0;
        }
      }
      __name(Keccak, "Keccak");
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s3 = this.s, i4, code3;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i4 = 1; i4 < blockCount + 1; ++i4) {
              blocks[i4] = 0;
            }
          }
          if (notString) {
            for (i4 = this.start; index < length2 && i4 < byteCount; ++index) {
              blocks[i4 >> 2] |= message[index] << SHIFT[i4++ & 3];
            }
          } else {
            for (i4 = this.start; index < length2 && i4 < byteCount; ++index) {
              code3 = message.charCodeAt(index);
              if (code3 < 128) {
                blocks[i4 >> 2] |= code3 << SHIFT[i4++ & 3];
              } else if (code3 < 2048) {
                blocks[i4 >> 2] |= (192 | code3 >> 6) << SHIFT[i4++ & 3];
                blocks[i4 >> 2] |= (128 | code3 & 63) << SHIFT[i4++ & 3];
              } else if (code3 < 55296 || code3 >= 57344) {
                blocks[i4 >> 2] |= (224 | code3 >> 12) << SHIFT[i4++ & 3];
                blocks[i4 >> 2] |= (128 | code3 >> 6 & 63) << SHIFT[i4++ & 3];
                blocks[i4 >> 2] |= (128 | code3 & 63) << SHIFT[i4++ & 3];
              } else {
                code3 = 65536 + ((code3 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i4 >> 2] |= (240 | code3 >> 18) << SHIFT[i4++ & 3];
                blocks[i4 >> 2] |= (128 | code3 >> 12 & 63) << SHIFT[i4++ & 3];
                blocks[i4 >> 2] |= (128 | code3 >> 6 & 63) << SHIFT[i4++ & 3];
                blocks[i4 >> 2] |= (128 | code3 & 63) << SHIFT[i4++ & 3];
              }
            }
          }
          this.lastByteIndex = i4;
          if (i4 >= byteCount) {
            this.start = i4 - byteCount;
            this.block = blocks[blockCount];
            for (i4 = 0; i4 < blockCount; ++i4) {
              s3[i4] ^= blocks[i4];
            }
            f(s3);
            this.reset = true;
          } else {
            this.start = i4;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x2, right) {
        var o = x2 & 255, n = 1;
        var bytes = [o];
        x2 = x2 >> 8;
        o = x2 & 255;
        while (o > 0) {
          bytes.unshift(o);
          x2 = x2 >> 8;
          o = x2 & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length2 = str.length;
        if (notString) {
          bytes = length2;
        } else {
          for (var i4 = 0; i4 < str.length; ++i4) {
            var code3 = str.charCodeAt(i4);
            if (code3 < 128) {
              bytes += 1;
            } else if (code3 < 2048) {
              bytes += 2;
            } else if (code3 < 55296 || code3 >= 57344) {
              bytes += 3;
            } else {
              code3 = 65536 + ((code3 & 1023) << 10 | str.charCodeAt(++i4) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w2) {
        var bytes = this.encode(w2);
        for (var i4 = 0; i4 < strs.length; ++i4) {
          bytes += this.encodeString(strs[i4]);
        }
        var paddingBytes = w2 - bytes % w2;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i4 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
        blocks[i4 >> 2] |= this.padding[i4 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i4 = 1; i4 < blockCount + 1; ++i4) {
            blocks[i4] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i4 = 0; i4 < blockCount; ++i4) {
          s3[i4] ^= blocks[i4];
        }
        f(s3);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i4 = 0; i4 < blockCount && j2 < outputBlocks; ++i4, ++j2) {
            block = s3[i4];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s3);
            i4 = 0;
          }
        }
        if (extraBytes) {
          block = s3[i4];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer2);
        while (j2 < outputBlocks) {
          for (i4 = 0; i4 < blockCount && j2 < outputBlocks; ++i4, ++j2) {
            array[j2] = s3[i4];
          }
          if (j2 % blockCount === 0) {
            f(s3);
          }
        }
        if (extraBytes) {
          array[i4] = s3[i4];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i4 = 0; i4 < blockCount && j2 < outputBlocks; ++i4, ++j2) {
            offset = j2 << 2;
            block = s3[i4];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s3);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s3[i4];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak.call(this, bits2, padding2, outputBits);
      }
      __name(Kmac, "Kmac");
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = /* @__PURE__ */ __name(function(s3) {
        var h3, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
          c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
          c2 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
          c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
          c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
          c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
          c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
          c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
          c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
          c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
          h3 = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s3[0] ^= h3;
          s3[1] ^= l;
          s3[10] ^= h3;
          s3[11] ^= l;
          s3[20] ^= h3;
          s3[21] ^= l;
          s3[30] ^= h3;
          s3[31] ^= l;
          s3[40] ^= h3;
          s3[41] ^= l;
          h3 = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s3[2] ^= h3;
          s3[3] ^= l;
          s3[12] ^= h3;
          s3[13] ^= l;
          s3[22] ^= h3;
          s3[23] ^= l;
          s3[32] ^= h3;
          s3[33] ^= l;
          s3[42] ^= h3;
          s3[43] ^= l;
          h3 = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s3[4] ^= h3;
          s3[5] ^= l;
          s3[14] ^= h3;
          s3[15] ^= l;
          s3[24] ^= h3;
          s3[25] ^= l;
          s3[34] ^= h3;
          s3[35] ^= l;
          s3[44] ^= h3;
          s3[45] ^= l;
          h3 = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s3[6] ^= h3;
          s3[7] ^= l;
          s3[16] ^= h3;
          s3[17] ^= l;
          s3[26] ^= h3;
          s3[27] ^= l;
          s3[36] ^= h3;
          s3[37] ^= l;
          s3[46] ^= h3;
          s3[47] ^= l;
          h3 = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s3[8] ^= h3;
          s3[9] ^= l;
          s3[18] ^= h3;
          s3[19] ^= l;
          s3[28] ^= h3;
          s3[29] ^= l;
          s3[38] ^= h3;
          s3[39] ^= l;
          s3[48] ^= h3;
          s3[49] ^= l;
          b0 = s3[0];
          b1 = s3[1];
          b32 = s3[11] << 4 | s3[10] >>> 28;
          b33 = s3[10] << 4 | s3[11] >>> 28;
          b14 = s3[20] << 3 | s3[21] >>> 29;
          b15 = s3[21] << 3 | s3[20] >>> 29;
          b46 = s3[31] << 9 | s3[30] >>> 23;
          b47 = s3[30] << 9 | s3[31] >>> 23;
          b28 = s3[40] << 18 | s3[41] >>> 14;
          b29 = s3[41] << 18 | s3[40] >>> 14;
          b20 = s3[2] << 1 | s3[3] >>> 31;
          b21 = s3[3] << 1 | s3[2] >>> 31;
          b2 = s3[13] << 12 | s3[12] >>> 20;
          b3 = s3[12] << 12 | s3[13] >>> 20;
          b34 = s3[22] << 10 | s3[23] >>> 22;
          b35 = s3[23] << 10 | s3[22] >>> 22;
          b16 = s3[33] << 13 | s3[32] >>> 19;
          b17 = s3[32] << 13 | s3[33] >>> 19;
          b48 = s3[42] << 2 | s3[43] >>> 30;
          b49 = s3[43] << 2 | s3[42] >>> 30;
          b40 = s3[5] << 30 | s3[4] >>> 2;
          b41 = s3[4] << 30 | s3[5] >>> 2;
          b22 = s3[14] << 6 | s3[15] >>> 26;
          b23 = s3[15] << 6 | s3[14] >>> 26;
          b4 = s3[25] << 11 | s3[24] >>> 21;
          b5 = s3[24] << 11 | s3[25] >>> 21;
          b36 = s3[34] << 15 | s3[35] >>> 17;
          b37 = s3[35] << 15 | s3[34] >>> 17;
          b18 = s3[45] << 29 | s3[44] >>> 3;
          b19 = s3[44] << 29 | s3[45] >>> 3;
          b10 = s3[6] << 28 | s3[7] >>> 4;
          b11 = s3[7] << 28 | s3[6] >>> 4;
          b42 = s3[17] << 23 | s3[16] >>> 9;
          b43 = s3[16] << 23 | s3[17] >>> 9;
          b24 = s3[26] << 25 | s3[27] >>> 7;
          b25 = s3[27] << 25 | s3[26] >>> 7;
          b6 = s3[36] << 21 | s3[37] >>> 11;
          b7 = s3[37] << 21 | s3[36] >>> 11;
          b38 = s3[47] << 24 | s3[46] >>> 8;
          b39 = s3[46] << 24 | s3[47] >>> 8;
          b30 = s3[8] << 27 | s3[9] >>> 5;
          b31 = s3[9] << 27 | s3[8] >>> 5;
          b12 = s3[18] << 20 | s3[19] >>> 12;
          b13 = s3[19] << 20 | s3[18] >>> 12;
          b44 = s3[29] << 7 | s3[28] >>> 25;
          b45 = s3[28] << 7 | s3[29] >>> 25;
          b26 = s3[38] << 8 | s3[39] >>> 24;
          b27 = s3[39] << 8 | s3[38] >>> 24;
          b8 = s3[48] << 14 | s3[49] >>> 18;
          b9 = s3[49] << 14 | s3[48] >>> 18;
          s3[0] = b0 ^ ~b2 & b4;
          s3[1] = b1 ^ ~b3 & b5;
          s3[10] = b10 ^ ~b12 & b14;
          s3[11] = b11 ^ ~b13 & b15;
          s3[20] = b20 ^ ~b22 & b24;
          s3[21] = b21 ^ ~b23 & b25;
          s3[30] = b30 ^ ~b32 & b34;
          s3[31] = b31 ^ ~b33 & b35;
          s3[40] = b40 ^ ~b42 & b44;
          s3[41] = b41 ^ ~b43 & b45;
          s3[2] = b2 ^ ~b4 & b6;
          s3[3] = b3 ^ ~b5 & b7;
          s3[12] = b12 ^ ~b14 & b16;
          s3[13] = b13 ^ ~b15 & b17;
          s3[22] = b22 ^ ~b24 & b26;
          s3[23] = b23 ^ ~b25 & b27;
          s3[32] = b32 ^ ~b34 & b36;
          s3[33] = b33 ^ ~b35 & b37;
          s3[42] = b42 ^ ~b44 & b46;
          s3[43] = b43 ^ ~b45 & b47;
          s3[4] = b4 ^ ~b6 & b8;
          s3[5] = b5 ^ ~b7 & b9;
          s3[14] = b14 ^ ~b16 & b18;
          s3[15] = b15 ^ ~b17 & b19;
          s3[24] = b24 ^ ~b26 & b28;
          s3[25] = b25 ^ ~b27 & b29;
          s3[34] = b34 ^ ~b36 & b38;
          s3[35] = b35 ^ ~b37 & b39;
          s3[44] = b44 ^ ~b46 & b48;
          s3[45] = b45 ^ ~b47 & b49;
          s3[6] = b6 ^ ~b8 & b0;
          s3[7] = b7 ^ ~b9 & b1;
          s3[16] = b16 ^ ~b18 & b10;
          s3[17] = b17 ^ ~b19 & b11;
          s3[26] = b26 ^ ~b28 & b20;
          s3[27] = b27 ^ ~b29 & b21;
          s3[36] = b36 ^ ~b38 & b30;
          s3[37] = b37 ^ ~b39 & b31;
          s3[46] = b46 ^ ~b48 & b40;
          s3[47] = b47 ^ ~b49 & b41;
          s3[8] = b8 ^ ~b0 & b2;
          s3[9] = b9 ^ ~b1 & b3;
          s3[18] = b18 ^ ~b10 & b12;
          s3[19] = b19 ^ ~b11 & b13;
          s3[28] = b28 ^ ~b20 & b22;
          s3[29] = b29 ^ ~b21 & b23;
          s3[38] = b38 ^ ~b30 & b32;
          s3[39] = b39 ^ ~b31 & b33;
          s3[48] = b48 ^ ~b40 & b42;
          s3[49] = b49 ^ ~b41 & b43;
          s3[0] ^= RC[n];
          s3[1] ^= RC[n + 1];
        }
      }, "f");
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i3 = 0; i3 < methodNames.length; ++i3) {
          root[methodNames[i3]] = methods[methodNames[i3]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// ../../../node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "../../../node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports, module2) {
    module2.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    __name(assert3, "assert");
    assert3.equal = /* @__PURE__ */ __name(function assertEqual3(l, r2, msg) {
      if (l != r2)
        throw new Error(msg || "Assertion failed: " + l + " != " + r2);
    }, "assertEqual");
  }
});

// ../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      }, "inherits");
    } else {
      module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = /* @__PURE__ */ __name(function() {
          }, "TempCtor");
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      }, "inherits");
    }
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i3) {
      if ((msg.charCodeAt(i3) & 64512) !== 55296) {
        return false;
      }
      if (i3 < 0 || i3 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i3 + 1) & 64512) === 56320;
    }
    __name(isSurrogatePair, "isSurrogatePair");
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i3 = 0; i3 < msg.length; i3++) {
            var c2 = msg.charCodeAt(i3);
            if (c2 < 128) {
              res[p++] = c2;
            } else if (c2 < 2048) {
              res[p++] = c2 >> 6 | 192;
              res[p++] = c2 & 63 | 128;
            } else if (isSurrogatePair(msg, i3)) {
              c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i3) & 1023);
              res[p++] = c2 >> 18 | 240;
              res[p++] = c2 >> 12 & 63 | 128;
              res[p++] = c2 >> 6 & 63 | 128;
              res[p++] = c2 & 63 | 128;
            } else {
              res[p++] = c2 >> 12 | 224;
              res[p++] = c2 >> 6 & 63 | 128;
              res[p++] = c2 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i3 = 0; i3 < msg.length; i3 += 2)
            res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
        }
      } else {
        for (i3 = 0; i3 < msg.length; i3++)
          res[i3] = msg[i3] | 0;
      }
      return res;
    }
    __name(toArray, "toArray");
    exports.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i3 = 0; i3 < msg.length; i3++)
        res += zero2(msg[i3].toString(16));
      return res;
    }
    __name(toHex2, "toHex");
    exports.toHex = toHex2;
    function htonl(w2) {
      var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
      return res >>> 0;
    }
    __name(htonl, "htonl");
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i3 = 0; i3 < msg.length; i3++) {
        var w2 = msg[i3];
        if (endian === "little")
          w2 = htonl(w2);
        res += zero8(w2.toString(16));
      }
      return res;
    }
    __name(toHex32, "toHex32");
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    __name(zero2, "zero2");
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    __name(zero8, "zero8");
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i3 = 0, k2 = start; i3 < res.length; i3++, k2 += 4) {
        var w2;
        if (endian === "big")
          w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
        else
          w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
        res[i3] = w2 >>> 0;
      }
      return res;
    }
    __name(join32, "join32");
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i3 = 0, k2 = 0; i3 < msg.length; i3++, k2 += 4) {
        var m3 = msg[i3];
        if (endian === "big") {
          res[k2] = m3 >>> 24;
          res[k2 + 1] = m3 >>> 16 & 255;
          res[k2 + 2] = m3 >>> 8 & 255;
          res[k2 + 3] = m3 & 255;
        } else {
          res[k2 + 3] = m3 >>> 24;
          res[k2 + 2] = m3 >>> 16 & 255;
          res[k2 + 1] = m3 >>> 8 & 255;
          res[k2] = m3 & 255;
        }
      }
      return res;
    }
    __name(split32, "split32");
    exports.split32 = split32;
    function rotr32(w2, b2) {
      return w2 >>> b2 | w2 << 32 - b2;
    }
    __name(rotr32, "rotr32");
    exports.rotr32 = rotr32;
    function rotl32(w2, b2) {
      return w2 << b2 | w2 >>> 32 - b2;
    }
    __name(rotl32, "rotl32");
    exports.rotl32 = rotl32;
    function sum32(a3, b2) {
      return a3 + b2 >>> 0;
    }
    __name(sum32, "sum32");
    exports.sum32 = sum32;
    function sum32_3(a3, b2, c2) {
      return a3 + b2 + c2 >>> 0;
    }
    __name(sum32_3, "sum32_3");
    exports.sum32_3 = sum32_3;
    function sum32_4(a3, b2, c2, d3) {
      return a3 + b2 + c2 + d3 >>> 0;
    }
    __name(sum32_4, "sum32_4");
    exports.sum32_4 = sum32_4;
    function sum32_5(a3, b2, c2, d3, e2) {
      return a3 + b2 + c2 + d3 + e2 >>> 0;
    }
    __name(sum32_5, "sum32_5");
    exports.sum32_5 = sum32_5;
    function sum64(buf2, pos, ah, al) {
      var bh = buf2[pos];
      var bl = buf2[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf2[pos] = hi >>> 0;
      buf2[pos + 1] = lo;
    }
    __name(sum64, "sum64");
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    __name(sum64_hi, "sum64_hi");
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    __name(sum64_lo, "sum64_lo");
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    __name(sum64_4_hi, "sum64_4_hi");
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    __name(sum64_4_lo, "sum64_4_lo");
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    __name(sum64_5_hi, "sum64_5_hi");
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    __name(sum64_5_lo, "sum64_5_lo");
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r2 = al << 32 - num | ah >>> num;
      return r2 >>> 0;
    }
    __name(rotr64_hi, "rotr64_hi");
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    __name(rotr64_lo, "rotr64_lo");
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    __name(shr64_hi, "shr64_hi");
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    __name(shr64_lo, "shr64_lo");
    exports.shr64_lo = shr64_lo;
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    __name(BlockHash, "BlockHash");
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = /* @__PURE__ */ __name(function update3(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r2 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r2, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r2, this.endian);
        for (var i3 = 0; i3 < msg.length; i3 += this._delta32)
          this._update(msg, i3, i3 + this._delta32);
      }
      return this;
    }, "update");
    BlockHash.prototype.digest = /* @__PURE__ */ __name(function digest2(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    }, "digest");
    BlockHash.prototype._pad = /* @__PURE__ */ __name(function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k2 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k2 + this.padLength);
      res[0] = 128;
      for (var i3 = 1; i3 < k2; i3++)
        res[i3] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t2 = 8; t2 < this.padLength; t2++)
          res[i3++] = 0;
        res[i3++] = 0;
        res[i3++] = 0;
        res[i3++] = 0;
        res[i3++] = 0;
        res[i3++] = len >>> 24 & 255;
        res[i3++] = len >>> 16 & 255;
        res[i3++] = len >>> 8 & 255;
        res[i3++] = len & 255;
      } else {
        res[i3++] = len & 255;
        res[i3++] = len >>> 8 & 255;
        res[i3++] = len >>> 16 & 255;
        res[i3++] = len >>> 24 & 255;
        res[i3++] = 0;
        res[i3++] = 0;
        res[i3++] = 0;
        res[i3++] = 0;
        for (t2 = 8; t2 < this.padLength; t2++)
          res[i3++] = 0;
      }
      return res;
    }, "pad");
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils();
    var rotr32 = utils.rotr32;
    function ft_1(s3, x2, y3, z2) {
      if (s3 === 0)
        return ch32(x2, y3, z2);
      if (s3 === 1 || s3 === 3)
        return p32(x2, y3, z2);
      if (s3 === 2)
        return maj32(x2, y3, z2);
    }
    __name(ft_1, "ft_1");
    exports.ft_1 = ft_1;
    function ch32(x2, y3, z2) {
      return x2 & y3 ^ ~x2 & z2;
    }
    __name(ch32, "ch32");
    exports.ch32 = ch32;
    function maj32(x2, y3, z2) {
      return x2 & y3 ^ x2 & z2 ^ y3 & z2;
    }
    __name(maj32, "maj32");
    exports.maj32 = maj32;
    function p32(x2, y3, z2) {
      return x2 ^ y3 ^ z2;
    }
    __name(p32, "p32");
    exports.p32 = p32;
    function s0_256(x2) {
      return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
    }
    __name(s0_256, "s0_256");
    exports.s0_256 = s0_256;
    function s1_256(x2) {
      return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
    }
    __name(s1_256, "s1_256");
    exports.s1_256 = s1_256;
    function g0_256(x2) {
      return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
    }
    __name(g0_256, "g0_256");
    exports.g0_256 = g0_256;
    function g1_256(x2) {
      return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
    }
    __name(g1_256, "g1_256");
    exports.g1_256 = g1_256;
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    __name(SHA1, "SHA1");
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = /* @__PURE__ */ __name(function _update(msg, start) {
      var W = this.W;
      for (var i3 = 0; i3 < 16; i3++)
        W[i3] = msg[start + i3];
      for (; i3 < W.length; i3++)
        W[i3] = rotl32(W[i3 - 3] ^ W[i3 - 8] ^ W[i3 - 14] ^ W[i3 - 16], 1);
      var a3 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d3 = this.h[3];
      var e2 = this.h[4];
      for (i3 = 0; i3 < W.length; i3++) {
        var s3 = ~~(i3 / 20);
        var t2 = sum32_5(rotl32(a3, 5), ft_1(s3, b2, c2, d3), e2, W[i3], sha1_K[s3]);
        e2 = d3;
        d3 = c2;
        c2 = rotl32(b2, 30);
        b2 = a3;
        a3 = t2;
      }
      this.h[0] = sum32(this.h[0], a3);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d3);
      this.h[4] = sum32(this.h[4], e2);
    }, "_update");
    SHA1.prototype._digest = /* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest");
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    __name(SHA256, "SHA256");
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = /* @__PURE__ */ __name(function _update(msg, start) {
      var W = this.W;
      for (var i3 = 0; i3 < 16; i3++)
        W[i3] = msg[start + i3];
      for (; i3 < W.length; i3++)
        W[i3] = sum32_4(g1_256(W[i3 - 2]), W[i3 - 7], g0_256(W[i3 - 15]), W[i3 - 16]);
      var a3 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d3 = this.h[3];
      var e2 = this.h[4];
      var f = this.h[5];
      var g2 = this.h[6];
      var h3 = this.h[7];
      assert3(this.k.length === W.length);
      for (i3 = 0; i3 < W.length; i3++) {
        var T1 = sum32_5(h3, s1_256(e2), ch32(e2, f, g2), this.k[i3], W[i3]);
        var T2 = sum32(s0_256(a3), maj32(a3, b2, c2));
        h3 = g2;
        g2 = f;
        f = e2;
        e2 = sum32(d3, T1);
        d3 = c2;
        c2 = b2;
        b2 = a3;
        a3 = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a3);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d3);
      this.h[4] = sum32(this.h[4], e2);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g2);
      this.h[7] = sum32(this.h[7], h3);
    }, "_update");
    SHA256.prototype._digest = /* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest");
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    __name(SHA224, "SHA224");
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = /* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    }, "digest");
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    __name(SHA512, "SHA512");
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = /* @__PURE__ */ __name(function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i3 = 0; i3 < 32; i3++)
        W[i3] = msg[start + i3];
      for (; i3 < W.length; i3 += 2) {
        var c0_hi = g1_512_hi(W[i3 - 4], W[i3 - 3]);
        var c0_lo = g1_512_lo(W[i3 - 4], W[i3 - 3]);
        var c1_hi = W[i3 - 14];
        var c1_lo = W[i3 - 13];
        var c2_hi = g0_512_hi(W[i3 - 30], W[i3 - 29]);
        var c2_lo = g0_512_lo(W[i3 - 30], W[i3 - 29]);
        var c3_hi = W[i3 - 32];
        var c3_lo = W[i3 - 31];
        W[i3] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i3 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    }, "_prepareBlock");
    SHA512.prototype._update = /* @__PURE__ */ __name(function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W.length);
      for (var i3 = 0; i3 < W.length; i3 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i3];
        var c3_lo = this.k[i3 + 1];
        var c4_hi = W[i3];
        var c4_lo = W[i3 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    }, "_update");
    SHA512.prototype._digest = /* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest");
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ ~xh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(ch64_hi, "ch64_hi");
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ ~xl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(ch64_lo, "ch64_lo");
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ xh & zh ^ yh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(maj64_hi, "maj64_hi");
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ xl & zl ^ yl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(maj64_lo, "maj64_lo");
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s0_512_hi, "s0_512_hi");
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s0_512_lo, "s0_512_lo");
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s1_512_hi, "s1_512_hi");
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s1_512_lo, "s1_512_lo");
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g0_512_hi, "g0_512_hi");
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g0_512_lo, "g0_512_lo");
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g1_512_hi, "g1_512_hi");
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g1_512_lo, "g1_512_lo");
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    __name(SHA384, "SHA384");
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = /* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    }, "digest");
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    __name(RIPEMD160, "RIPEMD160");
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = /* @__PURE__ */ __name(function update3(msg, start) {
      var A = this.h[0];
      var B2 = this.h[1];
      var C = this.h[2];
      var D2 = this.h[3];
      var E2 = this.h[4];
      var Ah = A;
      var Bh = B2;
      var Ch = C;
      var Dh = D2;
      var Eh = E2;
      for (var j = 0; j < 80; j++) {
        var T2 = sum32(
          rotl32(
            sum32_4(A, f(j, B2, C, D2), msg[r2[j] + start], K2(j)),
            s3[j]
          ),
          E2
        );
        A = E2;
        E2 = D2;
        D2 = rotl32(C, 10);
        C = B2;
        B2 = T2;
        T2 = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T2;
      }
      T2 = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D2, Eh);
      this.h[2] = sum32_3(this.h[3], E2, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B2, Ch);
      this.h[0] = T2;
    }, "update");
    RIPEMD160.prototype._digest = /* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    }, "digest");
    function f(j, x2, y3, z2) {
      if (j <= 15)
        return x2 ^ y3 ^ z2;
      else if (j <= 31)
        return x2 & y3 | ~x2 & z2;
      else if (j <= 47)
        return (x2 | ~y3) ^ z2;
      else if (j <= 63)
        return x2 & z2 | y3 & ~z2;
      else
        return x2 ^ (y3 | ~z2);
    }
    __name(f, "f");
    function K2(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    __name(K2, "K");
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    __name(Kh, "Kh");
    var r2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s3 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash3, key3, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key3, enc);
      this.Hash = hash3;
      this.blockSize = hash3.blockSize / 8;
      this.outSize = hash3.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key3, enc));
    }
    __name(Hmac, "Hmac");
    module2.exports = Hmac;
    Hmac.prototype._init = /* @__PURE__ */ __name(function init4(key3) {
      if (key3.length > this.blockSize)
        key3 = new this.Hash().update(key3).digest();
      assert3(key3.length <= this.blockSize);
      for (var i3 = key3.length; i3 < this.blockSize; i3++)
        key3.push(0);
      for (i3 = 0; i3 < key3.length; i3++)
        key3[i3] ^= 54;
      this.inner = new this.Hash().update(key3);
      for (i3 = 0; i3 < key3.length; i3++)
        key3[i3] ^= 106;
      this.outer = new this.Hash().update(key3);
    }, "init");
    Hmac.prototype.update = /* @__PURE__ */ __name(function update3(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    }, "update");
    Hmac.prototype.digest = /* @__PURE__ */ __name(function digest2(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    }, "digest");
  }
});

// ../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "../../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js"(exports) {
    var hash3 = exports;
    hash3.utils = require_utils();
    hash3.common = require_common();
    hash3.sha = require_sha();
    hash3.ripemd = require_ripemd();
    hash3.hmac = require_hmac();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  }
});

// ../../../node_modules/.pnpm/aes-js@3.0.0/node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "../../../node_modules/.pnpm/aes-js@3.0.0/node_modules/aes-js/index.js"(exports, module2) {
    "use strict";
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      __name(checkInt, "checkInt");
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i3 = 0; i3 < arrayish.length; i3++) {
          if (!checkInt(arrayish[i3]) || arrayish[i3] < 0 || arrayish[i3] > 255) {
            return false;
          }
        }
        return true;
      }
      __name(checkInts, "checkInts");
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      __name(coerceArray, "coerceArray");
      function createArray(length2) {
        return new Uint8Array(length2);
      }
      __name(createArray, "createArray");
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      __name(copyArray, "copyArray");
      var convertUtf8 = function() {
        function toBytes(text) {
          var result = [], i3 = 0;
          text = encodeURI(text);
          while (i3 < text.length) {
            var c2 = text.charCodeAt(i3++);
            if (c2 === 37) {
              result.push(parseInt(text.substr(i3, 2), 16));
              i3 += 2;
            } else {
              result.push(c2);
            }
          }
          return coerceArray(result);
        }
        __name(toBytes, "toBytes");
        function fromBytes4(bytes) {
          var result = [], i3 = 0;
          while (i3 < bytes.length) {
            var c2 = bytes[i3];
            if (c2 < 128) {
              result.push(String.fromCharCode(c2));
              i3++;
            } else if (c2 > 191 && c2 < 224) {
              result.push(String.fromCharCode((c2 & 31) << 6 | bytes[i3 + 1] & 63));
              i3 += 2;
            } else {
              result.push(String.fromCharCode((c2 & 15) << 12 | (bytes[i3 + 1] & 63) << 6 | bytes[i3 + 2] & 63));
              i3 += 3;
            }
          }
          return result.join("");
        }
        __name(fromBytes4, "fromBytes");
        return {
          toBytes,
          fromBytes: fromBytes4
        };
      }();
      var convertHex = function() {
        function toBytes(text) {
          var result = [];
          for (var i3 = 0; i3 < text.length; i3 += 2) {
            result.push(parseInt(text.substr(i3, 2), 16));
          }
          return result;
        }
        __name(toBytes, "toBytes");
        var Hex = "0123456789abcdef";
        function fromBytes4(bytes) {
          var result = [];
          for (var i3 = 0; i3 < bytes.length; i3++) {
            var v = bytes[i3];
            result.push(Hex[(v & 240) >> 4] + Hex[v & 15]);
          }
          return result.join("");
        }
        __name(fromBytes4, "fromBytes");
        return {
          toBytes,
          fromBytes: fromBytes4
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S3 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i3 = 0; i3 < bytes.length; i3 += 4) {
          result.push(
            bytes[i3] << 24 | bytes[i3 + 1] << 16 | bytes[i3 + 2] << 8 | bytes[i3 + 3]
          );
        }
        return result;
      }
      __name(convertToInt32, "convertToInt32");
      var AES = /* @__PURE__ */ __name(function(key3) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key3, true)
        });
        this._prepare();
      }, "AES");
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i3 = 0; i3 <= rounds; i3++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i3 = 0; i3 < KC; i3++) {
          index = i3 >> 2;
          this._Ke[index][i3 % 4] = tk[i3];
          this._Kd[rounds - index][i3 % 4] = tk[i3];
        }
        var rconpointer = 0;
        var t2 = KC, tt;
        while (t2 < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S3[tt >> 16 & 255] << 24 ^ S3[tt >> 8 & 255] << 16 ^ S3[tt & 255] << 8 ^ S3[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i3 = 1; i3 < KC; i3++) {
              tk[i3] ^= tk[i3 - 1];
            }
          } else {
            for (var i3 = 1; i3 < KC / 2; i3++) {
              tk[i3] ^= tk[i3 - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S3[tt & 255] ^ S3[tt >> 8 & 255] << 8 ^ S3[tt >> 16 & 255] << 16 ^ S3[tt >> 24 & 255] << 24;
            for (var i3 = KC / 2 + 1; i3 < KC; i3++) {
              tk[i3] ^= tk[i3 - 1];
            }
          }
          var i3 = 0, r2, c2;
          while (i3 < KC && t2 < roundKeyCount) {
            r2 = t2 >> 2;
            c2 = t2 % 4;
            this._Ke[r2][c2] = tk[i3];
            this._Kd[rounds - r2][c2] = tk[i3++];
            t2++;
          }
        }
        for (var r2 = 1; r2 < rounds; r2++) {
          for (var c2 = 0; c2 < 4; c2++) {
            tt = this._Kd[r2][c2];
            this._Kd[r2][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a3 = [0, 0, 0, 0];
        var t2 = convertToInt32(plaintext);
        for (var i3 = 0; i3 < 4; i3++) {
          t2[i3] ^= this._Ke[0][i3];
        }
        for (var r2 = 1; r2 < rounds; r2++) {
          for (var i3 = 0; i3 < 4; i3++) {
            a3[i3] = T1[t2[i3] >> 24 & 255] ^ T2[t2[(i3 + 1) % 4] >> 16 & 255] ^ T3[t2[(i3 + 2) % 4] >> 8 & 255] ^ T4[t2[(i3 + 3) % 4] & 255] ^ this._Ke[r2][i3];
          }
          t2 = a3.slice();
        }
        var result = createArray(16), tt;
        for (var i3 = 0; i3 < 4; i3++) {
          tt = this._Ke[rounds][i3];
          result[4 * i3] = (S3[t2[i3] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i3 + 1] = (S3[t2[(i3 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i3 + 2] = (S3[t2[(i3 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i3 + 3] = (S3[t2[(i3 + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a3 = [0, 0, 0, 0];
        var t2 = convertToInt32(ciphertext);
        for (var i3 = 0; i3 < 4; i3++) {
          t2[i3] ^= this._Kd[0][i3];
        }
        for (var r2 = 1; r2 < rounds; r2++) {
          for (var i3 = 0; i3 < 4; i3++) {
            a3[i3] = T5[t2[i3] >> 24 & 255] ^ T6[t2[(i3 + 3) % 4] >> 16 & 255] ^ T7[t2[(i3 + 2) % 4] >> 8 & 255] ^ T8[t2[(i3 + 1) % 4] & 255] ^ this._Kd[r2][i3];
          }
          t2 = a3.slice();
        }
        var result = createArray(16), tt;
        for (var i3 = 0; i3 < 4; i3++) {
          tt = this._Kd[rounds][i3];
          result[4 * i3] = (Si[t2[i3] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i3 + 1] = (Si[t2[(i3 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i3 + 2] = (Si[t2[(i3 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i3 + 3] = (Si[t2[(i3 + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = /* @__PURE__ */ __name(function(key3) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key3);
      }, "ModeOfOperationECB");
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i3 = 0; i3 < plaintext.length; i3 += 16) {
          copyArray(plaintext, block, 0, i3, i3 + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i3);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i3 = 0; i3 < ciphertext.length; i3 += 16) {
          copyArray(ciphertext, block, 0, i3, i3 + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i3);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = /* @__PURE__ */ __name(function(key3, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key3);
      }, "ModeOfOperationCBC");
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i3 = 0; i3 < plaintext.length; i3 += 16) {
          copyArray(plaintext, block, 0, i3, i3 + 16);
          for (var j = 0; j < 16; j++) {
            block[j] ^= this._lastCipherblock[j];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i3);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i3 = 0; i3 < ciphertext.length; i3 += 16) {
          copyArray(ciphertext, block, 0, i3, i3 + 16);
          block = this._aes.decrypt(block);
          for (var j = 0; j < 16; j++) {
            plaintext[i3 + j] = block[j] ^ this._lastCipherblock[j];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i3, i3 + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = /* @__PURE__ */ __name(function(key3, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key3);
      }, "ModeOfOperationCFB");
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i3 = 0; i3 < encrypted.length; i3 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            encrypted[i3 + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i3, i3 + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i3 = 0; i3 < plaintext.length; i3 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            plaintext[i3 + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i3, i3 + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = /* @__PURE__ */ __name(function(key3, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key3);
      }, "ModeOfOperationOFB");
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i3 = 0; i3 < encrypted.length; i3++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i3] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = /* @__PURE__ */ __name(function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      }, "Counter");
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i3 = 15; i3 >= 0; i3--) {
          if (this._counter[i3] === 255) {
            this._counter[i3] = 0;
          } else {
            this._counter[i3]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = /* @__PURE__ */ __name(function(key3, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key3);
      }, "ModeOfOperationCTR");
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i3 = 0; i3 < encrypted.length; i3++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i3] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i3 = data.length; i3 < result.length; i3++) {
          result[i3] = padder;
        }
        return result;
      }
      __name(pkcs7pad, "pkcs7pad");
      function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length2 = data.length - padder;
        for (var i3 = 0; i3 < padder; i3++) {
          if (data[length2 + i3] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length2);
        copyArray(data, result, 0, 0, length2);
        return result;
      }
      __name(pkcs7strip, "pkcs7strip");
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module2.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// ../../../node_modules/.pnpm/scrypt-js@3.0.1/node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "../../../node_modules/.pnpm/scrypt-js@3.0.1/node_modules/scrypt-js/scrypt.js"(exports, module2) {
    "use strict";
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA256(m3) {
        const K2 = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h3 = 2773480762;
        let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w2 = new Uint32Array(64);
        function blocks(p2) {
          let off = 0, len = p2.length;
          while (len >= 64) {
            let a3 = h0, b2 = h1, c2 = h22, d3 = h3, e2 = h4, f = h5, g2 = h6, h8 = h7, u2, i4, j, t1, t2;
            for (i4 = 0; i4 < 16; i4++) {
              j = off + i4 * 4;
              w2[i4] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
            }
            for (i4 = 16; i4 < 64; i4++) {
              u2 = w2[i4 - 2];
              t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
              u2 = w2[i4 - 15];
              t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
              w2[i4] = (t1 + w2[i4 - 7] | 0) + (t2 + w2[i4 - 16] | 0) | 0;
            }
            for (i4 = 0; i4 < 64; i4++) {
              t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f ^ ~e2 & g2) | 0) + (h8 + (K2[i4] + w2[i4] | 0) | 0) | 0;
              t2 = ((a3 >>> 2 | a3 << 32 - 2) ^ (a3 >>> 13 | a3 << 32 - 13) ^ (a3 >>> 22 | a3 << 32 - 22)) + (a3 & b2 ^ a3 & c2 ^ b2 & c2) | 0;
              h8 = g2;
              g2 = f;
              f = e2;
              e2 = d3 + t1 | 0;
              d3 = c2;
              c2 = b2;
              b2 = a3;
              a3 = t1 + t2 | 0;
            }
            h0 = h0 + a3 | 0;
            h1 = h1 + b2 | 0;
            h22 = h22 + c2 | 0;
            h3 = h3 + d3 | 0;
            h4 = h4 + e2 | 0;
            h5 = h5 + f | 0;
            h6 = h6 + g2 | 0;
            h7 = h7 + h8 | 0;
            off += 64;
            len -= 64;
          }
        }
        __name(blocks, "blocks");
        blocks(m3);
        let i3, bytesLeft = m3.length % 64, bitLenHi = m3.length / 536870912 | 0, bitLenLo = m3.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m3.slice(m3.length - bytesLeft, m3.length);
        p.push(128);
        for (i3 = bytesLeft + 1; i3 < numZeros; i3++) {
          p.push(0);
        }
        p.push(bitLenHi >>> 24 & 255);
        p.push(bitLenHi >>> 16 & 255);
        p.push(bitLenHi >>> 8 & 255);
        p.push(bitLenHi >>> 0 & 255);
        p.push(bitLenLo >>> 24 & 255);
        p.push(bitLenLo >>> 16 & 255);
        p.push(bitLenLo >>> 8 & 255);
        p.push(bitLenLo >>> 0 & 255);
        blocks(p);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h22 >>> 24 & 255,
          h22 >>> 16 & 255,
          h22 >>> 8 & 255,
          h22 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      __name(SHA256, "SHA256");
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i3;
        let dk = [];
        for (i3 = 0; i3 < 64; i3++) {
          inner[i3] = 54;
        }
        for (i3 = 0; i3 < password.length; i3++) {
          inner[i3] ^= password[i3];
        }
        for (i3 = 0; i3 < salt.length; i3++) {
          inner[64 + i3] = salt[i3];
        }
        for (i3 = innerLen - 4; i3 < innerLen; i3++) {
          inner[i3] = 0;
        }
        for (i3 = 0; i3 < 64; i3++)
          outerKey[i3] = 92;
        for (i3 = 0; i3 < password.length; i3++)
          outerKey[i3] ^= password[i3];
        function incrementCounter() {
          for (let i4 = innerLen - 1; i4 >= innerLen - 4; i4--) {
            inner[i4]++;
            if (inner[i4] <= 255)
              return;
            inner[i4] = 0;
          }
        }
        __name(incrementCounter, "incrementCounter");
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
      }
      __name(PBKDF2_HMAC_SHA256_OneIter, "PBKDF2_HMAC_SHA256_OneIter");
      function blockmix_salsa8(BY, Yi, r2, x2, _X) {
        let i3;
        arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
        for (i3 = 0; i3 < 2 * r2; i3++) {
          blockxor(BY, i3 * 16, _X, 16);
          salsa20_8(_X, x2);
          arraycopy(_X, 0, BY, Yi + i3 * 16, 16);
        }
        for (i3 = 0; i3 < r2; i3++) {
          arraycopy(BY, Yi + i3 * 2 * 16, BY, i3 * 16, 16);
        }
        for (i3 = 0; i3 < r2; i3++) {
          arraycopy(BY, Yi + (i3 * 2 + 1) * 16, BY, (i3 + r2) * 16, 16);
        }
      }
      __name(blockmix_salsa8, "blockmix_salsa8");
      function R2(a3, b2) {
        return a3 << b2 | a3 >>> 32 - b2;
      }
      __name(R2, "R");
      function salsa20_8(B2, x2) {
        arraycopy(B2, 0, x2, 0, 16);
        for (let i3 = 8; i3 > 0; i3 -= 2) {
          x2[4] ^= R2(x2[0] + x2[12], 7);
          x2[8] ^= R2(x2[4] + x2[0], 9);
          x2[12] ^= R2(x2[8] + x2[4], 13);
          x2[0] ^= R2(x2[12] + x2[8], 18);
          x2[9] ^= R2(x2[5] + x2[1], 7);
          x2[13] ^= R2(x2[9] + x2[5], 9);
          x2[1] ^= R2(x2[13] + x2[9], 13);
          x2[5] ^= R2(x2[1] + x2[13], 18);
          x2[14] ^= R2(x2[10] + x2[6], 7);
          x2[2] ^= R2(x2[14] + x2[10], 9);
          x2[6] ^= R2(x2[2] + x2[14], 13);
          x2[10] ^= R2(x2[6] + x2[2], 18);
          x2[3] ^= R2(x2[15] + x2[11], 7);
          x2[7] ^= R2(x2[3] + x2[15], 9);
          x2[11] ^= R2(x2[7] + x2[3], 13);
          x2[15] ^= R2(x2[11] + x2[7], 18);
          x2[1] ^= R2(x2[0] + x2[3], 7);
          x2[2] ^= R2(x2[1] + x2[0], 9);
          x2[3] ^= R2(x2[2] + x2[1], 13);
          x2[0] ^= R2(x2[3] + x2[2], 18);
          x2[6] ^= R2(x2[5] + x2[4], 7);
          x2[7] ^= R2(x2[6] + x2[5], 9);
          x2[4] ^= R2(x2[7] + x2[6], 13);
          x2[5] ^= R2(x2[4] + x2[7], 18);
          x2[11] ^= R2(x2[10] + x2[9], 7);
          x2[8] ^= R2(x2[11] + x2[10], 9);
          x2[9] ^= R2(x2[8] + x2[11], 13);
          x2[10] ^= R2(x2[9] + x2[8], 18);
          x2[12] ^= R2(x2[15] + x2[14], 7);
          x2[13] ^= R2(x2[12] + x2[15], 9);
          x2[14] ^= R2(x2[13] + x2[12], 13);
          x2[15] ^= R2(x2[14] + x2[13], 18);
        }
        for (let i3 = 0; i3 < 16; ++i3) {
          B2[i3] += x2[i3];
        }
      }
      __name(salsa20_8, "salsa20_8");
      function blockxor(S3, Si, D2, len) {
        for (let i3 = 0; i3 < len; i3++) {
          D2[i3] ^= S3[Si + i3];
        }
      }
      __name(blockxor, "blockxor");
      function arraycopy(src2, srcPos, dest, destPos, length2) {
        while (length2--) {
          dest[destPos++] = src2[srcPos++];
        }
      }
      __name(arraycopy, "arraycopy");
      function checkBufferish(o) {
        if (!o || typeof o.length !== "number") {
          return false;
        }
        for (let i3 = 0; i3 < o.length; i3++) {
          const v = o[i3];
          if (typeof v !== "number" || v % 1 || v < 0 || v >= 256) {
            return false;
          }
        }
        return true;
      }
      __name(checkBufferish, "checkBufferish");
      function ensureInteger(value, name3) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name3);
        }
        return value;
      }
      __name(ensureInteger, "ensureInteger");
      function _scrypt(password, salt, N10, r2, p, dkLen, callback) {
        N10 = ensureInteger(N10, "N");
        r2 = ensureInteger(r2, "r");
        p = ensureInteger(p, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N10 === 0 || (N10 & N10 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N10 > MAX_VALUE / 128 / r2) {
          throw new Error("N too large");
        }
        if (r2 > MAX_VALUE / 128 / p) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b2 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r2);
        const B2 = new Uint32Array(p * 32 * r2);
        for (let i3 = 0; i3 < B2.length; i3++) {
          const j = i3 * 4;
          B2[i3] = (b2[j + 3] & 255) << 24 | (b2[j + 2] & 255) << 16 | (b2[j + 1] & 255) << 8 | (b2[j + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r2);
        const V = new Uint32Array(32 * r2 * N10);
        const Yi = 32 * r2;
        const x2 = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p * N10 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        const limit = callback ? parseInt(1e3 / r2) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = /* @__PURE__ */ __name(function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state) {
            case 0:
              Bi = i0 * 32 * r2;
              arraycopy(B2, Bi, XY, 0, Yi);
              state = 1;
              i1 = 0;
            case 1:
              steps = N10 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i3 = 0; i3 < steps; i3++) {
                arraycopy(XY, 0, V, (i1 + i3) * Yi, Yi);
                blockmix_salsa8(XY, Yi, r2, x2, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N10) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps = N10 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i3 = 0; i3 < steps; i3++) {
                const offset = (2 * r2 - 1) * 16;
                const j = XY[offset] & N10 - 1;
                blockxor(V, j * Yi, XY, Yi);
                blockmix_salsa8(XY, Yi, r2, x2, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N10) {
                break;
              }
              arraycopy(XY, 0, B2, Bi, Yi);
              i0++;
              if (i0 < p) {
                state = 0;
                break;
              }
              b2 = [];
              for (let i3 = 0; i3 < B2.length; i3++) {
                b2.push(B2[i3] >> 0 & 255);
                b2.push(B2[i3] >> 8 & 255);
                b2.push(B2[i3] >> 16 & 255);
                b2.push(B2[i3] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b2, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        }, "incrementalSMix");
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      __name(_scrypt, "_scrypt");
      const lib = {
        scrypt: function(password, salt, N10, r2, p, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N10, r2, p, dkLen, function(error, progress, key3) {
              if (error) {
                reject(error);
              } else if (key3) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key3));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N10, r2, p, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N10, r2, p, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module2.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// ../../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "../../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js"(exports, module2) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z2 = 0; z2 < ALPHABET.length; z2++) {
      x2 = ALPHABET.charAt(z2);
      if (ALPHABET_MAP[x2] !== void 0)
        throw new TypeError(x2 + " is ambiguous");
      ALPHABET_MAP[x2] = z2;
    }
    var x2;
    var z2;
    function polymodStep(pre) {
      var b2 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
    }
    __name(polymodStep, "polymodStep");
    function prefixChk(prefix) {
      var chk = 1;
      for (var i3 = 0; i3 < prefix.length; ++i3) {
        var c2 = prefix.charCodeAt(i3);
        if (c2 < 33 || c2 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c2 >> 5;
      }
      chk = polymodStep(chk);
      for (i3 = 0; i3 < prefix.length; ++i3) {
        var v = prefix.charCodeAt(i3);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    __name(prefixChk, "prefixChk");
    function encode16(prefix, words2, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words2.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i3 = 0; i3 < words2.length; ++i3) {
        var x3 = words2[i3];
        if (x3 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x3;
        result += ALPHABET.charAt(x3);
      }
      for (i3 = 0; i3 < 6; ++i3) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i3 = 0; i3 < 6; ++i3) {
        var v = chk >> (5 - i3) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    __name(encode16, "encode");
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words2 = [];
      for (var i3 = 0; i3 < wordChars.length; ++i3) {
        var c2 = wordChars.charAt(i3);
        var v = ALPHABET_MAP[c2];
        if (v === void 0)
          return "Unknown character " + c2;
        chk = polymodStep(chk) ^ v;
        if (i3 + 6 >= wordChars.length)
          continue;
        words2.push(v);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words: words2 };
    }
    __name(__decode, "__decode");
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    __name(decodeUnsafe, "decodeUnsafe");
    function decode13(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    __name(decode13, "decode");
    function convert(data, inBits, outBits, pad2) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i3 = 0; i3 < data.length; ++i3) {
        value = value << inBits | data[i3];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad2) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    __name(convert, "convert");
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    __name(toWordsUnsafe, "toWordsUnsafe");
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    __name(toWords, "toWords");
    function fromWordsUnsafe(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    __name(fromWordsUnsafe, "fromWordsUnsafe");
    function fromWords(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    __name(fromWords, "fromWords");
    module2.exports = {
      decodeUnsafe,
      decode: decode13,
      encode: encode16,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getDidWebPlugin: () => getDidWebPlugin,
  initDidWebLearnCard: () => initDidWebLearnCard
});
module.exports = __toCommonJS(src_exports);

// src/plugin.ts
var getDidWebPlugin = /* @__PURE__ */ __name(async (learnCard, didWeb) => {
  const existingDid = learnCard.id.did();
  learnCard?.debug?.("Adding DID Web Plugin");
  if (!didWeb.includes("did:web:")) {
    throw new Error("Must provide a valid did:web DID into constructor.");
  }
  return {
    name: "DID Web",
    displayName: "DID Web",
    description: "The LearnCard DID Web Plugin is a plugin for adding did-web support to a LearnCard agent for signing VCs.",
    id: {
      did: (_learnCard, method) => {
        if (!method || method === "web")
          return didWeb;
        return learnCard.id.did(method);
      },
      keypair: (_learnCard, algorithm) => learnCard.id.keypair(algorithm)
    },
    methods: {}
  };
}, "getDidWebPlugin");

// ../../learn-card-core/dist/core.esm.js
var import_isomorphic_fetch = require("isomorphic-fetch");
var ac = __toESM(require_abort_controller());
var import_isomorphic_webcrypto = __toESM(require("isomorphic-webcrypto"));
var import_cross_fetch = __toESM(require_browser_ponyfill());

// ../../../node_modules/.pnpm/ethers@5.7.2/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger46,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version26,
  wordlists: () => wordlists
});

// ../../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn = __toESM(require_bn());

// ../../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/_version.js
var version = "logger/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
__name(_checkNormalize, "_checkNormalize");
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel3) {
  LogLevel3["DEBUG"] = "DEBUG";
  LogLevel3["INFO"] = "INFO";
  LogLevel3["WARNING"] = "WARNING";
  LogLevel3["ERROR"] = "ERROR";
  LogLevel3["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode3) {
  ErrorCode3["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode3["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode3["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode3["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode3["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode3["TIMEOUT"] = "TIMEOUT";
  ErrorCode3["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode3["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode3["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode3["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode3["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode3["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode3["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode3["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode3["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode3["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode3["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode3["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode3["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version29) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version29,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code3, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code3, {});
    }
    if (!code3) {
      code3 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key3) => {
      const value = params[key3];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i3 = 0; i3 < value.length; i3++) {
            hex += HEX[value[i3] >> 4];
            hex += HEX[value[i3] & 15];
          }
          messageDetails.push(key3 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key3 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key3 + "=" + JSON.stringify(params[key3].toString()));
      }
    });
    messageDetails.push(`code=${code3}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code3) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code3;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code3;
    Object.keys(params).forEach(function(key3) {
      error[key3] = params[key3];
    });
    return error;
  }
  throwError(message, code3, params) {
    throw this.makeError(message, code3, params);
  }
  throwArgumentError(message, name3, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name3,
      value
    });
  }
  assert(condition, message, code3, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code3, params);
  }
  assertArgument(condition, message, name3, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name3, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version29) {
    return new Logger(version29);
  }
};
__name(Logger, "Logger");
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// ../../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2 = "bytes/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
__name(isHexable, "isHexable");
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
__name(addSlice, "addSlice");
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
__name(isBytesLike, "isBytesLike");
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
__name(isInteger, "isInteger");
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i3 = 0; i3 < value.length; i3++) {
    const v = value[i3];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
__name(isBytes, "isBytes");
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i3 = 0; i3 < hex.length; i3 += 2) {
      result.push(parseInt(hex.substring(i3, i3 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
__name(arrayify, "arrayify");
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
__name(concat, "concat");
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
__name(stripZeros, "stripZeros");
function zeroPad(value, length2) {
  value = arrayify(value);
  if (value.length > length2) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice(result);
}
__name(zeroPad, "zeroPad");
function isHexString(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
__name(isHexString, "isHexString");
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i3 = 0; i3 < value.length; i3++) {
      let v = value[i3];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
__name(hexlify, "hexlify");
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
__name(hexDataLength, "hexDataLength");
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
__name(hexDataSlice, "hexDataSlice");
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
__name(hexConcat, "hexConcat");
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
__name(hexValue, "hexValue");
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
__name(hexStripZeros, "hexStripZeros");
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
__name(hexZeroPad, "hexZeroPad");
function splitSignature(signature3) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature3)) {
    let bytes = arrayify(signature3);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature3);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature3);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature3.r;
    result.s = signature3.s;
    result.v = signature3.v;
    result.recoveryParam = signature3.recoveryParam;
    result._vs = signature3._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature3);
      }
      vs2[0] &= 127;
      const s3 = hexlify(vs2);
      if (result.s == null) {
        result.s = s3;
      } else if (result.s !== s3) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature3);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature3);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature3);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature3);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature3);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature3);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature3);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature3);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
__name(splitSignature, "splitSignature");
function joinSignature(signature3) {
  signature3 = splitSignature(signature3);
  return hexlify(concat([
    signature3.r,
    signature3.s,
    signature3.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
__name(joinSignature, "joinSignature");

// ../../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3 = "bignumber/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN = import_bn.default.BN;
var logger2 = new Logger(version3);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
__name(isBigNumberish, "isBigNumberish");
var _warnedToStringRadix = false;
var BigNumber = class {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard) {
      logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key3) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger2.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger2.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
__name(BigNumber, "BigNumber");
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
__name(toHex, "toHex");
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
__name(toBigNumber, "toBigNumber");
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
__name(toBN, "toBN");
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
__name(throwFault, "throwFault");
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
__name(_base36To16, "_base36To16");
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
__name(_base16To36, "_base16To36");

// ../../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
var logger3 = new Logger(version3);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
__name(throwFault2, "throwFault");
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
__name(getMultiplier, "getMultiplier");
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
__name(formatFixed, "formatFixed");
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
__name(parseFixed, "parseFixed");
var FixedFormat = class {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match2 = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match2) {
          logger3.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match2[1] !== "u";
        width = parseInt(match2[2]);
        decimals = parseInt(match2[3]);
      }
    } else if (value) {
      const check = /* @__PURE__ */ __name((key3, type, defaultValue) => {
        if (value[key3] == null) {
          return defaultValue;
        }
        if (typeof value[key3] !== type) {
          logger3.throwArgumentError("invalid fixed format (" + key3 + " not " + type + ")", "format." + key3, value[key3]);
        }
        return value[key3];
      }, "check");
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard2, signed2, width, decimals);
  }
};
__name(FixedFormat, "FixedFormat");
var FixedNumber = class {
  constructor(constructorGuard, hex, value, format2) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format2;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format2) {
    return FixedNumber.fromString(this._value, format2);
  }
  static fromValue(value, decimals, format2) {
    if (format2 == null && decimals != null && !isBigNumberish(decimals)) {
      format2 = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format2 == null) {
      format2 = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format2));
  }
  static fromString(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format2) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format2);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format2);
    }
    try {
      return FixedNumber.fromValue(value, 0, format2);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
__name(FixedNumber, "FixedNumber");
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// ../../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/_version.js
var version4 = "properties/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger4 = new Logger(version4);
function defineReadOnly(object, name3, value) {
  Object.defineProperty(object, name3, {
    enumerable: true,
    value,
    writable: false
  });
}
__name(defineReadOnly, "defineReadOnly");
function getStatic(ctor, key3) {
  for (let i3 = 0; i3 < 32; i3++) {
    if (ctor[key3]) {
      return ctor[key3];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
__name(getStatic, "getStatic");
function resolveProperties(object) {
  return __awaiter(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key3) => {
      const value = object[key3];
      return Promise.resolve(value).then((v) => ({ key: key3, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
__name(resolveProperties, "resolveProperties");
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger4.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key3) => {
    if (!properties[key3]) {
      logger4.throwArgumentError("invalid object key - " + key3, "transaction:" + key3, object);
    }
  });
}
__name(checkProperties, "checkProperties");
function shallowCopy(object) {
  const result = {};
  for (const key3 in object) {
    result[key3] = object[key3];
  }
  return result;
}
__name(shallowCopy, "shallowCopy");
var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let value = null;
      try {
        value = object[keys[i3]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
__name(_isFrozen, "_isFrozen");
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key3 in object) {
      const value = object[key3];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key3, deepCopy(value));
    }
    return result;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
__name(_deepCopy, "_deepCopy");
function deepCopy(object) {
  return _deepCopy(object);
}
__name(deepCopy, "deepCopy");
var Description = class {
  constructor(info) {
    for (const key3 in info) {
      this[key3] = deepCopy(info[key3]);
    }
  }
};
__name(Description, "Description");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/_version.js
var version5 = "abi/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/fragments.js
var logger5 = new Logger(version5);
var _constructorGuard3 = {};
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name3) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name3]) {
      return true;
    }
  } else if (type === "address") {
    if (name3 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name3]) {
      return true;
    }
  }
  if (ModifiersBytes[name3] || name3 === "payable") {
    logger5.throwArgumentError("invalid modifier", "name", name3);
  }
  return false;
}
__name(checkModifier, "checkModifier");
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i3) {
    logger5.throwArgumentError(`unexpected character at position ${i3}`, "param", param);
  }
  __name(throwError, "throwError");
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  __name(newNode, "newNode");
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i3 = 0; i3 < param.length; i3++) {
    let c2 = param[i3];
    switch (c2) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i3);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i3);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i3);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i3);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i3);
              }
              if (node.indexed) {
                throwError(i3);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i3);
        }
        node.type += c2;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i3);
        }
        node.type += c2;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c2;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c2;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c2;
        } else {
          throwError(i3);
        }
    }
  }
  if (node.parent) {
    logger5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
__name(parseParamType, "parseParamType");
function populate(object, params) {
  for (let key3 in params) {
    defineReadOnly(object, key3, params[key3]);
  }
}
__name(populate, "populate");
var FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match2 = this.type.match(paramTypeArray);
    if (match2) {
      populate(this, {
        arrayLength: parseInt(match2[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match2[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger5.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format2);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format2 !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard3, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    __name(ParamTypify, "ParamTypify");
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
};
__name(ParamType, "ParamType");
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
__name(parseParams, "parseParams");
var Fragment = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger5.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger5.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
};
__name(Fragment, "Fragment");
var EventFragment = class extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger5.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger5.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let match2 = value.match(regexParen);
    if (!match2) {
      logger5.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match2[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger5.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match2[1].trim(),
      anonymous,
      inputs: parseParams(match2[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
};
__name(EventFragment, "EventFragment");
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger5.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger5.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
__name(parseGas, "parseGas");
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
__name(parseModifiers, "parseModifiers");
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger5.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger5.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger5.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
__name(verifyState, "verifyState");
var ConstructorFragment = class extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger5.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    if (format2 === FormatTypes.sighash) {
      logger5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger5.throwArgumentError("invalid constructor object", "value", value);
    }
    let state = verifyState(value);
    if (state.constant) {
      logger5.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger5.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
};
__name(ConstructorFragment, "ConstructorFragment");
var FunctionFragment = class extends ConstructorFragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger5.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format2)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger5.throwArgumentError("invalid function object", "value", value);
    }
    let state = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger5.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger5.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger5.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
};
__name(FunctionFragment, "FunctionFragment");
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
__name(checkForbidden, "checkForbidden");
var ErrorFragment = class extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger5.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger5.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard3, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger5.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
};
__name(ErrorFragment, "ErrorFragment");
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
__name(verifyType, "verifyType");
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger5.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
__name(verifyIdentifier, "verifyIdentifier");
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c2 = value[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger5.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
__name(splitNesting, "splitNesting");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
var logger6 = new Logger(version5);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = /* @__PURE__ */ __name(function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key3 in object) {
      const childPath = path.slice();
      childPath.push(key3);
      try {
        checkErrors(childPath, object[key3]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  }, "checkErrors");
  checkErrors([], result);
  return errors;
}
__name(checkResultErrors, "checkResultErrors");
var Coder = class {
  constructor(name3, type, localName, dynamic) {
    this.name = name3;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger6.throwArgumentError(message, this.localName, value);
  }
};
__name(Coder, "Coder");
var Writer = class {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat(writer._data));
  }
  writeBytes(value) {
    let bytes = arrayify(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify(BigNumber.from(value));
    if (bytes.length > this.wordSize) {
      logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
};
__name(Writer, "Writer");
var Reader = class {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(name3, value) {
    let match2 = name3.match("^u?int([0-9]+)$");
    if (match2 && parseInt(match2[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name3, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name3, value);
    }
    return Reader.coerce(name3, value);
  }
  _peekBytes(offset, length2, loose) {
    let alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
        alignedLength = length2;
      } else {
        logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length2, loose) {
    let bytes = this._peekBytes(0, length2, !!loose);
    this._offset += bytes.length;
    return bytes.slice(0, length2);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
};
__name(Reader, "Reader");

// ../../../node_modules/.pnpm/@ethersproject+keccak256@5.7.0/node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}
__name(keccak256, "keccak256");

// ../../../node_modules/.pnpm/@ethersproject+rlp@5.7.0/node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  decode: () => decode,
  encode: () => encode
});

// ../../../node_modules/.pnpm/@ethersproject+rlp@5.7.0/node_modules/@ethersproject/rlp/lib.esm/_version.js
var version6 = "rlp/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+rlp@5.7.0/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger7 = new Logger(version6);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
__name(arrayifyInteger, "arrayifyInteger");
function unarrayifyInteger(data, offset, length2) {
  let result = 0;
  for (let i3 = 0; i3 < length2; i3++) {
    result = result * 256 + data[offset + i3];
  }
  return result;
}
__name(unarrayifyInteger, "unarrayifyInteger");
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length3 = arrayifyInteger(payload.length);
    length3.unshift(247 + length3.length);
    return length3.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger7.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length2 = arrayifyInteger(data.length);
  length2.unshift(183 + length2.length);
  return length2.concat(data);
}
__name(_encode, "_encode");
function encode(object) {
  return hexlify(_encode(object));
}
__name(encode, "encode");
function _decodeChildren(data, offset, childOffset, length2) {
  const result = [];
  while (childOffset < offset + 1 + length2) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length2) {
      logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length2, result };
}
__name(_decodeChildren, "_decodeChildren");
function _decode(data, offset) {
  if (data.length === 0) {
    logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data.length) {
      logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length2);
  } else if (data[offset] >= 192) {
    const length2 = data[offset] - 192;
    if (offset + 1 + length2 > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length2);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
    return { consumed: 1 + lengthLength + length2, result };
  } else if (data[offset] >= 128) {
    const length2 = data[offset] - 128;
    if (offset + 1 + length2 > data.length) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length2));
    return { consumed: 1 + length2, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
__name(_decode, "_decode");
function decode(data) {
  const bytes = arrayify(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger7.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
__name(decode, "decode");

// ../../../node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/_version.js
var version7 = "address/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js
var logger8 = new Logger(version7);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i3 = 0; i3 < 40; i3++) {
    expanded[i3] = chars[i3].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hashed[i3 >> 1] >> 4 >= 8) {
      chars[i3] = chars[i3].toUpperCase();
    }
    if ((hashed[i3 >> 1] & 15) >= 8) {
      chars[i3 + 1] = chars[i3 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
__name(getChecksumAddress, "getChecksumAddress");
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
__name(log10, "log10");
var ibanLookup = {};
for (let i3 = 0; i3 < 10; i3++) {
  ibanLookup[String(i3)] = String(i3);
}
for (let i3 = 0; i3 < 26; i3++) {
  ibanLookup[String.fromCharCode(65 + i3)] = String(10 + i3);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
__name(ibanChecksum, "ibanChecksum");
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger8.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger8.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
__name(getAddress, "getAddress");
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
__name(isAddress, "isAddress");
function getIcapAddress(address) {
  let base362 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base362.length < 30) {
    base362 = "0" + base362;
  }
  return "XE" + ibanChecksum("XE00" + base362) + base362;
}
__name(getIcapAddress, "getIcapAddress");
function getContractAddress(transaction) {
  let from4 = null;
  try {
    from4 = getAddress(transaction.from);
  } catch (error) {
    logger8.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode([from4, nonce])), 12));
}
__name(getContractAddress, "getContractAddress");
function getCreate2Address(from4, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger8.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger8.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from4), salt, initCodeHash])), 12));
}
__name(getCreate2Address, "getCreate2Address");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
};
__name(AddressCoder, "AddressCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};
__name(AnonymousCoder, "AnonymousCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/array.js
var logger9 = new Logger(version5);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name3 = coder.localName;
      if (!name3) {
        logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name3]) {
        logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name3] = true;
      return values[name3];
    });
  } else {
    logger9.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger9.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length2 = writer.appendWriter(staticWriter);
  length2 += writer.appendWriter(dynamicWriter);
  return length2;
}
__name(pack, "pack");
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name3 = coder.localName;
    if (name3) {
      if (!accum[name3]) {
        accum[name3] = 0;
      }
      accum[name3]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name3 = coder.localName;
    if (!name3 || uniqueNames[name3] !== 1) {
      return;
    }
    if (name3 === "length") {
      name3 = "_length";
    }
    if (values[name3] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name3, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name3] = value;
    }
  });
  for (let i3 = 0; i3 < values.length; i3++) {
    const value = values[i3];
    if (value instanceof Error) {
      Object.defineProperty(values, i3, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
__name(unpack, "unpack");
var ArrayCoder = class extends Coder {
  constructor(coder, length2, localName) {
    const type = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
    const dynamic = length2 === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length2;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i3 = 0; i3 < this.length; i3++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger9.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i3 = 0; i3 < value.length; i3++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i3 = 0; i3 < count; i3++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
};
__name(ArrayCoder, "ArrayCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
};
__name(BooleanCoder, "BooleanCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length2 = writer.writeValue(value.length);
    length2 += writer.writeBytes(value);
    return length2;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
};
__name(DynamicBytesCoder, "DynamicBytesCoder");
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
};
__name(BytesCoder, "BytesCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder = class extends Coder {
  constructor(size, localName) {
    let name3 = "bytes" + String(size);
    super(name3, name3, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
};
__name(FixedBytesCoder, "FixedBytesCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
};
__name(NullCoder, "NullCoder");

// ../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne2,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero2
});

// ../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero = "0x0000000000000000000000000000000000000000";

// ../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2 = /* @__PURE__ */ BigNumber.from(-1);
var Zero2 = /* @__PURE__ */ BigNumber.from(0);
var One = /* @__PURE__ */ BigNumber.from(1);
var Two = /* @__PURE__ */ BigNumber.from(2);
var WeiPerEther = /* @__PURE__ */ BigNumber.from("1000000000000000000");
var MaxUint256 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = /* @__PURE__ */ BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = /* @__PURE__ */ BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// ../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// ../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol = "\u039E";

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder = class extends Coder {
  constructor(size, signed2, localName) {
    const name3 = (signed2 ? "int" : "uint") + size * 8;
    super(name3, name3, localName, false);
    this.size = size;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v = BigNumber.from(value);
    let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne2))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v.lt(Zero2) || v.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v = v.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
};
__name(NumberCoder, "NumberCoder");

// ../../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/_version.js
var version8 = "strings/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger10 = new Logger(version8);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm3) {
  UnicodeNormalizationForm3["current"] = "";
  UnicodeNormalizationForm3["NFC"] = "NFC";
  UnicodeNormalizationForm3["NFD"] = "NFD";
  UnicodeNormalizationForm3["NFKC"] = "NFKC";
  UnicodeNormalizationForm3["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason3) {
  Utf8ErrorReason3["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason3["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason3["OVERRUN"] = "string overrun";
  Utf8ErrorReason3["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason3["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason3["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason3["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
__name(errorFunc, "errorFunc");
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i3 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i3++;
    }
    return i3;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
__name(ignoreFunc, "ignoreFunc");
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
__name(replaceFunc, "replaceFunc");
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i3 = 0;
  while (i3 < bytes.length) {
    const c2 = bytes[i3++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i3 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i3 - 1, bytes, result);
      } else {
        i3 += onError(Utf8ErrorReason.BAD_PREFIX, i3 - 1, bytes, result);
      }
      continue;
    }
    if (i3 - 1 + extraLength >= bytes.length) {
      i3 += onError(Utf8ErrorReason.OVERRUN, i3 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i3];
      if ((nextChar & 192) != 128) {
        i3 += onError(Utf8ErrorReason.MISSING_CONTINUE, i3, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i3++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i3 += onError(Utf8ErrorReason.OUT_OF_RANGE, i3 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i3 += onError(Utf8ErrorReason.UTF16_SURROGATE, i3 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i3 += onError(Utf8ErrorReason.OVERLONG, i3 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
__name(getUtf8CodePoints, "getUtf8CodePoints");
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger10.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i3 = 0; i3 < str.length; i3++) {
    const c2 = str.charCodeAt(i3);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i3++;
      const c22 = str.charCodeAt(i3);
      if (i3 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
__name(toUtf8Bytes, "toUtf8Bytes");
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
__name(escapeChar, "escapeChar");
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
__name(_toEscapedUtf8String, "_toEscapedUtf8String");
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
__name(_toUtf8String, "_toUtf8String");
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
__name(toUtf8String, "toUtf8String");
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
__name(toUtf8CodePoints, "toUtf8CodePoints");

// ../../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String(text) {
  const bytes = toUtf8Bytes(text);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
__name(formatBytes32String, "formatBytes32String");
function parseBytes32String(bytes) {
  const data = arrayify(bytes);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length2 = 31;
  while (data[length2 - 1] === 0) {
    length2--;
  }
  return toUtf8String(data.slice(0, length2));
}
__name(parseBytes32String, "parseBytes32String");

// ../../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i3 = 0; i3 < data.length; i3 += 4) {
    result.push(parseInt(data.substring(i3, i3 + 4), 16));
  }
  return result;
}
__name(bytes2, "bytes2");
function createTable(data, func) {
  if (!func) {
    func = /* @__PURE__ */ __name(function(value) {
      return [parseInt(value, 16)];
    }, "func");
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
__name(createTable, "createTable");
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
__name(createRangeTable, "createRangeTable");
function matchMap(value, ranges) {
  let lo = 0;
  for (let i3 = 0; i3 < ranges.length; i3++) {
    let range = ranges[i3];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
__name(matchMap, "matchMap");
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
__name(flatten, "flatten");
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
__name(_nameprepTableA1, "_nameprepTableA1");
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
__name(_nameprepTableB2, "_nameprepTableB2");
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
__name(_nameprepTableC, "_nameprepTableC");
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code3) => {
    if (Table_B_1_flags.indexOf(code3) >= 0) {
      return [];
    }
    if (code3 >= 65024 && code3 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code3);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code3];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code3) => {
    if (_nameprepTableC(code3)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code3) => {
    if (_nameprepTableA1(code3)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name3 = _toUtf8String(codes);
  if (name3.substring(0, 1) === "-" || name3.substring(2, 4) === "--" || name3.substring(name3.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name3;
}
__name(nameprep, "nameprep");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};
__name(StringCoder, "StringCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name3 = coder.localName;
      if (name3) {
        if (!accum[name3]) {
          accum[name3] = 0;
        }
        accum[name3]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name3 = coder.localName;
      if (!name3 || uniqueNames[name3] !== 1) {
        return;
      }
      if (name3 === "length") {
        name3 = "_length";
      }
      if (values[name3] != null) {
        return;
      }
      values[name3] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
};
__name(TupleCoder, "TupleCoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger11 = new Logger(version5);
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = class {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match2 = param.type.match(paramTypeNumber);
    if (match2) {
      let size = parseInt(match2[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger11.throwArgumentError("invalid " + match2[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match2[1] === "int", param.name);
    }
    match2 = param.type.match(paramTypeBytes);
    if (match2) {
      let size = parseInt(match2[1]);
      if (size === 0 || size > 32) {
        logger11.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger11.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
};
__name(AbiCoder, "AbiCoder");
var defaultAbiCoder = new AbiCoder();

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak256(toUtf8Bytes(text));
}
__name(id, "id");

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/_version.js
var version9 = "hash/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  decode: () => decode2,
  encode: () => encode2
});

// ../../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/base64.js
function decode2(textData) {
  textData = atob(textData);
  const data = [];
  for (let i3 = 0; i3 < textData.length; i3++) {
    data.push(textData.charCodeAt(i3));
  }
  return arrayify(data);
}
__name(decode2, "decode");
function encode2(data) {
  data = arrayify(data);
  let textData = "";
  for (let i3 = 0; i3 < data.length; i3++) {
    textData += String.fromCharCode(data[i3]);
  }
  return btoa(textData);
}
__name(encode2, "encode");

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = /* @__PURE__ */ __name(function(arr, depth2) {
    forEach.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  }, "flatDeep");
  flatDeep(array, depth);
  return result;
}
__name(flat, "flat");
function fromEntries(array) {
  const result = {};
  for (let i3 = 0; i3 < array.length; i3++) {
    const value = array[i3];
    result[value[0]] = value[1];
  }
  return result;
}
__name(fromEntries, "fromEntries");
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  __name(u16, "u16");
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i3 = 1; i3 < symbol_count; i3++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  __name(read_bit, "read_bit");
  const N10 = 31;
  const FULL = Math.pow(2, N10);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i3 = 0; i3 < N10; i3++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a3 = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a3 ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a3 = a3 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a3 & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a3 = a3 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a3;
    range = 1 + b2 - a3;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
__name(decode_arithmetic, "decode_arithmetic");
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
__name(read_payload, "read_payload");
function read_compressed_payload(bytes) {
  return read_payload(decode_arithmetic(bytes));
}
__name(read_compressed_payload, "read_compressed_payload");
function signed(i3) {
  return i3 & 1 ? ~i3 >> 1 : i3 >> 1;
}
__name(signed, "signed");
function read_counts(n, next) {
  let v = Array(n);
  for (let i3 = 0; i3 < n; i3++)
    v[i3] = 1 + next();
  return v;
}
__name(read_counts, "read_counts");
function read_ascending(n, next) {
  let v = Array(n);
  for (let i3 = 0, x2 = -1; i3 < n; i3++)
    v[i3] = x2 += 1 + next();
  return v;
}
__name(read_ascending, "read_ascending");
function read_deltas(n, next) {
  let v = Array(n);
  for (let i3 = 0, x2 = 0; i3 < n; i3++)
    v[i3] = x2 += signed(next());
  return v;
}
__name(read_deltas, "read_deltas");
function read_member_array(next, lookup) {
  let v = read_ascending(next(), next);
  let n = next();
  let vX = read_ascending(n, next);
  let vN = read_counts(n, next);
  for (let i3 = 0; i3 < n; i3++) {
    for (let j = 0; j < vN[i3]; j++) {
      v.push(vX[i3] + j);
    }
  }
  return lookup ? v.map((x2) => lookup[x2]) : v;
}
__name(read_member_array, "read_member_array");
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next));
  }
  return fromEntries(flat(ret));
}
__name(read_mapped_map, "read_mapped_map");
function read_zero_terminated_array(next) {
  let v = [];
  while (true) {
    let i3 = next();
    if (i3 == 0)
      break;
    v.push(i3);
  }
  return v;
}
__name(read_zero_terminated_array, "read_zero_terminated_array");
function read_transposed(n, w2, next) {
  let m3 = Array(n).fill(void 0).map(() => []);
  for (let i3 = 0; i3 < w2; i3++) {
    read_deltas(n, next).forEach((x2, j) => m3[j].push(x2));
  }
  return m3;
}
__name(read_transposed, "read_transposed");
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m3 = read_transposed(vN.length, 1 + w2, next);
  return flat(m3.map((v, i3) => {
    const x2 = v[0], ys = v.slice(1);
    return Array(vN[i3]).fill(void 0).map((_, j) => {
      let j_dy = j * dy;
      return [x2 + j * dx, ys.map((y3) => y3 + j_dy)];
    });
  }));
}
__name(read_linear_table, "read_linear_table");
function read_replacement_table(w2, next) {
  let n = 1 + next();
  let m3 = read_transposed(n, 1 + w2, next);
  return m3.map((v) => [v[0], v.slice(1)]);
}
__name(read_replacement_table, "read_replacement_table");
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a3, b2) => a3 - b2);
  return read2();
  function read2() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read2() });
    }
    branches.sort((a3, b2) => b2.set.size - a3.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
  __name(read2, "read");
}
__name(read_emoji_trie, "read_emoji_trie");

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js
function getData() {
  return read_compressed_payload(decode2("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
__name(getData, "getData");

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js
var r = getData();
var VALID = new Set(read_member_array(r));
var IGNORED = new Set(read_member_array(r));
var MAPPED = read_mapped_map(r);
var EMOJI_ROOT = read_emoji_trie(r);
var HYPHEN = 45;
var UNDERSCORE = 95;
function explode_cp(name3) {
  return toUtf8CodePoints(name3);
}
__name(explode_cp, "explode_cp");
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
__name(filter_fe0f, "filter_fe0f");
function ens_normalize_post_check(name3) {
  for (let label of name3.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i3 = cps.lastIndexOf(UNDERSCORE) - 1; i3 >= 0; i3--) {
        if (cps[i3] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name3;
}
__name(ens_normalize_post_check, "ens_normalize_post_check");
function ens_normalize(name3) {
  return ens_normalize_post_check(normalize(name3, filter_fe0f));
}
__name(ens_normalize, "ens_normalize");
function normalize(name3, emoji_filter) {
  let input = explode_cp(name3).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
__name(normalize, "normalize");
function nfc(s3) {
  return s3.normalize("NFC");
}
__name(nfc, "nfc");
function consume_emoji_reversed(cps, eaten) {
  var _a;
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node = (_a = node.branches.find((x2) => x2.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
    if (!node)
      break;
    if (node.save) {
      saved = cp;
    } else if (node.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node.valid) {
      emoji = stack.slice();
      if (node.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
__name(consume_emoji_reversed, "consume_emoji_reversed");

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger12 = new Logger(version9);
var Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
__name(checkComponent, "checkComponent");
function ensNameSplit(name3) {
  const bytes = toUtf8Bytes(ens_normalize(name3));
  const comps = [];
  if (name3.length === 0) {
    return comps;
  }
  let last2 = 0;
  for (let i3 = 0; i3 < bytes.length; i3++) {
    const d3 = bytes[i3];
    if (d3 === 46) {
      comps.push(checkComponent(bytes.slice(last2, i3)));
      last2 = i3 + 1;
    }
  }
  if (last2 >= bytes.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes.slice(last2)));
  return comps;
}
__name(ensNameSplit, "ensNameSplit");
function isValidName(name3) {
  try {
    return ensNameSplit(name3).length !== 0;
  } catch (error) {
  }
  return false;
}
__name(isValidName, "isValidName");
function namehash(name3) {
  if (typeof name3 !== "string") {
    logger12.throwArgumentError("invalid ENS name; not a string", "name", name3);
  }
  let result = Zeros;
  const comps = ensNameSplit(name3);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
__name(namehash, "namehash");
function dnsEncode(name3) {
  return hexlify(concat(ensNameSplit(name3).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
__name(dnsEncode, "dnsEncode");

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/message.js
var messagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
__name(hashMessage, "hashMessage");

// ../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/typed-data.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger13 = new Logger(version9);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne3 = BigNumber.from(-1);
var Zero3 = BigNumber.from(0);
var One2 = BigNumber.from(1);
var MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
__name(hexPadRight, "hexPadRight");
var hexTrue = hexZeroPad(One2.toHexString(), 32);
var hexFalse = hexZeroPad(Zero3.toHexString(), 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key3) {
  return function(value) {
    if (typeof value !== "string") {
      logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key3)}`, `domain.${key3}`, value);
    }
    return value;
  };
}
__name(checkString, "checkString");
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes);
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match2 = type.match(/^(u?)int(\d*)$/);
    if (match2) {
      const signed2 = match2[1] === "";
      const width = parseInt(match2[2] || "256");
      if (width % 8 !== 0 || width > 256 || match2[2] && match2[2] !== String(width)) {
        logger13.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2562.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
      return function(value) {
        const v = BigNumber.from(value);
        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger13.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match2 = type.match(/^bytes(\d+)$/);
    if (match2) {
      const width = parseInt(match2[1]);
      if (width === 0 || width > 32 || match2[1] !== String(width)) {
        logger13.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger13.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
__name(getBaseEncoder, "getBaseEncoder");
function encodeType(name3, fields) {
  return `${name3}(${fields.map(({ name: name4, type }) => type + " " + name4).join(",")})`;
}
__name(encodeType, "encodeType");
var TypedDataEncoder = class {
  constructor(types) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links2 = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links2[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name3 in types) {
      const uniqueNames = {};
      types[name3].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger13.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name3)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name3) {
          logger13.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger13.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name3);
        links2[name3][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n) => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger13.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger13.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger13.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links2[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    __name(checkCircular, "checkCircular");
    checkCircular(this.primaryType, {});
    for (const name3 in subtypes) {
      const st = Object.keys(subtypes[name3]);
      st.sort();
      this._types[name3] = encodeType(name3, types[name3]) + st.map((t2) => encodeType(t2, types[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match2) {
      const subtype = match2[1];
      const subEncoder = this.getEncoder(subtype);
      const length2 = parseInt(match2[3]);
      return (value) => {
        if (length2 >= 0 && value.length !== length2) {
          logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256);
        }
        return keccak256(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name3, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name3]);
          if (this._types[type2]) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name3) {
    const result = this._types[name3];
    if (!result) {
      logger13.throwArgumentError(`unknown type: ${JSON.stringify(name3)}`, "name", name3);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name3, value) {
    return keccak256(this.encodeData(name3, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match2) {
      const subtype = match2[1];
      const length2 = parseInt(match2[3]);
      if (length2 >= 0 && value.length !== length2) {
        logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v) => this._visit(subtype, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name3, type: type2 }) => {
        accum[name3] = this._visit(type2, value[name3], callback);
        return accum;
      }, {});
    }
    return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name3, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name3, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name3 in domain) {
      const type = domainFieldTypes[name3];
      if (!type) {
        logger13.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name3)}`, "domain", domain);
      }
      domainFields.push({ name: name3, type });
    }
    domainFields.sort((a3, b2) => {
      return domainFieldNames.indexOf(a3.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak256(TypedDataEncoder.encode(domain, types, value));
  }
  static resolveNames(domain, types, value, resolveName2) {
    return __awaiter2(this, void 0, void 0, function* () {
      domain = shallowCopy(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name3 in ensCache) {
        ensCache[name3] = yield resolveName2(name3);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name3) => {
      const value2 = domain[name3];
      if (value2 == null) {
        return;
      }
      domainValues[name3] = domainChecks[name3](value2);
      domainTypes.push({ name: name3, type: domainFieldTypes[name3] });
    });
    const encoder = TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy(types);
    if (typesWithDomain.EIP712Domain) {
      logger13.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger13.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger13.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
};
__name(TypedDataEncoder, "TypedDataEncoder");

// ../../../node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/interface.js
var logger14 = new Logger(version5);
var LogDescription = class extends Description {
};
__name(LogDescription, "LogDescription");
var TransactionDescription = class extends Description {
};
__name(TransactionDescription, "TransactionDescription");
var ErrorDescription = class extends Description {
};
__name(ErrorDescription, "ErrorDescription");
var Indexed = class extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
};
__name(Indexed, "Indexed");
var BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
__name(wrapAccessError, "wrapAccessError");
var Interface = class {
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger14.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature3 = fragment.format();
      if (bucket[signature3]) {
        logger14.warn("duplicate definition - " + signature3);
        return;
      }
      bucket[signature3] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.full;
    }
    if (format2 === FormatTypes.sighash) {
      logger14.throwArgumentError("interface does not support formatting sighash", "format", format2);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format2));
    if (format2 === FormatTypes.json) {
      return JSON.stringify(abi.map((j) => JSON.parse(j)));
    }
    return abi;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name3 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name3)) {
          return this.functions[name3];
        }
      }
      logger14.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name3 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f) => f.split("(")[0] === name3);
      if (matching.length === 0) {
        logger14.throwArgumentError("no matching function", "name", name3);
      } else if (matching.length > 1) {
        logger14.throwArgumentError("multiple matching functions", "name", name3);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger14.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name3 in this.events) {
        if (topichash === this.getEventTopic(name3)) {
          return this.events[name3];
        }
      }
      logger14.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name3 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f) => f.split("(")[0] === name3);
      if (matching.length === 0) {
        logger14.throwArgumentError("no matching event", "name", name3);
      } else if (matching.length > 1) {
        logger14.throwArgumentError("multiple matching events", "name", name3);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger14.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name3 in this.errors) {
        const error = this.errors[name3];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name3];
        }
      }
      logger14.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name3 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f) => f.split("(")[0] === name3);
      if (matching.length === 0) {
        logger14.throwArgumentError("no matching error", "name", name3);
      } else if (matching.length > 1) {
        logger14.throwArgumentError("multiple matching errors", "name", name3);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger14.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify(data);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger14.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify(data);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger14.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify(data);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger14.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger14.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = /* @__PURE__ */ __name((param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    }, "encodeTopic");
    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger14.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger14.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger14.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger14.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index]) {
          result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i3 = 0; i3 < result.length; i3++) {
      const value = result[i3];
      if (value instanceof Error) {
        Object.defineProperty(result, i3, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i3}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
};
__name(Interface, "Interface");

// ../../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version10 = "abstract-provider/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger15 = new Logger(version10);
var ForkEvent = class extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
};
__name(ForkEvent, "ForkEvent");
var Provider = class {
  constructor() {
    logger15.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter3(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener2) {
    return this.on(eventName, listener2);
  }
  removeListener(eventName, listener2) {
    return this.off(eventName, listener2);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
};
__name(Provider, "Provider");

// ../../../node_modules/.pnpm/@ethersproject+abstract-signer@5.7.0/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version11 = "abstract-signer/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+abstract-signer@5.7.0/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger16 = new Logger(version11);
var allowedTransactionKeys = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
var Signer = class {
  constructor() {
    logger16.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name3) {
    return __awaiter4(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name3);
    });
  }
  checkTransaction(transaction) {
    for (const key3 in transaction) {
      if (allowedTransactionKeys.indexOf(key3) === -1) {
        logger16.throwArgumentError("invalid transaction key: " + key3, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger16.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter4(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter4(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger16.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger16.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger16.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger16.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger16.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger16.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger16.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger16.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};
__name(Signer, "Signer");
var VoidSigner = class extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger16.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
};
__name(VoidSigner, "VoidSigner");

// ../../../node_modules/.pnpm/@ethersproject+signing-key@5.7.0/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
var import_bn2 = __toESM(require_bn());
var import_hash2 = __toESM(require_hash());
function createCommonjsModule(fn, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base4) {
      return commonjsRequire(path, base4 === void 0 || base4 === null ? module2.path : base4);
    }
  }, fn(module2, module2.exports), module2.exports;
}
__name(createCommonjsModule, "createCommonjsModule");
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
__name(commonjsRequire, "commonjsRequire");
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
__name(assert, "assert");
assert.equal = /* @__PURE__ */ __name(function assertEqual(l, r2, msg) {
  if (l != r2)
    throw new Error(msg || "Assertion failed: " + l + " != " + r2);
}, "assertEqual");
var utils_1 = createCommonjsModule(function(module2, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i3 = 0; i3 < msg.length; i3++)
        res[i3] = msg[i3] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i3 = 0; i3 < msg.length; i3 += 2)
        res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
    } else {
      for (var i3 = 0; i3 < msg.length; i3++) {
        var c2 = msg.charCodeAt(i3);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  __name(toArray, "toArray");
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  __name(zero2, "zero2");
  utils.zero2 = zero2;
  function toHex2(msg) {
    var res = "";
    for (var i3 = 0; i3 < msg.length; i3++)
      res += zero2(msg[i3].toString(16));
    return res;
  }
  __name(toHex2, "toHex");
  utils.toHex = toHex2;
  utils.encode = /* @__PURE__ */ __name(function encode16(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  }, "encode");
});
var utils_1$1 = createCommonjsModule(function(module2, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode;
  function getNAF3(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i3 = 0; i3 < naf.length; i3++) {
      var z2;
      var mod2 = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod2 > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod2;
        else
          z2 = mod2;
        k2.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i3] = z2;
      k2.iushrn(1);
    }
    return naf;
  }
  __name(getNAF3, "getNAF");
  utils.getNAF = getNAF3;
  function getJSF3(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d22 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d22) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d22 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d22 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d22 === u2 + 1)
        d22 = 1 - d22;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  __name(getJSF3, "getJSF");
  utils.getJSF = getJSF3;
  function cachedProperty(obj, name3, computer) {
    var key3 = "_" + name3;
    obj.prototype[name3] = /* @__PURE__ */ __name(function cachedProperty2() {
      return this[key3] !== void 0 ? this[key3] : this[key3] = computer.call(this);
    }, "cachedProperty");
  }
  __name(cachedProperty, "cachedProperty");
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  __name(parseBytes, "parseBytes");
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn2.default(bytes, "hex", "le");
  }
  __name(intFromLE, "intFromLE");
  utils.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
__name(BaseCurve, "BaseCurve");
var base = BaseCurve;
BaseCurve.prototype.point = /* @__PURE__ */ __name(function point() {
  throw new Error("Not implemented");
}, "point");
BaseCurve.prototype.validate = /* @__PURE__ */ __name(function validate() {
  throw new Error("Not implemented");
}, "validate");
BaseCurve.prototype._fixedNafMul = /* @__PURE__ */ __name(function _fixedNafMul(p, k2) {
  assert$1(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a3 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i3 = I2; i3 > 0; i3--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i3)
        b2 = b2.mixedAdd(doubles.points[j]);
      else if (nafW === -i3)
        b2 = b2.mixedAdd(doubles.points[j].neg());
    }
    a3 = a3.add(b2);
  }
  return a3.toP();
}, "_fixedNafMul");
BaseCurve.prototype._wnafMul = /* @__PURE__ */ __name(function _wnafMul(p, k2) {
  var w2 = 4;
  var nafPoints = p._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i3 = naf.length - 1; i3 >= 0; i3--) {
    for (var l = 0; i3 >= 0 && naf[i3] === 0; i3--)
      l++;
    if (i3 >= 0)
      l++;
    acc = acc.dblp(l);
    if (i3 < 0)
      break;
    var z2 = naf[i3];
    assert$1(z2 !== 0);
    if (p.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
}, "_wnafMul");
BaseCurve.prototype._wnafMulAdd = /* @__PURE__ */ __name(function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i3;
  var j;
  var p;
  for (i3 = 0; i3 < len; i3++) {
    p = points[i3];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i3] = nafPoints.wnd;
    wnd[i3] = nafPoints.points;
  }
  for (i3 = len - 1; i3 >= 1; i3 -= 2) {
    var a3 = i3 - 1;
    var b2 = i3;
    if (wndWidth[a3] !== 1 || wndWidth[b2] !== 1) {
      naf[a3] = getNAF(coeffs[a3], wndWidth[a3], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max = Math.max(naf[a3].length, max);
      max = Math.max(naf[b2].length, max);
      continue;
    }
    var comb = [
      points[a3],
      null,
      null,
      points[b2]
    ];
    if (points[a3].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a3].add(points[b2]);
      comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
    } else if (points[a3].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a3].toJ().mixedAdd(points[b2]);
      comb[2] = points[a3].add(points[b2].neg());
    } else {
      comb[1] = points[a3].toJ().mixedAdd(points[b2]);
      comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a3], coeffs[b2]);
    max = Math.max(jsf[0].length, max);
    naf[a3] = new Array(max);
    naf[b2] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a3][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j] = 0;
      wnd[a3] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i3 = max; i3 >= 0; i3--) {
    var k2 = 0;
    while (i3 >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i3] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i3--;
    }
    if (i3 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i3 < 0)
      break;
    for (j = 0; j < len; j++) {
      var z2 = tmp[j];
      p;
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p = wnd[j][z2 - 1 >> 1];
      else if (z2 < 0)
        p = wnd[j][-z2 - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i3 = 0; i3 < len; i3++)
    wnd[i3] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
}, "_wnafMulAdd");
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
__name(BasePoint, "BasePoint");
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = /* @__PURE__ */ __name(function eq() {
  throw new Error("Not implemented");
}, "eq");
BasePoint.prototype.validate = /* @__PURE__ */ __name(function validate2() {
  return this.curve.validate(this);
}, "validate");
BaseCurve.prototype.decodePoint = /* @__PURE__ */ __name(function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
}, "decodePoint");
BasePoint.prototype.encodeCompressed = /* @__PURE__ */ __name(function encodeCompressed(enc) {
  return this.encode(enc, true);
}, "encodeCompressed");
BasePoint.prototype._encode = /* @__PURE__ */ __name(function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
}, "_encode");
BasePoint.prototype.encode = /* @__PURE__ */ __name(function encode3(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
}, "encode");
BasePoint.prototype.precompute = /* @__PURE__ */ __name(function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
}, "precompute");
BasePoint.prototype._hasDoubles = /* @__PURE__ */ __name(function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
}, "_hasDoubles");
BasePoint.prototype._getDoubles = /* @__PURE__ */ __name(function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i3 = 0; i3 < power; i3 += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
}, "_getDoubles");
BasePoint.prototype._getNAFPoints = /* @__PURE__ */ __name(function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl4 = max === 1 ? null : this.dbl();
  for (var i3 = 1; i3 < max; i3++)
    res[i3] = res[i3 - 1].add(dbl4);
  return {
    wnd,
    points: res
  };
}, "_getNAFPoints");
BasePoint.prototype._getBeta = /* @__PURE__ */ __name(function _getBeta() {
  return null;
}, "_getBeta");
BasePoint.prototype.dblp = /* @__PURE__ */ __name(function dblp(k2) {
  var r2 = this;
  for (var i3 = 0; i3 < k2; i3++)
    r2 = r2.dbl();
  return r2;
}, "dblp");
var inherits_browser = createCommonjsModule(function(module2) {
  if (typeof Object.create === "function") {
    module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    }, "inherits");
  } else {
    module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = /* @__PURE__ */ __name(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    }, "inherits");
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
__name(ShortCurve, "ShortCurve");
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = /* @__PURE__ */ __name(function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn2.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn2.default(vec.a, 16),
        b: new import_bn2.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
}, "_getEndomorphism");
ShortCurve.prototype._getEndoRoots = /* @__PURE__ */ __name(function _getEndoRoots(num) {
  var red = num === this.p ? this.red : import_bn2.default.mont(num);
  var tinv = new import_bn2.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s3 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s3).fromRed();
  var l2 = ntinv.redSub(s3).fromRed();
  return [l1, l2];
}, "_getEndoRoots");
ShortCurve.prototype._getEndoBasis = /* @__PURE__ */ __name(function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v = this.n.clone();
  var x1 = new import_bn2.default(1);
  var y1 = new import_bn2.default(0);
  var x2 = new import_bn2.default(0);
  var y22 = new import_bn2.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a22;
  var b2;
  var prevR;
  var i3 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v.div(u2);
    r2 = v.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y22.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i3 === 2) {
      break;
    }
    prevR = r2;
    v = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y22 = y1;
    y1 = y3;
  }
  a22 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a22.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a22 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a22.negative) {
    a22 = a22.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a22, b: b2 }
  ];
}, "_getEndoBasis");
ShortCurve.prototype._endoSplit = /* @__PURE__ */ __name(function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
}, "_endoSplit");
ShortCurve.prototype.pointFromX = /* @__PURE__ */ __name(function pointFromX(x2, odd) {
  x2 = new import_bn2.default(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y22.redSqrt();
  if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
}, "pointFromX");
ShortCurve.prototype.validate = /* @__PURE__ */ __name(function validate3(point4) {
  if (point4.inf)
    return true;
  var x2 = point4.x;
  var y3 = point4.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y3.redSqr().redISub(rhs).cmpn(0) === 0;
}, "validate");
ShortCurve.prototype._endoWnafMulAdd = /* @__PURE__ */ __name(function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i3 = 0; i3 < points.length; i3++) {
    var split = this._endoSplit(coeffs[i3]);
    var p = points[i3];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i3 * 2] = p;
    npoints[i3 * 2 + 1] = beta;
    ncoeffs[i3 * 2] = split.k1;
    ncoeffs[i3 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i3 * 2, jacobianResult);
  for (var j = 0; j < i3 * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
}, "_endoWnafMulAdd");
function Point(curve, x2, y3, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x2 === null && y3 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x2, 16);
    this.y = new import_bn2.default(y3, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
__name(Point, "Point");
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = /* @__PURE__ */ __name(function point2(x2, y3, isRed) {
  return new Point(this, x2, y3, isRed);
}, "point");
ShortCurve.prototype.pointFromJSON = /* @__PURE__ */ __name(function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
}, "pointFromJSON");
Point.prototype._getBeta = /* @__PURE__ */ __name(function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = /* @__PURE__ */ __name(function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    }, "endoMul");
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
}, "_getBeta");
Point.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
}, "toJSON");
Point.fromJSON = /* @__PURE__ */ __name(function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  __name(obj2point, "obj2point");
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
}, "fromJSON");
Point.prototype.inspect = /* @__PURE__ */ __name(function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, "inspect");
Point.prototype.isInfinity = /* @__PURE__ */ __name(function isInfinity() {
  return this.inf;
}, "isInfinity");
Point.prototype.add = /* @__PURE__ */ __name(function add(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
}, "add");
Point.prototype.dbl = /* @__PURE__ */ __name(function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a3 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a3).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
}, "dbl");
Point.prototype.getX = /* @__PURE__ */ __name(function getX() {
  return this.x.fromRed();
}, "getX");
Point.prototype.getY = /* @__PURE__ */ __name(function getY() {
  return this.y.fromRed();
}, "getY");
Point.prototype.mul = /* @__PURE__ */ __name(function mul(k2) {
  k2 = new import_bn2.default(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
}, "mul");
Point.prototype.mulAdd = /* @__PURE__ */ __name(function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
}, "mulAdd");
Point.prototype.jmulAdd = /* @__PURE__ */ __name(function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
}, "jmulAdd");
Point.prototype.eq = /* @__PURE__ */ __name(function eq2(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
}, "eq");
Point.prototype.neg = /* @__PURE__ */ __name(function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = /* @__PURE__ */ __name(function(p) {
      return p.neg();
    }, "negate");
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
}, "neg");
Point.prototype.toJ = /* @__PURE__ */ __name(function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
}, "toJ");
function JPoint(curve, x2, y3, z2) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y3 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x2, 16);
    this.y = new import_bn2.default(y3, 16);
    this.z = new import_bn2.default(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
__name(JPoint, "JPoint");
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = /* @__PURE__ */ __name(function jpoint(x2, y3, z2) {
  return new JPoint(this, x2, y3, z2);
}, "jpoint");
JPoint.prototype.toP = /* @__PURE__ */ __name(function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
}, "toP");
JPoint.prototype.neg = /* @__PURE__ */ __name(function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, "neg");
JPoint.prototype.add = /* @__PURE__ */ __name(function add2(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s22 = p.y.redMul(z2.redMul(this.z));
  var h3 = u1.redSub(u2);
  var r2 = s1.redSub(s22);
  if (h3.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h3.redSqr();
  var h32 = h22.redMul(h3);
  var v = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p.z).redMul(h3);
  return this.curve.jpoint(nx, ny, nz);
}, "add");
JPoint.prototype.mixedAdd = /* @__PURE__ */ __name(function mixedAdd(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s22 = p.y.redMul(z2).redMul(this.z);
  var h3 = u1.redSub(u2);
  var r2 = s1.redSub(s22);
  if (h3.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h3.redSqr();
  var h32 = h22.redMul(h3);
  var v = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h3);
  return this.curve.jpoint(nx, ny, nz);
}, "mixedAdd");
JPoint.prototype.dblp = /* @__PURE__ */ __name(function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i3;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i3 = 0; i3 < pow; i3++)
      r2 = r2.dbl();
    return r2;
  }
  var a3 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i3 = 0; i3 < pow; i3++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i3 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
}, "dblp");
JPoint.prototype.dbl = /* @__PURE__ */ __name(function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
}, "dbl");
JPoint.prototype._zeroDbl = /* @__PURE__ */ __name(function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m3 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m3.redSqr().redISub(s3).redISub(s3);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m3.redMul(s3.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a3 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d3 = this.x.redAdd(b2).redSqr().redISub(a3).redISub(c2);
    d3 = d3.redIAdd(d3);
    var e2 = a3.redAdd(a3).redIAdd(a3);
    var f = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d3).redISub(d3);
    ny = e2.redMul(d3.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
}, "_zeroDbl");
JPoint.prototype._threeDbl = /* @__PURE__ */ __name(function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m3 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m3.redSqr().redISub(s3).redISub(s3);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m3.redMul(s3.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
}, "_threeDbl");
JPoint.prototype._dbl = /* @__PURE__ */ __name(function _dbl() {
  var a3 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
}, "_dbl");
JPoint.prototype.trpl = /* @__PURE__ */ __name(function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m3 = xx.redAdd(xx).redIAdd(xx);
  var mm = m3.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m3.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
}, "trpl");
JPoint.prototype.mul = /* @__PURE__ */ __name(function mul2(k2, kbase) {
  k2 = new import_bn2.default(k2, kbase);
  return this.curve._wnafMul(this, k2);
}, "mul");
JPoint.prototype.eq = /* @__PURE__ */ __name(function eq3(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
}, "eq");
JPoint.prototype.eqXToP = /* @__PURE__ */ __name(function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
}, "eqXToP");
JPoint.prototype.inspect = /* @__PURE__ */ __name(function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, "inspect");
JPoint.prototype.isInfinity = /* @__PURE__ */ __name(function isInfinity2() {
  return this.z.cmpn(0) === 0;
}, "isInfinity");
var curve_1 = createCommonjsModule(function(module2, exports) {
  "use strict";
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = null;
  curve.edwards = null;
});
var curves_1 = createCommonjsModule(function(module2, exports) {
  "use strict";
  var curves = exports;
  var assert3 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert3(this.g.validate(), "Invalid curve");
    assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  __name(PresetCurve, "PresetCurve");
  curves.PresetCurve = PresetCurve;
  function defineCurve(name3, options) {
    Object.defineProperty(curves, name3, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name3, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  __name(defineCurve, "defineCurve");
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash2.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash2.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash2.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
__name(HmacDRBG, "HmacDRBG");
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = /* @__PURE__ */ __name(function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i3 = 0; i3 < this.V.length; i3++) {
    this.K[i3] = 0;
    this.V[i3] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
}, "init");
HmacDRBG.prototype._hmac = /* @__PURE__ */ __name(function hmac() {
  return new import_hash2.default.hmac(this.hash, this.K);
}, "hmac");
HmacDRBG.prototype._update = /* @__PURE__ */ __name(function update(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
}, "update");
HmacDRBG.prototype.reseed = /* @__PURE__ */ __name(function reseed(entropy, entropyEnc, add4, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add4;
    add4 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add4 = utils_1.toArray(add4, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add4 || []));
  this._reseed = 1;
}, "reseed");
HmacDRBG.prototype.generate = /* @__PURE__ */ __name(function generate(len, enc, add4, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add4;
    add4 = enc;
    enc = null;
  }
  if (add4) {
    add4 = utils_1.toArray(add4, addEnc || "hex");
    this._update(add4);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add4);
  this._reseed++;
  return utils_1.encode(res, enc);
}, "generate");
var assert$3 = utils_1$1.assert;
function KeyPair(ec3, options) {
  this.ec = ec3;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
__name(KeyPair, "KeyPair");
var key = KeyPair;
KeyPair.fromPublic = /* @__PURE__ */ __name(function fromPublic(ec3, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec3, {
    pub,
    pubEnc: enc
  });
}, "fromPublic");
KeyPair.fromPrivate = /* @__PURE__ */ __name(function fromPrivate(ec3, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec3, {
    priv,
    privEnc: enc
  });
}, "fromPrivate");
KeyPair.prototype.validate = /* @__PURE__ */ __name(function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
}, "validate");
KeyPair.prototype.getPublic = /* @__PURE__ */ __name(function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
}, "getPublic");
KeyPair.prototype.getPrivate = /* @__PURE__ */ __name(function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
}, "getPrivate");
KeyPair.prototype._importPrivate = /* @__PURE__ */ __name(function _importPrivate(key3, enc) {
  this.priv = new import_bn2.default(key3, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
}, "_importPrivate");
KeyPair.prototype._importPublic = /* @__PURE__ */ __name(function _importPublic(key3, enc) {
  if (key3.x || key3.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key3.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key3.x && key3.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key3.x, key3.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key3, enc);
}, "_importPublic");
KeyPair.prototype.derive = /* @__PURE__ */ __name(function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
}, "derive");
KeyPair.prototype.sign = /* @__PURE__ */ __name(function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
}, "sign");
KeyPair.prototype.verify = /* @__PURE__ */ __name(function verify(msg, signature3) {
  return this.ec.verify(msg, signature3, this);
}, "verify");
KeyPair.prototype.inspect = /* @__PURE__ */ __name(function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
}, "inspect");
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
__name(Signature, "Signature");
var signature = Signature;
function Position() {
  this.place = 0;
}
__name(Position, "Position");
function getLength(buf2, p) {
  var initial = buf2[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i3 = 0, off = p.place; i3 < octetLen; i3++, off++) {
    val <<= 8;
    val |= buf2[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
__name(getLength, "getLength");
function rmPadding(buf2) {
  var i3 = 0;
  var len = buf2.length - 1;
  while (!buf2[i3] && !(buf2[i3 + 1] & 128) && i3 < len) {
    i3++;
  }
  if (i3 === 0) {
    return buf2;
  }
  return buf2.slice(i3);
}
__name(rmPadding, "rmPadding");
Signature.prototype._importDER = /* @__PURE__ */ __name(function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s3 = data.slice(p.place, slen + p.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s3[0] === 0) {
    if (s3[1] & 128) {
      s3 = s3.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn2.default(r2);
  this.s = new import_bn2.default(s3);
  this.recoveryParam = null;
  return true;
}, "_importDER");
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
__name(constructLength, "constructLength");
Signature.prototype.toDER = /* @__PURE__ */ __name(function toDER(enc) {
  var r2 = this.r.toArray();
  var s3 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s3[0] & 128)
    s3 = [0].concat(s3);
  r2 = rmPadding(r2);
  s3 = rmPadding(s3);
  while (!s3[0] && !(s3[1] & 128)) {
    s3 = s3.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s3.length);
  var backHalf = arr.concat(s3);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
}, "toDER");
var rand = /* @__PURE__ */ __name(function() {
  throw new Error("unsupported");
}, "rand");
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
__name(EC, "EC");
var ec = EC;
EC.prototype.keyPair = /* @__PURE__ */ __name(function keyPair(options) {
  return new key(this, options);
}, "keyPair");
EC.prototype.keyFromPrivate = /* @__PURE__ */ __name(function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
}, "keyFromPrivate");
EC.prototype.keyFromPublic = /* @__PURE__ */ __name(function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
}, "keyFromPublic");
EC.prototype.genKeyPair = /* @__PURE__ */ __name(function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn2.default(2));
  for (; ; ) {
    var priv = new import_bn2.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
}, "genKeyPair");
EC.prototype._truncateToN = /* @__PURE__ */ __name(function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
}, "_truncateToN");
EC.prototype.sign = /* @__PURE__ */ __name(function sign2(msg, key3, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key3 = this.keyFromPrivate(key3, enc);
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key3.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn2.default(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s3 = k2.invm(this.n).mul(r2.mul(key3.getPrivate()).iadd(msg));
    s3 = s3.umod(this.n);
    if (s3.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s3.cmp(this.nh) > 0) {
      s3 = this.n.sub(s3);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s3, recoveryParam });
  }
}, "sign");
EC.prototype.verify = /* @__PURE__ */ __name(function verify2(msg, signature$1, key3, enc) {
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  key3 = this.keyFromPublic(key3, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s3 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s3.cmpn(1) < 0 || s3.cmp(this.n) >= 0)
    return false;
  var sinv = s3.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key3.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r2) === 0;
  }
  p = this.g.jmulAdd(u1, key3.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r2);
}, "verify");
EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n = this.n;
  var e2 = new import_bn2.default(msg);
  var r2 = signature$1.r;
  var s3 = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e2).mul(rInv).umod(n);
  var s22 = s3.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i3 = 0; i3 < 4; i3++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i3);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i3;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module2, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = null;
});
var EC$1 = elliptic_1.ec;

// ../../../node_modules/.pnpm/@ethersproject+signing-key@5.7.0/node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version12 = "signing-key/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+signing-key@5.7.0/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger17 = new Logger(version12);
var _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
__name(getCurve, "getCurve");
var SigningKey = class {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger17.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair3.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair3.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest2) {
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest2);
    if (digestBytes.length !== 32) {
      logger17.throwArgumentError("bad digest length", "digest", digest2);
    }
    const signature3 = keyPair3.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature3.recoveryParam,
      r: hexZeroPad("0x" + signature3.r.toString(16), 32),
      s: hexZeroPad("0x" + signature3.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair3.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
__name(SigningKey, "SigningKey");
function recoverPublicKey(digest2, signature3) {
  const sig = splitSignature(signature3);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest2), rs, sig.recoveryParam).encode("hex", false);
}
__name(recoverPublicKey, "recoverPublicKey");
function computePublicKey(key3, compressed) {
  const bytes = arrayify(key3);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger17.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
__name(computePublicKey, "computePublicKey");

// ../../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/_version.js
var version13 = "transactions/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger18 = new Logger(version13);
var TransactionTypes;
(function(TransactionTypes3) {
  TransactionTypes3[TransactionTypes3["legacy"] = 0] = "legacy";
  TransactionTypes3[TransactionTypes3["eip2930"] = 1] = "eip2930";
  TransactionTypes3[TransactionTypes3["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
__name(handleAddress, "handleAddress");
function handleNumber(value) {
  if (value === "0x") {
    return Zero2;
  }
  return BigNumber.from(value);
}
__name(handleNumber, "handleNumber");
var transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
var allowedTransactionKeys2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key3) {
  const publicKey = computePublicKey(key3);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
__name(computeAddress, "computeAddress");
function recoverAddress(digest2, signature3) {
  return computeAddress(recoverPublicKey(arrayify(digest2), signature3));
}
__name(recoverAddress, "recoverAddress");
function formatNumber(value, name3) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger18.throwArgumentError("invalid length for " + name3, "transaction:" + name3, value);
  }
  return result;
}
__name(formatNumber, "formatNumber");
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger18.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
__name(accessSetify, "accessSetify");
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger18.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a3, b2) => a3.address.localeCompare(b2.address));
  return result;
}
__name(accessListify, "accessListify");
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
__name(formatAccessList, "formatAccessList");
function _serializeEip1559(transaction, signature3) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger18.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature3) {
    const sig = splitSignature(signature3);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode(fields)]);
}
__name(_serializeEip1559, "_serializeEip1559");
function _serializeEip2930(transaction, signature3) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature3) {
    const sig = splitSignature(signature3);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode(fields)]);
}
__name(_serializeEip2930, "_serializeEip2930");
function _serialize(transaction, signature3) {
  checkProperties(transaction, allowedTransactionKeys2);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger18.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature3 && !isBytesLike(signature3) && signature3.v > 28) {
    chainId = Math.floor((signature3.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature3) {
    return encode(raw);
  }
  const sig = splitSignature(signature3);
  let v = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v) {
      logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature3);
    }
  } else if (sig.v !== v) {
    logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature3);
  }
  raw.push(hexlify(v));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode(raw);
}
__name(_serialize, "_serialize");
function serialize(transaction, signature3) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger18.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature3);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature3);
    case 2:
      return _serializeEip1559(transaction, signature3);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
__name(serialize, "serialize");
function _parseEipSignature(tx, fields, serialize3) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger18.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest2 = keccak256(serialize3(tx));
    tx.from = recoverAddress(digest2, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
__name(_parseEipSignature, "_parseEipSignature");
function _parseEip1559(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger18.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
__name(_parseEip1559, "_parseEip1559");
function _parseEip2930(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger18.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
__name(_parseEip2930, "_parseEip2930");
function _parse(rawTransaction) {
  const transaction = decode(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger18.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest2 = keccak256(encode(raw));
    try {
      tx.from = recoverAddress(digest2, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
__name(_parse, "_parse");
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
__name(parse, "parse");

// ../../../node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/_version.js
var version14 = "contracts/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/index.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger19 = new Logger(version14);
var allowedTransactionKeys3 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter5(this, void 0, void 0, function* () {
    const name3 = yield nameOrPromise;
    if (typeof name3 !== "string") {
      logger19.throwArgumentError("invalid address or ENS name", "name", name3);
    }
    try {
      return getAddress(name3);
    } catch (error) {
    }
    if (!resolver) {
      logger19.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name3);
    if (address == null) {
      logger19.throwArgumentError("resolver or addr is not configured for ENS name", "name", name3);
    }
    return address;
  });
}
__name(resolveName, "resolveName");
function resolveAddresses(resolver, value, paramType) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger19.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
__name(resolveAddresses, "resolveAddresses");
function populateTransaction(contract, fragment, args) {
  return __awaiter5(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger19.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter5(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger19.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data);
      for (let i3 = 0; i3 < bytes.length; i3++) {
        intrinsic += 4;
        if (bytes[i3]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger19.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key3) => overrides[key3] != null);
    if (leftovers.length) {
      logger19.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
__name(populateTransaction, "populateTransaction");
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
__name(buildPopulate, "buildPopulate");
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger19.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
__name(buildEstimate, "buildEstimate");
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e2) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
__name(addContractWait, "addContractWait");
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
__name(buildCall, "buildCall");
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger19.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
__name(buildSend, "buildSend");
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
__name(buildDefault, "buildDefault");
function getEventTag(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
__name(getEventTag, "getEventTag");
var RunningEvent = class {
  constructor(tag, filter2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener2, once) {
    this._listeners.push({ listener: listener2, once });
  }
  removeListener(listener2) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener2) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i3) => i3.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  getEmit(event) {
    return [event];
  }
};
__name(RunningEvent, "RunningEvent");
var ErrorRunningEvent = class extends RunningEvent {
  constructor() {
    super("error", null);
  }
};
__name(ErrorRunningEvent, "ErrorRunningEvent");
var FragmentRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger19.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag(filter2), filter2);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
};
__name(FragmentRunningEvent, "FragmentRunningEvent");
var WildcardRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
};
__name(WildcardRunningEvent, "WildcardRunningEvent");
var BaseContract = class {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger19.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name3) => {
        const filters = uniqueFilters[name3];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name3, this.filters[filters[0]]);
        } else {
          logger19.warn(`Duplicate definition of ${name3} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger19.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger19.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e2) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature3) => {
      const fragment = this.interface.functions[signature3];
      if (uniqueSignatures[signature3]) {
        logger19.warn(`Duplicate ABI entry for ${JSON.stringify(signature3)}`);
        return;
      }
      uniqueSignatures[signature3] = true;
      {
        const name3 = fragment.name;
        if (!uniqueNames[`%${name3}`]) {
          uniqueNames[`%${name3}`] = [];
        }
        uniqueNames[`%${name3}`].push(signature3);
      }
      if (this[signature3] == null) {
        defineReadOnly(this, signature3, buildDefault(this, fragment, true));
      }
      if (this.functions[signature3] == null) {
        defineReadOnly(this.functions, signature3, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature3] == null) {
        defineReadOnly(this.callStatic, signature3, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature3] == null) {
        defineReadOnly(this.populateTransaction, signature3, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature3] == null) {
        defineReadOnly(this.estimateGas, signature3, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name3) => {
      const signatures = uniqueNames[name3];
      if (signatures.length > 1) {
        return;
      }
      name3 = name3.substring(1);
      const signature3 = signatures[0];
      try {
        if (this[name3] == null) {
          defineReadOnly(this, name3, this[signature3]);
        }
      } catch (e2) {
      }
      if (this.functions[name3] == null) {
        defineReadOnly(this.functions, name3, this.functions[signature3]);
      }
      if (this.callStatic[name3] == null) {
        defineReadOnly(this.callStatic, name3, this.callStatic[signature3]);
      }
      if (this.populateTransaction[name3] == null) {
        defineReadOnly(this.populateTransaction, name3, this.populateTransaction[signature3]);
      }
      if (this.estimateGas[name3] == null) {
        defineReadOnly(this.estimateGas, name3, this.estimateGas[signature3]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code3) => {
          if (code3 === "0x") {
            logger19.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  fallback(overrides) {
    if (!this.signer) {
      logger19.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key3) {
      if (tx[key3] == null) {
        return;
      }
      logger19.throwError("cannot override " + key3, Logger.errors.UNSUPPORTED_OPERATION, { operation: key3 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  _wrapEvent(runningEvent, log, listener2) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener2) {
        return;
      }
      runningEvent.removeListener(listener2);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener2, once) {
    if (!this.provider) {
      logger19.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener2, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = /* @__PURE__ */ __name((log) => {
        let event = this._wrapEvent(runningEvent, log, listener2);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      }, "wrappedEmit");
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger19.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener2) {
    this._addEventListener(this._getRunningEvent(event), listener2, false);
    return this;
  }
  once(event, listener2) {
    this._addEventListener(this._getRunningEvent(event), listener2, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key3) => {
        return accum + this._runningEvents[key3].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener2) => {
          result.push(listener2);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener2) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener2);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener2) {
    return this.off(eventName, listener2);
  }
};
__name(BaseContract, "BaseContract");
var Contract = class extends BaseContract {
};
__name(Contract, "Contract");
var ContractFactory = class {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger19.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger19.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key3 in tx) {
        if (!allowedTransactionKeys3[key3]) {
          throw new Error("unknown transaction override " + key3);
        }
      }
    }
    ["data", "from", "to"].forEach((key3) => {
      if (tx[key3] == null) {
        return;
      }
      logger19.throwError("cannot override " + key3, Logger.errors.UNSUPPORTED_OPERATION, { operation: key3 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger19.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger19.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};
__name(ContractFactory, "ContractFactory");

// ../../../node_modules/.pnpm/@ethersproject+basex@5.7.0/node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX = class {
  constructor(alphabet3) {
    defineReadOnly(this, "alphabet", alphabet3);
    defineReadOnly(this, "base", alphabet3.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet3.charAt(0));
    for (let i3 = 0; i3 < alphabet3.length; i3++) {
      this._alphabetMap[alphabet3.charAt(i3)] = i3;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i3 = 0; i3 < source.length; ++i3) {
      let carry = source[i3];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string2 += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string2 += this.alphabet[digits[q2]];
    }
    return string2;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i3 = 0; i3 < value.length; i3++) {
      let byte = this._alphabetMap[value[i3]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes.push(0);
    }
    return arrayify(new Uint8Array(bytes.reverse()));
  }
};
__name(BaseX, "BaseX");
var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// ../../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var import_hash3 = __toESM(require_hash());

// ../../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

// ../../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/_version.js
var version15 = "sha2/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger20 = new Logger(version15);
function ripemd160(data) {
  return "0x" + import_hash3.default.ripemd160().update(arrayify(data)).digest("hex");
}
__name(ripemd160, "ripemd160");
function sha256(data) {
  return "0x" + import_hash3.default.sha256().update(arrayify(data)).digest("hex");
}
__name(sha256, "sha256");
function sha512(data) {
  return "0x" + import_hash3.default.sha512().update(arrayify(data)).digest("hex");
}
__name(sha512, "sha512");
function computeHmac(algorithm, key3, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger20.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm], arrayify(key3)).update(arrayify(data)).digest("hex");
}
__name(computeHmac, "computeHmac");

// ../../../node_modules/.pnpm/@ethersproject+pbkdf2@5.7.0/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T2;
  for (let i3 = 1; i3 <= l; i3++) {
    block1[salt.length] = i3 >> 24 & 255;
    block1[salt.length + 1] = i3 >> 16 & 255;
    block1[salt.length + 2] = i3 >> 8 & 255;
    block1[salt.length + 3] = i3 & 255;
    let U = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U.length;
      T2 = new Uint8Array(hLen);
      l = Math.ceil(keylen / hLen);
      r2 = keylen - (l - 1) * hLen;
    }
    T2.set(U);
    for (let j = 1; j < iterations; j++) {
      U = arrayify(computeHmac(hashAlgorithm, password, U));
      for (let k2 = 0; k2 < hLen; k2++)
        T2[k2] ^= U[k2];
    }
    const destPos = (i3 - 1) * hLen;
    const len = i3 === l ? r2 : hLen;
    DK.set(arrayify(T2).slice(0, len), destPos);
  }
  return hexlify(DK);
}
__name(pbkdf2, "pbkdf2");

// ../../../node_modules/.pnpm/@ethersproject+wordlists@5.7.0/node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version16 = "wordlists/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+wordlists@5.7.0/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist = false;
var logger21 = new Logger(version16);
var Wordlist = class {
  constructor(locale2) {
    logger21.checkAbstract(new.target, Wordlist);
    defineReadOnly(this, "locale", locale2);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i3 = 0; i3 < 2048; i3++) {
      const word = wordlist2.getWord(i3);
      if (i3 !== wordlist2.getWordIndex(word)) {
        return "0x";
      }
      words2.push(word);
    }
    return id(words2.join("\n") + "\n");
  }
  static register(lang, name3) {
    if (!name3) {
      name3 = lang.locale;
    }
    if (exportWordlist) {
      try {
        const anyGlobal2 = window;
        if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
          if (!anyGlobal2._ethers.wordlists[name3]) {
            defineReadOnly(anyGlobal2._ethers.wordlists, name3, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};
__name(Wordlist, "Wordlist");

// ../../../node_modules/.pnpm/@ethersproject+wordlists@5.7.0/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
__name(loadWords, "loadWords");
var LangEn = class extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords(this);
    return wordlist[index];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
};
__name(LangEn, "LangEn");
var langEn = new LangEn();
Wordlist.register(langEn);

// ../../../node_modules/.pnpm/@ethersproject+wordlists@5.7.0/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists = {
  en: langEn
};

// ../../../node_modules/.pnpm/@ethersproject+hdnode@5.7.0/node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version17 = "hdnode/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+hdnode@5.7.0/node_modules/@ethersproject/hdnode/lib.esm/index.js
var logger22 = new Logger(version17);
var N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
__name(getUpperMask, "getUpperMask");
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
__name(getLowerMask, "getLowerMask");
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
__name(bytes32, "bytes32");
function base58check(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
__name(base58check, "base58check");
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger22.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
__name(getWordlist, "getWordlist");
var _constructorGuard4 = {};
var defaultPath = "m/44'/60'/0'/0/0";
var HDNode = class {
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
    if (constructorGuard !== _constructorGuard4) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index) {
    if (index > 4294967295) {
      throw new Error("invalid index - " + String(index));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify(this.publicKey));
    }
    for (let i3 = 24; i3 >= 0; i3 -= 8) {
      data[33 + (i3 >> 3)] = index >> 24 - i3 & 255;
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    let ki = null;
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek = new SigningKey(hexlify(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard4, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i3 = 0; i3 < components.length; i3++) {
      const component = components[i3];
      if (component.match(/^[0-9]+'$/)) {
        const index = parseInt(component.substring(0, component.length - 1));
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index);
      } else if (component.match(/^[0-9]+$/)) {
        const index = parseInt(component);
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard4, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes = Base58.decode(extendedKey);
    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify(bytes.slice(5, 9));
    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes.slice(13, 45));
    const key3 = bytes.slice(45, 78);
    switch (hexlify(bytes.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard4, null, hexlify(key3), parentFingerprint, chainCode, index, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key3[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard4, hexlify(key3.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
    }
    return logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
};
__name(HDNode, "HDNode");
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
__name(mnemonicToSeed, "mnemonicToSeed");
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger22.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i3 = 0; i3 < words2.length; i3++) {
    let index = wordlist2.getWordIndex(words2[i3].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
__name(mnemonicToEntropy, "mnemonicToEntropy");
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i3 = 0; i3 < entropy.length; i3++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i3];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i3] >> 8 - remainingBits;
      indices.push(entropy[i3] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
__name(entropyToMnemonic, "entropyToMnemonic");
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
__name(isValidMnemonic, "isValidMnemonic");
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger22.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}
__name(getAccountPath, "getAccountPath");

// ../../../node_modules/.pnpm/@ethersproject+random@5.7.0/node_modules/@ethersproject/random/lib.esm/_version.js
var version18 = "random/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+random@5.7.0/node_modules/@ethersproject/random/lib.esm/random.js
var logger23 = new Logger(version18);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
__name(getGlobal, "getGlobal");
var anyGlobal = getGlobal();
var crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto2 || !crypto2.getRandomValues) {
  logger23.warn("WARNING: Missing strong random number source");
  crypto2 = {
    getRandomValues: function(buffer2) {
      return logger23.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes(length2) {
  if (length2 <= 0 || length2 > 1024 || length2 % 1 || length2 != length2) {
    logger23.throwArgumentError("invalid length", "length", length2);
  }
  const result = new Uint8Array(length2);
  crypto2.getRandomValues(result);
  return arrayify(result);
}
__name(randomBytes, "randomBytes");

// ../../../node_modules/.pnpm/@ethersproject+random@5.7.0/node_modules/@ethersproject/random/lib.esm/shuffle.js
function shuffled(array) {
  array = array.slice();
  for (let i3 = array.length - 1; i3 > 0; i3--) {
    const j = Math.floor(Math.random() * (i3 + 1));
    const tmp = array[i3];
    array[i3] = array[j];
    array[j] = tmp;
  }
  return array;
}
__name(shuffled, "shuffled");

// ../../../node_modules/.pnpm/@ethersproject+json-wallets@5.7.0/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
var import_aes_js = __toESM(require_aes_js());

// ../../../node_modules/.pnpm/@ethersproject+json-wallets@5.7.0/node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version19 = "json-wallets/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+json-wallets@5.7.0/node_modules/@ethersproject/json-wallets/lib.esm/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
__name(looseArrayify, "looseArrayify");
function zpad(value, length2) {
  value = String(value);
  while (value.length < length2) {
    value = "0" + value;
  }
  return value;
}
__name(zpad, "zpad");
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
__name(getPassword, "getPassword");
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i3 = 0; i3 < comps.length; i3++) {
    let matchingChild = null;
    for (const key3 in currentChild) {
      if (key3.toLowerCase() === comps[i3]) {
        matchingChild = currentChild[key3];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
__name(searchPath, "searchPath");
function uuidV4(randomBytes2) {
  const bytes = arrayify(randomBytes2);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = hexlify(bytes);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
__name(uuidV4, "uuidV4");

// ../../../node_modules/.pnpm/@ethersproject+json-wallets@5.7.0/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
var logger24 = new Logger(version19);
var CrowdsaleAccount = class extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
};
__name(CrowdsaleAccount, "CrowdsaleAccount");
function decrypt(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger24.throwArgumentError("invalid encseed", "json", json);
  }
  const key3 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key3, iv);
  const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i3 = 0; i3 < seed.length; i3++) {
    seedHex += String.fromCharCode(seed[i3]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
__name(decrypt, "decrypt");

// ../../../node_modules/.pnpm/@ethersproject+json-wallets@5.7.0/node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
__name(isCrowdsaleWallet, "isCrowdsaleWallet");
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
__name(isKeystoreWallet, "isKeystoreWallet");
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
__name(getJsonWalletAddress, "getJsonWalletAddress");

// ../../../node_modules/.pnpm/@ethersproject+json-wallets@5.7.0/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
var import_aes_js2 = __toESM(require_aes_js());
var import_scrypt_js = __toESM(require_scrypt());
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger25 = new Logger(version19);
function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
__name(hasMnemonic, "hasMnemonic");
var KeystoreAccount = class extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
};
__name(KeystoreAccount, "KeystoreAccount");
function _decrypt(data, key3, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key3, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
__name(_decrypt, "_decrypt");
function _getAccount(data, key3) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256(concat([key3.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key3.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger25.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key3.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale2 = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale2);
      const node = HDNode.fromMnemonic(mnemonic, null, locale2).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
__name(_getAccount, "_getAccount");
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return arrayify(pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
}
__name(pbkdf2Sync, "pbkdf2Sync");
function pbkdf22(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
__name(pbkdf22, "pbkdf2");
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError = /* @__PURE__ */ __name(function(name3, value) {
      return logger25.throwArgumentError("invalid key-derivation function parameters", name3, value);
    }, "throwError");
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N10 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N10 || !r2 || !p) {
        throwError("kdf", kdf);
      }
      if ((N10 & N10 - 1) !== 0) {
        throwError("N", N10);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N10, r2, p, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }
      const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger25.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
__name(_computeKdfKey, "_computeKdfKey");
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key3 = _computeKdfKey(data, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data, key3);
}
__name(decryptSync, "decryptSync");
function decrypt2(json, password, progressCallback) {
  return __awaiter6(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key3 = yield _computeKdfKey(data, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data, key3);
  });
}
__name(decrypt2, "decrypt");
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e2) {
    return Promise.reject(e2);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale2 = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale2 = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
    ;
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N10 = 1 << 17, r2 = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N10 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N10, r2, p, 64, progressCallback).then((key3) => {
    key3 = arrayify(key3);
    const derivedKey = key3.slice(0, 16);
    const macPrefix = key3.slice(16, 32);
    const mnemonicKey = key3.slice(32, 64);
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N10,
          dklen: 32,
          p,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = new Date();
      const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale: locale2,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
__name(encrypt, "encrypt");

// ../../../node_modules/.pnpm/@ethersproject+json-wallets@5.7.0/node_modules/@ethersproject/json-wallets/lib.esm/index.js
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
__name(decryptJsonWallet, "decryptJsonWallet");
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
__name(decryptJsonWalletSync, "decryptJsonWalletSync");

// ../../../node_modules/.pnpm/@ethersproject+wallet@5.7.0/node_modules/@ethersproject/wallet/lib.esm/_version.js
var version20 = "wallet/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+wallet@5.7.0/node_modules/@ethersproject/wallet/lib.esm/index.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger26 = new Logger(version20);
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
__name(isAccount, "isAccount");
function hasMnemonic2(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
__name(hasMnemonic2, "hasMnemonic");
var Wallet = class extends Signer {
  constructor(privateKey, provider) {
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger26.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic2(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger26.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger26.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider && !Provider.isProvider(provider)) {
      logger26.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new Wallet(this, provider);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger26.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature3 = this._signingKey().signDigest(keccak256(serialize(tx)));
      return serialize(tx, signature3);
    });
  }
  signMessage(message) {
    return __awaiter7(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter7(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name3) => {
        if (this.provider == null) {
          logger26.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name3
          });
        }
        return this.provider.resolveName(name3);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt(this, password, options, progressCallback);
  }
  static createRandom(options) {
    let entropy = randomBytes(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json, password, progressCallback) {
    return decryptJsonWallet(json, password, progressCallback).then((account) => {
      return new Wallet(account);
    });
  }
  static fromEncryptedJsonSync(json, password) {
    return new Wallet(decryptJsonWalletSync(json, password));
  }
  static fromMnemonic(mnemonic, path, wordlist2) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
  }
};
__name(Wallet, "Wallet");
function verifyMessage(message, signature3) {
  return recoverAddress(hashMessage(message), signature3);
}
__name(verifyMessage, "verifyMessage");
function verifyTypedData(domain, types, value, signature3) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature3);
}
__name(verifyTypedData, "verifyTypedData");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  AnkrProvider: () => AnkrProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});

// ../../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/_version.js
var version21 = "networks/5.7.1";

// ../../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js
var logger27 = new Logger(version21);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
__name(isRenetworkable, "isRenetworkable");
function ethDefaultProvider(network) {
  const func = /* @__PURE__ */ __name(function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  }, "func");
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
__name(ethDefaultProvider, "ethDefaultProvider");
function etcDefaultProvider(url, network) {
  const func = /* @__PURE__ */ __name(function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  }, "func");
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
__name(etcDefaultProvider, "etcDefaultProvider");
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name3 in networks) {
      const standard2 = networks[name3];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger27.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger27.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
__name(getNetwork, "getNetwork");

// ../../../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/lib.esm/_version.js
var version22 = "web/5.7.1";

// ../../../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/lib.esm/geturl.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key3) => {
        headers[key3.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key3) => {
        headers[key3.toLowerCase()] = response.headers.get(key3);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
__name(getUrl, "getUrl");

// ../../../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/lib.esm/index.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger28 = new Logger(version22);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
__name(staller, "staller");
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify(value);
  }
  return value;
}
__name(bodyify, "bodyify");
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code3) => {
    return String.fromCharCode(parseInt(code3, 16));
  }));
}
__name(unpercent, "unpercent");
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger28.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger28.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger28.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key3 in connection.headers) {
        headers[key3.toLowerCase()] = { key: key3, value: String(connection.headers[key3]) };
        if (["if-none-match", "if-modified-since"].indexOf(key3.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger28.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode2(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode2(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key3) => {
    const header = headers[key3];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer3 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer3 = setTimeout(() => {
          if (timer3 == null) {
            return;
          }
          timer3 = null;
          reject(logger28.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = /* @__PURE__ */ __name(function() {
      if (timer3 == null) {
        return;
      }
      clearTimeout(timer3);
      timer3 = null;
    }, "cancel");
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter9(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger28.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger28.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger28.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
__name(_fetchData, "_fetchData");
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = /* @__PURE__ */ __name((value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger28.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  }, "processJsonFunc");
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
__name(fetchJson, "fetchJson");
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer3 = null;
    let done = false;
    const cancel = /* @__PURE__ */ __name(() => {
      if (done) {
        return false;
      }
      done = true;
      if (timer3) {
        clearTimeout(timer3);
      }
      return true;
    }, "cancel");
    if (options.timeout) {
      timer3 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    __name(check, "check");
    check();
  });
}
__name(poll, "poll");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/base-provider.js
var import_bech32 = __toESM(require_bech32());

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/_version.js
var version23 = "providers/5.7.2";

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/formatter.js
var logger29 = new Logger(version23);
var Formatter = class {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash3 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = /* @__PURE__ */ __name((v) => {
      return this.data(v, true);
    }, "strictData");
    formats.transaction = {
      hash: hash3,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash3, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash3,
      address,
      topics: Formatter.arrayOf(hash3),
      data,
      logIndex: number,
      blockHash: hash3
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash3,
      transactionHash: hash3,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash3),
      parentHash: hash3,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash3)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash3, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash3),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash3),
      transactionHash: hash3,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  bigNumber(value) {
    return BigNumber.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger29.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger29.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v = BigNumber.from(value);
    try {
      return v.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format2) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format2, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger29.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger29.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger29.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v) => this.topics(v));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format2, object) {
    const result = {};
    for (const key3 in format2) {
      try {
        const value = format2[key3](object[key3]);
        if (value !== void 0) {
          result[key3] = value;
        }
      } catch (error) {
        error.checkKey = key3;
        error.checkValue = object[key3];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format2, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format2(value);
    };
  }
  static allowFalsish(format2, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format2(value);
    };
  }
  static arrayOf(format2) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format2(value));
      });
      return result;
    };
  }
};
__name(Formatter, "Formatter");
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
__name(isCommunityResourcable, "isCommunityResourcable");
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
__name(isCommunityResource, "isCommunityResource");
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}
__name(showThrottleMessage, "showThrottleMessage");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/base-provider.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger30 = new Logger(version23);
var MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger30.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
__name(checkTopic, "checkTopic");
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
__name(serializeTopics, "serializeTopics");
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
__name(deserializeTopics, "deserializeTopics");
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger30.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
__name(getEventTag2, "getEventTag");
function getTime() {
  return new Date().getTime();
}
__name(getTime, "getTime");
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
__name(stall, "stall");
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = class {
  constructor(tag, listener2, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener2);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
__name(Event, "Event");
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
__name(bytes32ify, "bytes32ify");
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
__name(base58Encode, "base58Encode");
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
__name(_parseString, "_parseString");
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length2 = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length2);
}
__name(_parseBytes, "_parseBytes");
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger30.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
__name(getIpfsLink, "getIpfsLink");
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
__name(numPad, "numPad");
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
__name(bytesPad, "bytesPad");
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i3 = 0; i3 < datas.length; i3++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i3 = 0; i3 < datas.length; i3++) {
    const data = arrayify(datas[i3]);
    result[i3] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
__name(encodeBytes, "encodeBytes");
var Resolver = class {
  constructor(provider, address, name3, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name3);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter10(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger30.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter10(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger30.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length2 = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length2 = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length2 = bytes[1];
      let version29 = bytes[0];
      if (version29 === 0) {
        if (length2 !== 20 && length2 !== 32) {
          version29 = -1;
        }
      } else {
        version29 = -1;
      }
      if (version29 >= 0 && bytes.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
        const words2 = import_bech32.default.toWords(bytes.slice(2));
        words2.unshift(version29);
        return import_bech32.default.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger30.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter10(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i3 = 0; i3 < matchers.length; i3++) {
          const match2 = avatar.match(matchers[i3]);
          if (match2 == null) {
            continue;
          }
          const scheme = match2[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match2[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter10(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length2 = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length2 * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length2 = parseInt(ipns[3], 16);
        if (ipns[4].length === length2 * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash3 = encode2("0x" + skynet[1]).replace(/[=+\/]/g, (a3) => urlSafe[a3]);
          return "sia://" + hash3;
        }
      }
      return logger30.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key3) {
    return __awaiter10(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key3);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key3.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
__name(Resolver, "Resolver");
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider {
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger30.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger30.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i3 = 0; i3 < urls.length; i3++) {
        const url = urls[i3];
        const href = url.replace("{sender}", sender).replace("{data}", data);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger30.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger30.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m3) => JSON.stringify(m3)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter10(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger30.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger30.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i3 = this._emitted.block + 1; i3 <= blockNumber; i3++) {
          this.emit("block", i3);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key3) => {
          if (key3 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key3];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key3];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash3 = event.hash;
            let runner = this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash3] = receipt.blockNumber;
              this.emit(hash3, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter2 = event.filter;
              filter2.fromBlock = event._lastBlockNumber + 1;
              filter2.toBlock = blockNumber;
              const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter2.fromBlock) {
                filter2.fromBlock = minFromBlock;
              }
              if (filter2.fromBlock < 0) {
                filter2.fromBlock = 0;
              }
              const runner = this.getLogs(filter2).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter2, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter10(this, void 0, void 0, function* () {
      return logger30.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter10(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger30.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter10(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter10(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = /* @__PURE__ */ __name(function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        }, "alreadyDone");
        const minedHandler = /* @__PURE__ */ __name((receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        }, "minedHandler");
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = /* @__PURE__ */ __name((blockNumber) => __awaiter10(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter10(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger30.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          }), "replaceHandler");
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer3 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger30.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer3.unref) {
            timer3.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer3);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter10(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p) => hexValue(p))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash3, startBlock) {
    if (hash3 != null && hexDataLength(hash3) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash3 != null && tx.hash !== hash3) {
      logger30.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
    }
    result.wait = (confirms, timeout) => __awaiter10(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger30.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash3, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v ? this._getAddress(v) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v ? BigNumber.from(v) : null);
      });
      ["type"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v != null ? v : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v ? hexlify(v) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter10(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key3) => {
        if (filter2[key3] == null) {
          return;
        }
        result[key3] = filter2[key3];
      });
      ["fromBlock", "toBlock"].forEach((key3) => {
        if (filter2[key3] == null) {
          return;
        }
        result[key3] = this._getBlockTag(filter2[key3]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger30.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger30.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u2 = 0; u2 < urlsLength; u2++) {
            const url = _parseString(urlsData, u2 * 32);
            if (url == null) {
              logger30.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data, 64);
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger30.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger30.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter10(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger30.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger30.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger30.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i3 = 0; i3 < block.transactions.length; i3++) {
            const tx = block.transactions[i3];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger30.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name3) {
    return __awaiter10(this, void 0, void 0, function* () {
      let currentName = name3;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name3 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name3);
          if (currentName !== name3 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name3, operation) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger30.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name3).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name3) {
    return __awaiter10(this, void 0, void 0, function* () {
      name3 = yield name3;
      try {
        return Promise.resolve(this.formatter.address(name3));
      } catch (error) {
        if (isHexString(name3)) {
          throw error;
        }
      }
      if (typeof name3 !== "string") {
        logger30.throwArgumentError("invalid ENS name", "name", name3);
      }
      const resolver = yield this.getResolver(name3);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter10(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name3 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name3);
      if (addr != address) {
        return null;
      }
      return name3;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter10(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name3 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name3);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger30.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener2, once) {
    const event = new Event(getEventTag2(eventName), listener2, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener2) {
    return this._addEventListener(eventName, listener2, false);
  }
  once(eventName, listener2) {
    return this._addEventListener(eventName, listener2, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener2) {
    if (listener2 == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener2) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};
__name(BaseProvider, "BaseProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger31 = new Logger(version23);
var errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data = isHexString(value.data) ? value.data : null;
    if (!requireData || data) {
      return { message: value.message, data };
    }
  }
  if (typeof value === "object") {
    for (const key3 in value) {
      const result = spelunk(value[key3], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
__name(spelunk, "spelunk");
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger31.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger31.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger31.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger31.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger31.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
__name(checkError, "checkError");
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
__name(timer, "timer");
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
__name(getResult, "getResult");
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
__name(getLowerCase, "getLowerCase");
var _constructorGuard5 = {};
var JsonRpcSigner = class extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard5) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger31.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger31.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger31.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter11(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger31.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger31.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger31.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter11(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash3;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter11(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter11(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter11(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name3) => {
        return this.provider.resolveName(name3);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter11(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
__name(JsonRpcSigner, "JsonRpcSigner");
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
};
__name(UncheckedJsonRpcSigner, "UncheckedJsonRpcSigner");
var allowedTransactionKeys4 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter11(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a3) => this.formatter.address(a3));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger31.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes2) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes2.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      __name(poll2, "poll");
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys4);
    if (allowExtra) {
      for (const key3 in allowExtra) {
        if (allowExtra[key3]) {
          allowed[key3] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key3) {
      if (transaction[key3] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key3]));
      if (key3 === "gasLimit") {
        key3 = "gas";
      }
      result[key3] = value;
    });
    ["from", "to", "data"].forEach(function(key3) {
      if (transaction[key3] == null) {
        return;
      }
      result[key3] = hexlify(transaction[key3]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};
__name(JsonRpcProvider, "JsonRpcProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/ws.js
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger49 = new Logger(version23);
  WS = /* @__PURE__ */ __name(function() {
    logger49.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  }, "WS");
}

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger32 = new Logger(version23);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger32.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger32.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger32.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter12(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger32.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      __name(callback, "callback");
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter12(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = /* @__PURE__ */ __name((event2) => {
          const hash3 = event2.hash;
          this.getTransactionReceipt(hash3).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash3, receipt);
          });
        }, "emitReceipt");
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e2) => e2.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e2) => e2.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter12(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
};
__name(WebSocketProvider, "WebSocketProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger33 = new Logger(version23);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter13(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger33.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
__name(StaticJsonRpcProvider, "StaticJsonRpcProvider");
var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger33.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key3) => {
        defineReadOnly(this, key3, apiKey[key3]);
      });
    }
  }
  _startPending() {
    logger33.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger33.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network, apiKey) {
    return logger33.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};
__name(UrlJsonRpcProvider, "UrlJsonRpcProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger34 = new Logger(version23);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
__name(AlchemyWebSocketProvider, "AlchemyWebSocketProvider");
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger34.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger34.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
__name(AlchemyProvider, "AlchemyProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
var logger35 = new Logger(version23);
var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name3) {
  switch (name3) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger35.throwArgumentError("unsupported network", "name", name3);
}
__name(getHost, "getHost");
var AnkrProvider = class extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey2;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
};
__name(AnkrProvider, "AnkrProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger36 = new Logger(version23);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger36.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger36.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter14(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};
__name(CloudflareProvider, "CloudflareProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger37 = new Logger(version23);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key3 in transaction) {
    if (transaction[key3] == null) {
      continue;
    }
    let value = transaction[key3];
    if (key3 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key3]) {
      value = hexValue(hexlify(value));
    } else if (key3 === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key3] = value;
  }
  return result;
}
__name(getTransactionPostData, "getTransactionPostData");
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
__name(getResult2, "getResult");
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
__name(getJsonResult, "getJsonResult");
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
__name(checkLogTag, "checkLogTag");
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e2 = error.error;
    if (e2 && (e2.message.match(/reverted/i) || e2.message.match(/VM execution error/i))) {
      let data = e2.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger37.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger37.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger37.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger37.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger37.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
__name(checkError2, "checkError");
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    return logger37.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module2, params) {
    const query = Object.keys(params).reduce((accum, key3) => {
      const value = params[key3];
      if (value != null) {
        accum += `&${key3}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module2}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module2, params) {
    params.module = module2;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module2, params, post2) {
    return __awaiter15(this, void 0, void 0, function* () {
      const url = post2 ? this.getPostUrl() : this.getUrl(module2, params);
      const payload = post2 ? this.getPostData(module2, params) : null;
      const procFunc = module2 === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key3) => {
          return `${key3}=${payload[key3]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter15(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter15(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger37.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger37.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i3 = 0; i3 < logs.length; i3++) {
            const log = logs[i3];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter15(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key3) {
          if (tx[key3] == "") {
            delete tx[key3];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};
__name(EtherscanProvider, "EtherscanProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger38 = new Logger(version23);
function now() {
  return new Date().getTime();
}
__name(now, "now");
function checkNetworks(networks2) {
  let result = null;
  for (let i3 = 0; i3 < networks2.length; i3++) {
    const network = networks2[i3];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger38.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
__name(checkNetworks, "checkNetworks");
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a3 = values[middle - 1], b2 = values[middle];
  if (maxDelta != null && Math.abs(a3 - b2) > maxDelta) {
    return null;
  }
  return (a3 + b2) / 2;
}
__name(median, "median");
function serialize2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i3) => serialize2(i3)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key3) => {
      let v = value[key3];
      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize2(v);
      }
      return JSON.stringify(key3) + ":" + v;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
__name(serialize2, "serialize");
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer3 = null;
  let promise = new Promise((resolve) => {
    cancel = /* @__PURE__ */ __name(function() {
      if (timer3) {
        clearTimeout(timer3);
        timer3 = null;
      }
      resolve();
    }, "cancel");
    timer3 = setTimeout(cancel, duration);
  });
  const wait = /* @__PURE__ */ __name((func) => {
    promise = promise.then(func);
    return promise;
  }, "wait");
  function getPromise() {
    return promise;
  }
  __name(getPromise, "getPromise");
  return { cancel, getPromise, wait };
}
__name(stall2, "stall");
var ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now2) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now2) {
    result.duration = now2 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
__name(exposeDebugConfig, "exposeDebugConfig");
function normalizedTally(normalize2, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c2) => {
      const value = normalize2(c2.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c2.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i3 = 0; i3 < keys.length; i3++) {
      const check = tally[keys[i3]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
__name(normalizedTally, "normalizedTally");
function getProcessFunc(provider, method, params) {
  let normalize2 = serialize2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        let blockNumber = median(configs.map((c2) => c2.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c2) => c2.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize2 = /* @__PURE__ */ __name(function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      }, "normalize");
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize2 = /* @__PURE__ */ __name(function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        }, "normalize");
      } else {
        normalize2 = /* @__PURE__ */ __name(function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        }, "normalize");
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize2, provider.quorum);
}
__name(getProcessFunc, "getProcessFunc");
function waitForSync(config2, blockNumber) {
  return __awaiter16(this, void 0, void 0, function* () {
    const provider = config2.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
__name(waitForSync, "waitForSync");
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter16(this, void 0, void 0, function* () {
    let provider = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter2 = params.filter;
        if (filter2.fromBlock && isHexString(filter2.fromBlock) || filter2.toBlock && isHexString(filter2.toBlock)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getLogs(filter2);
      }
    }
    return logger38.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
__name(getRunner, "getRunner");
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger38.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger38.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c2) => accum + c2.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger38.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c2) => c2.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter16(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c2) => c2.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter16(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c2) => {
          return c2.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i4 = 0; i4 < results.length; i4++) {
          const result = results[i4];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a3, b2) => a3.priority - b2.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i3 = 0;
      let first2 = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c2) => c2.runner && t0 - c2.start < c2.stallTimeout).reduce((accum, c2) => accum + c2.weight, 0);
        while (inflightWeight < this.quorum && i3 < configs.length) {
          const config2 = configs[i3++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall2(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c2) => {
          if (c2.done || !c2.runner) {
            return;
          }
          waiting.push(c2.runner);
          if (c2.staller) {
            waiting.push(c2.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c2) => c2.done && c2.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== void 0) {
            configs.forEach((c2) => {
              if (c2.staller) {
                c2.staller.cancel();
              }
              c2.cancelled = true;
            });
            return result;
          }
          if (!first2) {
            yield stall2(100).getPromise();
          }
          first2 = false;
        }
        const errors = configs.reduce((accum, c2) => {
          if (!c2.done || c2.error == null) {
            return accum;
          }
          const code3 = c2.error.code;
          if (ForwardErrors.indexOf(code3) >= 0) {
            if (!accum[code3]) {
              accum[code3] = { error: c2.error, weight: 0 };
            }
            accum[code3].weight += c2.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c2) => {
            if (c2.staller) {
              c2.staller.cancel();
            }
            c2.cancelled = true;
          });
          const e2 = tally.error;
          const props = {};
          ForwardProperties.forEach((name3) => {
            if (e2[name3] == null) {
              return;
            }
            props[name3] = e2[name3];
          });
          logger38.throwError(e2.reason || e2.message, errorCode, props);
        });
        if (configs.filter((c2) => !c2.done).length === 0) {
          break;
        }
      }
      configs.forEach((c2) => {
        if (c2.staller) {
          c2.staller.cancel();
        }
        c2.cancelled = true;
      });
      return logger38.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method,
        params,
        results: configs.map((c2) => exposeDebugConfig(c2)),
        provider: this
      });
    });
  }
};
__name(FallbackProvider, "FallbackProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
var IpcProvider = null;

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/infura-provider.js
var logger39 = new Logger(version23);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger39.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
__name(InfuraWebSocketProvider, "InfuraWebSocketProvider");
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger39.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger39.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "sepolia":
        host = "sepolia.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host = "arbitrum-goerli.infura.io";
        break;
      default:
        logger39.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
__name(InfuraProvider, "InfuraProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
};
__name(JsonRpcBatchProvider, "JsonRpcBatchProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
var logger40 = new Logger(version23);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger40.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger40.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger40.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};
__name(NodesmithProvider, "NodesmithProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
var logger41 = new Logger(version23);
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
var PocketProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger41.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger41.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    const connection = { headers: {}, url };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
};
__name(PocketProvider, "PocketProvider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/web3-provider.js
var logger42 = new Logger(version23);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
__name(buildWeb3LegacyFetcher, "buildWeb3LegacyFetcher");
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
__name(buildEip1193Fetcher, "buildEip1193Fetcher");
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger42.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger42.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};
__name(Web3Provider, "Web3Provider");

// ../../../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/index.js
var logger43 = new Logger(version23);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match2 = network.match(/^(ws|http)s?:/i);
    if (match2) {
      switch (match2[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger43.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n = getNetwork(network);
  if (!n || !n._defaultProvider) {
    logger43.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}
__name(getDefaultProvider, "getDefaultProvider");

// ../../../node_modules/.pnpm/ethers@5.7.2/node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports3,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack2,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});

// ../../../node_modules/.pnpm/@ethersproject+solidity@5.7.0/node_modules/@ethersproject/solidity/lib.esm/_version.js
var version24 = "solidity/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+solidity@5.7.0/node_modules/@ethersproject/solidity/lib.esm/index.js
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
var Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
var logger44 = new Logger(version24);
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match2 = type.match(regexNumber);
  if (match2) {
    let size = parseInt(match2[2] || "256");
    if (match2[2] && String(size) !== match2[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger44.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray2) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match2 = type.match(regexBytes);
  if (match2) {
    const size = parseInt(match2[1]);
    if (String(size) !== match2[1] || size === 0 || size > 32) {
      logger44.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger44.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray2) {
      return arrayify((value + Zeros2).substring(0, 66));
    }
    return value;
  }
  match2 = type.match(regexArray);
  if (match2 && Array.isArray(value)) {
    const baseType = match2[1];
    const count = parseInt(match2[2] || String(value.length));
    if (count != value.length) {
      logger44.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger44.throwArgumentError("invalid type", "type", type);
}
__name(_pack, "_pack");
function pack2(types, values) {
  if (types.length != values.length) {
    logger44.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
__name(pack2, "pack");
function keccak2562(types, values) {
  return keccak256(pack2(types, values));
}
__name(keccak2562, "keccak256");
function sha2562(types, values) {
  return sha256(pack2(types, values));
}
__name(sha2562, "sha256");

// ../../../node_modules/.pnpm/@ethersproject+units@5.7.0/node_modules/@ethersproject/units/lib.esm/_version.js
var version25 = "units/5.7.0";

// ../../../node_modules/.pnpm/@ethersproject+units@5.7.0/node_modules/@ethersproject/units/lib.esm/index.js
var logger45 = new Logger(version25);
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger45.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
__name(commify, "commify");
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
__name(formatUnits, "formatUnits");
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger45.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
__name(parseUnits, "parseUnits");
function formatEther(wei) {
  return formatUnits(wei, 18);
}
__name(formatEther, "formatEther");
function parseEther(ether) {
  return parseUnits(ether, 18);
}
__name(parseEther, "parseEther");

// ../../../node_modules/.pnpm/ethers@5.7.2/node_modules/ethers/lib.esm/_version.js
var version26 = "ethers/5.7.2";

// ../../../node_modules/.pnpm/ethers@5.7.2/node_modules/ethers/lib.esm/ethers.js
var logger46 = new Logger(version26);

// ../../../node_modules/.pnpm/ethers@5.7.2/node_modules/ethers/lib.esm/index.js
try {
  const anyGlobal2 = window;
  if (anyGlobal2._ethers == null) {
    anyGlobal2._ethers = ethers_exports;
  }
} catch (error) {
}

// ../../learn-card-core/dist/core.esm.js
var import_meta = {};
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a3, b2) => (typeof require !== "undefined" ? require : a3)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = /* @__PURE__ */ __name((fn, res) => /* @__PURE__ */ __name(function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
}, "__init"), "__esm");
var __commonJS2 = /* @__PURE__ */ __name((cb, mod2) => /* @__PURE__ */ __name(function __require2() {
  return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
}, "__require2"), "__commonJS");
var __export2 = /* @__PURE__ */ __name((target, all) => {
  for (var name3 in all)
    __defProp2(target, name3, { get: all[name3], enumerable: true });
}, "__export");
var __copyProps2 = /* @__PURE__ */ __name((to, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key22 of __getOwnPropNames2(from4))
      if (!__hasOwnProp2.call(to, key22) && key22 !== except)
        __defProp2(to, key22, { get: () => from4[key22], enumerable: !(desc = __getOwnPropDesc2(from4, key22)) || desc.enumerable });
  }
  return to;
}, "__copyProps");
var __toESM2 = /* @__PURE__ */ __name((mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
)), "__toESM");
var __toCommonJS2 = /* @__PURE__ */ __name((mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2), "__toCommonJS");
var require_global = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/global.js"(exports, module2) {
    var check = /* @__PURE__ */ __name2(function(it) {
      return it && it.Math == Math && it;
    }, "check");
    module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
      return this;
    }() || Function("return this")();
  }
});
var require_fails = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/fails.js"(exports, module2) {
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});
var require_descriptors = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/descriptors.js"(exports, module2) {
    var fails = require_fails();
    module2.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
  }
});
var require_function_bind_native = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-bind-native.js"(exports, module2) {
    var fails = require_fails();
    module2.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});
var require_function_call = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-call.js"(exports, module2) {
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module2.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});
var require_object_property_is_enumerable = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    }, "propertyIsEnumerable"), "propertyIsEnumerable") : $propertyIsEnumerable;
  }
});
var require_create_property_descriptor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/create-property-descriptor.js"(exports, module2) {
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});
var require_function_uncurry_this = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-uncurry-this.js"(exports, module2) {
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});
var require_classof_raw = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/classof-raw.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var toString6 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module2.exports = function(it) {
      return stringSlice(toString6(it), 8, -1);
    };
  }
});
var require_indexed_object = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/indexed-object.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module2.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) == "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});
var require_is_null_or_undefined = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-null-or-undefined.js"(exports, module2) {
    module2.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});
var require_require_object_coercible = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/require-object-coercible.js"(exports, module2) {
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module2.exports = function(it) {
      if (isNullOrUndefined(it))
        throw $TypeError("Can't call method on " + it);
      return it;
    };
  }
});
var require_to_indexed_object = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-indexed-object.js"(exports, module2) {
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module2.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});
var require_document_all = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/document-all.js"(exports, module2) {
    var documentAll = typeof document == "object" && document.all;
    var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
    module2.exports = {
      all: documentAll,
      IS_HTMLDDA
    };
  }
});
var require_is_callable = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-callable.js"(exports, module2) {
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});
var require_is_object = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-object.js"(exports, module2) {
    var isCallable = require_is_callable();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module2.exports = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});
var require_get_built_in = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/get-built-in.js"(exports, module2) {
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = /* @__PURE__ */ __name2(function(argument) {
      return isCallable(argument) ? argument : void 0;
    }, "aFunction");
    module2.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
    };
  }
});
var require_object_is_prototype_of = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-is-prototype-of.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis({}.isPrototypeOf);
  }
});
var require_engine_user_agent = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-user-agent.js"(exports, module2) {
    module2.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  }
});
var require_engine_v8_version = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-v8-version.js"(exports, module2) {
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process3 = global2.process;
    var Deno2 = global2.Deno;
    var versions = process3 && process3.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match2;
    var version122;
    if (v8) {
      match2 = v8.split(".");
      version122 = match2[0] > 0 && match2[0] < 4 ? 1 : +(match2[0] + match2[1]);
    }
    if (!version122 && userAgent) {
      match2 = userAgent.match(/Edge\/(\d+)/);
      if (!match2 || match2[1] >= 74) {
        match2 = userAgent.match(/Chrome\/(\d+)/);
        if (match2)
          version122 = +match2[1];
      }
    }
    module2.exports = version122;
  }
});
var require_symbol_constructor_detection = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module2) {
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol();
      return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});
var require_use_symbol_as_uid = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module2) {
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});
var require_is_symbol = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-symbol.js"(exports, module2) {
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module2.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});
var require_try_to_string = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/try-to-string.js"(exports, module2) {
    var $String = String;
    module2.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});
var require_a_callable = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/a-callable.js"(exports, module2) {
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw $TypeError(tryToString(argument) + " is not a function");
    };
  }
});
var require_get_method = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/get-method.js"(exports, module2) {
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module2.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});
var require_ordinary_to_primitive = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module2) {
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module2.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      throw $TypeError("Can't convert object to primitive value");
    };
  }
});
var require_is_pure = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-pure.js"(exports, module2) {
    module2.exports = false;
  }
});
var require_define_global_property = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/define-global-property.js"(exports, module2) {
    var global2 = require_global();
    var defineProperty = Object.defineProperty;
    module2.exports = function(key22, value) {
      try {
        defineProperty(global2, key22, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key22] = value;
      }
      return value;
    };
  }
});
var require_shared_store = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/shared-store.js"(exports, module2) {
    var global2 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
    module2.exports = store;
  }
});
var require_shared = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/shared.js"(exports, module2) {
    var IS_PURE = require_is_pure();
    var store = require_shared_store();
    (module2.exports = function(key22, value) {
      return store[key22] || (store[key22] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.28.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.28.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});
var require_to_object = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-object.js"(exports, module2) {
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module2.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});
var require_has_own_property = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/has-own-property.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
    module2.exports = Object.hasOwn || /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function hasOwn(it, key22) {
      return hasOwnProperty2(toObject(it), key22);
    }, "hasOwn"), "hasOwn");
  }
});
var require_uid = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/uid.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var id2 = 0;
    var postfix = Math.random();
    var toString6 = uncurryThis(1 .toString);
    module2.exports = function(key22) {
      return "Symbol(" + (key22 === void 0 ? "" : key22) + ")_" + toString6(++id2 + postfix, 36);
    };
  }
});
var require_well_known_symbol = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/well-known-symbol.js"(exports, module2) {
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = global2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module2.exports = function(name3) {
      if (!hasOwn(WellKnownSymbolsStore, name3)) {
        WellKnownSymbolsStore[name3] = NATIVE_SYMBOL && hasOwn(Symbol2, name3) ? Symbol2[name3] : createWellKnownSymbol("Symbol." + name3);
      }
      return WellKnownSymbolsStore[name3];
    };
  }
});
var require_to_primitive = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-primitive.js"(exports, module2) {
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module2.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result))
          return result;
        throw $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});
var require_to_property_key = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-property-key.js"(exports, module2) {
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module2.exports = function(argument) {
      var key22 = toPrimitive(argument, "string");
      return isSymbol(key22) ? key22 : key22 + "";
    };
  }
});
var require_document_create_element = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/document-create-element.js"(exports, module2) {
    var global2 = require_global();
    var isObject = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module2.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});
var require_ie8_dom_define = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/ie8-dom-define.js"(exports, module2) {
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module2.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
  }
});
var require_object_get_own_property_descriptor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getOwnPropertyDescriptor(O2, P) {
      O2 = toIndexedObject(O2);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O2, P);
        } catch (error) {
        }
      if (hasOwn(O2, P))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O2, P), O2[P]);
    }, "getOwnPropertyDescriptor"), "getOwnPropertyDescriptor");
  }
});
var require_v8_prototype_define_bug = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module2) {
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module2.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype != 42;
    });
  }
});
var require_an_object = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/an-object.js"(exports, module2) {
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isObject(argument))
        return argument;
      throw $TypeError($String(argument) + " is not an object");
    };
  }
});
var require_object_define_property = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-define-property.js"(exports) {
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function defineProperty(O2, P, Attributes) {
      anObject(O2);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O2 === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O2, P);
        if (current && current[WRITABLE]) {
          O2[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O2, P, Attributes);
    }, "defineProperty"), "defineProperty") : $defineProperty : /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function defineProperty(O2, P, Attributes) {
      anObject(O2);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O2, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O2[P] = Attributes.value;
      return O2;
    }, "defineProperty"), "defineProperty");
  }
});
var require_create_non_enumerable_property = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module2) {
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = DESCRIPTORS ? function(object, key22, value) {
      return definePropertyModule.f(object, key22, createPropertyDescriptor(1, value));
    } : function(object, key22, value) {
      object[key22] = value;
      return object;
    };
  }
});
var require_function_name = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-name.js"(exports, module2) {
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function something() {
    }, "something"), "something")).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module2.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});
var require_inspect_source = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/inspect-source.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module2.exports = store.inspectSource;
  }
});
var require_weak_map_basic_detection = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module2) {
    var global2 = require_global();
    var isCallable = require_is_callable();
    var WeakMap2 = global2.WeakMap;
    module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});
var require_shared_key = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/shared-key.js"(exports, module2) {
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module2.exports = function(key22) {
      return keys[key22] || (keys[key22] = uid(key22));
    };
  }
});
var require_hidden_keys = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/hidden-keys.js"(exports, module2) {
    module2.exports = {};
  }
});
var require_internal_state = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/internal-state.js"(exports, module2) {
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global2 = require_global();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey2 = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap2 = global2.WeakMap;
    var set;
    var get2;
    var has;
    var enforce = /* @__PURE__ */ __name2(function(it) {
      return has(it) ? get2(it) : set(it, {});
    }, "enforce");
    var getterFor = /* @__PURE__ */ __name2(function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get2(it)).type !== TYPE) {
          throw TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    }, "getterFor");
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = /* @__PURE__ */ __name2(function(it, metadata) {
        if (store.has(it))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      }, "set");
      get2 = /* @__PURE__ */ __name2(function(it) {
        return store.get(it) || {};
      }, "get");
      has = /* @__PURE__ */ __name2(function(it) {
        return store.has(it);
      }, "has");
    } else {
      STATE = sharedKey2("state");
      hiddenKeys[STATE] = true;
      set = /* @__PURE__ */ __name2(function(it, metadata) {
        if (hasOwn(it, STATE))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      }, "set");
      get2 = /* @__PURE__ */ __name2(function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      }, "get");
      has = /* @__PURE__ */ __name2(function(it) {
        return hasOwn(it, STATE);
      }, "has");
    }
    var store;
    var STATE;
    module2.exports = {
      set,
      get: get2,
      has,
      enforce,
      getterFor
    };
  }
});
var require_make_built_in = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/make-built-in.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module2.exports = function(value, name3, options) {
      if (stringSlice($String(name3), 0, 7) === "Symbol(") {
        name3 = "[" + replace($String(name3), /^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name3 = "get " + name3;
      if (options && options.setter)
        name3 = "set " + name3;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name3) {
        if (DESCRIPTORS)
          defineProperty(value, "name", { value: name3, configurable: true });
        else
          value.name = name3;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS)
            defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name3 == "string" ? name3 : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString6"), "toString"), "toString");
  }
});
var require_define_built_in = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/define-built-in.js"(exports, module2) {
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module2.exports = function(O2, key22, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name3 = options.name !== void 0 ? options.name : key22;
      if (isCallable(value))
        makeBuiltIn(value, name3, options);
      if (options.global) {
        if (simple)
          O2[key22] = value;
        else
          defineGlobalProperty(key22, value);
      } else {
        try {
          if (!options.unsafe)
            delete O2[key22];
          else if (O2[key22])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O2[key22] = value;
        else
          definePropertyModule.f(O2, key22, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O2;
    };
  }
});
var require_math_trunc = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/math-trunc.js"(exports, module2) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = Math.trunc || /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function trunc(x2) {
      var n = +x2;
      return (n > 0 ? floor : ceil)(n);
    }, "trunc"), "trunc");
  }
});
var require_to_integer_or_infinity = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module2) {
    var trunc = require_math_trunc();
    module2.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});
var require_to_absolute_index = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-absolute-index.js"(exports, module2) {
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module2.exports = function(index, length2) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length2, 0) : min(integer, length2);
    };
  }
});
var require_to_length = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-length.js"(exports, module2) {
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module2.exports = function(argument) {
      return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
    };
  }
});
var require_length_of_array_like = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/length-of-array-like.js"(exports, module2) {
    var toLength = require_to_length();
    module2.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});
var require_array_includes = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/array-includes.js"(exports, module2) {
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = /* @__PURE__ */ __name2(function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O2 = toIndexedObject($this);
        var length2 = lengthOfArrayLike(O2);
        var index = toAbsoluteIndex(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el != el)
          while (length2 > index) {
            value = O2[index++];
            if (value != value)
              return true;
          }
        else
          for (; length2 > index; index++) {
            if ((IS_INCLUDES || index in O2) && O2[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    }, "createMethod");
    module2.exports = {
      includes: createMethod(true),
      indexOf: createMethod(false)
    };
  }
});
var require_object_keys_internal = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-keys-internal.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module2.exports = function(object, names2) {
      var O2 = toIndexedObject(object);
      var i22 = 0;
      var result = [];
      var key22;
      for (key22 in O2)
        !hasOwn(hiddenKeys, key22) && hasOwn(O2, key22) && push(result, key22);
      while (names2.length > i22)
        if (hasOwn(O2, key22 = names2[i22++])) {
          ~indexOf(result, key22) || push(result, key22);
        }
      return result;
    };
  }
});
var require_enum_bug_keys = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/enum-bug-keys.js"(exports, module2) {
    module2.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});
var require_object_get_own_property_names = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getOwnPropertyNames(O2) {
      return internalObjectKeys(O2, hiddenKeys);
    }, "getOwnPropertyNames"), "getOwnPropertyNames");
  }
});
var require_object_get_own_property_symbols = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    exports.f = Object.getOwnPropertySymbols;
  }
});
var require_own_keys = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/own-keys.js"(exports, module2) {
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat4 = uncurryThis([].concat);
    module2.exports = getBuiltIn("Reflect", "ownKeys") || /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat4(keys, getOwnPropertySymbols(it)) : keys;
    }, "ownKeys"), "ownKeys");
  }
});
var require_copy_constructor_properties = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/copy-constructor-properties.js"(exports, module2) {
    var hasOwn = require_has_own_property();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module2.exports = function(target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i22 = 0; i22 < keys.length; i22++) {
        var key22 = keys[i22];
        if (!hasOwn(target, key22) && !(exceptions && hasOwn(exceptions, key22))) {
          defineProperty(target, key22, getOwnPropertyDescriptor(source, key22));
        }
      }
    };
  }
});
var require_is_forced = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-forced.js"(exports, module2) {
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = /* @__PURE__ */ __name2(function(feature, detection) {
      var value = data[normalize2(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    }, "isForced");
    var normalize2 = isForced.normalize = function(string2) {
      return String(string2).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module2.exports = isForced;
  }
});
var require_export = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/export.js"(exports, module2) {
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module2.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key22, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global2;
      } else if (STATIC) {
        target = global2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global2[TARGET] || {}).prototype;
      }
      if (target)
        for (key22 in source) {
          sourceProperty = source[key22];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key22);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key22];
          FORCED = isForced(GLOBAL ? key22 : TARGET + (STATIC ? "." : "#") + key22, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key22, sourceProperty, options);
        }
    };
  }
});
var require_correct_prototype_getter = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/correct-prototype-getter.js"(exports, module2) {
    var fails = require_fails();
    module2.exports = !fails(function() {
      function F() {
      }
      __name(F, "F");
      __name2(F, "F");
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
  }
});
var require_object_get_prototype_of = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-get-prototype-of.js"(exports, module2) {
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey2 = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey2("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O2) {
      var object = toObject(O2);
      if (hasOwn(object, IE_PROTO))
        return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});
var require_function_uncurry_this_accessor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module2.exports = function(object, key22, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key22)[method]));
      } catch (error) {
      }
    };
  }
});
var require_a_possible_prototype = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/a-possible-prototype.js"(exports, module2) {
    var isCallable = require_is_callable();
    var $String = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (typeof argument == "object" || isCallable(argument))
        return argument;
      throw $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});
var require_object_set_prototype_of = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-set-prototype-of.js"(exports, module2) {
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function setPrototypeOf(O2, proto) {
        anObject(O2);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O2, proto);
        else
          O2.__proto__ = proto;
        return O2;
      }, "setPrototypeOf"), "setPrototypeOf");
    }() : void 0);
  }
});
var require_object_keys = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-keys.js"(exports, module2) {
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keys(O2) {
      return internalObjectKeys(O2, enumBugKeys);
    }, "keys"), "keys");
  }
});
var require_object_define_properties = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-define-properties.js"(exports) {
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function defineProperties(O2, Properties) {
      anObject(O2);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length2 = keys.length;
      var index = 0;
      var key22;
      while (length2 > index)
        definePropertyModule.f(O2, key22 = keys[index++], props[key22]);
      return O2;
    }, "defineProperties"), "defineProperties");
  }
});
var require_html = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/html.js"(exports, module2) {
    var getBuiltIn = require_get_built_in();
    module2.exports = getBuiltIn("document", "documentElement");
  }
});
var require_object_create = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-create.js"(exports, module2) {
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey2 = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey2("IE_PROTO");
    var EmptyConstructor = /* @__PURE__ */ __name2(function() {
    }, "EmptyConstructor");
    var scriptTag = /* @__PURE__ */ __name2(function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    }, "scriptTag");
    var NullProtoObjectViaActiveX = /* @__PURE__ */ __name2(function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    }, "NullProtoObjectViaActiveX");
    var NullProtoObjectViaIFrame = /* @__PURE__ */ __name2(function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    }, "NullProtoObjectViaIFrame");
    var activeXDocument;
    var NullProtoObject = /* @__PURE__ */ __name2(function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length2 = enumBugKeys.length;
      while (length2--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
      return NullProtoObject();
    }, "NullProtoObject");
    hiddenKeys[IE_PROTO] = true;
    module2.exports = Object.create || /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function create2(O2, Properties) {
      var result;
      if (O2 !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O2);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O2;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    }, "create2"), "create");
  }
});
var require_install_error_cause = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/install-error-cause.js"(exports, module2) {
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module2.exports = function(O2, options) {
      if (isObject(options) && "cause" in options) {
        createNonEnumerableProperty(O2, "cause", options.cause);
      }
    };
  }
});
var require_error_stack_clear = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/error-stack-clear.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var $Error = Error;
    var replace = uncurryThis("".replace);
    var TEST = function(arg) {
      return String($Error(arg).stack);
    }("zxcasd");
    var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
    var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
    module2.exports = function(stack, dropEntries) {
      if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
        while (dropEntries--)
          stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
      }
      return stack;
    };
  }
});
var require_error_stack_installable = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/error-stack-installable.js"(exports, module2) {
    var fails = require_fails();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = !fails(function() {
      var error = Error("a");
      if (!("stack" in error))
        return true;
      Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
      return error.stack !== 7;
    });
  }
});
var require_error_stack_install = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/error-stack-install.js"(exports, module2) {
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var clearErrorStack = require_error_stack_clear();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var captureStackTrace = Error.captureStackTrace;
    module2.exports = function(error, C, stack, dropEntries) {
      if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace)
          captureStackTrace(error, C);
        else
          createNonEnumerableProperty(error, "stack", clearErrorStack(stack, dropEntries));
      }
    };
  }
});
var require_function_uncurry_this_clause = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module2) {
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module2.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis(fn);
    };
  }
});
var require_function_bind_context = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-bind-context.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind2 = uncurryThis(uncurryThis.bind);
    module2.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});
var require_iterators = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/iterators.js"(exports, module2) {
    module2.exports = {};
  }
});
var require_is_array_iterator_method = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-array-iterator-method.js"(exports, module2) {
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module2.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});
var require_to_string_tag_support = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-string-tag-support.js"(exports, module2) {
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module2.exports = String(test) === "[object z]";
  }
});
var require_classof = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/classof.js"(exports, module2) {
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = /* @__PURE__ */ __name2(function(it, key22) {
      try {
        return it[key22];
      } catch (error) {
      }
    }, "tryGet");
    module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O2, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && isCallable(O2.callee) ? "Arguments" : result;
    };
  }
});
var require_get_iterator_method = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/get-iterator-method.js"(exports, module2) {
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module2.exports = function(it) {
      if (!isNullOrUndefined(it))
        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});
var require_get_iterator = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/get-iterator.js"(exports, module2) {
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module2.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});
var require_iterator_close = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/iterator-close.js"(exports, module2) {
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module2.exports = function(iterator2, kind, value) {
      var innerResult, innerError;
      anObject(iterator2);
      try {
        innerResult = getMethod(iterator2, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator2);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});
var require_iterate = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/iterate.js"(exports, module2) {
    var bind2 = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = /* @__PURE__ */ __name2(function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    }, "Result");
    var ResultPrototype = Result.prototype;
    module2.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind2(unboundFunction, that);
      var iterator2, iterFn, index, length2, result, next, step;
      var stop = /* @__PURE__ */ __name2(function(condition) {
        if (iterator2)
          iteratorClose(iterator2, "normal", condition);
        return new Result(true, condition);
      }, "stop");
      var callFn = /* @__PURE__ */ __name2(function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      }, "callFn");
      if (IS_RECORD) {
        iterator2 = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator2 = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length2 = lengthOfArrayLike(iterable); length2 > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator2 = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator2.next;
      while (!(step = call(next, iterator2)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator2, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});
var require_to_string = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/to-string.js"(exports, module2) {
    var classof = require_classof();
    var $String = String;
    module2.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});
var require_normalize_string_argument = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/normalize-string-argument.js"(exports, module2) {
    var toString6 = require_to_string();
    module2.exports = function(argument, $default) {
      return argument === void 0 ? arguments.length < 2 ? "" : $default : toString6(argument);
    };
  }
});
var require_es_aggregate_error_constructor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.aggregate-error.constructor.js"() {
    "use strict";
    var $ = require_export();
    var isPrototypeOf = require_object_is_prototype_of();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var copyConstructorProperties = require_copy_constructor_properties();
    var create2 = require_object_create();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    var installErrorCause = require_install_error_cause();
    var installErrorStack = require_error_stack_install();
    var iterate = require_iterate();
    var normalizeStringArgument = require_normalize_string_argument();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Error = Error;
    var push = [].push;
    var $AggregateError = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function AggregateError(errors, message) {
      var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
      var that;
      if (setPrototypeOf) {
        that = setPrototypeOf($Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
      } else {
        that = isInstance ? this : create2(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
      }
      if (message !== void 0)
        createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
      installErrorStack(that, $AggregateError, that.stack, 1);
      if (arguments.length > 2)
        installErrorCause(that, arguments[2]);
      var errorsArray = [];
      iterate(errors, push, { that: errorsArray });
      createNonEnumerableProperty(that, "errors", errorsArray);
      return that;
    }, "AggregateError"), "AggregateError");
    if (setPrototypeOf)
      setPrototypeOf($AggregateError, $Error);
    else
      copyConstructorProperties($AggregateError, $Error, { name: true });
    var AggregateErrorPrototype = $AggregateError.prototype = create2($Error.prototype, {
      constructor: createPropertyDescriptor(1, $AggregateError),
      message: createPropertyDescriptor(1, ""),
      name: createPropertyDescriptor(1, "AggregateError")
    });
    $({ global: true, constructor: true, arity: 2 }, {
      AggregateError: $AggregateError
    });
  }
});
var require_es_aggregate_error = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.aggregate-error.js"() {
    require_es_aggregate_error_constructor();
  }
});
var require_add_to_unscopables = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/add-to-unscopables.js"(exports, module2) {
    var wellKnownSymbol = require_well_known_symbol();
    var create2 = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] == void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create2(null)
      });
    }
    module2.exports = function(key22) {
      ArrayPrototype[UNSCOPABLES][key22] = true;
    };
  }
});
var require_iterators_core = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/iterators-core.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var create2 = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    else if (IS_PURE)
      IteratorPrototype = create2(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module2.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});
var require_set_to_string_tag = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/set-to-string-tag.js"(exports, module2) {
    var defineProperty = require_object_define_property().f;
    var hasOwn = require_has_own_property();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module2.exports = function(target, TAG3, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG3 });
      }
    };
  }
});
var require_iterator_create_constructor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/iterator-create-constructor.js"(exports, module2) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create2 = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = /* @__PURE__ */ __name2(function() {
      return this;
    }, "returnThis");
    module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});
var require_iterator_define = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/iterator-define.js"(exports, module2) {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = /* @__PURE__ */ __name2(function() {
      return this;
    }, "returnThis");
    module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = /* @__PURE__ */ __name2(function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keys() {
              return new IteratorConstructor(this, KIND);
            }, "keys"), "keys");
          case VALUES:
            return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function values() {
              return new IteratorConstructor(this, KIND);
            }, "values"), "values");
          case ENTRIES:
            return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function entries() {
              return new IteratorConstructor(this, KIND);
            }, "entries"), "entries");
        }
        return function() {
          return new IteratorConstructor(this);
        };
      }, "getIterationMethod");
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function values() {
            return call(nativeIterator, this);
          }, "values"), "values");
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
  }
});
var require_create_iter_result_object = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/create-iter-result-object.js"(exports, module2) {
    module2.exports = function(value, done) {
      return { value, done };
    };
  }
});
var require_es_array_iterator = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.array.iterator.js"(exports, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      if (kind == "keys")
        return createIterResultObject(index, false);
      if (kind == "values")
        return createIterResultObject(target[index], false);
      return createIterResultObject([index, target[index]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values")
      try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
  }
});
var require_object_to_string = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/object-to-string.js"(exports, module2) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
      return "[object " + classof(this) + "]";
    }, "toString6"), "toString");
  }
});
var require_es_object_to_string = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.object.to-string.js"() {
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var defineBuiltIn = require_define_built_in();
    var toString6 = require_object_to_string();
    if (!TO_STRING_TAG_SUPPORT) {
      defineBuiltIn(Object.prototype, "toString", toString6, { unsafe: true });
    }
  }
});
var require_engine_is_node = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-is-node.js"(exports, module2) {
    var classof = require_classof_raw();
    module2.exports = typeof process != "undefined" && classof(process) == "process";
  }
});
var require_define_built_in_accessor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/define-built-in-accessor.js"(exports, module2) {
    var makeBuiltIn = require_make_built_in();
    var defineProperty = require_object_define_property();
    module2.exports = function(target, name3, descriptor) {
      if (descriptor.get)
        makeBuiltIn(descriptor.get, name3, { getter: true });
      if (descriptor.set)
        makeBuiltIn(descriptor.set, name3, { setter: true });
      return defineProperty.f(target, name3, descriptor);
    };
  }
});
var require_set_species = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/set-species.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});
var require_an_instance = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/an-instance.js"(exports, module2) {
    var isPrototypeOf = require_object_is_prototype_of();
    var $TypeError = TypeError;
    module2.exports = function(it, Prototype) {
      if (isPrototypeOf(Prototype, it))
        return it;
      throw $TypeError("Incorrect invocation");
    };
  }
});
var require_is_constructor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/is-constructor.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop2 = /* @__PURE__ */ __name2(function() {
    }, "noop");
    var empty2 = [];
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.exec(noop2);
    var isConstructorModern = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop2, empty2, argument);
        return true;
      } catch (error) {
        return false;
      }
    }, "isConstructor"), "isConstructor");
    var isConstructorLegacy = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    }, "isConstructor"), "isConstructor");
    isConstructorLegacy.sham = true;
    module2.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});
var require_a_constructor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/a-constructor.js"(exports, module2) {
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isConstructor(argument))
        return argument;
      throw $TypeError(tryToString(argument) + " is not a constructor");
    };
  }
});
var require_species_constructor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/species-constructor.js"(exports, module2) {
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(O2, defaultConstructor) {
      var C = anObject(O2).constructor;
      var S3;
      return C === void 0 || isNullOrUndefined(S3 = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S3);
    };
  }
});
var require_function_apply = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/function-apply.js"(exports, module2) {
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});
var require_array_slice = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/array-slice.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis([].slice);
  }
});
var require_validate_arguments_length = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/validate-arguments-length.js"(exports, module2) {
    var $TypeError = TypeError;
    module2.exports = function(passed, required) {
      if (passed < required)
        throw $TypeError("Not enough arguments");
      return passed;
    };
  }
});
var require_engine_is_ios = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-is-ios.js"(exports, module2) {
    var userAgent = require_engine_user_agent();
    module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});
var require_task = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/task.js"(exports, module2) {
    var global2 = require_global();
    var apply = require_function_apply();
    var bind2 = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var set = global2.setImmediate;
    var clear = global2.clearImmediate;
    var process3 = global2.process;
    var Dispatch = global2.Dispatch;
    var Function2 = global2.Function;
    var MessageChannel = global2.MessageChannel;
    var String2 = global2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails(function() {
      $location = global2.location;
    });
    var run = /* @__PURE__ */ __name2(function(id2) {
      if (hasOwn(queue, id2)) {
        var fn = queue[id2];
        delete queue[id2];
        fn();
      }
    }, "run");
    var runner = /* @__PURE__ */ __name2(function(id2) {
      return function() {
        run(id2);
      };
    }, "runner");
    var eventListener = /* @__PURE__ */ __name2(function(event) {
      run(event.data);
    }, "eventListener");
    var globalPostMessageDefer = /* @__PURE__ */ __name2(function(id2) {
      global2.postMessage(String2(id2), $location.protocol + "//" + $location.host);
    }, "globalPostMessageDefer");
    if (!set || !clear) {
      set = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function setImmediate2(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function2(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      }, "setImmediate2"), "setImmediate");
      clear = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function clearImmediate(id2) {
        delete queue[id2];
      }, "clearImmediate"), "clearImmediate");
      if (IS_NODE) {
        defer = /* @__PURE__ */ __name2(function(id2) {
          process3.nextTick(runner(id2));
        }, "defer");
      } else if (Dispatch && Dispatch.now) {
        defer = /* @__PURE__ */ __name2(function(id2) {
          Dispatch.now(runner(id2));
        }, "defer");
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind2(port.postMessage, port);
      } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = /* @__PURE__ */ __name2(function(id2) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id2);
          };
        }, "defer");
      } else {
        defer = /* @__PURE__ */ __name2(function(id2) {
          setTimeout(runner(id2), 0);
        }, "defer");
      }
    }
    module2.exports = {
      set,
      clear
    };
  }
});
var require_queue = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/queue.js"(exports, module2) {
    var Queue = /* @__PURE__ */ __name2(function() {
      this.head = null;
      this.tail = null;
    }, "Queue");
    Queue.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    module2.exports = Queue;
  }
});
var require_engine_is_ios_pebble = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-is-ios-pebble.js"(exports, module2) {
    var userAgent = require_engine_user_agent();
    module2.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  }
});
var require_engine_is_webos_webkit = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module2) {
    var userAgent = require_engine_user_agent();
    module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});
var require_microtask = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/microtask.js"(exports, module2) {
    var global2 = require_global();
    var bind2 = require_function_bind_context();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var macrotask = require_task().set;
    var Queue = require_queue();
    var IS_IOS = require_engine_is_ios();
    var IS_IOS_PEBBLE = require_engine_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
    var IS_NODE = require_engine_is_node();
    var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
    var document2 = global2.document;
    var process3 = global2.process;
    var Promise2 = global2.Promise;
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
    var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var notify;
    var toggle;
    var node;
    var promise;
    var then;
    if (!microtask) {
      queue = new Queue();
      flush = /* @__PURE__ */ __name2(function() {
        var parent, fn;
        if (IS_NODE && (parent = process3.domain))
          parent.exit();
        while (fn = queue.get())
          try {
            fn();
          } catch (error) {
            if (queue.head)
              notify();
            throw error;
          }
        if (parent)
          parent.enter();
      }, "flush");
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node = document2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify = /* @__PURE__ */ __name2(function() {
          node.data = toggle = !toggle;
        }, "notify");
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind2(promise.then, promise);
        notify = /* @__PURE__ */ __name2(function() {
          then(flush);
        }, "notify");
      } else if (IS_NODE) {
        notify = /* @__PURE__ */ __name2(function() {
          process3.nextTick(flush);
        }, "notify");
      } else {
        macrotask = bind2(macrotask, global2);
        notify = /* @__PURE__ */ __name2(function() {
          macrotask(flush);
        }, "notify");
      }
      microtask = /* @__PURE__ */ __name2(function(fn) {
        if (!queue.head)
          notify();
        queue.add(fn);
      }, "microtask");
    }
    var queue;
    var flush;
    module2.exports = microtask;
  }
});
var require_host_report_errors = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/host-report-errors.js"(exports, module2) {
    module2.exports = function(a3, b2) {
      try {
        arguments.length == 1 ? console.error(a3) : console.error(a3, b2);
      } catch (error) {
      }
    };
  }
});
var require_perform = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/perform.js"(exports, module2) {
    module2.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});
var require_promise_native_constructor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/promise-native-constructor.js"(exports, module2) {
    var global2 = require_global();
    module2.exports = global2.Promise;
  }
});
var require_engine_is_deno = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-is-deno.js"(exports, module2) {
    module2.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
  }
});
var require_engine_is_browser = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/engine-is-browser.js"(exports, module2) {
    var IS_DENO = require_engine_is_deno();
    var IS_NODE = require_engine_is_node();
    module2.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
  }
});
var require_promise_constructor_detection = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/promise-constructor-detection.js"(exports, module2) {
    var global2 = require_global();
    var NativePromiseConstructor = require_promise_native_constructor();
    var isCallable = require_is_callable();
    var isForced = require_is_forced();
    var inspectSource = require_inspect_source();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_BROWSER = require_engine_is_browser();
    var IS_DENO = require_engine_is_deno();
    var IS_PURE = require_is_pure();
    var V8_VERSION = require_engine_v8_version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
        return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve) {
          resolve(1);
        });
        var FakePromise = /* @__PURE__ */ __name2(function(exec) {
          exec(function() {
          }, function() {
          });
        }, "FakePromise");
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    module2.exports = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
  }
});
var require_new_promise_capability = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/new-promise-capability.js"(exports, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var $TypeError = TypeError;
    var PromiseCapability = /* @__PURE__ */ __name2(function(C) {
      var resolve, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    }, "PromiseCapability");
    module2.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});
var require_es_promise_constructor = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.constructor.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var IS_NODE = require_engine_is_node();
    var global2 = require_global();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var hostReportErrors = require_host_report_errors();
    var perform = require_perform();
    var Queue = require_queue();
    var InternalStateModule = require_internal_state();
    var NativePromiseConstructor = require_promise_native_constructor();
    var PromiseConstructorDetection = require_promise_constructor_detection();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = global2.TypeError;
    var document2 = global2.document;
    var process3 = global2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var isThenable = /* @__PURE__ */ __name2(function(it) {
      var then;
      return isObject(it) && isCallable(then = it.then) ? then : false;
    }, "isThenable");
    var callReaction = /* @__PURE__ */ __name2(function(reaction, state) {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED)
              onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else
            resolve(result);
        } else
          reject(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject(error);
      }
    }, "callReaction");
    var notify = /* @__PURE__ */ __name2(function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    }, "notify");
    var dispatchEvent = /* @__PURE__ */ __name2(function(name3, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name3, false, true);
        global2.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global2["on" + name3]))
        handler(event);
      else if (name3 === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    }, "dispatchEvent");
    var onUnhandled = /* @__PURE__ */ __name2(function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process3.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    }, "onUnhandled");
    var isUnhandled = /* @__PURE__ */ __name2(function(state) {
      return state.rejection !== HANDLED && !state.parent;
    }, "isUnhandled");
    var onHandleUnhandled = /* @__PURE__ */ __name2(function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process3.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    }, "onHandleUnhandled");
    var bind2 = /* @__PURE__ */ __name2(function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    }, "bind");
    var internalReject = /* @__PURE__ */ __name2(function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    }, "internalReject");
    var internalResolve = /* @__PURE__ */ __name2(function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind2(internalResolve, wrapper, state),
                bind2(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    }, "internalResolve");
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind2(internalResolve, state), bind2(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      }, "Promise2"), "Promise");
      PromisePrototype = PromiseConstructor.prototype;
      Internal = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: void 0
        });
      }, "Promise2"), "Promise");
      Internal.prototype = defineBuiltIn(PromisePrototype, "then", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process3.domain : void 0;
        if (state.state == PENDING)
          state.reactions.add(reaction);
        else
          microtask(function() {
            callReaction(reaction, state);
          });
        return reaction.promise;
      }, "then"), "then"));
      OwnPromiseCapability = /* @__PURE__ */ __name2(function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind2(internalResolve, state);
        this.reject = bind2(internalReject, state);
      }, "OwnPromiseCapability");
      newPromiseCapabilityModule.f = newPromiseCapability = /* @__PURE__ */ __name2(function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      }, "newPromiseCapability");
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, "then", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, "then"), "then"), { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
  }
});
var require_check_correctness_of_iteration = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module2) {
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module2.exports = function(exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING)
        return false;
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});
var require_promise_statics_incorrect_iteration = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module2) {
    var NativePromiseConstructor = require_promise_native_constructor();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    module2.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
  }
});
var require_es_promise_all = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.all.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }, "all"), "all")
    });
  }
});
var require_es_promise_catch = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.catch.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var NativePromiseConstructor = require_promise_native_constructor();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var method;
  }
});
var require_es_promise_race = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.race.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }, "race"), "race")
    });
  }
});
var require_es_promise_reject = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.reject.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function reject(r2) {
        var capability = newPromiseCapabilityModule.f(this);
        call(capability.reject, void 0, r2);
        return capability.promise;
      }, "reject"), "reject")
    });
  }
});
var require_promise_resolve = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/promise-resolve.js"(exports, module2) {
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module2.exports = function(C, x2) {
      anObject(C);
      if (isObject(x2) && x2.constructor === C)
        return x2;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x2);
      return promiseCapability.promise;
    };
  }
});
var require_es_promise_resolve = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.resolve.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var promiseResolve = require_promise_resolve();
    var PromiseConstructorWrapper = getBuiltIn("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function resolve(x2) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
      }, "resolve"), "resolve")
    });
  }
});
var require_es_promise = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.js"() {
    require_es_promise_constructor();
    require_es_promise_all();
    require_es_promise_catch();
    require_es_promise_race();
    require_es_promise_reject();
    require_es_promise_resolve();
  }
});
var require_es_promise_all_settled = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.all-settled.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      allSettled: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call(promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = { status: "fulfilled", value };
              --remaining || resolve(values);
            }, function(error) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = { status: "rejected", reason: error };
              --remaining || resolve(values);
            });
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }, "allSettled"), "allSettled")
    });
  }
});
var require_es_promise_any = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.any.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var getBuiltIn = require_get_built_in();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    var PROMISE_ANY_ERROR = "No one promise resolved";
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      any: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function any(iterable) {
        var C = this;
        var AggregateError = getBuiltIn("AggregateError");
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aCallable(C.resolve);
          var errors = [];
          var counter = 0;
          var remaining = 1;
          var alreadyResolved = false;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyRejected = false;
            remaining++;
            call(promiseResolve, C, promise).then(function(value) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyResolved = true;
              resolve(value);
            }, function(error) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyRejected = true;
              errors[index] = error;
              --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
            });
          });
          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }, "any"), "any")
    });
  }
});
var require_es_promise_finally = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.promise.finally.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var fails = require_fails();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var speciesConstructor = require_species_constructor();
    var promiseResolve = require_promise_resolve();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
      NativePromisePrototype["finally"].call({ then: function() {
      } }, function() {
      });
    });
    $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
      "finally": function(onFinally) {
        var C = speciesConstructor(this, getBuiltIn("Promise"));
        var isFunction2 = isCallable(onFinally);
        return this.then(
          isFunction2 ? function(x2) {
            return promiseResolve(C, onFinally()).then(function() {
              return x2;
            });
          } : onFinally,
          isFunction2 ? function(e2) {
            return promiseResolve(C, onFinally()).then(function() {
              throw e2;
            });
          } : onFinally
        );
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["finally"];
      if (NativePromisePrototype["finally"] !== method) {
        defineBuiltIn(NativePromisePrototype, "finally", method, { unsafe: true });
      }
    }
    var method;
  }
});
var require_string_multibyte = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/string-multibyte.js"(exports, module2) {
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString6 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = /* @__PURE__ */ __name2(function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S3 = toString6(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S3.length;
        var first2, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first2 = charCodeAt(S3, position);
        return first2 < 55296 || first2 > 56319 || position + 1 === size || (second = charCodeAt(S3, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S3, position) : first2 : CONVERT_TO_STRING ? stringSlice(S3, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
      };
    }, "createMethod");
    module2.exports = {
      codeAt: createMethod(false),
      charAt: createMethod(true)
    };
  }
});
var require_es_string_iterator = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/es.string.iterator.js"() {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    var toString6 = require_to_string();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString6(iterated),
        index: 0
      });
    }, /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function next() {
      var state = getInternalState(this);
      var string2 = state.string;
      var index = state.index;
      var point32;
      if (index >= string2.length)
        return createIterResultObject(void 0, true);
      point32 = charAt(string2, index);
      state.index += point32.length;
      return createIterResultObject(point32, false);
    }, "next"), "next"));
  }
});
var require_path = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/path.js"(exports, module2) {
    var global2 = require_global();
    module2.exports = global2;
  }
});
var require_promise = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/es/promise/index.js"(exports, module2) {
    require_es_aggregate_error();
    require_es_array_iterator();
    require_es_object_to_string();
    require_es_promise();
    require_es_promise_all_settled();
    require_es_promise_any();
    require_es_promise_finally();
    require_es_string_iterator();
    var path = require_path();
    module2.exports = path.Promise;
  }
});
var require_dom_iterables = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/dom-iterables.js"(exports, module2) {
    module2.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});
var require_dom_token_list_prototype = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module2) {
    var documentCreateElement = require_document_create_element();
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    module2.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  }
});
var require_web_dom_collections_iterator = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    var global2 = require_global();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = /* @__PURE__ */ __name2(function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues)
          try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
        if (!CollectionPrototype[TO_STRING_TAG]) {
          createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME2);
        }
        if (DOMIterables[COLLECTION_NAME2])
          for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    }, "handlePrototype");
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  }
});
var require_promise2 = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/stable/promise/index.js"(exports, module2) {
    var parent = require_promise();
    require_web_dom_collections_iterator();
    module2.exports = parent;
  }
});
var require_promise3 = __commonJS2({
  "../../node_modules/.pnpm/core-js@3.28.0/node_modules/core-js/actual/promise/index.js"(exports, module2) {
    var parent = require_promise2();
    module2.exports = parent;
  }
});
var require_lodash = __commonJS2({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER22 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      __name(apply, "apply");
      __name2(apply, "apply");
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      __name(arrayAggregator, "arrayAggregator");
      __name2(arrayAggregator, "arrayAggregator");
      function arrayEach(array, iteratee) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEach, "arrayEach");
      __name2(arrayEach, "arrayEach");
      function arrayEachRight(array, iteratee) {
        var length2 = array == null ? 0 : array.length;
        while (length2--) {
          if (iteratee(array[length2], length2, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEachRight, "arrayEachRight");
      __name2(arrayEachRight, "arrayEachRight");
      function arrayEvery(array, predicate) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      __name(arrayEvery, "arrayEvery");
      __name2(arrayEvery, "arrayEvery");
      function arrayFilter(array, predicate) {
        var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length2) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      __name(arrayFilter, "arrayFilter");
      __name2(arrayFilter, "arrayFilter");
      function arrayIncludes(array, value) {
        var length2 = array == null ? 0 : array.length;
        return !!length2 && baseIndexOf(array, value, 0) > -1;
      }
      __name(arrayIncludes, "arrayIncludes");
      __name2(arrayIncludes, "arrayIncludes");
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      __name(arrayIncludesWith, "arrayIncludesWith");
      __name2(arrayIncludesWith, "arrayIncludesWith");
      function arrayMap(array, iteratee) {
        var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
        while (++index < length2) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      __name(arrayMap, "arrayMap");
      __name2(arrayMap, "arrayMap");
      function arrayPush(array, values) {
        var index = -1, length2 = values.length, offset = array.length;
        while (++index < length2) {
          array[offset + index] = values[index];
        }
        return array;
      }
      __name(arrayPush, "arrayPush");
      __name2(arrayPush, "arrayPush");
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length2 = array == null ? 0 : array.length;
        if (initAccum && length2) {
          accumulator = array[++index];
        }
        while (++index < length2) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      __name(arrayReduce, "arrayReduce");
      __name2(arrayReduce, "arrayReduce");
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length2 = array == null ? 0 : array.length;
        if (initAccum && length2) {
          accumulator = array[--length2];
        }
        while (length2--) {
          accumulator = iteratee(accumulator, array[length2], length2, array);
        }
        return accumulator;
      }
      __name(arrayReduceRight, "arrayReduceRight");
      __name2(arrayReduceRight, "arrayReduceRight");
      function arraySome(array, predicate) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      __name(arraySome, "arraySome");
      __name2(arraySome, "arraySome");
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      __name(asciiToArray, "asciiToArray");
      __name2(asciiToArray, "asciiToArray");
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      __name(asciiWords, "asciiWords");
      __name2(asciiWords, "asciiWords");
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key22, collection2) {
          if (predicate(value, key22, collection2)) {
            result = key22;
            return false;
          }
        });
        return result;
      }
      __name(baseFindKey, "baseFindKey");
      __name2(baseFindKey, "baseFindKey");
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length2) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      __name(baseFindIndex, "baseFindIndex");
      __name2(baseFindIndex, "baseFindIndex");
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      __name(baseIndexOf, "baseIndexOf");
      __name2(baseIndexOf, "baseIndexOf");
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length2 = array.length;
        while (++index < length2) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      __name(baseIndexOfWith, "baseIndexOfWith");
      __name2(baseIndexOfWith, "baseIndexOfWith");
      function baseIsNaN(value) {
        return value !== value;
      }
      __name(baseIsNaN, "baseIsNaN");
      __name2(baseIsNaN, "baseIsNaN");
      function baseMean(array, iteratee) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSum(array, iteratee) / length2 : NAN;
      }
      __name(baseMean, "baseMean");
      __name2(baseMean, "baseMean");
      function baseProperty(key22) {
        return function(object) {
          return object == null ? undefined2 : object[key22];
        };
      }
      __name(baseProperty, "baseProperty");
      __name2(baseProperty, "baseProperty");
      function basePropertyOf(object) {
        return function(key22) {
          return object == null ? undefined2 : object[key22];
        };
      }
      __name(basePropertyOf, "basePropertyOf");
      __name2(basePropertyOf, "basePropertyOf");
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      __name(baseReduce, "baseReduce");
      __name2(baseReduce, "baseReduce");
      function baseSortBy(array, comparer) {
        var length2 = array.length;
        array.sort(comparer);
        while (length2--) {
          array[length2] = array[length2].value;
        }
        return array;
      }
      __name(baseSortBy, "baseSortBy");
      __name2(baseSortBy, "baseSortBy");
      function baseSum(array, iteratee) {
        var result, index = -1, length2 = array.length;
        while (++index < length2) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      __name(baseSum, "baseSum");
      __name2(baseSum, "baseSum");
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      __name(baseTimes, "baseTimes");
      __name2(baseTimes, "baseTimes");
      function baseToPairs(object, props) {
        return arrayMap(props, function(key22) {
          return [key22, object[key22]];
        });
      }
      __name(baseToPairs, "baseToPairs");
      __name2(baseToPairs, "baseToPairs");
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      __name(baseTrim, "baseTrim");
      __name2(baseTrim, "baseTrim");
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      __name(baseUnary, "baseUnary");
      __name2(baseUnary, "baseUnary");
      function baseValues(object, props) {
        return arrayMap(props, function(key22) {
          return object[key22];
        });
      }
      __name(baseValues, "baseValues");
      __name2(baseValues, "baseValues");
      function cacheHas(cache, key22) {
        return cache.has(key22);
      }
      __name(cacheHas, "cacheHas");
      __name2(cacheHas, "cacheHas");
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length2 = strSymbols.length;
        while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      __name(charsStartIndex, "charsStartIndex");
      __name2(charsStartIndex, "charsStartIndex");
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      __name(charsEndIndex, "charsEndIndex");
      __name2(charsEndIndex, "charsEndIndex");
      function countHolders(array, placeholder) {
        var length2 = array.length, result = 0;
        while (length2--) {
          if (array[length2] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      __name(countHolders, "countHolders");
      __name2(countHolders, "countHolders");
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      __name(escapeStringChar, "escapeStringChar");
      __name2(escapeStringChar, "escapeStringChar");
      function getValue(object, key22) {
        return object == null ? undefined2 : object[key22];
      }
      __name(getValue, "getValue");
      __name2(getValue, "getValue");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      __name(hasUnicode, "hasUnicode");
      __name2(hasUnicode, "hasUnicode");
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      __name(hasUnicodeWord, "hasUnicodeWord");
      __name2(hasUnicodeWord, "hasUnicodeWord");
      function iteratorToArray(iterator2) {
        var data, result = [];
        while (!(data = iterator2.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      __name(iteratorToArray, "iteratorToArray");
      __name2(iteratorToArray, "iteratorToArray");
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key22) {
          result[++index] = [key22, value];
        });
        return result;
      }
      __name(mapToArray, "mapToArray");
      __name2(mapToArray, "mapToArray");
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      __name(overArg, "overArg");
      __name2(overArg, "overArg");
      function replaceHolders(array, placeholder) {
        var index = -1, length2 = array.length, resIndex = 0, result = [];
        while (++index < length2) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      __name(replaceHolders, "replaceHolders");
      __name2(replaceHolders, "replaceHolders");
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      __name(setToArray, "setToArray");
      __name2(setToArray, "setToArray");
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      __name(setToPairs, "setToPairs");
      __name2(setToPairs, "setToPairs");
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length2 = array.length;
        while (++index < length2) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      __name(strictIndexOf, "strictIndexOf");
      __name2(strictIndexOf, "strictIndexOf");
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      __name(strictLastIndexOf, "strictLastIndexOf");
      __name2(strictLastIndexOf, "strictLastIndexOf");
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      __name(stringSize, "stringSize");
      __name2(stringSize, "stringSize");
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      __name(stringToArray, "stringToArray");
      __name2(stringToArray, "stringToArray");
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      __name(trimmedEndIndex, "trimmedEndIndex");
      __name2(trimmedEndIndex, "trimmedEndIndex");
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      __name(unicodeSize, "unicodeSize");
      __name2(unicodeSize, "unicodeSize");
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      __name(unicodeToArray, "unicodeToArray");
      __name2(unicodeToArray, "unicodeToArray");
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      __name(unicodeWords, "unicodeWords");
      __name2(unicodeWords, "unicodeWords");
      var runInContext = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function runInContext2(context2) {
        context2 = context2 == null ? root : _2.defaults(root.Object(), context2, _2.pick(root, contextProps));
        var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context2["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer3 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        __name(lodash, "lodash");
        __name2(lodash, "lodash");
        var baseCreate = function() {
          function object() {
          }
          __name(object, "object");
          __name2(object, "object");
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        __name(baseLodash, "baseLodash");
        __name2(baseLodash, "baseLodash");
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        __name(LodashWrapper, "LodashWrapper");
        __name2(LodashWrapper, "LodashWrapper");
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        __name(LazyWrapper, "LazyWrapper");
        __name2(LazyWrapper, "LazyWrapper");
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        __name(lazyClone, "lazyClone");
        __name2(lazyClone, "lazyClone");
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        __name(lazyReverse, "lazyReverse");
        __name2(lazyReverse, "lazyReverse");
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length2-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        __name(lazyValue, "lazyValue");
        __name2(lazyValue, "lazyValue");
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(Hash, "Hash");
        __name2(Hash, "Hash");
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        __name(hashClear, "hashClear");
        __name2(hashClear, "hashClear");
        function hashDelete(key22) {
          var result2 = this.has(key22) && delete this.__data__[key22];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        __name(hashDelete, "hashDelete");
        __name2(hashDelete, "hashDelete");
        function hashGet(key22) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key22];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key22) ? data[key22] : undefined2;
        }
        __name(hashGet, "hashGet");
        __name2(hashGet, "hashGet");
        function hashHas(key22) {
          var data = this.__data__;
          return nativeCreate ? data[key22] !== undefined2 : hasOwnProperty2.call(data, key22);
        }
        __name(hashHas, "hashHas");
        __name2(hashHas, "hashHas");
        function hashSet(key22, value) {
          var data = this.__data__;
          this.size += this.has(key22) ? 0 : 1;
          data[key22] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        __name(hashSet, "hashSet");
        __name2(hashSet, "hashSet");
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(ListCache, "ListCache");
        __name2(ListCache, "ListCache");
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        __name(listCacheClear, "listCacheClear");
        __name2(listCacheClear, "listCacheClear");
        function listCacheDelete(key22) {
          var data = this.__data__, index = assocIndexOf(data, key22);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        __name(listCacheDelete, "listCacheDelete");
        __name2(listCacheDelete, "listCacheDelete");
        function listCacheGet(key22) {
          var data = this.__data__, index = assocIndexOf(data, key22);
          return index < 0 ? undefined2 : data[index][1];
        }
        __name(listCacheGet, "listCacheGet");
        __name2(listCacheGet, "listCacheGet");
        function listCacheHas(key22) {
          return assocIndexOf(this.__data__, key22) > -1;
        }
        __name(listCacheHas, "listCacheHas");
        __name2(listCacheHas, "listCacheHas");
        function listCacheSet(key22, value) {
          var data = this.__data__, index = assocIndexOf(data, key22);
          if (index < 0) {
            ++this.size;
            data.push([key22, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        __name(listCacheSet, "listCacheSet");
        __name2(listCacheSet, "listCacheSet");
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(MapCache, "MapCache");
        __name2(MapCache, "MapCache");
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        __name(mapCacheClear, "mapCacheClear");
        __name2(mapCacheClear, "mapCacheClear");
        function mapCacheDelete(key22) {
          var result2 = getMapData(this, key22)["delete"](key22);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        __name(mapCacheDelete, "mapCacheDelete");
        __name2(mapCacheDelete, "mapCacheDelete");
        function mapCacheGet(key22) {
          return getMapData(this, key22).get(key22);
        }
        __name(mapCacheGet, "mapCacheGet");
        __name2(mapCacheGet, "mapCacheGet");
        function mapCacheHas(key22) {
          return getMapData(this, key22).has(key22);
        }
        __name(mapCacheHas, "mapCacheHas");
        __name2(mapCacheHas, "mapCacheHas");
        function mapCacheSet(key22, value) {
          var data = getMapData(this, key22), size2 = data.size;
          data.set(key22, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        __name(mapCacheSet, "mapCacheSet");
        __name2(mapCacheSet, "mapCacheSet");
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length2 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length2) {
            this.add(values2[index]);
          }
        }
        __name(SetCache, "SetCache");
        __name2(SetCache, "SetCache");
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        __name(setCacheAdd, "setCacheAdd");
        __name2(setCacheAdd, "setCacheAdd");
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        __name(setCacheHas, "setCacheHas");
        __name2(setCacheHas, "setCacheHas");
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        __name(Stack, "Stack");
        __name2(Stack, "Stack");
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        __name(stackClear, "stackClear");
        __name2(stackClear, "stackClear");
        function stackDelete(key22) {
          var data = this.__data__, result2 = data["delete"](key22);
          this.size = data.size;
          return result2;
        }
        __name(stackDelete, "stackDelete");
        __name2(stackDelete, "stackDelete");
        function stackGet(key22) {
          return this.__data__.get(key22);
        }
        __name(stackGet, "stackGet");
        __name2(stackGet, "stackGet");
        function stackHas(key22) {
          return this.__data__.has(key22);
        }
        __name(stackHas, "stackHas");
        __name2(stackHas, "stackHas");
        function stackSet(key22, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key22, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key22, value);
          this.size = data.size;
          return this;
        }
        __name(stackSet, "stackSet");
        __name2(stackSet, "stackSet");
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
          for (var key22 in value) {
            if ((inherited || hasOwnProperty2.call(value, key22)) && !(skipIndexes && (key22 == "length" || isBuff && (key22 == "offset" || key22 == "parent") || isType && (key22 == "buffer" || key22 == "byteLength" || key22 == "byteOffset") || isIndex(key22, length2)))) {
              result2.push(key22);
            }
          }
          return result2;
        }
        __name(arrayLikeKeys, "arrayLikeKeys");
        __name2(arrayLikeKeys, "arrayLikeKeys");
        function arraySample(array) {
          var length2 = array.length;
          return length2 ? array[baseRandom(0, length2 - 1)] : undefined2;
        }
        __name(arraySample, "arraySample");
        __name2(arraySample, "arraySample");
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        __name(arraySampleSize, "arraySampleSize");
        __name2(arraySampleSize, "arraySampleSize");
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        __name(arrayShuffle, "arrayShuffle");
        __name2(arrayShuffle, "arrayShuffle");
        function assignMergeValue(object, key22, value) {
          if (value !== undefined2 && !eq42(object[key22], value) || value === undefined2 && !(key22 in object)) {
            baseAssignValue(object, key22, value);
          }
        }
        __name(assignMergeValue, "assignMergeValue");
        __name2(assignMergeValue, "assignMergeValue");
        function assignValue(object, key22, value) {
          var objValue = object[key22];
          if (!(hasOwnProperty2.call(object, key22) && eq42(objValue, value)) || value === undefined2 && !(key22 in object)) {
            baseAssignValue(object, key22, value);
          }
        }
        __name(assignValue, "assignValue");
        __name2(assignValue, "assignValue");
        function assocIndexOf(array, key22) {
          var length2 = array.length;
          while (length2--) {
            if (eq42(array[length2][0], key22)) {
              return length2;
            }
          }
          return -1;
        }
        __name(assocIndexOf, "assocIndexOf");
        __name2(assocIndexOf, "assocIndexOf");
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key22, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        __name(baseAggregator, "baseAggregator");
        __name2(baseAggregator, "baseAggregator");
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        __name(baseAssign, "baseAssign");
        __name2(baseAssign, "baseAssign");
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        __name(baseAssignIn, "baseAssignIn");
        __name2(baseAssignIn, "baseAssignIn");
        function baseAssignValue(object, key22, value) {
          if (key22 == "__proto__" && defineProperty) {
            defineProperty(object, key22, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key22] = value;
          }
        }
        __name(baseAssignValue, "baseAssignValue");
        __name2(baseAssignValue, "baseAssignValue");
        function baseAt(object, paths) {
          var index = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
          while (++index < length2) {
            result2[index] = skip ? undefined2 : get2(object, paths[index]);
          }
          return result2;
        }
        __name(baseAt, "baseAt");
        __name2(baseAt, "baseAt");
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        __name(baseClamp, "baseClamp");
        __name2(baseClamp, "baseClamp");
        function baseClone(value, bitmask, customizer, key22, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key22, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer3(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key3) {
              result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key3) {
            if (props) {
              key3 = subValue;
              subValue = value[key3];
            }
            assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
          });
          return result2;
        }
        __name(baseClone, "baseClone");
        __name2(baseClone, "baseClone");
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        __name(baseConforms, "baseConforms");
        __name2(baseConforms, "baseConforms");
        function baseConformsTo(object, source, props) {
          var length2 = props.length;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (length2--) {
            var key22 = props[length2], predicate = source[key22], value = object[key22];
            if (value === undefined2 && !(key22 in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        __name(baseConformsTo, "baseConformsTo");
        __name2(baseConformsTo, "baseConformsTo");
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        __name(baseDelay, "baseDelay");
        __name2(baseDelay, "baseDelay");
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values2.length;
          if (!length2) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length2) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseDifference, "baseDifference");
        __name2(baseDifference, "baseDifference");
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        __name(baseEvery, "baseEvery");
        __name2(baseEvery, "baseEvery");
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length2 = array.length;
          while (++index < length2) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        __name(baseExtremum, "baseExtremum");
        __name2(baseExtremum, "baseExtremum");
        function baseFill(array, value, start, end) {
          var length2 = array.length;
          start = toInteger2(start);
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end === undefined2 || end > length2 ? length2 : toInteger2(end);
          if (end < 0) {
            end += length2;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        __name(baseFill, "baseFill");
        __name2(baseFill, "baseFill");
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        __name(baseFilter, "baseFilter");
        __name2(baseFilter, "baseFilter");
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length2 = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length2) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        __name(baseFlatten, "baseFlatten");
        __name2(baseFlatten, "baseFlatten");
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        __name(baseForOwn, "baseForOwn");
        __name2(baseForOwn, "baseForOwn");
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        __name(baseForOwnRight, "baseForOwnRight");
        __name2(baseForOwnRight, "baseForOwnRight");
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key22) {
            return isFunction2(object[key22]);
          });
        }
        __name(baseFunctions, "baseFunctions");
        __name2(baseFunctions, "baseFunctions");
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length2 = path.length;
          while (object != null && index < length2) {
            object = object[toKey(path[index++])];
          }
          return index && index == length2 ? object : undefined2;
        }
        __name(baseGet, "baseGet");
        __name2(baseGet, "baseGet");
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        __name(baseGetAllKeys, "baseGetAllKeys");
        __name2(baseGetAllKeys, "baseGetAllKeys");
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        __name(baseGetTag, "baseGetTag");
        __name2(baseGetTag, "baseGetTag");
        function baseGt(value, other) {
          return value > other;
        }
        __name(baseGt, "baseGt");
        __name2(baseGt, "baseGt");
        function baseHas(object, key22) {
          return object != null && hasOwnProperty2.call(object, key22);
        }
        __name(baseHas, "baseHas");
        __name2(baseHas, "baseHas");
        function baseHasIn(object, key22) {
          return object != null && key22 in Object2(object);
        }
        __name(baseHasIn, "baseHasIn");
        __name2(baseHasIn, "baseHasIn");
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        __name(baseInRange, "baseInRange");
        __name2(baseInRange, "baseInRange");
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length2 && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseIntersection, "baseIntersection");
        __name2(baseIntersection, "baseIntersection");
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key22, object2) {
            setter(accumulator, iteratee2(value), key22, object2);
          });
          return accumulator;
        }
        __name(baseInverter, "baseInverter");
        __name2(baseInverter, "baseInverter");
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last2(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        __name(baseInvoke, "baseInvoke");
        __name2(baseInvoke, "baseInvoke");
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        __name(baseIsArguments, "baseIsArguments");
        __name2(baseIsArguments, "baseIsArguments");
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        __name(baseIsArrayBuffer, "baseIsArrayBuffer");
        __name2(baseIsArrayBuffer, "baseIsArrayBuffer");
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        __name(baseIsDate, "baseIsDate");
        __name2(baseIsDate, "baseIsDate");
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        __name(baseIsEqual, "baseIsEqual");
        __name2(baseIsEqual, "baseIsEqual");
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer3(object)) {
            if (!isBuffer3(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        __name(baseIsEqualDeep, "baseIsEqualDeep");
        __name2(baseIsEqualDeep, "baseIsEqualDeep");
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        __name(baseIsMap, "baseIsMap");
        __name2(baseIsMap, "baseIsMap");
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length2 = index, noCustomizer = !customizer;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length2) {
            data = matchData[index];
            var key22 = data[0], objValue = object[key22], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key22 in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key22, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        __name(baseIsMatch, "baseIsMatch");
        __name2(baseIsMatch, "baseIsMatch");
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        __name(baseIsNative, "baseIsNative");
        __name2(baseIsNative, "baseIsNative");
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        __name(baseIsRegExp, "baseIsRegExp");
        __name2(baseIsRegExp, "baseIsRegExp");
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        __name(baseIsSet, "baseIsSet");
        __name2(baseIsSet, "baseIsSet");
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        __name(baseIsTypedArray, "baseIsTypedArray");
        __name2(baseIsTypedArray, "baseIsTypedArray");
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity4;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        __name(baseIteratee, "baseIteratee");
        __name2(baseIteratee, "baseIteratee");
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key22 in Object2(object)) {
            if (hasOwnProperty2.call(object, key22) && key22 != "constructor") {
              result2.push(key22);
            }
          }
          return result2;
        }
        __name(baseKeys, "baseKeys");
        __name2(baseKeys, "baseKeys");
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key22 in object) {
            if (!(key22 == "constructor" && (isProto || !hasOwnProperty2.call(object, key22)))) {
              result2.push(key22);
            }
          }
          return result2;
        }
        __name(baseKeysIn, "baseKeysIn");
        __name2(baseKeysIn, "baseKeysIn");
        function baseLt(value, other) {
          return value < other;
        }
        __name(baseLt, "baseLt");
        __name2(baseLt, "baseLt");
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key22, collection2) {
            result2[++index] = iteratee2(value, key22, collection2);
          });
          return result2;
        }
        __name(baseMap, "baseMap");
        __name2(baseMap, "baseMap");
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        __name(baseMatches, "baseMatches");
        __name2(baseMatches, "baseMatches");
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get2(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        __name(baseMatchesProperty, "baseMatchesProperty");
        __name2(baseMatchesProperty, "baseMatchesProperty");
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key22) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key22, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key22), srcValue, key22 + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key22, newValue);
            }
          }, keysIn);
        }
        __name(baseMerge, "baseMerge");
        __name2(baseMerge, "baseMerge");
        function baseMergeDeep(object, source, key22, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key22), srcValue = safeGet(source, key22), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key22, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key22 + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key22, newValue);
        }
        __name(baseMergeDeep, "baseMergeDeep");
        __name2(baseMergeDeep, "baseMergeDeep");
        function baseNth(array, n) {
          var length2 = array.length;
          if (!length2) {
            return;
          }
          n += n < 0 ? length2 : 0;
          return isIndex(n, length2) ? array[n] : undefined2;
        }
        __name(baseNth, "baseNth");
        __name2(baseNth, "baseNth");
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity4];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key22, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        __name(baseOrderBy, "baseOrderBy");
        __name2(baseOrderBy, "baseOrderBy");
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        __name(basePick, "basePick");
        __name2(basePick, "basePick");
        function basePickBy(object, paths, predicate) {
          var index = -1, length2 = paths.length, result2 = {};
          while (++index < length2) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        __name(basePickBy, "basePickBy");
        __name2(basePickBy, "basePickBy");
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        __name(basePropertyDeep, "basePropertyDeep");
        __name2(basePropertyDeep, "basePropertyDeep");
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length2 = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length2) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        __name(basePullAll, "basePullAll");
        __name2(basePullAll, "basePullAll");
        function basePullAt(array, indexes) {
          var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
          while (length2--) {
            var index = indexes[length2];
            if (length2 == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        __name(basePullAt, "basePullAt");
        __name2(basePullAt, "basePullAt");
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        __name(baseRandom, "baseRandom");
        __name2(baseRandom, "baseRandom");
        function baseRange(start, end, step, fromRight) {
          var index = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
          while (length2--) {
            result2[fromRight ? length2 : ++index] = start;
            start += step;
          }
          return result2;
        }
        __name(baseRange, "baseRange");
        __name2(baseRange, "baseRange");
        function baseRepeat(string2, n) {
          var result2 = "";
          if (!string2 || n < 1 || n > MAX_SAFE_INTEGER22) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string2;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string2 += string2;
            }
          } while (n);
          return result2;
        }
        __name(baseRepeat, "baseRepeat");
        __name2(baseRepeat, "baseRepeat");
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity4), func + "");
        }
        __name(baseRest, "baseRest");
        __name2(baseRest, "baseRest");
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        __name(baseSample, "baseSample");
        __name2(baseSample, "baseSample");
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        __name(baseSampleSize, "baseSampleSize");
        __name2(baseSampleSize, "baseSampleSize");
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
          while (nested != null && ++index < length2) {
            var key22 = toKey(path[index]), newValue = value;
            if (key22 === "__proto__" || key22 === "constructor" || key22 === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key22];
              newValue = customizer ? customizer(objValue, key22, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key22, newValue);
            nested = nested[key22];
          }
          return object;
        }
        __name(baseSet, "baseSet");
        __name2(baseSet, "baseSet");
        var baseSetData = !metaMap ? identity4 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity4 : function(func, string2) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        __name(baseShuffle, "baseShuffle");
        __name2(baseShuffle, "baseShuffle");
        function baseSlice(array, start, end) {
          var index = -1, length2 = array.length;
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end > length2 ? length2 : end;
          if (end < 0) {
            end += length2;
          }
          length2 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length2);
          while (++index < length2) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        __name(baseSlice, "baseSlice");
        __name2(baseSlice, "baseSlice");
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        __name(baseSome, "baseSome");
        __name2(baseSome, "baseSome");
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity4, retHighest);
        }
        __name(baseSortedIndex, "baseSortedIndex");
        __name2(baseSortedIndex, "baseSortedIndex");
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        __name(baseSortedIndexBy, "baseSortedIndexBy");
        __name2(baseSortedIndexBy, "baseSortedIndexBy");
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length2 = array.length, resIndex = 0, result2 = [];
          while (++index < length2) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq42(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        __name(baseSortedUniq, "baseSortedUniq");
        __name2(baseSortedUniq, "baseSortedUniq");
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        __name(baseToNumber, "baseToNumber");
        __name2(baseToNumber, "baseToNumber");
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        __name(baseToString, "baseToString");
        __name2(baseToString, "baseToString");
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length2 >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length2) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseUniq, "baseUniq");
        __name2(baseUniq, "baseUniq");
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last2(path))];
        }
        __name(baseUnset, "baseUnset");
        __name2(baseUnset, "baseUnset");
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        __name(baseUpdate, "baseUpdate");
        __name2(baseUpdate, "baseUpdate");
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length2 = array.length, index = fromRight ? length2 : -1;
          while ((fromRight ? index-- : ++index < length2) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length2) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length2 : index);
        }
        __name(baseWhile, "baseWhile");
        __name2(baseWhile, "baseWhile");
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        __name(baseWrapperValue, "baseWrapperValue");
        __name2(baseWrapperValue, "baseWrapperValue");
        function baseXor(arrays, iteratee2, comparator) {
          var length2 = arrays.length;
          if (length2 < 2) {
            return length2 ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length2);
          while (++index < length2) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length2) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        __name(baseXor, "baseXor");
        __name2(baseXor, "baseXor");
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length2 = props.length, valsLength = values2.length, result2 = {};
          while (++index < length2) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        __name(baseZipObject, "baseZipObject");
        __name2(baseZipObject, "baseZipObject");
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        __name(castArrayLikeObject, "castArrayLikeObject");
        __name2(castArrayLikeObject, "castArrayLikeObject");
        function castFunction(value) {
          return typeof value == "function" ? value : identity4;
        }
        __name(castFunction, "castFunction");
        __name2(castFunction, "castFunction");
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString6(value));
        }
        __name(castPath, "castPath");
        __name2(castPath, "castPath");
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length2 = array.length;
          end = end === undefined2 ? length2 : end;
          return !start && end >= length2 ? array : baseSlice(array, start, end);
        }
        __name(castSlice, "castSlice");
        __name2(castSlice, "castSlice");
        var clearTimeout2 = ctxClearTimeout || function(id2) {
          return root.clearTimeout(id2);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length2 = buffer2.length, result2 = allocUnsafe2 ? allocUnsafe2(length2) : new buffer2.constructor(length2);
          buffer2.copy(result2);
          return result2;
        }
        __name(cloneBuffer, "cloneBuffer");
        __name2(cloneBuffer, "cloneBuffer");
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        __name(cloneArrayBuffer, "cloneArrayBuffer");
        __name2(cloneArrayBuffer, "cloneArrayBuffer");
        function cloneDataView(dataView2, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView2.buffer) : dataView2.buffer;
          return new dataView2.constructor(buffer2, dataView2.byteOffset, dataView2.byteLength);
        }
        __name(cloneDataView, "cloneDataView");
        __name2(cloneDataView, "cloneDataView");
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        __name(cloneRegExp, "cloneRegExp");
        __name2(cloneRegExp, "cloneRegExp");
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        __name(cloneSymbol, "cloneSymbol");
        __name2(cloneSymbol, "cloneSymbol");
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        __name(cloneTypedArray, "cloneTypedArray");
        __name2(cloneTypedArray, "cloneTypedArray");
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        __name(compareAscending, "compareAscending");
        __name2(compareAscending, "compareAscending");
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
          while (++index < length2) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        __name(compareMultiple, "compareMultiple");
        __name2(compareMultiple, "compareMultiple");
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        __name(composeArgs, "composeArgs");
        __name2(composeArgs, "composeArgs");
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        __name(composeArgsRight, "composeArgsRight");
        __name2(composeArgsRight, "composeArgsRight");
        function copyArray(source, array) {
          var index = -1, length2 = source.length;
          array || (array = Array2(length2));
          while (++index < length2) {
            array[index] = source[index];
          }
          return array;
        }
        __name(copyArray, "copyArray");
        __name2(copyArray, "copyArray");
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length2 = props.length;
          while (++index < length2) {
            var key22 = props[index];
            var newValue = customizer ? customizer(object[key22], source[key22], key22, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key22];
            }
            if (isNew) {
              baseAssignValue(object, key22, newValue);
            } else {
              assignValue(object, key22, newValue);
            }
          }
          return object;
        }
        __name(copyObject, "copyObject");
        __name2(copyObject, "copyObject");
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        __name(copySymbols, "copySymbols");
        __name2(copySymbols, "copySymbols");
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        __name(copySymbolsIn, "copySymbolsIn");
        __name2(copySymbolsIn, "copySymbolsIn");
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        __name(createAggregator, "createAggregator");
        __name2(createAggregator, "createAggregator");
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined2, guard = length2 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined2 : customizer;
              length2 = 1;
            }
            object = Object2(object);
            while (++index < length2) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        __name(createAssigner, "createAssigner");
        __name2(createAssigner, "createAssigner");
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length2) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        __name(createBaseEach, "createBaseEach");
        __name2(createBaseEach, "createBaseEach");
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
            while (length2--) {
              var key22 = props[fromRight ? length2 : ++index];
              if (iteratee2(iterable[key22], key22, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        __name(createBaseFor, "createBaseFor");
        __name2(createBaseFor, "createBaseFor");
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          __name(wrapper, "wrapper");
          __name2(wrapper, "wrapper");
          return wrapper;
        }
        __name(createBind, "createBind");
        __name2(createBind, "createBind");
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString6(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        __name(createCaseFirst, "createCaseFirst");
        __name2(createCaseFirst, "createCaseFirst");
        function createCompounder(callback) {
          return function(string2) {
            return arrayReduce(words2(deburr(string2).replace(reApos, "")), callback, "");
          };
        }
        __name(createCompounder, "createCompounder");
        __name2(createCompounder, "createCompounder");
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        __name(createCtor, "createCtor");
        __name2(createCtor, "createCtor");
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index = length2, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length2 -= holders.length;
            if (length2 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length2
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          __name(wrapper, "wrapper");
          __name2(wrapper, "wrapper");
          return wrapper;
        }
        __name(createCurry, "createCurry");
        __name2(createCurry, "createCurry");
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = /* @__PURE__ */ __name2(function(key22) {
                return iteratee2(iterable[key22], key22, iterable);
              }, "predicate");
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        __name(createFind, "createFind");
        __name2(createFind, "createFind");
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length2 = funcs.length, index = length2, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length2;
            while (++index < length2) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData2(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length2 ? funcs[index2].apply(this, args) : value;
              while (++index2 < length2) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        __name(createFlow, "createFlow");
        __name2(createFlow, "createFlow");
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index = length2;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length2 -= holdersCount;
            if (isCurried && length2 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length2
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length2 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length2 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length2) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          __name(wrapper, "wrapper");
          __name2(wrapper, "wrapper");
          return wrapper;
        }
        __name(createHybrid, "createHybrid");
        __name2(createHybrid, "createHybrid");
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        __name(createInverter, "createInverter");
        __name2(createInverter, "createInverter");
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        __name(createMathOperation, "createMathOperation");
        __name2(createMathOperation, "createMathOperation");
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        __name(createOver, "createOver");
        __name2(createOver, "createOver");
        function createPadding(length2, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length2) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
        }
        __name(createPadding, "createPadding");
        __name2(createPadding, "createPadding");
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          __name(wrapper, "wrapper");
          __name2(wrapper, "wrapper");
          return wrapper;
        }
        __name(createPartial, "createPartial");
        __name2(createPartial, "createPartial");
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        __name(createRange, "createRange");
        __name2(createRange, "createRange");
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        __name(createRelationalOperation, "createRelationalOperation");
        __name2(createRelationalOperation, "createRelationalOperation");
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        __name(createRecurry, "createRecurry");
        __name2(createRecurry, "createRecurry");
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString6(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString6(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        __name(createRound, "createRound");
        __name2(createRound, "createRound");
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        __name(createToPairs, "createToPairs");
        __name2(createToPairs, "createToPairs");
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length2 = partials ? partials.length : 0;
          if (!length2) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger2(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger2(arity);
          length2 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData2(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        __name(createWrap, "createWrap");
        __name2(createWrap, "createWrap");
        function customDefaultsAssignIn(objValue, srcValue, key22, object) {
          if (objValue === undefined2 || eq42(objValue, objectProto[key22]) && !hasOwnProperty2.call(object, key22)) {
            return srcValue;
          }
          return objValue;
        }
        __name(customDefaultsAssignIn, "customDefaultsAssignIn");
        __name2(customDefaultsAssignIn, "customDefaultsAssignIn");
        function customDefaultsMerge(objValue, srcValue, key22, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        __name(customDefaultsMerge, "customDefaultsMerge");
        __name2(customDefaultsMerge, "customDefaultsMerge");
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        __name(customOmitClone, "customOmitClone");
        __name2(customOmitClone, "customOmitClone");
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        __name(equalArrays, "equalArrays");
        __name2(equalArrays, "equalArrays");
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq42(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        __name(equalByTag, "equalByTag");
        __name2(equalByTag, "equalByTag");
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key22 = objProps[index];
            if (!(isPartial ? key22 in other : hasOwnProperty2.call(other, key22))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key22 = objProps[index];
            var objValue = object[key22], othValue = other[key22];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key22, other, object, stack) : customizer(objValue, othValue, key22, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key22 == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        __name(equalObjects, "equalObjects");
        __name2(equalObjects, "equalObjects");
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten2), func + "");
        }
        __name(flatRest, "flatRest");
        __name2(flatRest, "flatRest");
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        __name(getAllKeys, "getAllKeys");
        __name2(getAllKeys, "getAllKeys");
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        __name(getAllKeysIn, "getAllKeysIn");
        __name2(getAllKeysIn, "getAllKeysIn");
        var getData2 = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length2--) {
            var data = array[length2], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        __name(getFuncName, "getFuncName");
        __name2(getFuncName, "getFuncName");
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        __name(getHolder, "getHolder");
        __name2(getHolder, "getHolder");
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        __name(getIteratee, "getIteratee");
        __name2(getIteratee, "getIteratee");
        function getMapData(map3, key22) {
          var data = map3.__data__;
          return isKeyable(key22) ? data[typeof key22 == "string" ? "string" : "hash"] : data.map;
        }
        __name(getMapData, "getMapData");
        __name2(getMapData, "getMapData");
        function getMatchData(object) {
          var result2 = keys(object), length2 = result2.length;
          while (length2--) {
            var key22 = result2[length2], value = object[key22];
            result2[length2] = [key22, value, isStrictComparable(value)];
          }
          return result2;
        }
        __name(getMatchData, "getMatchData");
        __name2(getMatchData, "getMatchData");
        function getNative(object, key22) {
          var value = getValue(object, key22);
          return baseIsNative(value) ? value : undefined2;
        }
        __name(getNative, "getNative");
        __name2(getNative, "getNative");
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        __name(getRawTag, "getRawTag");
        __name2(getRawTag, "getRawTag");
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = /* @__PURE__ */ __name2(function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          }, "getTag");
        }
        function getView(start, end, transforms) {
          var index = -1, length2 = transforms.length;
          while (++index < length2) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        __name(getView, "getView");
        __name2(getView, "getView");
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        __name(getWrapDetails, "getWrapDetails");
        __name2(getWrapDetails, "getWrapDetails");
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length2 = path.length, result2 = false;
          while (++index < length2) {
            var key22 = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key22))) {
              break;
            }
            object = object[key22];
          }
          if (result2 || ++index != length2) {
            return result2;
          }
          length2 = object == null ? 0 : object.length;
          return !!length2 && isLength(length2) && isIndex(key22, length2) && (isArray2(object) || isArguments(object));
        }
        __name(hasPath, "hasPath");
        __name2(hasPath, "hasPath");
        function initCloneArray(array) {
          var length2 = array.length, result2 = new array.constructor(length2);
          if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        __name(initCloneArray, "initCloneArray");
        __name2(initCloneArray, "initCloneArray");
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        __name(initCloneObject, "initCloneObject");
        __name2(initCloneObject, "initCloneObject");
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        __name(initCloneByTag, "initCloneByTag");
        __name2(initCloneByTag, "initCloneByTag");
        function insertWrapDetails(source, details) {
          var length2 = details.length;
          if (!length2) {
            return source;
          }
          var lastIndex = length2 - 1;
          details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length2 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        __name(insertWrapDetails, "insertWrapDetails");
        __name2(insertWrapDetails, "insertWrapDetails");
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        __name(isFlattenable, "isFlattenable");
        __name2(isFlattenable, "isFlattenable");
        function isIndex(value, length2) {
          var type = typeof value;
          length2 = length2 == null ? MAX_SAFE_INTEGER22 : length2;
          return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        __name(isIndex, "isIndex");
        __name2(isIndex, "isIndex");
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq42(object[index], value);
          }
          return false;
        }
        __name(isIterateeCall, "isIterateeCall");
        __name2(isIterateeCall, "isIterateeCall");
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        __name(isKey, "isKey");
        __name2(isKey, "isKey");
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        __name(isKeyable, "isKeyable");
        __name2(isKeyable, "isKeyable");
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData2(other);
          return !!data && func === data[0];
        }
        __name(isLaziable, "isLaziable");
        __name2(isLaziable, "isLaziable");
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        __name(isMasked, "isMasked");
        __name2(isMasked, "isMasked");
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        __name(isPrototype, "isPrototype");
        __name2(isPrototype, "isPrototype");
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        __name(isStrictComparable, "isStrictComparable");
        __name2(isStrictComparable, "isStrictComparable");
        function matchesStrictComparable(key22, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key22] === srcValue && (srcValue !== undefined2 || key22 in Object2(object));
          };
        }
        __name(matchesStrictComparable, "matchesStrictComparable");
        __name2(matchesStrictComparable, "matchesStrictComparable");
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key22) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key22;
          });
          var cache = result2.cache;
          return result2;
        }
        __name(memoizeCapped, "memoizeCapped");
        __name2(memoizeCapped, "memoizeCapped");
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        __name(mergeData, "mergeData");
        __name2(mergeData, "mergeData");
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key22 in Object2(object)) {
              result2.push(key22);
            }
          }
          return result2;
        }
        __name(nativeKeysIn, "nativeKeysIn");
        __name2(nativeKeysIn, "nativeKeysIn");
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        __name(objectToString, "objectToString");
        __name2(objectToString, "objectToString");
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length2 = nativeMax(args.length - start, 0), array = Array2(length2);
            while (++index < length2) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        __name(overRest, "overRest");
        __name2(overRest, "overRest");
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        __name(parent, "parent");
        __name2(parent, "parent");
        function reorder(array, indexes) {
          var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length2--) {
            var index = indexes[length2];
            array[length2] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        __name(reorder, "reorder");
        __name2(reorder, "reorder");
        function safeGet(object, key22) {
          if (key22 === "constructor" && typeof object[key22] === "function") {
            return;
          }
          if (key22 == "__proto__") {
            return;
          }
          return object[key22];
        }
        __name(safeGet, "safeGet");
        __name2(safeGet, "safeGet");
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        __name(setWrapToString, "setWrapToString");
        __name2(setWrapToString, "setWrapToString");
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        __name(shortOut, "shortOut");
        __name2(shortOut, "shortOut");
        function shuffleSelf(array, size2) {
          var index = -1, length2 = array.length, lastIndex = length2 - 1;
          size2 = size2 === undefined2 ? length2 : size2;
          while (++index < size2) {
            var rand22 = baseRandom(index, lastIndex), value = array[rand22];
            array[rand22] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        __name(shuffleSelf, "shuffleSelf");
        __name2(shuffleSelf, "shuffleSelf");
        var stringToPath = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match2, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        __name(toKey, "toKey");
        __name2(toKey, "toKey");
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        __name(toSource, "toSource");
        __name2(toSource, "toSource");
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        __name(updateWrapDetails, "updateWrapDetails");
        __name2(updateWrapDetails, "updateWrapDetails");
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        __name(wrapperClone, "wrapperClone");
        __name2(wrapperClone, "wrapperClone");
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger2(size2), 0);
          }
          var length2 = array == null ? 0 : array.length;
          if (!length2 || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
          while (index < length2) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        __name(chunk, "chunk");
        __name2(chunk, "chunk");
        function compact(array) {
          var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length2) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        __name(compact, "compact");
        __name2(compact, "compact");
        function concat4() {
          var length2 = arguments.length;
          if (!length2) {
            return [];
          }
          var args = Array2(length2 - 1), array = arguments[0], index = length2;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        __name(concat4, "concat4");
        __name2(concat4, "concat");
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last2(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last2(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          return baseSlice(array, n < 0 ? 0 : n, length2);
        }
        __name(drop, "drop");
        __name2(drop, "drop");
        function dropRight(array, n, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          n = length2 - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        __name(dropRight, "dropRight");
        __name2(dropRight, "dropRight");
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        __name(dropRightWhile, "dropRightWhile");
        __name2(dropRightWhile, "dropRightWhile");
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        __name(dropWhile, "dropWhile");
        __name2(dropWhile, "dropWhile");
        function fill(array, value, start, end) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length2;
          }
          return baseFill(array, value, start, end);
        }
        __name(fill, "fill");
        __name2(fill, "fill");
        function findIndex2(array, predicate, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index < 0) {
            index = nativeMax(length2 + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        __name(findIndex2, "findIndex2");
        __name2(findIndex2, "findIndex");
        function findLastIndex(array, predicate, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = length2 - 1;
          if (fromIndex !== undefined2) {
            index = toInteger2(fromIndex);
            index = fromIndex < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        __name(findLastIndex, "findLastIndex");
        __name2(findLastIndex, "findLastIndex");
        function flatten2(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseFlatten(array, 1) : [];
        }
        __name(flatten2, "flatten");
        __name2(flatten2, "flatten");
        function flattenDeep(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseFlatten(array, INFINITY) : [];
        }
        __name(flattenDeep, "flattenDeep");
        __name2(flattenDeep, "flattenDeep");
        function flattenDepth(array, depth) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger2(depth);
          return baseFlatten(array, depth);
        }
        __name(flattenDepth, "flattenDepth");
        __name2(flattenDepth, "flattenDepth");
        function fromPairs(pairs) {
          var index = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length2) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        __name(fromPairs, "fromPairs");
        __name2(fromPairs, "fromPairs");
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        __name(head, "head");
        __name2(head, "head");
        function indexOf(array, value, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index < 0) {
            index = nativeMax(length2 + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        __name(indexOf, "indexOf");
        __name2(indexOf, "indexOf");
        function initial(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSlice(array, 0, -1) : [];
        }
        __name(initial, "initial");
        __name2(initial, "initial");
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last2(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        __name(join, "join");
        __name2(join, "join");
        function last2(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? array[length2 - 1] : undefined2;
        }
        __name(last2, "last2");
        __name2(last2, "last");
        function lastIndexOf(array, value, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = length2;
          if (fromIndex !== undefined2) {
            index = toInteger2(fromIndex);
            index = index < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        __name(lastIndexOf, "lastIndexOf");
        __name2(lastIndexOf, "lastIndexOf");
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger2(n)) : undefined2;
        }
        __name(nth, "nth");
        __name2(nth, "nth");
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        __name(pullAll, "pullAll");
        __name2(pullAll, "pullAll");
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        __name(pullAllBy, "pullAllBy");
        __name2(pullAllBy, "pullAllBy");
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        __name(pullAllWith, "pullAllWith");
        __name2(pullAllWith, "pullAllWith");
        var pullAt = flatRest(function(array, indexes) {
          var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length2) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length2 = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length2) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        __name(remove, "remove");
        __name2(remove, "remove");
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        __name(reverse, "reverse");
        __name2(reverse, "reverse");
        function slice2(array, start, end) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length2;
          } else {
            start = start == null ? 0 : toInteger2(start);
            end = end === undefined2 ? length2 : toInteger2(end);
          }
          return baseSlice(array, start, end);
        }
        __name(slice2, "slice2");
        __name2(slice2, "slice");
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        __name(sortedIndex, "sortedIndex");
        __name2(sortedIndex, "sortedIndex");
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        __name(sortedIndexBy, "sortedIndexBy");
        __name2(sortedIndexBy, "sortedIndexBy");
        function sortedIndexOf(array, value) {
          var length2 = array == null ? 0 : array.length;
          if (length2) {
            var index = baseSortedIndex(array, value);
            if (index < length2 && eq42(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        __name(sortedIndexOf, "sortedIndexOf");
        __name2(sortedIndexOf, "sortedIndexOf");
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        __name(sortedLastIndex, "sortedLastIndex");
        __name2(sortedLastIndex, "sortedLastIndex");
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        __name(sortedLastIndexBy, "sortedLastIndexBy");
        __name2(sortedLastIndexBy, "sortedLastIndexBy");
        function sortedLastIndexOf(array, value) {
          var length2 = array == null ? 0 : array.length;
          if (length2) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq42(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        __name(sortedLastIndexOf, "sortedLastIndexOf");
        __name2(sortedLastIndexOf, "sortedLastIndexOf");
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        __name(sortedUniq, "sortedUniq");
        __name2(sortedUniq, "sortedUniq");
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        __name(sortedUniqBy, "sortedUniqBy");
        __name2(sortedUniqBy, "sortedUniqBy");
        function tail(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSlice(array, 1, length2) : [];
        }
        __name(tail, "tail");
        __name2(tail, "tail");
        function take2(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        __name(take2, "take2");
        __name2(take2, "take");
        function takeRight(array, n, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          n = length2 - n;
          return baseSlice(array, n < 0 ? 0 : n, length2);
        }
        __name(takeRight, "takeRight");
        __name2(takeRight, "takeRight");
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        __name(takeRightWhile, "takeRightWhile");
        __name2(takeRightWhile, "takeRightWhile");
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        __name(takeWhile, "takeWhile");
        __name2(takeWhile, "takeWhile");
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        __name(uniq, "uniq");
        __name2(uniq, "uniq");
        function uniqBy2(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        __name(uniqBy2, "uniqBy2");
        __name2(uniqBy2, "uniqBy");
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        __name(uniqWith, "uniqWith");
        __name2(uniqWith, "uniqWith");
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length2 = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length2 = nativeMax(group.length, length2);
              return true;
            }
          });
          return baseTimes(length2, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        __name(unzip, "unzip");
        __name2(unzip, "unzip");
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        __name(unzipWith, "unzipWith");
        __name2(unzipWith, "unzipWith");
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor2 = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        __name(zipObject, "zipObject");
        __name2(zipObject, "zipObject");
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        __name(zipObjectDeep, "zipObjectDeep");
        __name2(zipObjectDeep, "zipObjectDeep");
        var zipWith = baseRest(function(arrays) {
          var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        __name(chain, "chain");
        __name2(chain, "chain");
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        __name(tap, "tap");
        __name2(tap, "tap");
        function thru(value, interceptor) {
          return interceptor(value);
        }
        __name(thru, "thru");
        __name2(thru, "thru");
        var wrapperAt = flatRest(function(paths) {
          var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = /* @__PURE__ */ __name2(function(object) {
            return baseAt(object, paths);
          }, "interceptor");
          if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length2 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length2 && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        __name(wrapperChain, "wrapperChain");
        __name2(wrapperChain, "wrapperChain");
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        __name(wrapperCommit, "wrapperCommit");
        __name2(wrapperCommit, "wrapperCommit");
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        __name(wrapperNext, "wrapperNext");
        __name2(wrapperNext, "wrapperNext");
        function wrapperToIterator() {
          return this;
        }
        __name(wrapperToIterator, "wrapperToIterator");
        __name2(wrapperToIterator, "wrapperToIterator");
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        __name(wrapperPlant, "wrapperPlant");
        __name2(wrapperPlant, "wrapperPlant");
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        __name(wrapperReverse, "wrapperReverse");
        __name2(wrapperReverse, "wrapperReverse");
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        __name(wrapperValue, "wrapperValue");
        __name2(wrapperValue, "wrapperValue");
        var countBy = createAggregator(function(result2, value, key22) {
          if (hasOwnProperty2.call(result2, key22)) {
            ++result2[key22];
          } else {
            baseAssignValue(result2, key22, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        __name(every, "every");
        __name2(every, "every");
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        __name(filter2, "filter2");
        __name2(filter2, "filter");
        var find = createFind(findIndex2);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        __name(flatMap, "flatMap");
        __name2(flatMap, "flatMap");
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        __name(flatMapDeep, "flatMapDeep");
        __name2(flatMapDeep, "flatMapDeep");
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger2(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        __name(flatMapDepth, "flatMapDepth");
        __name2(flatMapDepth, "flatMapDepth");
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(forEach, "forEach");
        __name2(forEach, "forEach");
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(forEachRight, "forEachRight");
        __name2(forEachRight, "forEachRight");
        var groupBy = createAggregator(function(result2, value, key22) {
          if (hasOwnProperty2.call(result2, key22)) {
            result2[key22].push(value);
          } else {
            baseAssignValue(result2, key22, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
          var length2 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length2 + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        __name(includes, "includes");
        __name2(includes, "includes");
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key22) {
          baseAssignValue(result2, key22, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(map2, "map2");
        __name2(map2, "map");
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        __name(orderBy, "orderBy");
        __name2(orderBy, "orderBy");
        var partition = createAggregator(function(result2, value, key22) {
          result2[key22 ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        __name(reduce, "reduce");
        __name2(reduce, "reduce");
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        __name(reduceRight, "reduceRight");
        __name2(reduceRight, "reduceRight");
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        __name(reject, "reject");
        __name2(reject, "reject");
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        __name(sample, "sample");
        __name2(sample, "sample");
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        __name(sampleSize, "sampleSize");
        __name2(sampleSize, "sampleSize");
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        __name(shuffle, "shuffle");
        __name2(shuffle, "shuffle");
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        __name(size, "size");
        __name2(size, "size");
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        __name(some, "some");
        __name2(some, "some");
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length2 = iteratees.length;
          if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger2(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        __name(after, "after");
        __name2(after, "after");
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        __name(ary, "ary");
        __name2(ary, "ary");
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger2(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        __name(before, "before");
        __name2(before, "before");
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key22, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key22, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        __name(curry, "curry");
        __name2(curry, "curry");
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        __name(curryRight, "curryRight");
        __name2(curryRight, "curryRight");
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          __name(invokeFunc, "invokeFunc");
          __name2(invokeFunc, "invokeFunc");
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          __name(leadingEdge, "leadingEdge");
          __name2(leadingEdge, "leadingEdge");
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          __name(remainingWait, "remainingWait");
          __name2(remainingWait, "remainingWait");
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          __name(shouldInvoke, "shouldInvoke");
          __name2(shouldInvoke, "shouldInvoke");
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          __name(timerExpired, "timerExpired");
          __name2(timerExpired, "timerExpired");
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          __name(trailingEdge, "trailingEdge");
          __name2(trailingEdge, "trailingEdge");
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          __name(cancel, "cancel");
          __name2(cancel, "cancel");
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          __name(flush, "flush");
          __name2(flush, "flush");
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          __name(debounced, "debounced");
          __name2(debounced, "debounced");
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        __name(debounce, "debounce");
        __name2(debounce, "debounce");
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        __name(flip, "flip");
        __name2(flip, "flip");
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = /* @__PURE__ */ __name2(function() {
            var args = arguments, key22 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key22)) {
              return cache.get(key22);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key22, result2) || cache;
            return result2;
          }, "memoized");
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        __name(memoize, "memoize");
        __name2(memoize, "memoize");
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        __name(negate, "negate");
        __name2(negate, "negate");
        function once(func) {
          return before(2, func);
        }
        __name(once, "once");
        __name2(once, "once");
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length2 = nativeMin(args.length, funcsLength);
            while (++index < length2) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger2(start);
          return baseRest(func, start);
        }
        __name(rest, "rest");
        __name2(rest, "rest");
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger2(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        __name(spread, "spread");
        __name2(spread, "spread");
        function throttle2(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        __name(throttle2, "throttle2");
        __name2(throttle2, "throttle");
        function unary(func) {
          return ary(func, 1);
        }
        __name(unary, "unary");
        __name2(unary, "unary");
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        __name(wrap, "wrap");
        __name2(wrap, "wrap");
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        __name(castArray, "castArray");
        __name2(castArray, "castArray");
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        __name(clone, "clone");
        __name2(clone, "clone");
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        __name(cloneWith, "cloneWith");
        __name2(cloneWith, "cloneWith");
        function cloneDeep6(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        __name(cloneDeep6, "cloneDeep6");
        __name2(cloneDeep6, "cloneDeep");
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        __name(cloneDeepWith, "cloneDeepWith");
        __name2(cloneDeepWith, "cloneDeepWith");
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        __name(conformsTo, "conformsTo");
        __name2(conformsTo, "conformsTo");
        function eq42(value, other) {
          return value === other || value !== value && other !== other;
        }
        __name(eq42, "eq4");
        __name2(eq42, "eq");
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        __name(isArrayLike2, "isArrayLike2");
        __name2(isArrayLike2, "isArrayLike");
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike2(value);
        }
        __name(isArrayLikeObject, "isArrayLikeObject");
        __name2(isArrayLikeObject, "isArrayLikeObject");
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        __name(isBoolean, "isBoolean");
        __name2(isBoolean, "isBoolean");
        var isBuffer3 = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        __name(isElement, "isElement");
        __name2(isElement, "isElement");
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key22 in value) {
            if (hasOwnProperty2.call(value, key22)) {
              return false;
            }
          }
          return true;
        }
        __name(isEmpty, "isEmpty");
        __name2(isEmpty, "isEmpty");
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        __name(isEqual, "isEqual");
        __name2(isEqual, "isEqual");
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        __name(isEqualWith, "isEqualWith");
        __name2(isEqualWith, "isEqualWith");
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        __name(isError, "isError");
        __name2(isError, "isError");
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        __name(isFinite2, "isFinite2");
        __name2(isFinite2, "isFinite");
        function isFunction2(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        __name(isFunction2, "isFunction2");
        __name2(isFunction2, "isFunction");
        function isInteger3(value) {
          return typeof value == "number" && value == toInteger2(value);
        }
        __name(isInteger3, "isInteger3");
        __name2(isInteger3, "isInteger");
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER22;
        }
        __name(isLength, "isLength");
        __name2(isLength, "isLength");
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        __name(isObject, "isObject");
        __name2(isObject, "isObject");
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        __name(isObjectLike, "isObjectLike");
        __name2(isObjectLike, "isObjectLike");
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        __name(isMatch, "isMatch");
        __name2(isMatch, "isMatch");
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        __name(isMatchWith, "isMatchWith");
        __name2(isMatchWith, "isMatchWith");
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        __name(isNaN2, "isNaN2");
        __name2(isNaN2, "isNaN");
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        __name(isNative, "isNative");
        __name2(isNative, "isNative");
        function isNull(value) {
          return value === null;
        }
        __name(isNull, "isNull");
        __name2(isNull, "isNull");
        function isNil(value) {
          return value == null;
        }
        __name(isNil, "isNil");
        __name2(isNil, "isNil");
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        __name(isNumber, "isNumber");
        __name2(isNumber, "isNumber");
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        __name(isPlainObject, "isPlainObject");
        __name2(isPlainObject, "isPlainObject");
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger3(value) && value >= -MAX_SAFE_INTEGER22 && value <= MAX_SAFE_INTEGER22;
        }
        __name(isSafeInteger, "isSafeInteger");
        __name2(isSafeInteger, "isSafeInteger");
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        __name(isString, "isString");
        __name2(isString, "isString");
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        __name(isSymbol, "isSymbol");
        __name2(isSymbol, "isSymbol");
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        __name(isUndefined, "isUndefined");
        __name2(isUndefined, "isUndefined");
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        __name(isWeakMap, "isWeakMap");
        __name2(isWeakMap, "isWeakMap");
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        __name(isWeakSet, "isWeakSet");
        __name2(isWeakSet, "isWeakSet");
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike2(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        __name(toArray, "toArray");
        __name2(toArray, "toArray");
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign5 = value < 0 ? -1 : 1;
            return sign5 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        __name(toFinite, "toFinite");
        __name2(toFinite, "toFinite");
        function toInteger2(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        __name(toInteger2, "toInteger2");
        __name2(toInteger2, "toInteger");
        function toLength(value) {
          return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        __name(toLength, "toLength");
        __name2(toLength, "toLength");
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        __name(toNumber, "toNumber");
        __name2(toNumber, "toNumber");
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        __name(toPlainObject, "toPlainObject");
        __name2(toPlainObject, "toPlainObject");
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER22, MAX_SAFE_INTEGER22) : value === 0 ? value : 0;
        }
        __name(toSafeInteger, "toSafeInteger");
        __name2(toSafeInteger, "toSafeInteger");
        function toString6(value) {
          return value == null ? "" : baseToString(value);
        }
        __name(toString6, "toString6");
        __name2(toString6, "toString");
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike2(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key22 in source) {
            if (hasOwnProperty2.call(source, key22)) {
              assignValue(object, key22, source[key22]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        __name(create2, "create2");
        __name2(create2, "create");
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length2 = sources.length;
          var guard = length2 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length2 = 1;
          }
          while (++index < length2) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key22 = props[propsIndex];
              var value = object[key22];
              if (value === undefined2 || eq42(value, objectProto[key22]) && !hasOwnProperty2.call(object, key22)) {
                object[key22] = source[key22];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey2(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        __name(findKey2, "findKey2");
        __name2(findKey2, "findKey");
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        __name(findLastKey, "findLastKey");
        __name2(findLastKey, "findLastKey");
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        __name(forIn, "forIn");
        __name2(forIn, "forIn");
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        __name(forInRight, "forInRight");
        __name2(forInRight, "forInRight");
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        __name(forOwn, "forOwn");
        __name2(forOwn, "forOwn");
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        __name(forOwnRight, "forOwnRight");
        __name2(forOwnRight, "forOwnRight");
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        __name(functions, "functions");
        __name2(functions, "functions");
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        __name(functionsIn, "functionsIn");
        __name2(functionsIn, "functionsIn");
        function get2(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        __name(get2, "get2");
        __name2(get2, "get");
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        __name(has, "has");
        __name2(has, "has");
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        __name(hasIn, "hasIn");
        __name2(hasIn, "hasIn");
        var invert = createInverter(function(result2, value, key22) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key22;
        }, constant(identity4));
        var invertBy = createInverter(function(result2, value, key22) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key22);
          } else {
            result2[value] = [key22];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        __name(keys, "keys");
        __name2(keys, "keys");
        function keysIn(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        __name(keysIn, "keysIn");
        __name2(keysIn, "keysIn");
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key22, object2) {
            baseAssignValue(result2, iteratee2(value, key22, object2), value);
          });
          return result2;
        }
        __name(mapKeys, "mapKeys");
        __name2(mapKeys, "mapKeys");
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key22, object2) {
            baseAssignValue(result2, key22, iteratee2(value, key22, object2));
          });
          return result2;
        }
        __name(mapValues, "mapValues");
        __name2(mapValues, "mapValues");
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length2 = paths.length;
          while (length2--) {
            baseUnset(result2, paths[length2]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        __name(omitBy, "omitBy");
        __name2(omitBy, "omitBy");
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        __name(pickBy, "pickBy");
        __name2(pickBy, "pickBy");
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length2 = path.length;
          if (!length2) {
            length2 = 1;
            object = undefined2;
          }
          while (++index < length2) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length2;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        __name(result, "result");
        __name2(result, "result");
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        __name(set, "set");
        __name2(set, "set");
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        __name(setWith, "setWith");
        __name2(setWith, "setWith");
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer3(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        __name(transform, "transform");
        __name2(transform, "transform");
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        __name(unset, "unset");
        __name2(unset, "unset");
        function update22(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        __name(update22, "update2");
        __name2(update22, "update");
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        __name(updateWith, "updateWith");
        __name2(updateWith, "updateWith");
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        __name(values, "values");
        __name2(values, "values");
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        __name(valuesIn, "valuesIn");
        __name2(valuesIn, "valuesIn");
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        __name(clamp, "clamp");
        __name2(clamp, "clamp");
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        __name(inRange, "inRange");
        __name2(inRange, "inRange");
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand22 = nativeRandom();
            return nativeMin(lower + rand22 * (upper - lower + freeParseFloat("1e-" + ((rand22 + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        __name(random, "random");
        __name2(random, "random");
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string2) {
          return upperFirst(toString6(string2).toLowerCase());
        }
        __name(capitalize, "capitalize");
        __name2(capitalize, "capitalize");
        function deburr(string2) {
          string2 = toString6(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        __name(deburr, "deburr");
        __name2(deburr, "deburr");
        function endsWith(string2, target, position) {
          string2 = toString6(string2);
          target = baseToString(target);
          var length2 = string2.length;
          position = position === undefined2 ? length2 : baseClamp(toInteger2(position), 0, length2);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        __name(endsWith, "endsWith");
        __name2(endsWith, "endsWith");
        function escape(string2) {
          string2 = toString6(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        __name(escape, "escape");
        __name2(escape, "escape");
        function escapeRegExp(string2) {
          string2 = toString6(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        __name(escapeRegExp, "escapeRegExp");
        __name2(escapeRegExp, "escapeRegExp");
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad2(string2, length2, chars) {
          string2 = toString6(string2);
          length2 = toInteger2(length2);
          var strLength = length2 ? stringSize(string2) : 0;
          if (!length2 || strLength >= length2) {
            return string2;
          }
          var mid = (length2 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
        }
        __name(pad2, "pad2");
        __name2(pad2, "pad");
        function padEnd(string2, length2, chars) {
          string2 = toString6(string2);
          length2 = toInteger2(length2);
          var strLength = length2 ? stringSize(string2) : 0;
          return length2 && strLength < length2 ? string2 + createPadding(length2 - strLength, chars) : string2;
        }
        __name(padEnd, "padEnd");
        __name2(padEnd, "padEnd");
        function padStart(string2, length2, chars) {
          string2 = toString6(string2);
          length2 = toInteger2(length2);
          var strLength = length2 ? stringSize(string2) : 0;
          return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string2 : string2;
        }
        __name(padStart, "padStart");
        __name2(padStart, "padStart");
        function parseInt2(string2, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString6(string2).replace(reTrimStart, ""), radix || 0);
        }
        __name(parseInt2, "parseInt2");
        __name2(parseInt2, "parseInt");
        function repeat(string2, n, guard) {
          if (guard ? isIterateeCall(string2, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          return baseRepeat(toString6(string2), n);
        }
        __name(repeat, "repeat");
        __name2(repeat, "repeat");
        function replace() {
          var args = arguments, string2 = toString6(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        __name(replace, "replace");
        __name2(replace, "replace");
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string2, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString6(string2);
          if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator, limit);
        }
        __name(split, "split");
        __name2(split, "split");
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString6(string2);
          position = position == null ? 0 : baseClamp(toInteger2(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        __name(startsWith, "startsWith");
        __name2(startsWith, "startsWith");
        function template(string2, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string2, options, guard)) {
            options = undefined2;
          }
          string2 = toString6(string2);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        __name(template, "template");
        __name2(template, "template");
        function toLower(value) {
          return toString6(value).toLowerCase();
        }
        __name(toLower, "toLower");
        __name2(toLower, "toLower");
        function toUpper(value) {
          return toString6(value).toUpperCase();
        }
        __name(toUpper, "toUpper");
        __name2(toUpper, "toUpper");
        function trim(string2, chars, guard) {
          string2 = toString6(string2);
          if (string2 && (guard || chars === undefined2)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        __name(trim, "trim");
        __name2(trim, "trim");
        function trimEnd(string2, chars, guard) {
          string2 = toString6(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        __name(trimEnd, "trimEnd");
        __name2(trimEnd, "trimEnd");
        function trimStart(string2, chars, guard) {
          string2 = toString6(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        __name(trimStart, "trimStart");
        __name2(trimStart, "trimStart");
        function truncate(string2, options) {
          var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length2 = "length" in options ? toInteger2(options.length) : length2;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string2 = toString6(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length2 >= strLength) {
            return string2;
          }
          var end = length2 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string2.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString6(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        __name(truncate, "truncate");
        __name2(truncate, "truncate");
        function unescape(string2) {
          string2 = toString6(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        __name(unescape, "unescape");
        __name2(unescape, "unescape");
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words2(string2, pattern, guard) {
          string2 = toString6(string2);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern) || [];
        }
        __name(words2, "words");
        __name2(words2, "words");
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key22) {
            key22 = toKey(key22);
            baseAssignValue(object, key22, bind2(object[key22], object));
          });
          return object;
        });
        function cond(pairs) {
          var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length2) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        __name(cond, "cond");
        __name2(cond, "cond");
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        __name(conforms, "conforms");
        __name2(conforms, "conforms");
        function constant(value) {
          return function() {
            return value;
          };
        }
        __name(constant, "constant");
        __name2(constant, "constant");
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        __name(defaultTo, "defaultTo");
        __name2(defaultTo, "defaultTo");
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity4(value) {
          return value;
        }
        __name(identity4, "identity4");
        __name2(identity4, "identity");
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        __name(iteratee, "iteratee");
        __name2(iteratee, "iteratee");
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        __name(matches, "matches");
        __name2(matches, "matches");
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        __name(matchesProperty, "matchesProperty");
        __name2(matchesProperty, "matchesProperty");
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        __name(mixin, "mixin");
        __name2(mixin, "mixin");
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        __name(noConflict, "noConflict");
        __name2(noConflict, "noConflict");
        function noop2() {
        }
        __name(noop2, "noop2");
        __name2(noop2, "noop");
        function nthArg(n) {
          n = toInteger2(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        __name(nthArg, "nthArg");
        __name2(nthArg, "nthArg");
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        __name(property, "property");
        __name2(property, "property");
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        __name(propertyOf, "propertyOf");
        __name2(propertyOf, "propertyOf");
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        __name(stubArray, "stubArray");
        __name2(stubArray, "stubArray");
        function stubFalse() {
          return false;
        }
        __name(stubFalse, "stubFalse");
        __name2(stubFalse, "stubFalse");
        function stubObject() {
          return {};
        }
        __name(stubObject, "stubObject");
        __name2(stubObject, "stubObject");
        function stubString() {
          return "";
        }
        __name(stubString, "stubString");
        __name2(stubString, "stubString");
        function stubTrue() {
          return true;
        }
        __name(stubTrue, "stubTrue");
        __name2(stubTrue, "stubTrue");
        function times(n, iteratee2) {
          n = toInteger2(n);
          if (n < 1 || n > MAX_SAFE_INTEGER22) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length2 = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length2, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        __name(times, "times");
        __name2(times, "times");
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString6(value)));
        }
        __name(toPath, "toPath");
        __name2(toPath, "toPath");
        function uniqueId(prefix) {
          var id2 = ++idCounter;
          return toString6(prefix) + id2;
        }
        __name(uniqueId, "uniqueId");
        __name2(uniqueId, "uniqueId");
        var add32 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity4, baseGt) : undefined2;
        }
        __name(max, "max");
        __name2(max, "max");
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        __name(maxBy, "maxBy");
        __name2(maxBy, "maxBy");
        function mean(array) {
          return baseMean(array, identity4);
        }
        __name(mean, "mean");
        __name2(mean, "mean");
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        __name(meanBy, "meanBy");
        __name2(meanBy, "meanBy");
        function min(array) {
          return array && array.length ? baseExtremum(array, identity4, baseLt) : undefined2;
        }
        __name(min, "min");
        __name2(min, "min");
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        __name(minBy, "minBy");
        __name2(minBy, "minBy");
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity4) : 0;
        }
        __name(sum, "sum");
        __name2(sum, "sum");
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        __name(sumBy, "sumBy");
        __name2(sumBy, "sumBy");
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind2;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat4;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice2;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take2;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle2;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy2;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update22;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words2;
        lodash.wrap = wrap;
        lodash.xor = xor2;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add32;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep6;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq42;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex2;
        lodash.findKey = findKey2;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get2;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity4;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike2;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer3;
        lodash.isDate = isDate2;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger3;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last2;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now2;
        lodash.pad = pad2;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger2;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString6;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger2(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity4);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger2(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger2(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = /* @__PURE__ */ __name2(function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            }, "interceptor");
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key22 = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key22)) {
              realNames[key22] = [];
            }
            realNames[key22].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      }, "runInContext2"), "runInContext");
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(exports);
  }
});
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
__name(asUint8Array, "asUint8Array");
var init_as_uint8array = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
    __name2(asUint8Array, "asUint8Array");
  }
});
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
__name(allocUnsafe, "allocUnsafe");
var init_alloc = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/alloc.js"() {
    init_as_uint8array();
    __name2(allocUnsafe, "allocUnsafe");
  }
});
var concat_exports = {};
__export2(concat_exports, {
  concat: () => concat2
});
function concat2(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
__name(concat2, "concat");
var init_concat = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/concat.js"() {
    init_alloc();
    init_as_uint8array();
    __name2(concat2, "concat");
  }
});
function base2(ALPHABET, name3) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i22 = 0; i22 < ALPHABET.length; i22++) {
    var x2 = ALPHABET.charAt(i22);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i22;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode16(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode16, "encode16");
  __name2(encode16, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  __name2(decodeUnsafe, "decodeUnsafe");
  function decode13(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name3} character`);
  }
  __name(decode13, "decode13");
  __name2(decode13, "decode");
  return {
    encode: encode16,
    decodeUnsafe,
    decode: decode13
  };
}
__name(base2, "base");
var src;
var _brrp__multiformats_scope_baseX;
var base_x_default;
var init_base_x = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js"() {
    __name2(base2, "base");
    src = base2;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});
var empty;
var equals;
var coerce2;
var fromString;
var toString2;
var init_bytes = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    equals = /* @__PURE__ */ __name2((aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    }, "equals");
    coerce2 = /* @__PURE__ */ __name2((o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    }, "coerce");
    fromString = /* @__PURE__ */ __name2((str) => new TextEncoder().encode(str), "fromString");
    toString2 = /* @__PURE__ */ __name2((b2) => new TextDecoder().decode(b2), "toString");
  }
});
var Encoder;
var Decoder;
var ComposedDecoder;
var or;
var Codec;
var from;
var baseX;
var decode3;
var encode4;
var rfc4648;
var init_base = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder = /* @__PURE__ */ __name(class {
      constructor(name3, prefix, baseEncode) {
        this.name = name3;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    }, "Encoder");
    __name2(Encoder, "Encoder");
    Decoder = /* @__PURE__ */ __name(class {
      constructor(name3, prefix, baseDecode) {
        this.name = name3;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    }, "Decoder");
    __name2(Decoder, "Decoder");
    ComposedDecoder = /* @__PURE__ */ __name(class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    }, "ComposedDecoder");
    __name2(ComposedDecoder, "ComposedDecoder");
    or = /* @__PURE__ */ __name2((left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    }), "or");
    Codec = /* @__PURE__ */ __name(class {
      constructor(name3, prefix, baseEncode, baseDecode) {
        this.name = name3;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name3, prefix, baseEncode);
        this.decoder = new Decoder(name3, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    }, "Codec");
    __name2(Codec, "Codec");
    from = /* @__PURE__ */ __name2(({ name: name3, prefix, encode: encode16, decode: decode13 }) => new Codec(name3, prefix, encode16, decode13), "from");
    baseX = /* @__PURE__ */ __name2(({ prefix, name: name3, alphabet: alphabet3 }) => {
      const { encode: encode16, decode: decode13 } = base_x_default(alphabet3, name3);
      return from({
        prefix,
        name: name3,
        encode: encode16,
        decode: (text) => coerce2(decode13(text))
      });
    }, "baseX");
    decode3 = /* @__PURE__ */ __name2((string2, alphabet3, bitsPerChar, name3) => {
      const codes = {};
      for (let i22 = 0; i22 < alphabet3.length; ++i22) {
        codes[alphabet3[i22]] = i22;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i22 = 0; i22 < end; ++i22) {
        const value = codes[string2[i22]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name3} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    }, "decode");
    encode4 = /* @__PURE__ */ __name2((data, alphabet3, bitsPerChar) => {
      const pad2 = alphabet3[alphabet3.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i22 = 0; i22 < data.length; ++i22) {
        buffer2 = buffer2 << 8 | data[i22];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet3[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet3[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    }, "encode");
    rfc4648 = /* @__PURE__ */ __name2(({ name: name3, prefix, bitsPerChar, alphabet: alphabet3 }) => {
      return from({
        prefix,
        name: name3,
        encode(input) {
          return encode4(input, alphabet3, bitsPerChar);
        },
        decode(input) {
          return decode3(input, alphabet3, bitsPerChar, name3);
        }
      });
    }, "rfc4648");
  }
});
var identity_exports = {};
__export2(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base();
    init_bytes();
    identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf2) => toString2(buf2),
      decode: (str) => fromString(str)
    });
  }
});
var base2_exports = {};
__export2(base2_exports, {
  base2: () => base22
});
var base22;
var init_base2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base();
    base22 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});
var base8_exports = {};
__export2(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});
var base10_exports = {};
__export2(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});
var base16_exports = {};
__export2(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16;
var base16upper;
var init_base16 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});
var base32_exports = {};
__export2(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32;
var base32upper;
var base32pad;
var base32padupper;
var base32hex;
var base32hexupper;
var base32hexpad;
var base32hexpadupper;
var base32z;
var init_base32 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});
var base36_exports = {};
__export2(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36;
var base36upper;
var init_base36 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});
var base58_exports = {};
__export2(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc;
var base58flickr;
var init_base58 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});
var base64_exports = {};
__export2(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64;
var base64pad;
var base64url;
var base64urlpad;
var init_base64 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});
var base256emoji_exports = {};
__export2(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode22(data) {
  return data.reduce((p, c2) => {
    p += alphabetBytesToChars[c2];
    return p;
  }, "");
}
__name(encode22, "encode2");
function decode22(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode22, "decode2");
var alphabet;
var alphabetBytesToChars;
var alphabetCharsToBytes;
var base256emoji;
var init_base256emoji = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base();
    alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet.reduce((p, c2, i22) => {
      p[i22] = c2;
      return p;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p, c2, i22) => {
      p[c2.codePointAt(0)] = i22;
      return p;
    }, []);
    __name2(encode22, "encode");
    __name2(decode22, "decode");
    base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode22,
      decode: decode22
    });
  }
});
function encode32(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode32.bytes = offset - oldOffset + 1;
  return out;
}
__name(encode32, "encode3");
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1) << shift : (b2 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
__name(read, "read");
var encode_1;
var MSB;
var REST;
var MSBALL;
var INT;
var decode32;
var MSB$1;
var REST$1;
var N1;
var N2;
var N3;
var N4;
var N5;
var N6;
var N7;
var N8;
var N9;
var length;
var varint;
var _brrp_varint;
var varint_default;
var init_varint = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode32;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    __name2(encode32, "encode");
    decode32 = read;
    MSB$1 = 128;
    REST$1 = 127;
    __name2(read, "read");
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = /* @__PURE__ */ __name2(function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    }, "length");
    varint = {
      encode: encode_1,
      decode: decode32,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});
var decode4;
var encodeTo;
var encodingLength;
var init_varint2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode4 = /* @__PURE__ */ __name2((data, offset = 0) => {
      const code3 = varint_default.decode(data, offset);
      return [
        code3,
        varint_default.decode.bytes
      ];
    }, "decode");
    encodeTo = /* @__PURE__ */ __name2((int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    }, "encodeTo");
    encodingLength = /* @__PURE__ */ __name2((int) => {
      return varint_default.encodingLength(int);
    }, "encodingLength");
  }
});
var create;
var decode5;
var equals2;
var Digest;
var init_digest = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create = /* @__PURE__ */ __name2((code3, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = encodingLength(code3);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code3, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest2, digestOffset);
      return new Digest(code3, size, digest2, bytes);
    }, "create");
    decode5 = /* @__PURE__ */ __name2((multihash) => {
      const bytes = coerce2(multihash);
      const [code3, sizeOffset] = decode4(bytes);
      const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
      const digest2 = bytes.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code3, size, digest2, bytes);
    }, "decode");
    equals2 = /* @__PURE__ */ __name2((a3, b2) => {
      if (a3 === b2) {
        return true;
      } else {
        return a3.code === b2.code && a3.size === b2.size && equals(a3.bytes, b2.bytes);
      }
    }, "equals");
    Digest = /* @__PURE__ */ __name(class {
      constructor(code3, size, digest2, bytes) {
        this.code = code3;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes;
      }
    }, "Digest");
    __name2(Digest, "Digest");
  }
});
var from2;
var Hasher;
var init_hasher = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from2 = /* @__PURE__ */ __name2(({ name: name3, code: code3, encode: encode16 }) => new Hasher(name3, code3, encode16), "from");
    Hasher = /* @__PURE__ */ __name(class {
      constructor(name3, code3, encode16) {
        this.name = name3;
        this.code = code3;
        this.encode = encode16;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    }, "Hasher");
    __name2(Hasher, "Hasher");
  }
});
var sha2_browser_exports = {};
__export2(sha2_browser_exports, {
  sha256: () => sha2563,
  sha512: () => sha5122
});
var sha;
var sha2563;
var sha5122;
var init_sha2_browser = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_hasher();
    sha = /* @__PURE__ */ __name2((name3) => async (data) => new Uint8Array(await crypto.subtle.digest(name3, data)), "sha");
    sha2563 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha5122 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});
var identity_exports2 = {};
__export2(identity_exports2, {
  identity: () => identity2
});
var code;
var name;
var encode42;
var digest;
var identity2;
var init_identity2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code = 0;
    name = "identity";
    encode42 = coerce2;
    digest = /* @__PURE__ */ __name2((input) => create(code, encode42(input)), "digest");
    identity2 = {
      code,
      name,
      encode: encode42,
      digest
    };
  }
});
var init_raw = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
  }
});
var textEncoder;
var textDecoder;
var init_json = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
  }
});
var CID;
var parseCIDtoBytes;
var toStringV0;
var toStringV1;
var DAG_PB_CODE;
var SHA_256_CODE;
var encodeCID;
var cidSymbol;
var readonly;
var hidden;
var version27;
var deprecate;
var IS_CID_DEPRECATION;
var init_cid = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = /* @__PURE__ */ __name(class {
      constructor(version122, code3, multihash, bytes) {
        this.code = code3;
        this.version = version122;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code3, multihash } = this;
            if (code3 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code3, digest: digest2 } = this.multihash;
            const multihash = create(code3, digest2);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base4) {
        const { bytes, version: version122, _baseCache } = this;
        switch (version122) {
          case 0:
            return toStringV0(bytes, _baseCache, base4 || base58btc.encoder);
          default:
            return toStringV1(bytes, _baseCache, base4 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version122, code: code3, multihash, bytes } = value;
          return new CID(version122, code3, multihash, bytes || encodeCID(version122, code3, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version122, multihash, code: code3 } = value;
          const digest2 = decode5(multihash);
          return CID.create(version122, code3, digest2);
        } else {
          return null;
        }
      }
      static create(version122, code3, digest2) {
        if (typeof code3 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version122) {
          case 0: {
            if (code3 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version122, code3, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version122, code3, digest2.bytes);
            return new CID(version122, code3, digest2, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code3, digest2) {
        return CID.create(1, code3, digest2);
      }
      static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
        return [
          cid,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = /* @__PURE__ */ __name2(() => {
          const [i22, length2] = decode4(initialBytes.subarray(offset));
          offset += length2;
          return i22;
        }, "next");
        let version122 = next();
        let codec = DAG_PB_CODE;
        if (version122 === 18) {
          version122 = 0;
          offset = 0;
        } else if (version122 === 1) {
          codec = next();
        }
        if (version122 !== 0 && version122 !== 1) {
          throw new RangeError(`Invalid CID version ${version122}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version122,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base4) {
        const [prefix, bytes] = parseCIDtoBytes(source, base4);
        const cid = CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    }, "CID");
    __name2(CID, "CID");
    parseCIDtoBytes = /* @__PURE__ */ __name2((source, base4) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base4 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base4 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base4.decode(source)
          ];
        }
      }
    }, "parseCIDtoBytes");
    toStringV0 = /* @__PURE__ */ __name2((bytes, cache, base4) => {
      const { prefix } = base4;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    }, "toStringV0");
    toStringV1 = /* @__PURE__ */ __name2((bytes, cache, base4) => {
      const { prefix } = base4;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    }, "toStringV1");
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = /* @__PURE__ */ __name2((version122, code3, multihash) => {
      const codeOffset = encodingLength(version122);
      const hashOffset = codeOffset + encodingLength(code3);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version122, bytes, 0);
      encodeTo(code3, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    }, "encodeCID");
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version27 = "0.0.0-dev";
    deprecate = /* @__PURE__ */ __name2((range, message) => {
      if (range.test(version27)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    }, "deprecate");
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});
var init_src = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});
var bases;
var hashes;
var init_basics = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js"() {
    init_identity();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2_browser();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases = {
      ...identity_exports,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    hashes = {
      ...sha2_browser_exports,
      ...identity_exports2
    };
  }
});
function createCodec(name3, prefix, encode16, decode13) {
  return {
    name: name3,
    prefix,
    encoder: {
      name: name3,
      prefix,
      encode: encode16
    },
    decoder: { decode: decode13 }
  };
}
__name(createCodec, "createCodec");
var string;
var ascii;
var BASES;
var bases_default;
var init_bases = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    init_alloc();
    __name2(createCodec, "createCodec");
    string = createCodec("utf8", "u", (buf2) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf2);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf2) => {
      let string2 = "a";
      for (let i22 = 0; i22 < buf2.length; i22++) {
        string2 += String.fromCharCode(buf2[i22]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf2 = allocUnsafe(str.length);
      for (let i22 = 0; i22 < str.length; i22++) {
        buf2[i22] = str.charCodeAt(i22);
      }
      return buf2;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});
var from_string_exports = {};
__export2(from_string_exports, {
  fromString: () => fromString2
});
function fromString2(string2, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base4.decoder.decode(`${base4.prefix}${string2}`);
}
__name(fromString2, "fromString2");
var init_from_string = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
    init_as_uint8array();
    __name2(fromString2, "fromString");
  }
});
var to_string_exports = {};
__export2(to_string_exports, {
  toString: () => toString3
});
function toString3(array, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base4.encoder.encode(array).substring(1);
}
__name(toString3, "toString3");
var init_to_string = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
    __name2(toString3, "toString");
  }
});
var require_int = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+int@1.0.1/node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a3, b2) {
      var ah = a3 >>> 16 & 65535, al = a3 & 65535;
      var bh = b2 >>> 16 & 65535, bl = b2 & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    __name(imulShim, "imulShim");
    __name2(imulShim, "imulShim");
    exports.mul = Math.imul || imulShim;
    function add32(a3, b2) {
      return a3 + b2 | 0;
    }
    __name(add32, "add3");
    __name2(add32, "add");
    exports.add = add32;
    function sub(a3, b2) {
      return a3 - b2 | 0;
    }
    __name(sub, "sub");
    __name2(sub, "sub");
    exports.sub = sub;
    function rotl(x2, n) {
      return x2 << n | x2 >>> 32 - n;
    }
    __name(rotl, "rotl");
    __name2(rotl, "rotl");
    exports.rotl = rotl;
    function rotr(x2, n) {
      return x2 << 32 - n | x2 >>> n;
    }
    __name(rotr, "rotr");
    __name2(rotr, "rotr");
    exports.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    __name(isIntegerShim, "isIntegerShim");
    __name2(isIntegerShim, "isIntegerShim");
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n) {
      return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
    };
  }
});
var require_binary = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+binary@1.0.1/node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    __name(readInt16BE, "readInt16BE");
    __name2(readInt16BE, "readInt16BE");
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    __name(readUint16BE, "readUint16BE");
    __name2(readUint16BE, "readUint16BE");
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    __name(readInt16LE, "readInt16LE");
    __name2(readInt16LE, "readInt16LE");
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    __name(readUint16LE, "readUint16LE");
    __name2(readUint16LE, "readUint16LE");
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    __name(writeUint16BE, "writeUint16BE");
    __name2(writeUint16BE, "writeUint16BE");
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    __name(writeUint16LE, "writeUint16LE");
    __name2(writeUint16LE, "writeUint16LE");
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    __name(readInt32BE, "readInt32BE");
    __name2(readInt32BE, "readInt32BE");
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    __name(readUint32BE, "readUint32BE");
    __name2(readUint32BE, "readUint32BE");
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    __name(readInt32LE, "readInt32LE");
    __name2(readInt32LE, "readInt32LE");
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    __name(readUint32LE, "readUint32LE");
    __name2(readUint32LE, "readUint32LE");
    exports.readUint32LE = readUint32LE;
    function writeUint32BE2(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    __name(writeUint32BE2, "writeUint32BE2");
    __name2(writeUint32BE2, "writeUint32BE");
    exports.writeUint32BE = writeUint32BE2;
    exports.writeInt32BE = writeUint32BE2;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    __name(writeUint32LE, "writeUint32LE");
    __name2(writeUint32LE, "writeUint32LE");
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    __name(readInt64BE, "readInt64BE");
    __name2(readInt64BE, "readInt64BE");
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    __name(readUint64BE, "readUint64BE");
    __name2(readUint64BE, "readUint64BE");
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    __name(readInt64LE, "readInt64LE");
    __name2(readInt64LE, "readInt64LE");
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    __name(readUint64LE, "readUint64LE");
    __name2(readUint64LE, "readUint64LE");
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE2(value / 4294967296 >>> 0, out, offset);
      writeUint32BE2(value >>> 0, out, offset + 4);
      return out;
    }
    __name(writeUint64BE, "writeUint64BE");
    __name2(writeUint64BE, "writeUint64BE");
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    __name(writeUint64LE, "writeUint64LE");
    __name2(writeUint64LE, "writeUint64LE");
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul32 = 1;
      for (var i22 = bitLength / 8 + offset - 1; i22 >= offset; i22--) {
        result += array[i22] * mul32;
        mul32 *= 256;
      }
      return result;
    }
    __name(readUintBE, "readUintBE");
    __name2(readUintBE, "readUintBE");
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul32 = 1;
      for (var i22 = offset; i22 < offset + bitLength / 8; i22++) {
        result += array[i22] * mul32;
        mul32 *= 256;
      }
      return result;
    }
    __name(readUintLE, "readUintLE");
    __name2(readUintLE, "readUintLE");
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i22 = bitLength / 8 + offset - 1; i22 >= offset; i22--) {
        out[i22] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    __name(writeUintBE, "writeUintBE");
    __name2(writeUintBE, "writeUintBE");
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i22 = offset; i22 < offset + bitLength / 8; i22++) {
        out[i22] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    __name(writeUintLE, "writeUintLE");
    __name2(writeUintLE, "writeUintLE");
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    __name(readFloat32BE, "readFloat32BE");
    __name2(readFloat32BE, "readFloat32BE");
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    __name(readFloat32LE, "readFloat32LE");
    __name2(readFloat32LE, "readFloat32LE");
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    __name(readFloat64BE, "readFloat64BE");
    __name2(readFloat64BE, "readFloat64BE");
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    __name(readFloat64LE, "readFloat64LE");
    __name2(readFloat64LE, "readFloat64LE");
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    __name(writeFloat32BE, "writeFloat32BE");
    __name2(writeFloat32BE, "writeFloat32BE");
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    __name(writeFloat32LE, "writeFloat32LE");
    __name2(writeFloat32LE, "writeFloat32LE");
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    __name(writeFloat64BE, "writeFloat64BE");
    __name2(writeFloat64BE, "writeFloat64BE");
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    __name(writeFloat64LE, "writeFloat64LE");
    __name2(writeFloat64LE, "writeFloat64LE");
    exports.writeFloat64LE = writeFloat64LE;
  }
});
var require_wipe = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+wipe@1.0.1/node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i22 = 0; i22 < array.length; i22++) {
        array[i22] = 0;
      }
      return array;
    }
    __name(wipe, "wipe");
    __name2(wipe, "wipe");
    exports.wipe = wipe;
  }
});
var require_sha256 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+sha256@1.0.1/node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA256 = function() {
      function SHA2562() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      __name(SHA2562, "SHA2562");
      __name2(SHA2562, "SHA256");
      SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2562.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
      };
      SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i22 = left + 1; i22 < padLength - 8; i22++) {
            this._buffer[i22] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i22 = 0; i22 < this.digestLength / 4; i22++) {
          binary_1.writeUint32BE(this._state[i22], out, i22 * 4);
        }
        return this;
      };
      SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2562.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2562.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2562;
    }();
    exports.SHA256 = SHA256;
    var K2 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w2, v, p, pos, len) {
      while (len >= 64) {
        var a3 = v[0];
        var b2 = v[1];
        var c2 = v[2];
        var d3 = v[3];
        var e2 = v[4];
        var f = v[5];
        var g2 = v[6];
        var h3 = v[7];
        for (var i22 = 0; i22 < 16; i22++) {
          var j = pos + i22 * 4;
          w2[i22] = binary_1.readUint32BE(p, j);
        }
        for (var i22 = 16; i22 < 64; i22++) {
          var u2 = w2[i22 - 2];
          var t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
          u2 = w2[i22 - 15];
          var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
          w2[i22] = (t1 + w2[i22 - 7] | 0) + (t2 + w2[i22 - 16] | 0);
        }
        for (var i22 = 0; i22 < 64; i22++) {
          var t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f ^ ~e2 & g2) | 0) + (h3 + (K2[i22] + w2[i22] | 0) | 0) | 0;
          var t2 = ((a3 >>> 2 | a3 << 32 - 2) ^ (a3 >>> 13 | a3 << 32 - 13) ^ (a3 >>> 22 | a3 << 32 - 22)) + (a3 & b2 ^ a3 & c2 ^ b2 & c2) | 0;
          h3 = g2;
          g2 = f;
          f = e2;
          e2 = d3 + t1 | 0;
          d3 = c2;
          c2 = b2;
          b2 = a3;
          a3 = t1 + t2 | 0;
        }
        v[0] += a3;
        v[1] += b2;
        v[2] += c2;
        v[3] += d3;
        v[4] += e2;
        v[5] += f;
        v[6] += g2;
        v[7] += h3;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    __name(hashBlocks, "hashBlocks");
    __name2(hashBlocks, "hashBlocks");
    function hash3(data) {
      var h3 = new SHA256();
      h3.update(data);
      var digest2 = h3.digest();
      h3.clean();
      return digest2;
    }
    __name(hash3, "hash3");
    __name2(hash3, "hash");
    exports.hash = hash3;
  }
});
var require_sha32 = __commonJS2({
  "../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js"(exports, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = /* @__PURE__ */ __name2(function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
        };
      }, "createOutputMethod");
      var createShakeOutputMethod = /* @__PURE__ */ __name2(function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
        };
      }, "createShakeOutputMethod");
      var createCshakeOutputMethod = /* @__PURE__ */ __name2(function(bits2, padding2, outputType) {
        return function(message, outputBits, n, s3) {
          return methods["cshake" + bits2].update(message, outputBits, n, s3)[outputType]();
        };
      }, "createCshakeOutputMethod");
      var createKmacOutputMethod = /* @__PURE__ */ __name2(function(bits2, padding2, outputType) {
        return function(key22, message, outputBits, s3) {
          return methods["kmac" + bits2].update(key22, message, outputBits, s3)[outputType]();
        };
      }, "createKmacOutputMethod");
      var createOutputMethods = /* @__PURE__ */ __name2(function(method, createMethod2, bits2, padding2) {
        for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
          var type = OUTPUT_TYPES[i3];
          method[type] = createMethod2(bits2, padding2, type);
        }
        return method;
      }, "createOutputMethods");
      var createMethod = /* @__PURE__ */ __name2(function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      }, "createMethod");
      var createShakeMethod = /* @__PURE__ */ __name2(function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      }, "createShakeMethod");
      var createCshakeMethod = /* @__PURE__ */ __name2(function(bits2, padding2) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n, s3) {
          if (!n && !s3) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding2, outputBits).bytepad([n, s3], w2);
          }
        };
        method.update = function(message, outputBits, n, s3) {
          return method.create(outputBits, n, s3).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      }, "createCshakeMethod");
      var createKmacMethod = /* @__PURE__ */ __name2(function(bits2, padding2) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key22, outputBits, s3) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s3], w2).bytepad([key22], w2);
        };
        method.update = function(key22, message, outputBits, s3) {
          return method.create(key22, outputBits, s3).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      }, "createKmacMethod");
      var algorithms2 = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i22 = 0; i22 < algorithms2.length; ++i22) {
        var algorithm = algorithms2[i22];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i3 = 0; i3 < 50; ++i3) {
          this.s[i3] = 0;
        }
      }
      __name(Keccak, "Keccak");
      __name2(Keccak, "Keccak");
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s3 = this.s, i3, code3;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i3 = 1; i3 < blockCount + 1; ++i3) {
              blocks[i3] = 0;
            }
          }
          if (notString) {
            for (i3 = this.start; index < length2 && i3 < byteCount; ++index) {
              blocks[i3 >> 2] |= message[index] << SHIFT[i3++ & 3];
            }
          } else {
            for (i3 = this.start; index < length2 && i3 < byteCount; ++index) {
              code3 = message.charCodeAt(index);
              if (code3 < 128) {
                blocks[i3 >> 2] |= code3 << SHIFT[i3++ & 3];
              } else if (code3 < 2048) {
                blocks[i3 >> 2] |= (192 | code3 >> 6) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code3 & 63) << SHIFT[i3++ & 3];
              } else if (code3 < 55296 || code3 >= 57344) {
                blocks[i3 >> 2] |= (224 | code3 >> 12) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code3 >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code3 & 63) << SHIFT[i3++ & 3];
              } else {
                code3 = 65536 + ((code3 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i3 >> 2] |= (240 | code3 >> 18) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code3 >> 12 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code3 >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code3 & 63) << SHIFT[i3++ & 3];
              }
            }
          }
          this.lastByteIndex = i3;
          if (i3 >= byteCount) {
            this.start = i3 - byteCount;
            this.block = blocks[blockCount];
            for (i3 = 0; i3 < blockCount; ++i3) {
              s3[i3] ^= blocks[i3];
            }
            f(s3);
            this.reset = true;
          } else {
            this.start = i3;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x2, right) {
        var o = x2 & 255, n = 1;
        var bytes = [o];
        x2 = x2 >> 8;
        o = x2 & 255;
        while (o > 0) {
          bytes.unshift(o);
          x2 = x2 >> 8;
          o = x2 & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length2 = str.length;
        if (notString) {
          bytes = length2;
        } else {
          for (var i3 = 0; i3 < str.length; ++i3) {
            var code3 = str.charCodeAt(i3);
            if (code3 < 128) {
              bytes += 1;
            } else if (code3 < 2048) {
              bytes += 2;
            } else if (code3 < 55296 || code3 >= 57344) {
              bytes += 3;
            } else {
              code3 = 65536 + ((code3 & 1023) << 10 | str.charCodeAt(++i3) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w2) {
        var bytes = this.encode(w2);
        for (var i3 = 0; i3 < strs.length; ++i3) {
          bytes += this.encodeString(strs[i3]);
        }
        var paddingBytes = w2 - bytes % w2;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
        blocks[i3 >> 2] |= this.padding[i3 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i3 = 0; i3 < blockCount; ++i3) {
          s3[i3] ^= blocks[i3];
        }
        f(s3);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            block = s3[i3];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s3);
            i3 = 0;
          }
        }
        if (extraBytes) {
          block = s3[i3];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer2);
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            array[j2] = s3[i3];
          }
          if (j2 % blockCount === 0) {
            f(s3);
          }
        }
        if (extraBytes) {
          array[i3] = s3[i3];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            offset = j2 << 2;
            block = s3[i3];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s3);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s3[i3];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak.call(this, bits2, padding2, outputBits);
      }
      __name(Kmac, "Kmac");
      __name2(Kmac, "Kmac");
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = /* @__PURE__ */ __name2(function(s3) {
        var h3, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
          c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
          c2 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
          c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
          c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
          c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
          c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
          c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
          c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
          c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
          h3 = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s3[0] ^= h3;
          s3[1] ^= l;
          s3[10] ^= h3;
          s3[11] ^= l;
          s3[20] ^= h3;
          s3[21] ^= l;
          s3[30] ^= h3;
          s3[31] ^= l;
          s3[40] ^= h3;
          s3[41] ^= l;
          h3 = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s3[2] ^= h3;
          s3[3] ^= l;
          s3[12] ^= h3;
          s3[13] ^= l;
          s3[22] ^= h3;
          s3[23] ^= l;
          s3[32] ^= h3;
          s3[33] ^= l;
          s3[42] ^= h3;
          s3[43] ^= l;
          h3 = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s3[4] ^= h3;
          s3[5] ^= l;
          s3[14] ^= h3;
          s3[15] ^= l;
          s3[24] ^= h3;
          s3[25] ^= l;
          s3[34] ^= h3;
          s3[35] ^= l;
          s3[44] ^= h3;
          s3[45] ^= l;
          h3 = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s3[6] ^= h3;
          s3[7] ^= l;
          s3[16] ^= h3;
          s3[17] ^= l;
          s3[26] ^= h3;
          s3[27] ^= l;
          s3[36] ^= h3;
          s3[37] ^= l;
          s3[46] ^= h3;
          s3[47] ^= l;
          h3 = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s3[8] ^= h3;
          s3[9] ^= l;
          s3[18] ^= h3;
          s3[19] ^= l;
          s3[28] ^= h3;
          s3[29] ^= l;
          s3[38] ^= h3;
          s3[39] ^= l;
          s3[48] ^= h3;
          s3[49] ^= l;
          b0 = s3[0];
          b1 = s3[1];
          b32 = s3[11] << 4 | s3[10] >>> 28;
          b33 = s3[10] << 4 | s3[11] >>> 28;
          b14 = s3[20] << 3 | s3[21] >>> 29;
          b15 = s3[21] << 3 | s3[20] >>> 29;
          b46 = s3[31] << 9 | s3[30] >>> 23;
          b47 = s3[30] << 9 | s3[31] >>> 23;
          b28 = s3[40] << 18 | s3[41] >>> 14;
          b29 = s3[41] << 18 | s3[40] >>> 14;
          b20 = s3[2] << 1 | s3[3] >>> 31;
          b21 = s3[3] << 1 | s3[2] >>> 31;
          b2 = s3[13] << 12 | s3[12] >>> 20;
          b3 = s3[12] << 12 | s3[13] >>> 20;
          b34 = s3[22] << 10 | s3[23] >>> 22;
          b35 = s3[23] << 10 | s3[22] >>> 22;
          b16 = s3[33] << 13 | s3[32] >>> 19;
          b17 = s3[32] << 13 | s3[33] >>> 19;
          b48 = s3[42] << 2 | s3[43] >>> 30;
          b49 = s3[43] << 2 | s3[42] >>> 30;
          b40 = s3[5] << 30 | s3[4] >>> 2;
          b41 = s3[4] << 30 | s3[5] >>> 2;
          b22 = s3[14] << 6 | s3[15] >>> 26;
          b23 = s3[15] << 6 | s3[14] >>> 26;
          b4 = s3[25] << 11 | s3[24] >>> 21;
          b5 = s3[24] << 11 | s3[25] >>> 21;
          b36 = s3[34] << 15 | s3[35] >>> 17;
          b37 = s3[35] << 15 | s3[34] >>> 17;
          b18 = s3[45] << 29 | s3[44] >>> 3;
          b19 = s3[44] << 29 | s3[45] >>> 3;
          b10 = s3[6] << 28 | s3[7] >>> 4;
          b11 = s3[7] << 28 | s3[6] >>> 4;
          b42 = s3[17] << 23 | s3[16] >>> 9;
          b43 = s3[16] << 23 | s3[17] >>> 9;
          b24 = s3[26] << 25 | s3[27] >>> 7;
          b25 = s3[27] << 25 | s3[26] >>> 7;
          b6 = s3[36] << 21 | s3[37] >>> 11;
          b7 = s3[37] << 21 | s3[36] >>> 11;
          b38 = s3[47] << 24 | s3[46] >>> 8;
          b39 = s3[46] << 24 | s3[47] >>> 8;
          b30 = s3[8] << 27 | s3[9] >>> 5;
          b31 = s3[9] << 27 | s3[8] >>> 5;
          b12 = s3[18] << 20 | s3[19] >>> 12;
          b13 = s3[19] << 20 | s3[18] >>> 12;
          b44 = s3[29] << 7 | s3[28] >>> 25;
          b45 = s3[28] << 7 | s3[29] >>> 25;
          b26 = s3[38] << 8 | s3[39] >>> 24;
          b27 = s3[39] << 8 | s3[38] >>> 24;
          b8 = s3[48] << 14 | s3[49] >>> 18;
          b9 = s3[49] << 14 | s3[48] >>> 18;
          s3[0] = b0 ^ ~b2 & b4;
          s3[1] = b1 ^ ~b3 & b5;
          s3[10] = b10 ^ ~b12 & b14;
          s3[11] = b11 ^ ~b13 & b15;
          s3[20] = b20 ^ ~b22 & b24;
          s3[21] = b21 ^ ~b23 & b25;
          s3[30] = b30 ^ ~b32 & b34;
          s3[31] = b31 ^ ~b33 & b35;
          s3[40] = b40 ^ ~b42 & b44;
          s3[41] = b41 ^ ~b43 & b45;
          s3[2] = b2 ^ ~b4 & b6;
          s3[3] = b3 ^ ~b5 & b7;
          s3[12] = b12 ^ ~b14 & b16;
          s3[13] = b13 ^ ~b15 & b17;
          s3[22] = b22 ^ ~b24 & b26;
          s3[23] = b23 ^ ~b25 & b27;
          s3[32] = b32 ^ ~b34 & b36;
          s3[33] = b33 ^ ~b35 & b37;
          s3[42] = b42 ^ ~b44 & b46;
          s3[43] = b43 ^ ~b45 & b47;
          s3[4] = b4 ^ ~b6 & b8;
          s3[5] = b5 ^ ~b7 & b9;
          s3[14] = b14 ^ ~b16 & b18;
          s3[15] = b15 ^ ~b17 & b19;
          s3[24] = b24 ^ ~b26 & b28;
          s3[25] = b25 ^ ~b27 & b29;
          s3[34] = b34 ^ ~b36 & b38;
          s3[35] = b35 ^ ~b37 & b39;
          s3[44] = b44 ^ ~b46 & b48;
          s3[45] = b45 ^ ~b47 & b49;
          s3[6] = b6 ^ ~b8 & b0;
          s3[7] = b7 ^ ~b9 & b1;
          s3[16] = b16 ^ ~b18 & b10;
          s3[17] = b17 ^ ~b19 & b11;
          s3[26] = b26 ^ ~b28 & b20;
          s3[27] = b27 ^ ~b29 & b21;
          s3[36] = b36 ^ ~b38 & b30;
          s3[37] = b37 ^ ~b39 & b31;
          s3[46] = b46 ^ ~b48 & b40;
          s3[47] = b47 ^ ~b49 & b41;
          s3[8] = b8 ^ ~b0 & b2;
          s3[9] = b9 ^ ~b1 & b3;
          s3[18] = b18 ^ ~b10 & b12;
          s3[19] = b19 ^ ~b11 & b13;
          s3[28] = b28 ^ ~b20 & b22;
          s3[29] = b29 ^ ~b21 & b23;
          s3[38] = b38 ^ ~b30 & b32;
          s3[39] = b39 ^ ~b31 & b33;
          s3[48] = b48 ^ ~b40 & b42;
          s3[49] = b49 ^ ~b41 & b43;
          s3[0] ^= RC[n];
          s3[1] ^= RC[n + 1];
        }
      }, "f");
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i22 = 0; i22 < methodNames.length; ++i22) {
          root[methodNames[i22]] = methods[methodNames[i22]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});
var require_package = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/package.json"(exports, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});
var require_buffer2 = __commonJS2({
  "(disabled):../../node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js"() {
  }
});
var require_bn2 = __commonJS2({
  "../../node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js"(exports, module2) {
    (function(module3, exports2) {
      "use strict";
      function assert22(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      __name(assert22, "assert2");
      __name2(assert22, "assert");
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = /* @__PURE__ */ __name2(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      __name(inherits, "inherits");
      __name2(inherits, "inherits");
      function BN32(number, base4, endian) {
        if (BN32.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base4 === "le" || base4 === "be") {
            endian = base4;
            base4 = 10;
          }
          this._init(number || 0, base4 || 10, endian || "be");
        }
      }
      __name(BN32, "BN3");
      __name2(BN32, "BN");
      if (typeof module3 === "object") {
        module3.exports = BN32;
      } else {
        exports2.BN = BN32;
      }
      BN32.BN = BN32;
      BN32.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer2().Buffer;
        }
      } catch (e2) {
      }
      BN32.isBN = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isBN(num) {
        if (num instanceof BN32) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN32.wordSize && Array.isArray(num.words);
      }, "isBN"), "isBN");
      BN32.max = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, "max"), "max");
      BN32.min = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, "min"), "min");
      BN32.prototype._init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init4(number, base4, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base4, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base4, endian);
        }
        if (base4 === "hex") {
          base4 = 16;
        }
        assert22(base4 === (base4 | 0) && base4 >= 2 && base4 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base4 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base4, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base4, endian);
            }
          }
        }
      }, "init4"), "init");
      BN32.prototype._initNumber = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _initNumber(number, base4, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert22(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base4, endian);
      }, "_initNumber"), "_initNumber");
      BN32.prototype._initArray = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _initArray(number, base4, endian) {
        assert22(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i22 = 0; i22 < this.length; i22++) {
          this.words[i22] = 0;
        }
        var j, w2;
        var off = 0;
        if (endian === "be") {
          for (i22 = number.length - 1, j = 0; i22 >= 0; i22 -= 3) {
            w2 = number[i22] | number[i22 - 1] << 8 | number[i22 - 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i22 = 0, j = 0; i22 < number.length; i22 += 3) {
            w2 = number[i22] | number[i22 + 1] << 8 | number[i22 + 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      }, "_initArray"), "_initArray");
      function parseHex4Bits(string2, index) {
        var c2 = string2.charCodeAt(index);
        if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          return c2 - 48 & 15;
        }
      }
      __name(parseHex4Bits, "parseHex4Bits");
      __name2(parseHex4Bits, "parseHex4Bits");
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      __name(parseHexByte, "parseHexByte");
      __name2(parseHexByte, "parseHexByte");
      BN32.prototype._parseHex = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i22 = 0; i22 < this.length; i22++) {
          this.words[i22] = 0;
        }
        var off = 0;
        var j = 0;
        var w2;
        if (endian === "be") {
          for (i22 = number.length - 1; i22 >= start; i22 -= 2) {
            w2 = parseHexByte(number, start, i22) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i22 = parseLength % 2 === 0 ? start + 1 : start; i22 < number.length; i22 += 2) {
            w2 = parseHexByte(number, start, i22) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      }, "_parseHex"), "_parseHex");
      function parseBase(str, start, end, mul32) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i22 = start; i22 < len; i22++) {
          var c2 = str.charCodeAt(i22) - 48;
          r2 *= mul32;
          if (c2 >= 49) {
            r2 += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r2 += c2 - 17 + 10;
          } else {
            r2 += c2;
          }
        }
        return r2;
      }
      __name(parseBase, "parseBase");
      __name2(parseBase, "parseBase");
      BN32.prototype._parseBase = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _parseBase(number, base4, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base4) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base4 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i22 = start; i22 < end; i22 += limbLen) {
          word = parseBase(number, i22, i22 + limbLen, base4);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i22, number.length, base4);
          for (i22 = 0; i22 < mod2; i22++) {
            pow *= base4;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      }, "_parseBase"), "_parseBase");
      BN32.prototype.copy = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function copy(dest) {
        dest.words = new Array(this.length);
        for (var i22 = 0; i22 < this.length; i22++) {
          dest.words[i22] = this.words[i22];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      }, "copy"), "copy");
      BN32.prototype.clone = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function clone() {
        var r2 = new BN32(null);
        this.copy(r2);
        return r2;
      }, "clone"), "clone");
      BN32.prototype._expand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      }, "_expand"), "_expand");
      BN32.prototype.strip = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      }, "strip"), "strip");
      BN32.prototype._normSign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      }, "_normSign"), "_normSign");
      BN32.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect5() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }, "inspect5"), "inspect");
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN32.prototype.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6(base4, padding2) {
        base4 = base4 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base4 === 16 || base4 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i22 = 0; i22 < this.length; i22++) {
            var w2 = this.words[i22];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            if (carry !== 0 || i22 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i22--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base4 === (base4 | 0) && base4 >= 2 && base4 <= 36) {
          var groupSize = groupSizes[base4];
          var groupBase = groupBases[base4];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modn(groupBase).toString(base4);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert22(false, "Base should be between 2 and 36");
      }, "toString6"), "toString");
      BN32.prototype.toNumber = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert22(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      }, "toNumber"), "toNumber");
      BN32.prototype.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
        return this.toString(16);
      }, "toJSON2"), "toJSON");
      BN32.prototype.toBuffer = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toBuffer(endian, length2) {
        assert22(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length2);
      }, "toBuffer"), "toBuffer");
      BN32.prototype.toArray = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      }, "toArray"), "toArray");
      BN32.prototype.toArrayLike = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toArrayLike(ArrayType, endian, length2) {
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert22(byteLength <= reqLength, "byte array longer than desired length");
        assert22(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i22;
        var q2 = this.clone();
        if (!littleEndian) {
          for (i22 = 0; i22 < reqLength - byteLength; i22++) {
            res[i22] = 0;
          }
          for (i22 = 0; !q2.isZero(); i22++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[reqLength - i22 - 1] = b2;
          }
        } else {
          for (i22 = 0; !q2.isZero(); i22++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[i22] = b2;
          }
          for (; i22 < reqLength; i22++) {
            res[i22] = 0;
          }
        }
        return res;
      }, "toArrayLike"), "toArrayLike");
      if (Math.clz32) {
        BN32.prototype._countBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _countBits(w2) {
          return 32 - Math.clz32(w2);
        }, "_countBits"), "_countBits");
      } else {
        BN32.prototype._countBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _countBits(w2) {
          var t2 = w2;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        }, "_countBits"), "_countBits");
      }
      BN32.prototype._zeroBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _zeroBits(w2) {
        if (w2 === 0)
          return 26;
        var t2 = w2;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      }, "_zeroBits"), "_zeroBits");
      BN32.prototype.bitLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      }, "bitLength"), "bitLength");
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w2;
      }
      __name(toBitArray, "toBitArray");
      __name2(toBitArray, "toBitArray");
      BN32.prototype.zeroBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i22 = 0; i22 < this.length; i22++) {
          var b2 = this._zeroBits(this.words[i22]);
          r2 += b2;
          if (b2 !== 26)
            break;
        }
        return r2;
      }, "zeroBits"), "zeroBits");
      BN32.prototype.byteLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, "byteLength"), "byteLength");
      BN32.prototype.toTwos = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      }, "toTwos"), "toTwos");
      BN32.prototype.fromTwos = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      }, "fromTwos"), "fromTwos");
      BN32.prototype.isNeg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isNeg() {
        return this.negative !== 0;
      }, "isNeg"), "isNeg");
      BN32.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg32() {
        return this.clone().ineg();
      }, "neg3"), "neg");
      BN32.prototype.ineg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      }, "ineg"), "ineg");
      BN32.prototype.iuor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i22 = 0; i22 < num.length; i22++) {
          this.words[i22] = this.words[i22] | num.words[i22];
        }
        return this.strip();
      }, "iuor"), "iuor");
      BN32.prototype.ior = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ior(num) {
        assert22((this.negative | num.negative) === 0);
        return this.iuor(num);
      }, "ior"), "ior");
      BN32.prototype.or = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, "or2"), "or");
      BN32.prototype.uor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, "uor"), "uor");
      BN32.prototype.iuand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i22 = 0; i22 < b2.length; i22++) {
          this.words[i22] = this.words[i22] & num.words[i22];
        }
        this.length = b2.length;
        return this.strip();
      }, "iuand"), "iuand");
      BN32.prototype.iand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iand(num) {
        assert22((this.negative | num.negative) === 0);
        return this.iuand(num);
      }, "iand"), "iand");
      BN32.prototype.and = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, "and"), "and");
      BN32.prototype.uand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, "uand"), "uand");
      BN32.prototype.iuxor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iuxor(num) {
        var a3;
        var b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        for (var i22 = 0; i22 < b2.length; i22++) {
          this.words[i22] = a3.words[i22] ^ b2.words[i22];
        }
        if (this !== a3) {
          for (; i22 < a3.length; i22++) {
            this.words[i22] = a3.words[i22];
          }
        }
        this.length = a3.length;
        return this.strip();
      }, "iuxor"), "iuxor");
      BN32.prototype.ixor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ixor(num) {
        assert22((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }, "ixor"), "ixor");
      BN32.prototype.xor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, "xor2"), "xor");
      BN32.prototype.uxor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, "uxor"), "uxor");
      BN32.prototype.inotn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inotn(width) {
        assert22(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i22 = 0; i22 < bytesNeeded; i22++) {
          this.words[i22] = ~this.words[i22] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i22] = ~this.words[i22] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      }, "inotn"), "inotn");
      BN32.prototype.notn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function notn(width) {
        return this.clone().inotn(width);
      }, "notn"), "notn");
      BN32.prototype.setn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function setn(bit, val) {
        assert22(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      }, "setn"), "setn");
      BN32.prototype.iadd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a3, b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i22 = 0; i22 < b2.length; i22++) {
          r2 = (a3.words[i22] | 0) + (b2.words[i22] | 0) + carry;
          this.words[i22] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i22 < a3.length; i22++) {
          r2 = (a3.words[i22] | 0) + carry;
          this.words[i22] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i22 < a3.length; i22++) {
            this.words[i22] = a3.words[i22];
          }
        }
        return this;
      }, "iadd"), "iadd");
      BN32.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, "add3"), "add");
      BN32.prototype.isub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b2;
        if (cmp > 0) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i22 = 0; i22 < b2.length; i22++) {
          r2 = (a3.words[i22] | 0) - (b2.words[i22] | 0) + carry;
          carry = r2 >> 26;
          this.words[i22] = r2 & 67108863;
        }
        for (; carry !== 0 && i22 < a3.length; i22++) {
          r2 = (a3.words[i22] | 0) + carry;
          carry = r2 >> 26;
          this.words[i22] = r2 & 67108863;
        }
        if (carry === 0 && i22 < a3.length && a3 !== this) {
          for (; i22 < a3.length; i22++) {
            this.words[i22] = a3.words[i22];
          }
        }
        this.length = Math.max(this.length, i22);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this.strip();
      }, "isub"), "isub");
      BN32.prototype.sub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sub(num) {
        return this.clone().isub(num);
      }, "sub"), "sub");
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a3 * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i22 = k2 - j | 0;
            a3 = self2.words[i22] | 0;
            b2 = num.words[j] | 0;
            r2 = a3 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      __name(smallMulTo, "smallMulTo");
      __name2(smallMulTo, "smallMulTo");
      var comb10MulTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c2 !== 0) {
          o[19] = c2;
          out.length++;
        }
        return out;
      }, "comb10MulTo2"), "comb10MulTo");
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i22 = k2 - j;
            var a3 = self2.words[i22] | 0;
            var b2 = num.words[j] | 0;
            var r2 = a3 * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      __name(bigMulTo, "bigMulTo");
      __name2(bigMulTo, "bigMulTo");
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      __name(jumboMulTo, "jumboMulTo");
      __name2(jumboMulTo, "jumboMulTo");
      BN32.prototype.mulTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      }, "mulTo"), "mulTo");
      function FFTM(x2, y3) {
        this.x = x2;
        this.y = y3;
      }
      __name(FFTM, "FFTM");
      __name2(FFTM, "FFTM");
      FFTM.prototype.makeRBT = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function makeRBT(N10) {
        var t2 = new Array(N10);
        var l = BN32.prototype._countBits(N10) - 1;
        for (var i22 = 0; i22 < N10; i22++) {
          t2[i22] = this.revBin(i22, l, N10);
        }
        return t2;
      }, "makeRBT"), "makeRBT");
      FFTM.prototype.revBin = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function revBin(x2, l, N10) {
        if (x2 === 0 || x2 === N10 - 1)
          return x2;
        var rb = 0;
        for (var i22 = 0; i22 < l; i22++) {
          rb |= (x2 & 1) << l - i22 - 1;
          x2 >>= 1;
        }
        return rb;
      }, "revBin"), "revBin");
      FFTM.prototype.permute = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function permute(rbt, rws, iws, rtws, itws, N10) {
        for (var i22 = 0; i22 < N10; i22++) {
          rtws[i22] = rws[rbt[i22]];
          itws[i22] = iws[rbt[i22]];
        }
      }, "permute"), "permute");
      FFTM.prototype.transform = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function transform(rws, iws, rtws, itws, N10, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N10);
        for (var s3 = 1; s3 < N10; s3 <<= 1) {
          var l = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N10; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s3; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s3];
              var io = itws[p + j + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s3] = re - ro;
              itws[p + j + s3] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      }, "transform"), "transform");
      FFTM.prototype.guessLen13b = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function guessLen13b(n, m3) {
        var N10 = Math.max(m3, n) | 1;
        var odd = N10 & 1;
        var i22 = 0;
        for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
          i22++;
        }
        return 1 << i22 + 1 + odd;
      }, "guessLen13b"), "guessLen13b");
      FFTM.prototype.conjugate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function conjugate(rws, iws, N10) {
        if (N10 <= 1)
          return;
        for (var i22 = 0; i22 < N10 / 2; i22++) {
          var t2 = rws[i22];
          rws[i22] = rws[N10 - i22 - 1];
          rws[N10 - i22 - 1] = t2;
          t2 = iws[i22];
          iws[i22] = -iws[N10 - i22 - 1];
          iws[N10 - i22 - 1] = -t2;
        }
      }, "conjugate"), "conjugate");
      FFTM.prototype.normalize13b = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function normalize13b(ws, N10) {
        var carry = 0;
        for (var i22 = 0; i22 < N10 / 2; i22++) {
          var w2 = Math.round(ws[2 * i22 + 1] / N10) * 8192 + Math.round(ws[2 * i22] / N10) + carry;
          ws[i22] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      }, "normalize13b"), "normalize13b");
      FFTM.prototype.convert13b = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convert13b(ws, len, rws, N10) {
        var carry = 0;
        for (var i22 = 0; i22 < len; i22++) {
          carry = carry + (ws[i22] | 0);
          rws[2 * i22] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i22 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i22 = 2 * len; i22 < N10; ++i22) {
          rws[i22] = 0;
        }
        assert22(carry === 0);
        assert22((carry & ~8191) === 0);
      }, "convert13b"), "convert13b");
      FFTM.prototype.stub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function stub(N10) {
        var ph = new Array(N10);
        for (var i22 = 0; i22 < N10; i22++) {
          ph[i22] = 0;
        }
        return ph;
      }, "stub"), "stub");
      FFTM.prototype.mulp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulp(x2, y3, out) {
        var N10 = 2 * this.guessLen13b(x2.length, y3.length);
        var rbt = this.makeRBT(N10);
        var _2 = this.stub(N10);
        var rws = new Array(N10);
        var rwst = new Array(N10);
        var iwst = new Array(N10);
        var nrws = new Array(N10);
        var nrwst = new Array(N10);
        var niwst = new Array(N10);
        var rmws = out.words;
        rmws.length = N10;
        this.convert13b(x2.words, x2.length, rws, N10);
        this.convert13b(y3.words, y3.length, nrws, N10);
        this.transform(rws, _2, rwst, iwst, N10, rbt);
        this.transform(nrws, _2, nrwst, niwst, N10, rbt);
        for (var i22 = 0; i22 < N10; i22++) {
          var rx = rwst[i22] * nrwst[i22] - iwst[i22] * niwst[i22];
          iwst[i22] = rwst[i22] * niwst[i22] + iwst[i22] * nrwst[i22];
          rwst[i22] = rx;
        }
        this.conjugate(rwst, iwst, N10);
        this.transform(rwst, iwst, rmws, _2, N10, rbt);
        this.conjugate(rmws, _2, N10);
        this.normalize13b(rmws, N10);
        out.negative = x2.negative ^ y3.negative;
        out.length = x2.length + y3.length;
        return out.strip();
      }, "mulp"), "mulp");
      BN32.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(num) {
        var out = new BN32(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }, "mul3"), "mul");
      BN32.prototype.mulf = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulf(num) {
        var out = new BN32(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }, "mulf"), "mulf");
      BN32.prototype.imul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imul(num) {
        return this.clone().mulTo(num, this);
      }, "imul"), "imul");
      BN32.prototype.imuln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imuln(num) {
        assert22(typeof num === "number");
        assert22(num < 67108864);
        var carry = 0;
        for (var i22 = 0; i22 < this.length; i22++) {
          var w2 = (this.words[i22] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i22] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i22] = carry;
          this.length++;
        }
        return this;
      }, "imuln"), "imuln");
      BN32.prototype.muln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function muln(num) {
        return this.clone().imuln(num);
      }, "muln"), "muln");
      BN32.prototype.sqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqr() {
        return this.mul(this);
      }, "sqr"), "sqr");
      BN32.prototype.isqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isqr() {
        return this.imul(this.clone());
      }, "isqr"), "isqr");
      BN32.prototype.pow = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0)
          return new BN32(1);
        var res = this;
        for (var i22 = 0; i22 < w2.length; i22++, res = res.sqr()) {
          if (w2[i22] !== 0)
            break;
        }
        if (++i22 < w2.length) {
          for (var q2 = res.sqr(); i22 < w2.length; i22++, q2 = q2.sqr()) {
            if (w2[i22] === 0)
              continue;
            res = res.mul(q2);
          }
        }
        return res;
      }, "pow"), "pow");
      BN32.prototype.iushln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iushln(bits) {
        assert22(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s3 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i22;
        if (r2 !== 0) {
          var carry = 0;
          for (i22 = 0; i22 < this.length; i22++) {
            var newCarry = this.words[i22] & carryMask;
            var c2 = (this.words[i22] | 0) - newCarry << r2;
            this.words[i22] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i22] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i22 = this.length - 1; i22 >= 0; i22--) {
            this.words[i22 + s3] = this.words[i22];
          }
          for (i22 = 0; i22 < s3; i22++) {
            this.words[i22] = 0;
          }
          this.length += s3;
        }
        return this.strip();
      }, "iushln"), "iushln");
      BN32.prototype.ishln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ishln(bits) {
        assert22(this.negative === 0);
        return this.iushln(bits);
      }, "ishln"), "ishln");
      BN32.prototype.iushrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iushrn(bits, hint, extended) {
        assert22(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r2 = bits % 26;
        var s3 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h3 -= s3;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i22 = 0; i22 < s3; i22++) {
            maskedWords.words[i22] = this.words[i22];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i22 = 0; i22 < this.length; i22++) {
            this.words[i22] = this.words[i22 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i22 = this.length - 1; i22 >= 0 && (carry !== 0 || i22 >= h3); i22--) {
          var word = this.words[i22] | 0;
          this.words[i22] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      }, "iushrn"), "iushrn");
      BN32.prototype.ishrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ishrn(bits, hint, extended) {
        assert22(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }, "ishrn"), "ishrn");
      BN32.prototype.shln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function shln(bits) {
        return this.clone().ishln(bits);
      }, "shln"), "shln");
      BN32.prototype.ushln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ushln(bits) {
        return this.clone().iushln(bits);
      }, "ushln"), "ushln");
      BN32.prototype.shrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function shrn(bits) {
        return this.clone().ishrn(bits);
      }, "shrn"), "shrn");
      BN32.prototype.ushrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, "ushrn"), "ushrn");
      BN32.prototype.testn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function testn(bit) {
        assert22(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s3 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s3)
          return false;
        var w2 = this.words[s3];
        return !!(w2 & q2);
      }, "testn"), "testn");
      BN32.prototype.imaskn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imaskn(bits) {
        assert22(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s3 = (bits - r2) / 26;
        assert22(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r2 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, "imaskn"), "imaskn");
      BN32.prototype.maskn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function maskn(bits) {
        return this.clone().imaskn(bits);
      }, "maskn"), "maskn");
      BN32.prototype.iaddn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iaddn(num) {
        assert22(typeof num === "number");
        assert22(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      }, "iaddn"), "iaddn");
      BN32.prototype._iaddn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _iaddn(num) {
        this.words[0] += num;
        for (var i22 = 0; i22 < this.length && this.words[i22] >= 67108864; i22++) {
          this.words[i22] -= 67108864;
          if (i22 === this.length - 1) {
            this.words[i22 + 1] = 1;
          } else {
            this.words[i22 + 1]++;
          }
        }
        this.length = Math.max(this.length, i22 + 1);
        return this;
      }, "_iaddn"), "_iaddn");
      BN32.prototype.isubn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isubn(num) {
        assert22(typeof num === "number");
        assert22(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i22 = 0; i22 < this.length && this.words[i22] < 0; i22++) {
            this.words[i22] += 67108864;
            this.words[i22 + 1] -= 1;
          }
        }
        return this.strip();
      }, "isubn"), "isubn");
      BN32.prototype.addn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function addn(num) {
        return this.clone().iaddn(num);
      }, "addn"), "addn");
      BN32.prototype.subn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function subn(num) {
        return this.clone().isubn(num);
      }, "subn"), "subn");
      BN32.prototype.iabs = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iabs() {
        this.negative = 0;
        return this;
      }, "iabs"), "iabs");
      BN32.prototype.abs = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function abs2() {
        return this.clone().iabs();
      }, "abs2"), "abs");
      BN32.prototype._ishlnsubmul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _ishlnsubmul(num, mul32, shift) {
        var len = num.length + shift;
        var i22;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i22 = 0; i22 < num.length; i22++) {
          w2 = (this.words[i22 + shift] | 0) + carry;
          var right = (num.words[i22] | 0) * mul32;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i22 + shift] = w2 & 67108863;
        }
        for (; i22 < this.length - shift; i22++) {
          w2 = (this.words[i22 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i22 + shift] = w2 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert22(carry === -1);
        carry = 0;
        for (i22 = 0; i22 < this.length; i22++) {
          w2 = -(this.words[i22] | 0) + carry;
          carry = w2 >> 26;
          this.words[i22] = w2 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      }, "_ishlnsubmul"), "_ishlnsubmul");
      BN32.prototype._wordDiv = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a3.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m3 = a3.length - b2.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN32(null);
          q2.length = m3 + 1;
          q2.words = new Array(q2.length);
          for (var i22 = 0; i22 < q2.length; i22++) {
            q2.words[i22] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b2, 1, m3);
        if (diff.negative === 0) {
          a3 = diff;
          if (q2) {
            q2.words[m3] = 1;
          }
        }
        for (var j = m3 - 1; j >= 0; j--) {
          var qj = (a3.words[b2.length + j] | 0) * 67108864 + (a3.words[b2.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b2, qj, j);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b2, 1, j);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j] = qj;
          }
        }
        if (q2) {
          q2.strip();
        }
        a3.strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a3
        };
      }, "_wordDiv"), "_wordDiv");
      BN32.prototype.divmod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function divmod(num, mode, positive) {
        assert22(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN32(0),
            mod: new BN32(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN32(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN32(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN32(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      }, "divmod"), "divmod");
      BN32.prototype.div = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function div(num) {
        return this.divmod(num, "div", false).div;
      }, "div"), "div");
      BN32.prototype.mod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      }, "mod2"), "mod");
      BN32.prototype.umod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, "umod"), "umod");
      BN32.prototype.divRound = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, "divRound"), "divRound");
      BN32.prototype.modn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function modn(num) {
        assert22(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i22 = this.length - 1; i22 >= 0; i22--) {
          acc = (p * acc + (this.words[i22] | 0)) % num;
        }
        return acc;
      }, "modn"), "modn");
      BN32.prototype.idivn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function idivn(num) {
        assert22(num <= 67108863);
        var carry = 0;
        for (var i22 = this.length - 1; i22 >= 0; i22--) {
          var w2 = (this.words[i22] | 0) + carry * 67108864;
          this.words[i22] = w2 / num | 0;
          carry = w2 % num;
        }
        return this.strip();
      }, "idivn"), "idivn");
      BN32.prototype.divn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function divn(num) {
        return this.clone().idivn(num);
      }, "divn"), "divn");
      BN32.prototype.egcd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function egcd(p) {
        assert22(p.negative === 0);
        assert22(!p.isZero());
        var x2 = this;
        var y3 = p.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p);
        } else {
          x2 = x2.clone();
        }
        var A = new BN32(1);
        var B2 = new BN32(0);
        var C = new BN32(0);
        var D2 = new BN32(1);
        var g2 = 0;
        while (x2.isEven() && y3.isEven()) {
          x2.iushrn(1);
          y3.iushrn(1);
          ++g2;
        }
        var yp = y3.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i22 = 0, im = 1; (x2.words[0] & im) === 0 && i22 < 26; ++i22, im <<= 1)
            ;
          if (i22 > 0) {
            x2.iushrn(i22);
            while (i22-- > 0) {
              if (A.isOdd() || B2.isOdd()) {
                A.iadd(yp);
                B2.isub(xp);
              }
              A.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y3.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y3.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D2.isOdd()) {
                C.iadd(yp);
                D2.isub(xp);
              }
              C.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y3) >= 0) {
            x2.isub(y3);
            A.isub(C);
            B2.isub(D2);
          } else {
            y3.isub(x2);
            C.isub(A);
            D2.isub(B2);
          }
        }
        return {
          a: C,
          b: D2,
          gcd: y3.iushln(g2)
        };
      }, "egcd"), "egcd");
      BN32.prototype._invmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _invmp(p) {
        assert22(p.negative === 0);
        assert22(!p.isZero());
        var a3 = this;
        var b2 = p.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN32(1);
        var x2 = new BN32(0);
        var delta = b2.clone();
        while (a3.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i22 = 0, im = 1; (a3.words[0] & im) === 0 && i22 < 26; ++i22, im <<= 1)
            ;
          if (i22 > 0) {
            a3.iushrn(i22);
            while (i22-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b2.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a3.cmp(b2) >= 0) {
            a3.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a3);
            x2.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      }, "_invmp"), "_invmp");
      BN32.prototype.gcd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b2 = num.clone();
        a3.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a3.isEven() && b2.isEven(); shift++) {
          a3.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a3.cmp(b2);
          if (r2 < 0) {
            var t2 = a3;
            a3 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a3.isub(b2);
        } while (true);
        return b2.iushln(shift);
      }, "gcd"), "gcd");
      BN32.prototype.invm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function invm(num) {
        return this.egcd(num).a.umod(num);
      }, "invm"), "invm");
      BN32.prototype.isEven = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isEven() {
        return (this.words[0] & 1) === 0;
      }, "isEven"), "isEven");
      BN32.prototype.isOdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isOdd() {
        return (this.words[0] & 1) === 1;
      }, "isOdd"), "isOdd");
      BN32.prototype.andln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function andln(num) {
        return this.words[0] & num;
      }, "andln"), "andln");
      BN32.prototype.bincn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bincn(bit) {
        assert22(typeof bit === "number");
        var r2 = bit % 26;
        var s3 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q2;
          return this;
        }
        var carry = q2;
        for (var i22 = s3; carry !== 0 && i22 < this.length; i22++) {
          var w2 = this.words[i22] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i22] = w2;
        }
        if (carry !== 0) {
          this.words[i22] = carry;
          this.length++;
        }
        return this;
      }, "bincn"), "bincn");
      BN32.prototype.isZero = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, "isZero"), "isZero");
      BN32.prototype.cmpn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert22(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmpn"), "cmpn");
      BN32.prototype.cmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmp"), "cmp");
      BN32.prototype.ucmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i22 = this.length - 1; i22 >= 0; i22--) {
          var a3 = this.words[i22] | 0;
          var b2 = num.words[i22] | 0;
          if (a3 === b2)
            continue;
          if (a3 < b2) {
            res = -1;
          } else if (a3 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      }, "ucmp"), "ucmp");
      BN32.prototype.gtn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gtn(num) {
        return this.cmpn(num) === 1;
      }, "gtn"), "gtn");
      BN32.prototype.gt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gt(num) {
        return this.cmp(num) === 1;
      }, "gt"), "gt");
      BN32.prototype.gten = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gten(num) {
        return this.cmpn(num) >= 0;
      }, "gten"), "gten");
      BN32.prototype.gte = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gte(num) {
        return this.cmp(num) >= 0;
      }, "gte"), "gte");
      BN32.prototype.ltn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ltn(num) {
        return this.cmpn(num) === -1;
      }, "ltn"), "ltn");
      BN32.prototype.lt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lt(num) {
        return this.cmp(num) === -1;
      }, "lt"), "lt");
      BN32.prototype.lten = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lten(num) {
        return this.cmpn(num) <= 0;
      }, "lten"), "lten");
      BN32.prototype.lte = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lte(num) {
        return this.cmp(num) <= 0;
      }, "lte"), "lte");
      BN32.prototype.eqn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eqn(num) {
        return this.cmpn(num) === 0;
      }, "eqn"), "eqn");
      BN32.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq42(num) {
        return this.cmp(num) === 0;
      }, "eq4"), "eq");
      BN32.red = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function red(num) {
        return new Red(num);
      }, "red"), "red");
      BN32.prototype.toRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toRed(ctx) {
        assert22(!this.red, "Already a number in reduction context");
        assert22(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      }, "toRed"), "toRed");
      BN32.prototype.fromRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromRed() {
        assert22(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      }, "fromRed"), "fromRed");
      BN32.prototype._forceRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _forceRed(ctx) {
        this.red = ctx;
        return this;
      }, "_forceRed"), "_forceRed");
      BN32.prototype.forceRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function forceRed(ctx) {
        assert22(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      }, "forceRed"), "forceRed");
      BN32.prototype.redAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redAdd(num) {
        assert22(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      }, "redAdd"), "redAdd");
      BN32.prototype.redIAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redIAdd(num) {
        assert22(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      }, "redIAdd"), "redIAdd");
      BN32.prototype.redSub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redSub(num) {
        assert22(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      }, "redSub"), "redSub");
      BN32.prototype.redISub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redISub(num) {
        assert22(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      }, "redISub"), "redISub");
      BN32.prototype.redShl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redShl(num) {
        assert22(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      }, "redShl"), "redShl");
      BN32.prototype.redMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redMul(num) {
        assert22(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      }, "redMul"), "redMul");
      BN32.prototype.redIMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redIMul(num) {
        assert22(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      }, "redIMul"), "redIMul");
      BN32.prototype.redSqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redSqr() {
        assert22(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      }, "redSqr"), "redSqr");
      BN32.prototype.redISqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redISqr() {
        assert22(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      }, "redISqr"), "redISqr");
      BN32.prototype.redSqrt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redSqrt() {
        assert22(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      }, "redSqrt"), "redSqrt");
      BN32.prototype.redInvm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redInvm() {
        assert22(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      }, "redInvm"), "redInvm");
      BN32.prototype.redNeg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redNeg() {
        assert22(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      }, "redNeg"), "redNeg");
      BN32.prototype.redPow = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redPow(num) {
        assert22(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      }, "redPow"), "redPow");
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name3, p) {
        this.name = name3;
        this.p = new BN32(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN32(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      __name(MPrime, "MPrime");
      __name2(MPrime, "MPrime");
      MPrime.prototype._tmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _tmp() {
        var tmp = new BN32(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      }, "_tmp"), "_tmp");
      MPrime.prototype.ireduce = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      }, "ireduce"), "ireduce");
      MPrime.prototype.split = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, "split"), "split");
      MPrime.prototype.imulK = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imulK(num) {
        return num.imul(this.k);
      }, "imulK"), "imulK");
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      __name(K256, "K256");
      __name2(K256, "K256");
      inherits(K256, MPrime);
      K256.prototype.split = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i22 = 0; i22 < outLen; i22++) {
          output.words[i22] = input.words[i22];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i22 = 10; i22 < input.length; i22++) {
          var next = input.words[i22] | 0;
          input.words[i22 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i22 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      }, "split"), "split");
      K256.prototype.imulK = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i22 = 0; i22 < num.length; i22++) {
          var w2 = num.words[i22] | 0;
          lo += w2 * 977;
          num.words[i22] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      }, "imulK"), "imulK");
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      __name(P224, "P224");
      __name2(P224, "P224");
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      __name(P192, "P192");
      __name2(P192, "P192");
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      __name(P25519, "P25519");
      __name2(P25519, "P25519");
      inherits(P25519, MPrime);
      P25519.prototype.imulK = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imulK(num) {
        var carry = 0;
        for (var i22 = 0; i22 < num.length; i22++) {
          var hi = (num.words[i22] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i22] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      }, "imulK"), "imulK");
      BN32._prime = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function prime(name3) {
        if (primes[name3])
          return primes[name3];
        var prime2;
        if (name3 === "k256") {
          prime2 = new K256();
        } else if (name3 === "p224") {
          prime2 = new P224();
        } else if (name3 === "p192") {
          prime2 = new P192();
        } else if (name3 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name3);
        }
        primes[name3] = prime2;
        return prime2;
      }, "prime"), "prime");
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN32._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert22(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      __name(Red, "Red");
      __name2(Red, "Red");
      Red.prototype._verify1 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _verify1(a3) {
        assert22(a3.negative === 0, "red works only with positives");
        assert22(a3.red, "red works only with red numbers");
      }, "_verify1"), "_verify1");
      Red.prototype._verify2 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _verify2(a3, b2) {
        assert22((a3.negative | b2.negative) === 0, "red works only with positives");
        assert22(
          a3.red && a3.red === b2.red,
          "red works only with red numbers"
        );
      }, "_verify2"), "_verify2");
      Red.prototype.imod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        return a3.umod(this.m)._forceRed(this);
      }, "imod"), "imod");
      Red.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg32(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      }, "neg3"), "neg");
      Red.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      }, "add3"), "add");
      Red.prototype.iadd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iadd(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      }, "iadd"), "iadd");
      Red.prototype.sub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      }, "sub"), "sub");
      Red.prototype.isub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      }, "isub"), "isub");
      Red.prototype.shl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      }, "shl"), "shl");
      Red.prototype.imul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imul(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.imul(b2));
      }, "imul"), "imul");
      Red.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.mul(b2));
      }, "mul3"), "mul");
      Red.prototype.isqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isqr(a3) {
        return this.imul(a3, a3.clone());
      }, "isqr"), "isqr");
      Red.prototype.sqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqr(a3) {
        return this.mul(a3, a3);
      }, "sqr"), "sqr");
      Red.prototype.sqrt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert22(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN32(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q2 = this.m.subn(1);
        var s3 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s3++;
          q2.iushrn(1);
        }
        assert22(!q2.isZero());
        var one = new BN32(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN32(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c2 = this.pow(z2, q2);
        var r2 = this.pow(a3, q2.addn(1).iushrn(1));
        var t2 = this.pow(a3, q2);
        var m3 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i22 = 0; tmp.cmp(one) !== 0; i22++) {
            tmp = tmp.redSqr();
          }
          assert22(i22 < m3);
          var b2 = this.pow(c2, new BN32(1).iushln(m3 - i22 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m3 = i22;
        }
        return r2;
      }, "sqrt"), "sqrt");
      Red.prototype.invm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      }, "invm"), "invm");
      Red.prototype.pow = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pow(a3, num) {
        if (num.isZero())
          return new BN32(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN32(1).toRed(this);
        wnd[1] = a3;
        for (var i22 = 2; i22 < wnd.length; i22++) {
          wnd[i22] = this.mul(wnd[i22 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i22 = num.length - 1; i22 >= 0; i22--) {
          var word = num.words[i22];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i22 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      }, "pow"), "pow");
      Red.prototype.convertTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      }, "convertTo"), "convertTo");
      Red.prototype.convertFrom = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }, "convertFrom"), "convertFrom");
      BN32.mont = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mont(num) {
        return new Mont(num);
      }, "mont"), "mont");
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN32(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      __name(Mont, "Mont");
      __name2(Mont, "Mont");
      inherits(Mont, Red);
      Mont.prototype.convertTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, "convertTo"), "convertTo");
      Mont.prototype.convertFrom = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      }, "convertFrom"), "convertFrom");
      Mont.prototype.imul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imul(a3, b2) {
        if (a3.isZero() || b2.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t2 = a3.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      }, "imul"), "imul");
      Mont.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(a3, b2) {
        if (a3.isZero() || b2.isZero())
          return new BN32(0)._forceRed(this);
        var t2 = a3.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      }, "mul3"), "mul");
      Mont.prototype.invm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      }, "invm"), "invm");
    })(typeof module2 === "undefined" || module2, exports);
  }
});
var require_minimalistic_assert2 = __commonJS2({
  "../../node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports, module2) {
    module2.exports = assert22;
    function assert22(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    __name(assert22, "assert2");
    __name2(assert22, "assert");
    assert22.equal = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function assertEqual22(l, r2, msg) {
      if (l != r2)
        throw new Error(msg || "Assertion failed: " + l + " != " + r2);
    }, "assertEqual2"), "assertEqual");
  }
});
var require_utils2 = __commonJS2({
  "../../node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i22 = 0; i22 < msg.length; i22++)
          res[i22] = msg[i22] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i22 = 0; i22 < msg.length; i22 += 2)
          res.push(parseInt(msg[i22] + msg[i22 + 1], 16));
      } else {
        for (var i22 = 0; i22 < msg.length; i22++) {
          var c2 = msg.charCodeAt(i22);
          var hi = c2 >> 8;
          var lo = c2 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    __name(toArray, "toArray");
    __name2(toArray, "toArray");
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    __name(zero2, "zero2");
    __name2(zero2, "zero2");
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i22 = 0; i22 < msg.length; i22++)
        res += zero2(msg[i22].toString(16));
      return res;
    }
    __name(toHex2, "toHex");
    __name2(toHex2, "toHex");
    utils.toHex = toHex2;
    utils.encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encode16(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    }, "encode16"), "encode");
  }
});
var require_utils22 = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN32 = require_bn2();
    var minAssert = require_minimalistic_assert2();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF22(num, w2, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w2 + 1;
      var k2 = num.clone();
      for (var i22 = 0; i22 < naf.length; i22++) {
        var z2;
        var mod2 = k2.andln(ws - 1);
        if (k2.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z2 = (ws >> 1) - mod2;
          else
            z2 = mod2;
          k2.isubn(z2);
        } else {
          z2 = 0;
        }
        naf[i22] = z2;
        k2.iushrn(1);
      }
      return naf;
    }
    __name(getNAF22, "getNAF2");
    __name2(getNAF22, "getNAF");
    utils.getNAF = getNAF22;
    function getJSF22(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u2 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    __name(getJSF22, "getJSF2");
    __name2(getJSF22, "getJSF");
    utils.getJSF = getJSF22;
    function cachedProperty(obj, name3, computer) {
      var key22 = "_" + name3;
      obj.prototype[name3] = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function cachedProperty2() {
        return this[key22] !== void 0 ? this[key22] : this[key22] = computer.call(this);
      }, "cachedProperty2"), "cachedProperty");
    }
    __name(cachedProperty, "cachedProperty");
    __name2(cachedProperty, "cachedProperty");
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    __name(parseBytes, "parseBytes");
    __name2(parseBytes, "parseBytes");
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN32(bytes, "hex", "le");
    }
    __name(intFromLE, "intFromLE");
    __name2(intFromLE, "intFromLE");
    utils.intFromLE = intFromLE;
  }
});
var require_brorand = __commonJS2({
  "../../node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js"(exports, module2) {
    var r2;
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function rand22(len) {
      if (!r2)
        r2 = new Rand(null);
      return r2.generate(len);
    }, "rand2"), "rand");
    function Rand(rand22) {
      this.rand = rand22;
    }
    __name(Rand, "Rand");
    __name2(Rand, "Rand");
    module2.exports.Rand = Rand;
    Rand.prototype.generate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function generate3(len) {
      return this._rand(len);
    }, "generate3"), "generate");
    Rand.prototype._rand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i22 = 0; i22 < res.length; i22++)
        res[i22] = this.rand.getByte();
      return res;
    }, "_rand"), "_rand");
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        }, "_rand"), "_rand");
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        }, "_rand"), "_rand");
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto3 = __require("crypto");
        if (typeof crypto3.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _rand(n) {
          return crypto3.randomBytes(n);
        }, "_rand"), "_rand");
      } catch (e2) {
      }
    }
    var crypto3;
  }
});
var require_base = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module2) {
    "use strict";
    var BN32 = require_bn2();
    var utils = require_utils22();
    var getNAF22 = utils.getNAF;
    var getJSF22 = utils.getJSF;
    var assert22 = utils.assert;
    function BaseCurve22(type, conf) {
      this.type = type;
      this.p = new BN32(conf.p, 16);
      this.red = conf.prime ? BN32.red(conf.prime) : BN32.mont(this.p);
      this.zero = new BN32(0).toRed(this.red);
      this.one = new BN32(1).toRed(this.red);
      this.two = new BN32(2).toRed(this.red);
      this.n = conf.n && new BN32(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    __name(BaseCurve22, "BaseCurve2");
    __name2(BaseCurve22, "BaseCurve");
    module2.exports = BaseCurve22;
    BaseCurve22.prototype.point = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function point32() {
      throw new Error("Not implemented");
    }, "point3"), "point");
    BaseCurve22.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate7() {
      throw new Error("Not implemented");
    }, "validate7"), "validate");
    BaseCurve22.prototype._fixedNafMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _fixedNafMul22(p, k2) {
      assert22(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF22(k2, 1, this._bitLength);
      var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I2 /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a3 = this.jpoint(null, null, null);
      var b2 = this.jpoint(null, null, null);
      for (var i22 = I2; i22 > 0; i22--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i22)
            b2 = b2.mixedAdd(doubles.points[j]);
          else if (nafW === -i22)
            b2 = b2.mixedAdd(doubles.points[j].neg());
        }
        a3 = a3.add(b2);
      }
      return a3.toP();
    }, "_fixedNafMul2"), "_fixedNafMul");
    BaseCurve22.prototype._wnafMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _wnafMul22(p, k2) {
      var w2 = 4;
      var nafPoints = p._getNAFPoints(w2);
      w2 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF22(k2, w2, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i22 = naf.length - 1; i22 >= 0; i22--) {
        for (var l = 0; i22 >= 0 && naf[i22] === 0; i22--)
          l++;
        if (i22 >= 0)
          l++;
        acc = acc.dblp(l);
        if (i22 < 0)
          break;
        var z2 = naf[i22];
        assert22(z2 !== 0);
        if (p.type === "affine") {
          if (z2 > 0)
            acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
        } else {
          if (z2 > 0)
            acc = acc.add(wnd[z2 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z2 - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    }, "_wnafMul2"), "_wnafMul");
    BaseCurve22.prototype._wnafMulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _wnafMulAdd22(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i22;
      var j;
      var p;
      for (i22 = 0; i22 < len; i22++) {
        p = points[i22];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i22] = nafPoints.wnd;
        wnd[i22] = nafPoints.points;
      }
      for (i22 = len - 1; i22 >= 1; i22 -= 2) {
        var a3 = i22 - 1;
        var b2 = i22;
        if (wndWidth[a3] !== 1 || wndWidth[b2] !== 1) {
          naf[a3] = getNAF22(coeffs[a3], wndWidth[a3], this._bitLength);
          naf[b2] = getNAF22(coeffs[b2], wndWidth[b2], this._bitLength);
          max = Math.max(naf[a3].length, max);
          max = Math.max(naf[b2].length, max);
          continue;
        }
        var comb = [
          points[a3],
          null,
          null,
          points[b2]
        ];
        if (points[a3].y.cmp(points[b2].y) === 0) {
          comb[1] = points[a3].add(points[b2]);
          comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
        } else if (points[a3].y.cmp(points[b2].y.redNeg()) === 0) {
          comb[1] = points[a3].toJ().mixedAdd(points[b2]);
          comb[2] = points[a3].add(points[b2].neg());
        } else {
          comb[1] = points[a3].toJ().mixedAdd(points[b2]);
          comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF22(coeffs[a3], coeffs[b2]);
        max = Math.max(jsf[0].length, max);
        naf[a3] = new Array(max);
        naf[b2] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a3][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b2][j] = 0;
          wnd[a3] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i22 = max; i22 >= 0; i22--) {
        var k2 = 0;
        while (i22 >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i22] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k2++;
          i22--;
        }
        if (i22 >= 0)
          k2++;
        acc = acc.dblp(k2);
        if (i22 < 0)
          break;
        for (j = 0; j < len; j++) {
          var z2 = tmp[j];
          p;
          if (z2 === 0)
            continue;
          else if (z2 > 0)
            p = wnd[j][z2 - 1 >> 1];
          else if (z2 < 0)
            p = wnd[j][-z2 - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i22 = 0; i22 < len; i22++)
        wnd[i22] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    }, "_wnafMulAdd2"), "_wnafMulAdd");
    function BasePoint22(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    __name(BasePoint22, "BasePoint2");
    __name2(BasePoint22, "BasePoint");
    BaseCurve22.BasePoint = BasePoint22;
    BasePoint22.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq42() {
      throw new Error("Not implemented");
    }, "eq4"), "eq");
    BasePoint22.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate7() {
      return this.curve.validate(this);
    }, "validate7"), "validate");
    BaseCurve22.prototype.decodePoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function decodePoint22(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert22(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert22(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    }, "decodePoint2"), "decodePoint");
    BasePoint22.prototype.encodeCompressed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodeCompressed22(enc) {
      return this.encode(enc, true);
    }, "encodeCompressed2"), "encodeCompressed");
    BasePoint22.prototype._encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _encode32(compact) {
      var len = this.curve.p.byteLength();
      var x2 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x2);
      return [4].concat(x2, this.getY().toArray("be", len));
    }, "_encode3"), "_encode");
    BasePoint22.prototype.encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encode16(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    }, "encode16"), "encode");
    BasePoint22.prototype.precompute = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function precompute22(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    }, "precompute2"), "precompute");
    BasePoint22.prototype._hasDoubles = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _hasDoubles22(k2) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
    }, "_hasDoubles2"), "_hasDoubles");
    BasePoint22.prototype._getDoubles = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getDoubles22(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i22 = 0; i22 < power; i22 += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    }, "_getDoubles2"), "_getDoubles");
    BasePoint22.prototype._getNAFPoints = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getNAFPoints22(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl32 = max === 1 ? null : this.dbl();
      for (var i22 = 1; i22 < max; i22++)
        res[i22] = res[i22 - 1].add(dbl32);
      return {
        wnd,
        points: res
      };
    }, "_getNAFPoints2"), "_getNAFPoints");
    BasePoint22.prototype._getBeta = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getBeta32() {
      return null;
    }, "_getBeta3"), "_getBeta");
    BasePoint22.prototype.dblp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dblp32(k2) {
      var r2 = this;
      for (var i22 = 0; i22 < k2; i22++)
        r2 = r2.dbl();
      return r2;
    }, "dblp3"), "dblp");
  }
});
var require_inherits_browser2 = __commonJS2({
  "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      }, "inherits"), "inherits");
    } else {
      module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = /* @__PURE__ */ __name2(function() {
          }, "TempCtor");
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      }, "inherits"), "inherits");
    }
  }
});
var require_short = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module2) {
    "use strict";
    var utils = require_utils22();
    var BN32 = require_bn2();
    var inherits = require_inherits_browser2();
    var Base = require_base();
    var assert22 = utils.assert;
    function ShortCurve22(conf) {
      Base.call(this, "short", conf);
      this.a = new BN32(conf.a, 16).toRed(this.red);
      this.b = new BN32(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    __name(ShortCurve22, "ShortCurve2");
    __name2(ShortCurve22, "ShortCurve");
    inherits(ShortCurve22, Base);
    module2.exports = ShortCurve22;
    ShortCurve22.prototype._getEndomorphism = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getEndomorphism22(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN32(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN32(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert22(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN32(vec.a, 16),
            b: new BN32(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    }, "_getEndomorphism2"), "_getEndomorphism");
    ShortCurve22.prototype._getEndoRoots = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getEndoRoots22(num) {
      var red = num === this.p ? this.red : BN32.mont(num);
      var tinv = new BN32(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s3 = new BN32(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s3).fromRed();
      var l2 = ntinv.redSub(s3).fromRed();
      return [l1, l2];
    }, "_getEndoRoots2"), "_getEndoRoots");
    ShortCurve22.prototype._getEndoBasis = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getEndoBasis22(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u2 = lambda;
      var v = this.n.clone();
      var x1 = new BN32(1);
      var y1 = new BN32(0);
      var x2 = new BN32(0);
      var y22 = new BN32(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b2;
      var prevR;
      var i22 = 0;
      var r2;
      var x3;
      while (u2.cmpn(0) !== 0) {
        var q2 = v.div(u2);
        r2 = v.sub(q2.mul(u2));
        x3 = x2.sub(q2.mul(x1));
        var y3 = y22.sub(q2.mul(y1));
        if (!a1 && r2.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r2.neg();
          b1 = x3;
        } else if (a1 && ++i22 === 2) {
          break;
        }
        prevR = r2;
        v = u2;
        u2 = r2;
        x2 = x1;
        x1 = x3;
        y22 = y1;
        y1 = y3;
      }
      a22 = r2.neg();
      b2 = x3;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b2 }
      ];
    }, "_getEndoBasis2"), "_getEndoBasis");
    ShortCurve22.prototype._endoSplit = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _endoSplit22(k2) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k2).divRound(this.n);
      var c2 = v1.b.neg().mul(k2).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k2.sub(p1).sub(p2);
      var k22 = q1.add(q2).neg();
      return { k1, k2: k22 };
    }, "_endoSplit2"), "_endoSplit");
    ShortCurve22.prototype.pointFromX = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromX22(x2, odd) {
      x2 = new BN32(x2, 16);
      if (!x2.red)
        x2 = x2.toRed(this.red);
      var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
      var y3 = y22.redSqrt();
      if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y3.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y3 = y3.redNeg();
      return this.point(x2, y3);
    }, "pointFromX2"), "pointFromX");
    ShortCurve22.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate7(point32) {
      if (point32.inf)
        return true;
      var x2 = point32.x;
      var y3 = point32.y;
      var ax = this.a.redMul(x2);
      var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
      return y3.redSqr().redISub(rhs).cmpn(0) === 0;
    }, "validate7"), "validate");
    ShortCurve22.prototype._endoWnafMulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _endoWnafMulAdd22(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i22 = 0; i22 < points.length; i22++) {
        var split = this._endoSplit(coeffs[i22]);
        var p = points[i22];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i22 * 2] = p;
        npoints[i22 * 2 + 1] = beta;
        ncoeffs[i22 * 2] = split.k1;
        ncoeffs[i22 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i22 * 2, jacobianResult);
      for (var j = 0; j < i22 * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    }, "_endoWnafMulAdd2"), "_endoWnafMulAdd");
    function Point22(curve, x2, y3, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x2 === null && y3 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN32(x2, 16);
        this.y = new BN32(y3, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    __name(Point22, "Point2");
    __name2(Point22, "Point");
    inherits(Point22, Base.BasePoint);
    ShortCurve22.prototype.point = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function point32(x2, y3, isRed) {
      return new Point22(this, x2, y3, isRed);
    }, "point3"), "point");
    ShortCurve22.prototype.pointFromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromJSON22(obj, red) {
      return Point22.fromJSON(this, obj, red);
    }, "pointFromJSON2"), "pointFromJSON");
    Point22.prototype._getBeta = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getBeta32() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = /* @__PURE__ */ __name2(function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        }, "endoMul");
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    }, "_getBeta3"), "_getBeta");
    Point22.prototype.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    }, "toJSON2"), "toJSON");
    Point22.fromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromJSON22(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      __name(obj2point, "obj2point");
      __name2(obj2point, "obj2point");
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    }, "fromJSON2"), "fromJSON");
    Point22.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect5() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, "inspect5"), "inspect");
    Point22.prototype.isInfinity = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isInfinity32() {
      return this.inf;
    }, "isInfinity3"), "isInfinity");
    Point22.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c2 = this.y.redSub(p.y);
      if (c2.cmpn(0) !== 0)
        c2 = c2.redMul(this.x.redSub(p.x).redInvm());
      var nx = c2.redSqr().redISub(this.x).redISub(p.x);
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }, "add3"), "add");
    Point22.prototype.dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dbl32() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a3 = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a3).redMul(dyinv);
      var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }, "dbl3"), "dbl");
    Point22.prototype.getX = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getX22() {
      return this.x.fromRed();
    }, "getX2"), "getX");
    Point22.prototype.getY = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getY22() {
      return this.y.fromRed();
    }, "getY2"), "getY");
    Point22.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(k2) {
      k2 = new BN32(k2, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k2]);
      else
        return this.curve._wnafMul(this, k2);
    }, "mul3"), "mul");
    Point22.prototype.mulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulAdd22(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    }, "mulAdd2"), "mulAdd");
    Point22.prototype.jmulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function jmulAdd22(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    }, "jmulAdd2"), "jmulAdd");
    Point22.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq42(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    }, "eq4"), "eq");
    Point22.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg32(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = /* @__PURE__ */ __name2(function(p) {
          return p.neg();
        }, "negate");
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    }, "neg3"), "neg");
    Point22.prototype.toJ = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJ22() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    }, "toJ2"), "toJ");
    function JPoint22(curve, x2, y3, z2) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x2 === null && y3 === null && z2 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN32(0);
      } else {
        this.x = new BN32(x2, 16);
        this.y = new BN32(y3, 16);
        this.z = new BN32(z2, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    __name(JPoint22, "JPoint2");
    __name2(JPoint22, "JPoint");
    inherits(JPoint22, Base.BasePoint);
    ShortCurve22.prototype.jpoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function jpoint22(x2, y3, z2) {
      return new JPoint22(this, x2, y3, z2);
    }, "jpoint2"), "jpoint");
    JPoint22.prototype.toP = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toP22() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    }, "toP2"), "toP");
    JPoint22.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg32() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, "neg3"), "neg");
    JPoint22.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s22 = p.y.redMul(z2.redMul(this.z));
      var h3 = u1.redSub(u2);
      var r2 = s1.redSub(s22);
      if (h3.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h3.redSqr();
      var h32 = h22.redMul(h3);
      var v = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h32).redISub(v).redISub(v);
      var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p.z).redMul(h3);
      return this.curve.jpoint(nx, ny, nz);
    }, "add3"), "add");
    JPoint22.prototype.mixedAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mixedAdd22(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s22 = p.y.redMul(z2).redMul(this.z);
      var h3 = u1.redSub(u2);
      var r2 = s1.redSub(s22);
      if (h3.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h3.redSqr();
      var h32 = h22.redMul(h3);
      var v = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h32).redISub(v).redISub(v);
      var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h3);
      return this.curve.jpoint(nx, ny, nz);
    }, "mixedAdd2"), "mixedAdd");
    JPoint22.prototype.dblp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dblp32(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i22;
      if (this.curve.zeroA || this.curve.threeA) {
        var r2 = this;
        for (i22 = 0; i22 < pow; i22++)
          r2 = r2.dbl();
        return r2;
      }
      var a3 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i22 = 0; i22 < pow; i22++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c2.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c2.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i22 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    }, "dblp3"), "dblp");
    JPoint22.prototype.dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dbl32() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    }, "dbl3"), "dbl");
    JPoint22.prototype._zeroDbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _zeroDbl22() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s3 = s3.redIAdd(s3);
        var m3 = xx.redAdd(xx).redIAdd(xx);
        var t2 = m3.redSqr().redISub(s3).redISub(s3);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t2;
        ny = m3.redMul(s3.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a3 = this.x.redSqr();
        var b2 = this.y.redSqr();
        var c2 = b2.redSqr();
        var d3 = this.x.redAdd(b2).redSqr().redISub(a3).redISub(c2);
        d3 = d3.redIAdd(d3);
        var e2 = a3.redAdd(a3).redIAdd(a3);
        var f = e2.redSqr();
        var c8 = c2.redIAdd(c2);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d3).redISub(d3);
        ny = e2.redMul(d3.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    }, "_zeroDbl2"), "_zeroDbl");
    JPoint22.prototype._threeDbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _threeDbl22() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s3 = s3.redIAdd(s3);
        var m3 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t2 = m3.redSqr().redISub(s3).redISub(s3);
        nx = t2;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m3.redMul(s3.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    }, "_threeDbl2"), "_threeDbl");
    JPoint22.prototype._dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _dbl22() {
      var a3 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c2.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c2.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    }, "_dbl2"), "_dbl");
    JPoint22.prototype.trpl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function trpl22() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m3 = xx.redAdd(xx).redIAdd(xx);
      var mm = m3.redSqr();
      var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e2 = e2.redIAdd(e2);
      e2 = e2.redAdd(e2).redIAdd(e2);
      e2 = e2.redISub(mm);
      var ee = e2.redSqr();
      var t2 = yyyy.redIAdd(yyyy);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      var u2 = m3.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
      var yyu4 = yy.redMul(u2);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    }, "trpl2"), "trpl");
    JPoint22.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(k2, kbase) {
      k2 = new BN32(k2, kbase);
      return this.curve._wnafMul(this, k2);
    }, "mul3"), "mul");
    JPoint22.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq42(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    }, "eq4"), "eq");
    JPoint22.prototype.eqXToP = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eqXToP22(x2) {
      var zs = this.z.redSqr();
      var rx = x2.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x2.clone();
      var t2 = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    }, "eqXToP2"), "eqXToP");
    JPoint22.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect5() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, "inspect5"), "inspect");
    JPoint22.prototype.isInfinity = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isInfinity32() {
      return this.z.cmpn(0) === 0;
    }, "isInfinity3"), "isInfinity");
  }
});
var require_mont = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module2) {
    "use strict";
    var BN32 = require_bn2();
    var inherits = require_inherits_browser2();
    var Base = require_base();
    var utils = require_utils22();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN32(conf.a, 16).toRed(this.red);
      this.b = new BN32(conf.b, 16).toRed(this.red);
      this.i4 = new BN32(4).toRed(this.red).redInvm();
      this.two = new BN32(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    __name(MontCurve, "MontCurve");
    __name2(MontCurve, "MontCurve");
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate7(point32) {
      var x2 = point32.normalize().x;
      var x22 = x2.redSqr();
      var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
      var y3 = rhs.redSqrt();
      return y3.redSqr().cmp(rhs) === 0;
    }, "validate7"), "validate");
    function Point22(curve, x2, z2) {
      Base.BasePoint.call(this, curve, "projective");
      if (x2 === null && z2 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN32(x2, 16);
        this.z = new BN32(z2, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    __name(Point22, "Point2");
    __name2(Point22, "Point");
    inherits(Point22, Base.BasePoint);
    MontCurve.prototype.decodePoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function decodePoint22(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    }, "decodePoint2"), "decodePoint");
    MontCurve.prototype.point = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function point32(x2, z2) {
      return new Point22(this, x2, z2);
    }, "point3"), "point");
    MontCurve.prototype.pointFromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromJSON22(obj) {
      return Point22.fromJSON(this, obj);
    }, "pointFromJSON2"), "pointFromJSON");
    Point22.prototype.precompute = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function precompute22() {
    }, "precompute2"), "precompute");
    Point22.prototype._encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _encode32() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    }, "_encode3"), "_encode");
    Point22.fromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromJSON22(curve, obj) {
      return new Point22(curve, obj[0], obj[1] || curve.one);
    }, "fromJSON2"), "fromJSON");
    Point22.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect5() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, "inspect5"), "inspect");
    Point22.prototype.isInfinity = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isInfinity32() {
      return this.z.cmpn(0) === 0;
    }, "isInfinity3"), "isInfinity");
    Point22.prototype.dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dbl32() {
      var a3 = this.x.redAdd(this.z);
      var aa = a3.redSqr();
      var b2 = this.x.redSub(this.z);
      var bb = b2.redSqr();
      var c2 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
      return this.curve.point(nx, nz);
    }, "dbl3"), "dbl");
    Point22.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32() {
      throw new Error("Not supported on Montgomery curve");
    }, "add3"), "add");
    Point22.prototype.diffAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function diffAdd(p, diff) {
      var a3 = this.x.redAdd(this.z);
      var b2 = this.x.redSub(this.z);
      var c2 = p.x.redAdd(p.z);
      var d3 = p.x.redSub(p.z);
      var da = d3.redMul(a3);
      var cb = c2.redMul(b2);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    }, "diffAdd"), "diffAdd");
    Point22.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(k2) {
      var t2 = k2.clone();
      var a3 = this;
      var b2 = this.curve.point(null, null);
      var c2 = this;
      for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
        bits.push(t2.andln(1));
      for (var i22 = bits.length - 1; i22 >= 0; i22--) {
        if (bits[i22] === 0) {
          a3 = a3.diffAdd(b2, c2);
          b2 = b2.dbl();
        } else {
          b2 = a3.diffAdd(b2, c2);
          a3 = a3.dbl();
        }
      }
      return b2;
    }, "mul3"), "mul");
    Point22.prototype.mulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulAdd22() {
      throw new Error("Not supported on Montgomery curve");
    }, "mulAdd2"), "mulAdd");
    Point22.prototype.jumlAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    }, "jumlAdd"), "jumlAdd");
    Point22.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq42(other) {
      return this.getX().cmp(other.getX()) === 0;
    }, "eq4"), "eq");
    Point22.prototype.normalize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function normalize2() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    }, "normalize"), "normalize");
    Point22.prototype.getX = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getX22() {
      this.normalize();
      return this.x.fromRed();
    }, "getX2"), "getX");
  }
});
var require_edwards = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module2) {
    "use strict";
    var utils = require_utils22();
    var BN32 = require_bn2();
    var inherits = require_inherits_browser2();
    var Base = require_base();
    var assert22 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN32(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN32(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN32(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert22(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    __name(EdwardsCurve, "EdwardsCurve");
    __name2(EdwardsCurve, "EdwardsCurve");
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    }, "_mulA"), "_mulA");
    EdwardsCurve.prototype._mulC = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    }, "_mulC"), "_mulC");
    EdwardsCurve.prototype.jpoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function jpoint22(x2, y3, z2, t2) {
      return this.point(x2, y3, z2, t2);
    }, "jpoint2"), "jpoint");
    EdwardsCurve.prototype.pointFromX = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromX22(x2, odd) {
      x2 = new BN32(x2, 16);
      if (!x2.red)
        x2 = x2.toRed(this.red);
      var x22 = x2.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y3 = y22.redSqrt();
      if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y3.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y3 = y3.redNeg();
      return this.point(x2, y3);
    }, "pointFromX2"), "pointFromX");
    EdwardsCurve.prototype.pointFromY = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromY(y3, odd) {
      y3 = new BN32(y3, 16);
      if (!y3.red)
        y3 = y3.toRed(this.red);
      var y22 = y3.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y3);
      }
      var x3 = x2.redSqrt();
      if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x3.fromRed().isOdd() !== odd)
        x3 = x3.redNeg();
      return this.point(x3, y3);
    }, "pointFromY"), "pointFromY");
    EdwardsCurve.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate7(point32) {
      if (point32.isInfinity())
        return true;
      point32.normalize();
      var x2 = point32.x.redSqr();
      var y22 = point32.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    }, "validate7"), "validate");
    function Point22(curve, x2, y3, z2, t2) {
      Base.BasePoint.call(this, curve, "projective");
      if (x2 === null && y3 === null && z2 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN32(x2, 16);
        this.y = new BN32(y3, 16);
        this.z = z2 ? new BN32(z2, 16) : this.curve.one;
        this.t = t2 && new BN32(t2, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    __name(Point22, "Point2");
    __name2(Point22, "Point");
    inherits(Point22, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromJSON22(obj) {
      return Point22.fromJSON(this, obj);
    }, "pointFromJSON2"), "pointFromJSON");
    EdwardsCurve.prototype.point = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function point32(x2, y3, z2, t2) {
      return new Point22(this, x2, y3, z2, t2);
    }, "point3"), "point");
    Point22.fromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromJSON22(curve, obj) {
      return new Point22(curve, obj[0], obj[1], obj[2]);
    }, "fromJSON2"), "fromJSON");
    Point22.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect5() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, "inspect5"), "inspect");
    Point22.prototype.isInfinity = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isInfinity32() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, "isInfinity3"), "isInfinity");
    Point22.prototype._extDbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _extDbl() {
      var a3 = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c2 = this.z.redSqr();
      c2 = c2.redIAdd(c2);
      var d3 = this.curve._mulA(a3);
      var e2 = this.x.redAdd(this.y).redSqr().redISub(a3).redISub(b2);
      var g2 = d3.redAdd(b2);
      var f = g2.redSub(c2);
      var h3 = d3.redSub(b2);
      var nx = e2.redMul(f);
      var ny = g2.redMul(h3);
      var nt = e2.redMul(h3);
      var nz = f.redMul(g2);
      return this.curve.point(nx, ny, nz, nt);
    }, "_extDbl"), "_extDbl");
    Point22.prototype._projDbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _projDbl() {
      var b2 = this.x.redAdd(this.y).redSqr();
      var c2 = this.x.redSqr();
      var d3 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e2;
      var h3;
      var j;
      if (this.curve.twisted) {
        e2 = this.curve._mulA(c2);
        var f = e2.redAdd(d3);
        if (this.zOne) {
          nx = b2.redSub(c2).redSub(d3).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e2.redSub(d3));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h3 = this.z.redSqr();
          j = f.redSub(h3).redISub(h3);
          nx = b2.redSub(c2).redISub(d3).redMul(j);
          ny = f.redMul(e2.redSub(d3));
          nz = f.redMul(j);
        }
      } else {
        e2 = c2.redAdd(d3);
        h3 = this.curve._mulC(this.z).redSqr();
        j = e2.redSub(h3).redSub(h3);
        nx = this.curve._mulC(b2.redISub(e2)).redMul(j);
        ny = this.curve._mulC(e2).redMul(c2.redISub(d3));
        nz = e2.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    }, "_projDbl"), "_projDbl");
    Point22.prototype.dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dbl32() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    }, "dbl3"), "dbl");
    Point22.prototype._extAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _extAdd(p) {
      var a3 = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b2 = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c2 = this.t.redMul(this.curve.dd).redMul(p.t);
      var d3 = this.z.redMul(p.z.redAdd(p.z));
      var e2 = b2.redSub(a3);
      var f = d3.redSub(c2);
      var g2 = d3.redAdd(c2);
      var h3 = b2.redAdd(a3);
      var nx = e2.redMul(f);
      var ny = g2.redMul(h3);
      var nt = e2.redMul(h3);
      var nz = f.redMul(g2);
      return this.curve.point(nx, ny, nz, nt);
    }, "_extAdd"), "_extAdd");
    Point22.prototype._projAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _projAdd(p) {
      var a3 = this.z.redMul(p.z);
      var b2 = a3.redSqr();
      var c2 = this.x.redMul(p.x);
      var d3 = this.y.redMul(p.y);
      var e2 = this.curve.d.redMul(c2).redMul(d3);
      var f = b2.redSub(e2);
      var g2 = b2.redAdd(e2);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c2).redISub(d3);
      var nx = a3.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a3.redMul(g2).redMul(d3.redSub(this.curve._mulA(c2)));
        nz = f.redMul(g2);
      } else {
        ny = a3.redMul(g2).redMul(d3.redSub(c2));
        nz = this.curve._mulC(f).redMul(g2);
      }
      return this.curve.point(nx, ny, nz);
    }, "_projAdd"), "_projAdd");
    Point22.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    }, "add3"), "add");
    Point22.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(k2) {
      if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else
        return this.curve._wnafMul(this, k2);
    }, "mul3"), "mul");
    Point22.prototype.mulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulAdd22(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    }, "mulAdd2"), "mulAdd");
    Point22.prototype.jmulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function jmulAdd22(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    }, "jmulAdd2"), "jmulAdd");
    Point22.prototype.normalize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function normalize2() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    }, "normalize"), "normalize");
    Point22.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg32() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    }, "neg3"), "neg");
    Point22.prototype.getX = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getX22() {
      this.normalize();
      return this.x.fromRed();
    }, "getX2"), "getX");
    Point22.prototype.getY = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getY22() {
      this.normalize();
      return this.y.fromRed();
    }, "getY2"), "getY");
    Point22.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq42(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    }, "eq4"), "eq");
    Point22.prototype.eqXToP = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eqXToP22(x2) {
      var rx = x2.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x2.clone();
      var t2 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    }, "eqXToP2"), "eqXToP");
    Point22.prototype.toP = Point22.prototype.normalize;
    Point22.prototype.mixedAdd = Point22.prototype.add;
  }
});
var require_curve = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});
var require_utils3 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert22 = require_minimalistic_assert2();
    var inherits = require_inherits_browser2();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i22) {
      if ((msg.charCodeAt(i22) & 64512) !== 55296) {
        return false;
      }
      if (i22 < 0 || i22 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i22 + 1) & 64512) === 56320;
    }
    __name(isSurrogatePair, "isSurrogatePair");
    __name2(isSurrogatePair, "isSurrogatePair");
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i22 = 0; i22 < msg.length; i22++) {
            var c2 = msg.charCodeAt(i22);
            if (c2 < 128) {
              res[p++] = c2;
            } else if (c2 < 2048) {
              res[p++] = c2 >> 6 | 192;
              res[p++] = c2 & 63 | 128;
            } else if (isSurrogatePair(msg, i22)) {
              c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i22) & 1023);
              res[p++] = c2 >> 18 | 240;
              res[p++] = c2 >> 12 & 63 | 128;
              res[p++] = c2 >> 6 & 63 | 128;
              res[p++] = c2 & 63 | 128;
            } else {
              res[p++] = c2 >> 12 | 224;
              res[p++] = c2 >> 6 & 63 | 128;
              res[p++] = c2 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i22 = 0; i22 < msg.length; i22 += 2)
            res.push(parseInt(msg[i22] + msg[i22 + 1], 16));
        }
      } else {
        for (i22 = 0; i22 < msg.length; i22++)
          res[i22] = msg[i22] | 0;
      }
      return res;
    }
    __name(toArray, "toArray");
    __name2(toArray, "toArray");
    exports.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i22 = 0; i22 < msg.length; i22++)
        res += zero2(msg[i22].toString(16));
      return res;
    }
    __name(toHex2, "toHex");
    __name2(toHex2, "toHex");
    exports.toHex = toHex2;
    function htonl(w2) {
      var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
      return res >>> 0;
    }
    __name(htonl, "htonl");
    __name2(htonl, "htonl");
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i22 = 0; i22 < msg.length; i22++) {
        var w2 = msg[i22];
        if (endian === "little")
          w2 = htonl(w2);
        res += zero8(w2.toString(16));
      }
      return res;
    }
    __name(toHex32, "toHex32");
    __name2(toHex32, "toHex32");
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    __name(zero2, "zero2");
    __name2(zero2, "zero2");
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    __name(zero8, "zero8");
    __name2(zero8, "zero8");
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert22(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i22 = 0, k2 = start; i22 < res.length; i22++, k2 += 4) {
        var w2;
        if (endian === "big")
          w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
        else
          w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
        res[i22] = w2 >>> 0;
      }
      return res;
    }
    __name(join32, "join32");
    __name2(join32, "join32");
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i22 = 0, k2 = 0; i22 < msg.length; i22++, k2 += 4) {
        var m3 = msg[i22];
        if (endian === "big") {
          res[k2] = m3 >>> 24;
          res[k2 + 1] = m3 >>> 16 & 255;
          res[k2 + 2] = m3 >>> 8 & 255;
          res[k2 + 3] = m3 & 255;
        } else {
          res[k2 + 3] = m3 >>> 24;
          res[k2 + 2] = m3 >>> 16 & 255;
          res[k2 + 1] = m3 >>> 8 & 255;
          res[k2] = m3 & 255;
        }
      }
      return res;
    }
    __name(split32, "split32");
    __name2(split32, "split32");
    exports.split32 = split32;
    function rotr32(w2, b2) {
      return w2 >>> b2 | w2 << 32 - b2;
    }
    __name(rotr32, "rotr32");
    __name2(rotr32, "rotr32");
    exports.rotr32 = rotr32;
    function rotl32(w2, b2) {
      return w2 << b2 | w2 >>> 32 - b2;
    }
    __name(rotl32, "rotl32");
    __name2(rotl32, "rotl32");
    exports.rotl32 = rotl32;
    function sum32(a3, b2) {
      return a3 + b2 >>> 0;
    }
    __name(sum32, "sum32");
    __name2(sum32, "sum32");
    exports.sum32 = sum32;
    function sum32_3(a3, b2, c2) {
      return a3 + b2 + c2 >>> 0;
    }
    __name(sum32_3, "sum32_3");
    __name2(sum32_3, "sum32_3");
    exports.sum32_3 = sum32_3;
    function sum32_4(a3, b2, c2, d3) {
      return a3 + b2 + c2 + d3 >>> 0;
    }
    __name(sum32_4, "sum32_4");
    __name2(sum32_4, "sum32_4");
    exports.sum32_4 = sum32_4;
    function sum32_5(a3, b2, c2, d3, e2) {
      return a3 + b2 + c2 + d3 + e2 >>> 0;
    }
    __name(sum32_5, "sum32_5");
    __name2(sum32_5, "sum32_5");
    exports.sum32_5 = sum32_5;
    function sum64(buf2, pos, ah, al) {
      var bh = buf2[pos];
      var bl = buf2[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf2[pos] = hi >>> 0;
      buf2[pos + 1] = lo;
    }
    __name(sum64, "sum64");
    __name2(sum64, "sum64");
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    __name(sum64_hi, "sum64_hi");
    __name2(sum64_hi, "sum64_hi");
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    __name(sum64_lo, "sum64_lo");
    __name2(sum64_lo, "sum64_lo");
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    __name(sum64_4_hi, "sum64_4_hi");
    __name2(sum64_4_hi, "sum64_4_hi");
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    __name(sum64_4_lo, "sum64_4_lo");
    __name2(sum64_4_lo, "sum64_4_lo");
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    __name(sum64_5_hi, "sum64_5_hi");
    __name2(sum64_5_hi, "sum64_5_hi");
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    __name(sum64_5_lo, "sum64_5_lo");
    __name2(sum64_5_lo, "sum64_5_lo");
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r2 = al << 32 - num | ah >>> num;
      return r2 >>> 0;
    }
    __name(rotr64_hi, "rotr64_hi");
    __name2(rotr64_hi, "rotr64_hi");
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    __name(rotr64_lo, "rotr64_lo");
    __name2(rotr64_lo, "rotr64_lo");
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    __name(shr64_hi, "shr64_hi");
    __name2(shr64_hi, "shr64_hi");
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    __name(shr64_lo, "shr64_lo");
    __name2(shr64_lo, "shr64_lo");
    exports.shr64_lo = shr64_lo;
  }
});
var require_common3 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var assert22 = require_minimalistic_assert2();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    __name(BlockHash, "BlockHash");
    __name2(BlockHash, "BlockHash");
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function update22(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r2 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r2, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r2, this.endian);
        for (var i22 = 0; i22 < msg.length; i22 += this._delta32)
          this._update(msg, i22, i22 + this._delta32);
      }
      return this;
    }, "update2"), "update");
    BlockHash.prototype.digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      this.update(this._pad());
      assert22(this.pending === null);
      return this._digest(enc);
    }, "digest2"), "digest");
    BlockHash.prototype._pad = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k2 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k2 + this.padLength);
      res[0] = 128;
      for (var i22 = 1; i22 < k2; i22++)
        res[i22] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t2 = 8; t2 < this.padLength; t2++)
          res[i22++] = 0;
        res[i22++] = 0;
        res[i22++] = 0;
        res[i22++] = 0;
        res[i22++] = 0;
        res[i22++] = len >>> 24 & 255;
        res[i22++] = len >>> 16 & 255;
        res[i22++] = len >>> 8 & 255;
        res[i22++] = len & 255;
      } else {
        res[i22++] = len & 255;
        res[i22++] = len >>> 8 & 255;
        res[i22++] = len >>> 16 & 255;
        res[i22++] = len >>> 24 & 255;
        res[i22++] = 0;
        res[i22++] = 0;
        res[i22++] = 0;
        res[i22++] = 0;
        for (t2 = 8; t2 < this.padLength; t2++)
          res[i22++] = 0;
      }
      return res;
    }, "pad2"), "pad");
  }
});
var require_common22 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s3, x2, y3, z2) {
      if (s3 === 0)
        return ch32(x2, y3, z2);
      if (s3 === 1 || s3 === 3)
        return p32(x2, y3, z2);
      if (s3 === 2)
        return maj32(x2, y3, z2);
    }
    __name(ft_1, "ft_1");
    __name2(ft_1, "ft_1");
    exports.ft_1 = ft_1;
    function ch32(x2, y3, z2) {
      return x2 & y3 ^ ~x2 & z2;
    }
    __name(ch32, "ch32");
    __name2(ch32, "ch32");
    exports.ch32 = ch32;
    function maj32(x2, y3, z2) {
      return x2 & y3 ^ x2 & z2 ^ y3 & z2;
    }
    __name(maj32, "maj32");
    __name2(maj32, "maj32");
    exports.maj32 = maj32;
    function p32(x2, y3, z2) {
      return x2 ^ y3 ^ z2;
    }
    __name(p32, "p32");
    __name2(p32, "p32");
    exports.p32 = p32;
    function s0_256(x2) {
      return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
    }
    __name(s0_256, "s0_256");
    __name2(s0_256, "s0_256");
    exports.s0_256 = s0_256;
    function s1_256(x2) {
      return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
    }
    __name(s1_256, "s1_256");
    __name2(s1_256, "s1_256");
    exports.s1_256 = s1_256;
    function g0_256(x2) {
      return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
    }
    __name(g0_256, "g0_256");
    __name2(g0_256, "g0_256");
    exports.g0_256 = g0_256;
    function g1_256(x2) {
      return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
    }
    __name(g1_256, "g1_256");
    __name2(g1_256, "g1_256");
    exports.g1_256 = g1_256;
  }
});
var require__6 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common3();
    var shaCommon = require_common22();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    __name(SHA1, "SHA1");
    __name2(SHA1, "SHA1");
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _update(msg, start) {
      var W = this.W;
      for (var i22 = 0; i22 < 16; i22++)
        W[i22] = msg[start + i22];
      for (; i22 < W.length; i22++)
        W[i22] = rotl32(W[i22 - 3] ^ W[i22 - 8] ^ W[i22 - 14] ^ W[i22 - 16], 1);
      var a3 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d3 = this.h[3];
      var e2 = this.h[4];
      for (i22 = 0; i22 < W.length; i22++) {
        var s3 = ~~(i22 / 20);
        var t2 = sum32_5(rotl32(a3, 5), ft_1(s3, b2, c2, d3), e2, W[i22], sha1_K[s3]);
        e2 = d3;
        d3 = c2;
        c2 = rotl32(b2, 30);
        b2 = a3;
        a3 = t2;
      }
      this.h[0] = sum32(this.h[0], a3);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d3);
      this.h[4] = sum32(this.h[4], e2);
    }, "_update"), "_update");
    SHA1.prototype._digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest2"), "digest");
  }
});
var require__22 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common3();
    var shaCommon = require_common22();
    var assert22 = require_minimalistic_assert2();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    __name(SHA256, "SHA256");
    __name2(SHA256, "SHA256");
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _update(msg, start) {
      var W = this.W;
      for (var i22 = 0; i22 < 16; i22++)
        W[i22] = msg[start + i22];
      for (; i22 < W.length; i22++)
        W[i22] = sum32_4(g1_256(W[i22 - 2]), W[i22 - 7], g0_256(W[i22 - 15]), W[i22 - 16]);
      var a3 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d3 = this.h[3];
      var e2 = this.h[4];
      var f = this.h[5];
      var g2 = this.h[6];
      var h3 = this.h[7];
      assert22(this.k.length === W.length);
      for (i22 = 0; i22 < W.length; i22++) {
        var T1 = sum32_5(h3, s1_256(e2), ch32(e2, f, g2), this.k[i22], W[i22]);
        var T2 = sum32(s0_256(a3), maj32(a3, b2, c2));
        h3 = g2;
        g2 = f;
        f = e2;
        e2 = sum32(d3, T1);
        d3 = c2;
        c2 = b2;
        b2 = a3;
        a3 = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a3);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d3);
      this.h[4] = sum32(this.h[4], e2);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g2);
      this.h[7] = sum32(this.h[7], h3);
    }, "_update"), "_update");
    SHA256.prototype._digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest2"), "digest");
  }
});
var require__32 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA256 = require__22();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    __name(SHA224, "SHA224");
    __name2(SHA224, "SHA224");
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    }, "digest2"), "digest");
  }
});
var require__42 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common3();
    var assert22 = require_minimalistic_assert2();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    __name(SHA512, "SHA512");
    __name2(SHA512, "SHA512");
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i22 = 0; i22 < 32; i22++)
        W[i22] = msg[start + i22];
      for (; i22 < W.length; i22 += 2) {
        var c0_hi = g1_512_hi(W[i22 - 4], W[i22 - 3]);
        var c0_lo = g1_512_lo(W[i22 - 4], W[i22 - 3]);
        var c1_hi = W[i22 - 14];
        var c1_lo = W[i22 - 13];
        var c2_hi = g0_512_hi(W[i22 - 30], W[i22 - 29]);
        var c2_lo = g0_512_lo(W[i22 - 30], W[i22 - 29]);
        var c3_hi = W[i22 - 32];
        var c3_lo = W[i22 - 31];
        W[i22] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i22 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    }, "_prepareBlock"), "_prepareBlock");
    SHA512.prototype._update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert22(this.k.length === W.length);
      for (var i22 = 0; i22 < W.length; i22 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i22];
        var c3_lo = this.k[i22 + 1];
        var c4_hi = W[i22];
        var c4_lo = W[i22 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    }, "_update"), "_update");
    SHA512.prototype._digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest2"), "digest");
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ ~xh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(ch64_hi, "ch64_hi");
    __name2(ch64_hi, "ch64_hi");
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ ~xl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(ch64_lo, "ch64_lo");
    __name2(ch64_lo, "ch64_lo");
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ xh & zh ^ yh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(maj64_hi, "maj64_hi");
    __name2(maj64_hi, "maj64_hi");
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ xl & zl ^ yl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(maj64_lo, "maj64_lo");
    __name2(maj64_lo, "maj64_lo");
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s0_512_hi, "s0_512_hi");
    __name2(s0_512_hi, "s0_512_hi");
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s0_512_lo, "s0_512_lo");
    __name2(s0_512_lo, "s0_512_lo");
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s1_512_hi, "s1_512_hi");
    __name2(s1_512_hi, "s1_512_hi");
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(s1_512_lo, "s1_512_lo");
    __name2(s1_512_lo, "s1_512_lo");
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g0_512_hi, "g0_512_hi");
    __name2(g0_512_hi, "g0_512_hi");
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g0_512_lo, "g0_512_lo");
    __name2(g0_512_lo, "g0_512_lo");
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g1_512_hi, "g1_512_hi");
    __name2(g1_512_hi, "g1_512_hi");
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    __name(g1_512_lo, "g1_512_lo");
    __name2(g1_512_lo, "g1_512_lo");
  }
});
var require__52 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__42();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    __name(SHA384, "SHA384");
    __name2(SHA384, "SHA384");
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    }, "digest2"), "digest");
  }
});
var require_sha2 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__6();
    exports.sha224 = require__32();
    exports.sha256 = require__22();
    exports.sha384 = require__52();
    exports.sha512 = require__42();
  }
});
var require_ripemd2 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var common = require_common3();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    __name(RIPEMD160, "RIPEMD160");
    __name2(RIPEMD160, "RIPEMD160");
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function update22(msg, start) {
      var A = this.h[0];
      var B2 = this.h[1];
      var C = this.h[2];
      var D2 = this.h[3];
      var E2 = this.h[4];
      var Ah = A;
      var Bh = B2;
      var Ch = C;
      var Dh = D2;
      var Eh = E2;
      for (var j = 0; j < 80; j++) {
        var T2 = sum32(
          rotl32(
            sum32_4(A, f(j, B2, C, D2), msg[r2[j] + start], K2(j)),
            s3[j]
          ),
          E2
        );
        A = E2;
        E2 = D2;
        D2 = rotl32(C, 10);
        C = B2;
        B2 = T2;
        T2 = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T2;
      }
      T2 = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D2, Eh);
      this.h[2] = sum32_3(this.h[3], E2, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B2, Ch);
      this.h[0] = T2;
    }, "update2"), "update");
    RIPEMD160.prototype._digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    }, "digest2"), "digest");
    function f(j, x2, y3, z2) {
      if (j <= 15)
        return x2 ^ y3 ^ z2;
      else if (j <= 31)
        return x2 & y3 | ~x2 & z2;
      else if (j <= 47)
        return (x2 | ~y3) ^ z2;
      else if (j <= 63)
        return x2 & z2 | y3 & ~z2;
      else
        return x2 ^ (y3 | ~z2);
    }
    __name(f, "f");
    __name2(f, "f");
    function K2(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    __name(K2, "K2");
    __name2(K2, "K");
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    __name(Kh, "Kh");
    __name2(Kh, "Kh");
    var r2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s3 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});
var require_hmac2 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var assert22 = require_minimalistic_assert2();
    function Hmac(hash3, key22, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key22, enc);
      this.Hash = hash3;
      this.blockSize = hash3.blockSize / 8;
      this.outSize = hash3.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key22, enc));
    }
    __name(Hmac, "Hmac");
    __name2(Hmac, "Hmac");
    module2.exports = Hmac;
    Hmac.prototype._init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init4(key22) {
      if (key22.length > this.blockSize)
        key22 = new this.Hash().update(key22).digest();
      assert22(key22.length <= this.blockSize);
      for (var i22 = key22.length; i22 < this.blockSize; i22++)
        key22.push(0);
      for (i22 = 0; i22 < key22.length; i22++)
        key22[i22] ^= 54;
      this.inner = new this.Hash().update(key22);
      for (i22 = 0; i22 < key22.length; i22++)
        key22[i22] ^= 106;
      this.outer = new this.Hash().update(key22);
    }, "init4"), "init");
    Hmac.prototype.update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function update22(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    }, "update2"), "update");
    Hmac.prototype.digest = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function digest2(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    }, "digest2"), "digest");
  }
});
var require_hash2 = __commonJS2({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js"(exports) {
    var hash3 = exports;
    hash3.utils = require_utils3();
    hash3.common = require_common3();
    hash3.sha = require_sha2();
    hash3.ripemd = require_ripemd2();
    hash3.hmac = require_hmac2();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  }
});
var require_secp256k1 = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});
var require_curves = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash3 = require_hash2();
    var curve = require_curve();
    var utils = require_utils22();
    var assert22 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert22(this.g.validate(), "Invalid curve");
      assert22(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    __name(PresetCurve, "PresetCurve");
    __name2(PresetCurve, "PresetCurve");
    curves.PresetCurve = PresetCurve;
    function defineCurve(name3, options) {
      Object.defineProperty(curves, name3, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name3, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    __name(defineCurve, "defineCurve");
    __name2(defineCurve, "defineCurve");
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash3.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash3.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e2) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash3.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});
var require_hmac_drbg = __commonJS2({
  "../../node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module2) {
    "use strict";
    var hash3 = require_hash2();
    var utils = require_utils2();
    var assert22 = require_minimalistic_assert2();
    function HmacDRBG22(options) {
      if (!(this instanceof HmacDRBG22))
        return new HmacDRBG22(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert22(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    __name(HmacDRBG22, "HmacDRBG2");
    __name2(HmacDRBG22, "HmacDRBG");
    module2.exports = HmacDRBG22;
    HmacDRBG22.prototype._init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init4(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i22 = 0; i22 < this.V.length; i22++) {
        this.K[i22] = 0;
        this.V[i22] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    }, "init4"), "init");
    HmacDRBG22.prototype._hmac = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function hmac22() {
      return new hash3.hmac(this.hash, this.K);
    }, "hmac2"), "hmac");
    HmacDRBG22.prototype._update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function update22(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    }, "update2"), "update");
    HmacDRBG22.prototype.reseed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function reseed22(entropy, entropyEnc, add32, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add32;
        add32 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add32 = utils.toArray(add32, addEnc);
      assert22(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add32 || []));
      this._reseed = 1;
    }, "reseed2"), "reseed");
    HmacDRBG22.prototype.generate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function generate3(len, enc, add32, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add32;
        add32 = enc;
        enc = null;
      }
      if (add32) {
        add32 = utils.toArray(add32, addEnc || "hex");
        this._update(add32);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add32);
      this._reseed++;
      return utils.encode(res, enc);
    }, "generate3"), "generate");
  }
});
var require_key = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module2) {
    "use strict";
    var BN32 = require_bn2();
    var utils = require_utils22();
    var assert22 = utils.assert;
    function KeyPair22(ec3, options) {
      this.ec = ec3;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    __name(KeyPair22, "KeyPair2");
    __name2(KeyPair22, "KeyPair");
    module2.exports = KeyPair22;
    KeyPair22.fromPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromPublic22(ec3, pub, enc) {
      if (pub instanceof KeyPair22)
        return pub;
      return new KeyPair22(ec3, {
        pub,
        pubEnc: enc
      });
    }, "fromPublic2"), "fromPublic");
    KeyPair22.fromPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromPrivate22(ec3, priv, enc) {
      if (priv instanceof KeyPair22)
        return priv;
      return new KeyPair22(ec3, {
        priv,
        privEnc: enc
      });
    }, "fromPrivate2"), "fromPrivate");
    KeyPair22.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate7() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    }, "validate7"), "validate");
    KeyPair22.prototype.getPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPublic22(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    }, "getPublic2"), "getPublic");
    KeyPair22.prototype.getPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPrivate22(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    }, "getPrivate2"), "getPrivate");
    KeyPair22.prototype._importPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _importPrivate22(key22, enc) {
      this.priv = new BN32(key22, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    }, "_importPrivate2"), "_importPrivate");
    KeyPair22.prototype._importPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _importPublic22(key22, enc) {
      if (key22.x || key22.y) {
        if (this.ec.curve.type === "mont") {
          assert22(key22.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert22(key22.x && key22.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key22.x, key22.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key22, enc);
    }, "_importPublic2"), "_importPublic");
    KeyPair22.prototype.derive = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function derive22(pub) {
      if (!pub.validate()) {
        assert22(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    }, "derive2"), "derive");
    KeyPair22.prototype.sign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign5(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    }, "sign5"), "sign");
    KeyPair22.prototype.verify = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function verify4(msg, signature22) {
      return this.ec.verify(msg, signature22, this);
    }, "verify4"), "verify");
    KeyPair22.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect5() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    }, "inspect5"), "inspect");
  }
});
var require_signature = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module2) {
    "use strict";
    var BN32 = require_bn2();
    var utils = require_utils22();
    var assert22 = utils.assert;
    function Signature22(options, enc) {
      if (options instanceof Signature22)
        return options;
      if (this._importDER(options, enc))
        return;
      assert22(options.r && options.s, "Signature without r or s");
      this.r = new BN32(options.r, 16);
      this.s = new BN32(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    __name(Signature22, "Signature2");
    __name2(Signature22, "Signature");
    module2.exports = Signature22;
    function Position22() {
      this.place = 0;
    }
    __name(Position22, "Position2");
    __name2(Position22, "Position");
    function getLength22(buf2, p) {
      var initial = buf2[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i22 = 0, off = p.place; i22 < octetLen; i22++, off++) {
        val <<= 8;
        val |= buf2[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    __name(getLength22, "getLength2");
    __name2(getLength22, "getLength");
    function rmPadding22(buf2) {
      var i22 = 0;
      var len = buf2.length - 1;
      while (!buf2[i22] && !(buf2[i22 + 1] & 128) && i22 < len) {
        i22++;
      }
      if (i22 === 0) {
        return buf2;
      }
      return buf2.slice(i22);
    }
    __name(rmPadding22, "rmPadding2");
    __name2(rmPadding22, "rmPadding");
    Signature22.prototype._importDER = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _importDER22(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position22();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength22(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength22(data, p);
      if (rlen === false) {
        return false;
      }
      var r2 = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength22(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s3 = data.slice(p.place, slen + p.place);
      if (r2[0] === 0) {
        if (r2[1] & 128) {
          r2 = r2.slice(1);
        } else {
          return false;
        }
      }
      if (s3[0] === 0) {
        if (s3[1] & 128) {
          s3 = s3.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN32(r2);
      this.s = new BN32(s3);
      this.recoveryParam = null;
      return true;
    }, "_importDER2"), "_importDER");
    function constructLength22(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    __name(constructLength22, "constructLength2");
    __name2(constructLength22, "constructLength");
    Signature22.prototype.toDER = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toDER22(enc) {
      var r2 = this.r.toArray();
      var s3 = this.s.toArray();
      if (r2[0] & 128)
        r2 = [0].concat(r2);
      if (s3[0] & 128)
        s3 = [0].concat(s3);
      r2 = rmPadding22(r2);
      s3 = rmPadding22(s3);
      while (!s3[0] && !(s3[1] & 128)) {
        s3 = s3.slice(1);
      }
      var arr = [2];
      constructLength22(arr, r2.length);
      arr = arr.concat(r2);
      arr.push(2);
      constructLength22(arr, s3.length);
      var backHalf = arr.concat(s3);
      var res = [48];
      constructLength22(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    }, "toDER2"), "toDER");
  }
});
var require_ec = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module2) {
    "use strict";
    var BN32 = require_bn2();
    var HmacDRBG22 = require_hmac_drbg();
    var utils = require_utils22();
    var curves = require_curves();
    var rand22 = require_brorand();
    var assert22 = utils.assert;
    var KeyPair22 = require_key();
    var Signature22 = require_signature();
    function EC22(options) {
      if (!(this instanceof EC22))
        return new EC22(options);
      if (typeof options === "string") {
        assert22(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    __name(EC22, "EC2");
    __name2(EC22, "EC");
    module2.exports = EC22;
    EC22.prototype.keyPair = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyPair22(options) {
      return new KeyPair22(this, options);
    }, "keyPair2"), "keyPair");
    EC22.prototype.keyFromPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyFromPrivate22(priv, enc) {
      return KeyPair22.fromPrivate(this, priv, enc);
    }, "keyFromPrivate2"), "keyFromPrivate");
    EC22.prototype.keyFromPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyFromPublic22(pub, enc) {
      return KeyPair22.fromPublic(this, pub, enc);
    }, "keyFromPublic2"), "keyFromPublic");
    EC22.prototype.genKeyPair = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function genKeyPair22(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG22({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand22(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN32(2));
      for (; ; ) {
        var priv = new BN32(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    }, "genKeyPair2"), "genKeyPair");
    EC22.prototype._truncateToN = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _truncateToN22(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    }, "_truncateToN2"), "_truncateToN");
    EC22.prototype.sign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign5(msg, key22, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key22 = this.keyFromPrivate(key22, enc);
      msg = this._truncateToN(new BN32(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key22.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG22({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN32(1));
      for (var iter = 0; ; iter++) {
        var k2 = options.k ? options.k(iter) : new BN32(drbg.generate(this.n.byteLength()));
        k2 = this._truncateToN(k2, true);
        if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k2);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r2 = kpX.umod(this.n);
        if (r2.cmpn(0) === 0)
          continue;
        var s3 = k2.invm(this.n).mul(r2.mul(key22.getPrivate()).iadd(msg));
        s3 = s3.umod(this.n);
        if (s3.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
        if (options.canonical && s3.cmp(this.nh) > 0) {
          s3 = this.n.sub(s3);
          recoveryParam ^= 1;
        }
        return new Signature22({ r: r2, s: s3, recoveryParam });
      }
    }, "sign5"), "sign");
    EC22.prototype.verify = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function verify4(msg, signature22, key22, enc) {
      msg = this._truncateToN(new BN32(msg, 16));
      key22 = this.keyFromPublic(key22, enc);
      signature22 = new Signature22(signature22, "hex");
      var r2 = signature22.r;
      var s3 = signature22.s;
      if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
        return false;
      if (s3.cmpn(1) < 0 || s3.cmp(this.n) >= 0)
        return false;
      var sinv = s3.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r2).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key22.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r2) === 0;
      }
      p = this.g.jmulAdd(u1, key22.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r2);
    }, "verify4"), "verify");
    EC22.prototype.recoverPubKey = function(msg, signature22, j, enc) {
      assert22((3 & j) === j, "The recovery param is more than two bits");
      signature22 = new Signature22(signature22, enc);
      var n = this.n;
      var e2 = new BN32(msg);
      var r2 = signature22.r;
      var s3 = signature22.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
      else
        r2 = this.curve.pointFromX(r2, isYOdd);
      var rInv = signature22.r.invm(n);
      var s1 = n.sub(e2).mul(rInv).umod(n);
      var s22 = s3.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r2, s22);
    };
    EC22.prototype.getKeyRecoveryParam = function(e2, signature22, Q2, enc) {
      signature22 = new Signature22(signature22, enc);
      if (signature22.recoveryParam !== null)
        return signature22.recoveryParam;
      for (var i22 = 0; i22 < 4; i22++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e2, signature22, i22);
        } catch (e3) {
          continue;
        }
        if (Qprime.eq(Q2))
          return i22;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});
var require_key2 = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module2) {
    "use strict";
    var utils = require_utils22();
    var assert22 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair22(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    __name(KeyPair22, "KeyPair2");
    __name2(KeyPair22, "KeyPair");
    KeyPair22.fromPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromPublic22(eddsa, pub) {
      if (pub instanceof KeyPair22)
        return pub;
      return new KeyPair22(eddsa, { pub });
    }, "fromPublic2"), "fromPublic");
    KeyPair22.fromSecret = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair22)
        return secret;
      return new KeyPair22(eddsa, { secret });
    }, "fromSecret"), "fromSecret");
    KeyPair22.prototype.secret = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function secret() {
      return this._secret;
    }, "secret"), "secret");
    cachedProperty(KeyPair22, "pubBytes", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    }, "pubBytes"), "pubBytes"));
    cachedProperty(KeyPair22, "pub", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    }, "pub"), "pub"));
    cachedProperty(KeyPair22, "privBytes", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function privBytes() {
      var eddsa = this.eddsa;
      var hash3 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a3 = hash3.slice(0, eddsa.encodingLength);
      a3[0] &= 248;
      a3[lastIx] &= 127;
      a3[lastIx] |= 64;
      return a3;
    }, "privBytes"), "privBytes"));
    cachedProperty(KeyPair22, "priv", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    }, "priv"), "priv"));
    cachedProperty(KeyPair22, "hash", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function hash3() {
      return this.eddsa.hash().update(this.secret()).digest();
    }, "hash3"), "hash"));
    cachedProperty(KeyPair22, "messagePrefix", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function messagePrefix22() {
      return this.hash().slice(this.eddsa.encodingLength);
    }, "messagePrefix2"), "messagePrefix"));
    KeyPair22.prototype.sign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign5(message) {
      assert22(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    }, "sign5"), "sign");
    KeyPair22.prototype.verify = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function verify4(message, sig) {
      return this.eddsa.verify(message, sig, this);
    }, "verify4"), "verify");
    KeyPair22.prototype.getSecret = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getSecret(enc) {
      assert22(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    }, "getSecret"), "getSecret");
    KeyPair22.prototype.getPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPublic22(enc) {
      return utils.encode(this.pubBytes(), enc);
    }, "getPublic2"), "getPublic");
    module2.exports = KeyPair22;
  }
});
var require_signature2 = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module2) {
    "use strict";
    var BN32 = require_bn2();
    var utils = require_utils22();
    var assert22 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature22(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert22(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN32)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    __name(Signature22, "Signature2");
    __name2(Signature22, "Signature");
    cachedProperty(Signature22, "S", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function S3() {
      return this.eddsa.decodeInt(this.Sencoded());
    }, "S3"), "S"));
    cachedProperty(Signature22, "R", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function R2() {
      return this.eddsa.decodePoint(this.Rencoded());
    }, "R2"), "R"));
    cachedProperty(Signature22, "Rencoded", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    }, "Rencoded"), "Rencoded"));
    cachedProperty(Signature22, "Sencoded", /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    }, "Sencoded"), "Sencoded"));
    Signature22.prototype.toBytes = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    }, "toBytes"), "toBytes");
    Signature22.prototype.toHex = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toHex2() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    }, "toHex"), "toHex");
    module2.exports = Signature22;
  }
});
var require_eddsa = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module2) {
    "use strict";
    var hash3 = require_hash2();
    var curves = require_curves();
    var utils = require_utils22();
    var assert22 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair22 = require_key2();
    var Signature22 = require_signature2();
    function EDDSA(curve) {
      assert22(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash3.sha512;
    }
    __name(EDDSA, "EDDSA");
    __name2(EDDSA, "EDDSA");
    module2.exports = EDDSA;
    EDDSA.prototype.sign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign5(message, secret) {
      message = parseBytes(message);
      var key22 = this.keyFromSecret(secret);
      var r2 = this.hashInt(key22.messagePrefix(), message);
      var R2 = this.g.mul(r2);
      var Rencoded = this.encodePoint(R2);
      var s_ = this.hashInt(Rencoded, key22.pubBytes(), message).mul(key22.priv());
      var S3 = r2.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R2, S: S3, Rencoded });
    }, "sign5"), "sign");
    EDDSA.prototype.verify = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function verify4(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key22 = this.keyFromPublic(pub);
      var h3 = this.hashInt(sig.Rencoded(), key22.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key22.pub().mul(h3));
      return RplusAh.eq(SG);
    }, "verify4"), "verify");
    EDDSA.prototype.hashInt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function hashInt() {
      var hash4 = this.hash();
      for (var i22 = 0; i22 < arguments.length; i22++)
        hash4.update(arguments[i22]);
      return utils.intFromLE(hash4.digest()).umod(this.curve.n);
    }, "hashInt"), "hashInt");
    EDDSA.prototype.keyFromPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyFromPublic22(pub) {
      return KeyPair22.fromPublic(this, pub);
    }, "keyFromPublic2"), "keyFromPublic");
    EDDSA.prototype.keyFromSecret = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyFromSecret(secret) {
      return KeyPair22.fromSecret(this, secret);
    }, "keyFromSecret"), "keyFromSecret");
    EDDSA.prototype.makeSignature = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function makeSignature(sig) {
      if (sig instanceof Signature22)
        return sig;
      return new Signature22(this, sig);
    }, "makeSignature"), "makeSignature");
    EDDSA.prototype.encodePoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodePoint(point32) {
      var enc = point32.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point32.getX().isOdd() ? 128 : 0;
      return enc;
    }, "encodePoint"), "encodePoint");
    EDDSA.prototype.decodePoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function decodePoint22(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y3 = utils.intFromLE(normed);
      return this.curve.pointFromY(y3, xIsOdd);
    }, "decodePoint2"), "decodePoint");
    EDDSA.prototype.encodeInt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    }, "encodeInt"), "encodeInt");
    EDDSA.prototype.decodeInt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    }, "decodeInt"), "decodeInt");
    EDDSA.prototype.isPoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isPoint(val) {
      return val instanceof this.pointClass;
    }, "isPoint"), "isPoint");
  }
});
var require_elliptic = __commonJS2({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils22();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});
var require_browser = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+random@1.0.2/node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = /* @__PURE__ */ __name(class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length2);
        for (let i22 = 0; i22 < out.length; i22 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i22, i22 + Math.min(out.length - i22, QUOTA)));
        }
        return out;
      }
    }, "BrowserRandomSource");
    __name2(BrowserRandomSource, "BrowserRandomSource");
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});
var require_node = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+random@1.0.2/node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = /* @__PURE__ */ __name(class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = __require("crypto");
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer2 = this._crypto.randomBytes(length2);
        if (buffer2.length !== length2) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length2);
        for (let i22 = 0; i22 < out.length; i22++) {
          out[i22] = buffer2[i22];
        }
        (0, wipe_1.wipe)(buffer2);
        return out;
      }
    }, "NodeRandomSource");
    __name2(NodeRandomSource, "NodeRandomSource");
    exports.NodeRandomSource = NodeRandomSource;
  }
});
var require_system = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+random@1.0.2/node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = /* @__PURE__ */ __name(class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length2);
      }
    }, "SystemRandomSource");
    __name2(SystemRandomSource, "SystemRandomSource");
    exports.SystemRandomSource = SystemRandomSource;
  }
});
var require_random = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+random@1.0.2/node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes5(length2, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length2);
    }
    __name(randomBytes5, "randomBytes5");
    __name2(randomBytes5, "randomBytes");
    exports.randomBytes = randomBytes5;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf2 = randomBytes5(4, prng);
      const result = (0, binary_1.readUint32LE)(buf2);
      (0, wipe_1.wipe)(buf2);
      return result;
    }
    __name(randomUint32, "randomUint32");
    __name2(randomUint32, "randomUint32");
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString2(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        const buf2 = randomBytes5(Math.ceil(length2 * 256 / maxByte), prng);
        for (let i22 = 0; i22 < buf2.length && length2 > 0; i22++) {
          const randomByte = buf2[i22];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        (0, wipe_1.wipe)(buf2);
      }
      return out;
    }
    __name(randomString2, "randomString2");
    __name2(randomString2, "randomString");
    exports.randomString = randomString2;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString2(length2, charset, prng);
    }
    __name(randomStringForEntropy, "randomStringForEntropy");
    __name2(randomStringForEntropy, "randomStringForEntropy");
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});
var require_sha512 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+sha512@1.0.1/node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = function() {
      function SHA5122() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._stateHi = new Int32Array(8);
        this._stateLo = new Int32Array(8);
        this._tempHi = new Int32Array(16);
        this._tempLo = new Int32Array(16);
        this._buffer = new Uint8Array(256);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      __name(SHA5122, "SHA5122");
      __name2(SHA5122, "SHA512");
      SHA5122.prototype._initState = function() {
        this._stateHi[0] = 1779033703;
        this._stateHi[1] = 3144134277;
        this._stateHi[2] = 1013904242;
        this._stateHi[3] = 2773480762;
        this._stateHi[4] = 1359893119;
        this._stateHi[5] = 2600822924;
        this._stateHi[6] = 528734635;
        this._stateHi[7] = 1541459225;
        this._stateLo[0] = 4089235720;
        this._stateLo[1] = 2227873595;
        this._stateLo[2] = 4271175723;
        this._stateLo[3] = 1595750129;
        this._stateLo[4] = 2917565137;
        this._stateLo[5] = 725511199;
        this._stateLo[6] = 4215389547;
        this._stateLo[7] = 327033209;
      };
      SHA5122.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA5122.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._tempHi);
        wipe_1.wipe(this._tempLo);
        this.reset();
      };
      SHA5122.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA512: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA5122.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 128 < 112 ? 128 : 256;
          this._buffer[left] = 128;
          for (var i22 = left + 1; i22 < padLength - 8; i22++) {
            this._buffer[i22] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i22 = 0; i22 < this.digestLength / 8; i22++) {
          binary_1.writeUint32BE(this._stateHi[i22], out, i22 * 8);
          binary_1.writeUint32BE(this._stateLo[i22], out, i22 * 8 + 4);
        }
        return this;
      };
      SHA5122.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA5122.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA5122.prototype.restoreState = function(savedState) {
        this._stateHi.set(savedState.stateHi);
        this._stateLo.set(savedState.stateLo);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA5122.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.stateHi);
        wipe_1.wipe(savedState.stateLo);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA5122;
    }();
    exports.SHA512 = SHA512;
    var K2 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m3, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h3, l;
      var th, tl;
      var a3, b2, c2, d3;
      while (len >= 128) {
        for (var i22 = 0; i22 < 16; i22++) {
          var j = 8 * i22 + pos;
          wh[i22] = binary_1.readUint32BE(m3, j);
          wl[i22] = binary_1.readUint32BE(m3, j + 4);
        }
        for (var i22 = 0; i22 < 80; i22++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h3 = ah7;
          l = al7;
          a3 = l & 65535;
          b2 = l >>> 16;
          c2 = h3 & 65535;
          d3 = h3 >>> 16;
          h3 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a3 += l & 65535;
          b2 += l >>> 16;
          c2 += h3 & 65535;
          d3 += h3 >>> 16;
          h3 = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a3 += l & 65535;
          b2 += l >>> 16;
          c2 += h3 & 65535;
          d3 += h3 >>> 16;
          h3 = K2[i22 * 2];
          l = K2[i22 * 2 + 1];
          a3 += l & 65535;
          b2 += l >>> 16;
          c2 += h3 & 65535;
          d3 += h3 >>> 16;
          h3 = wh[i22 % 16];
          l = wl[i22 % 16];
          a3 += l & 65535;
          b2 += l >>> 16;
          c2 += h3 & 65535;
          d3 += h3 >>> 16;
          b2 += a3 >>> 16;
          c2 += b2 >>> 16;
          d3 += c2 >>> 16;
          th = c2 & 65535 | d3 << 16;
          tl = a3 & 65535 | b2 << 16;
          h3 = th;
          l = tl;
          a3 = l & 65535;
          b2 = l >>> 16;
          c2 = h3 & 65535;
          d3 = h3 >>> 16;
          h3 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a3 += l & 65535;
          b2 += l >>> 16;
          c2 += h3 & 65535;
          d3 += h3 >>> 16;
          h3 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a3 += l & 65535;
          b2 += l >>> 16;
          c2 += h3 & 65535;
          d3 += h3 >>> 16;
          b2 += a3 >>> 16;
          c2 += b2 >>> 16;
          d3 += c2 >>> 16;
          bh7 = c2 & 65535 | d3 << 16;
          bl7 = a3 & 65535 | b2 << 16;
          h3 = bh3;
          l = bl3;
          a3 = l & 65535;
          b2 = l >>> 16;
          c2 = h3 & 65535;
          d3 = h3 >>> 16;
          h3 = th;
          l = tl;
          a3 += l & 65535;
          b2 += l >>> 16;
          c2 += h3 & 65535;
          d3 += h3 >>> 16;
          b2 += a3 >>> 16;
          c2 += b2 >>> 16;
          d3 += c2 >>> 16;
          bh3 = c2 & 65535 | d3 << 16;
          bl3 = a3 & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i22 % 16 === 15) {
            for (var j = 0; j < 16; j++) {
              h3 = wh[j];
              l = wl[j];
              a3 = l & 65535;
              b2 = l >>> 16;
              c2 = h3 & 65535;
              d3 = h3 >>> 16;
              h3 = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a3 += l & 65535;
              b2 += l >>> 16;
              c2 += h3 & 65535;
              d3 += h3 >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h3 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a3 += l & 65535;
              b2 += l >>> 16;
              c2 += h3 & 65535;
              d3 += h3 >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h3 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a3 += l & 65535;
              b2 += l >>> 16;
              c2 += h3 & 65535;
              d3 += h3 >>> 16;
              b2 += a3 >>> 16;
              c2 += b2 >>> 16;
              d3 += c2 >>> 16;
              wh[j] = c2 & 65535 | d3 << 16;
              wl[j] = a3 & 65535 | b2 << 16;
            }
          }
        }
        h3 = ah0;
        l = al0;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[0];
        l = hl[0];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[0] = ah0 = c2 & 65535 | d3 << 16;
        hl[0] = al0 = a3 & 65535 | b2 << 16;
        h3 = ah1;
        l = al1;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[1];
        l = hl[1];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[1] = ah1 = c2 & 65535 | d3 << 16;
        hl[1] = al1 = a3 & 65535 | b2 << 16;
        h3 = ah2;
        l = al2;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[2];
        l = hl[2];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[2] = ah2 = c2 & 65535 | d3 << 16;
        hl[2] = al2 = a3 & 65535 | b2 << 16;
        h3 = ah3;
        l = al3;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[3];
        l = hl[3];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[3] = ah3 = c2 & 65535 | d3 << 16;
        hl[3] = al3 = a3 & 65535 | b2 << 16;
        h3 = ah4;
        l = al4;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[4];
        l = hl[4];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[4] = ah4 = c2 & 65535 | d3 << 16;
        hl[4] = al4 = a3 & 65535 | b2 << 16;
        h3 = ah5;
        l = al5;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[5];
        l = hl[5];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[5] = ah5 = c2 & 65535 | d3 << 16;
        hl[5] = al5 = a3 & 65535 | b2 << 16;
        h3 = ah6;
        l = al6;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[6];
        l = hl[6];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[6] = ah6 = c2 & 65535 | d3 << 16;
        hl[6] = al6 = a3 & 65535 | b2 << 16;
        h3 = ah7;
        l = al7;
        a3 = l & 65535;
        b2 = l >>> 16;
        c2 = h3 & 65535;
        d3 = h3 >>> 16;
        h3 = hh[7];
        l = hl[7];
        a3 += l & 65535;
        b2 += l >>> 16;
        c2 += h3 & 65535;
        d3 += h3 >>> 16;
        b2 += a3 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[7] = ah7 = c2 & 65535 | d3 << 16;
        hl[7] = al7 = a3 & 65535 | b2 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    __name(hashBlocks, "hashBlocks");
    __name2(hashBlocks, "hashBlocks");
    function hash3(data) {
      var h3 = new SHA512();
      h3.update(data);
      var digest2 = h3.digest();
      h3.clean();
      return digest2;
    }
    __name(hash3, "hash3");
    __name2(hash3, "hash");
    exports.hash = hash3;
  }
});
var require_ed25519 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+ed25519@1.0.3/node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init4) {
      const r2 = new Float64Array(16);
      if (init4) {
        for (let i22 = 0; i22 < init4.length; i22++) {
          r2[i22] = init4[i22];
        }
      }
      return r2;
    }
    __name(gf, "gf");
    __name2(gf, "gf");
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D2 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X2 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y2 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I2 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r2, a3) {
      for (let i22 = 0; i22 < 16; i22++) {
        r2[i22] = a3[i22] | 0;
      }
    }
    __name(set25519, "set25519");
    __name2(set25519, "set25519");
    function car25519(o) {
      let c2 = 1;
      for (let i22 = 0; i22 < 16; i22++) {
        let v = o[i22] + c2 + 65535;
        c2 = Math.floor(v / 65536);
        o[i22] = v - c2 * 65536;
      }
      o[0] += c2 - 1 + 37 * (c2 - 1);
    }
    __name(car25519, "car25519");
    __name2(car25519, "car25519");
    function sel25519(p, q2, b2) {
      const c2 = ~(b2 - 1);
      for (let i22 = 0; i22 < 16; i22++) {
        const t2 = c2 & (p[i22] ^ q2[i22]);
        p[i22] ^= t2;
        q2[i22] ^= t2;
      }
    }
    __name(sel25519, "sel25519");
    __name2(sel25519, "sel25519");
    function pack25519(o, n) {
      const m3 = gf();
      const t2 = gf();
      for (let i22 = 0; i22 < 16; i22++) {
        t2[i22] = n[i22];
      }
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (let j = 0; j < 2; j++) {
        m3[0] = t2[0] - 65517;
        for (let i22 = 1; i22 < 15; i22++) {
          m3[i22] = t2[i22] - 65535 - (m3[i22 - 1] >> 16 & 1);
          m3[i22 - 1] &= 65535;
        }
        m3[15] = t2[15] - 32767 - (m3[14] >> 16 & 1);
        const b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t2, m3, 1 - b2);
      }
      for (let i22 = 0; i22 < 16; i22++) {
        o[2 * i22] = t2[i22] & 255;
        o[2 * i22 + 1] = t2[i22] >> 8;
      }
    }
    __name(pack25519, "pack25519");
    __name2(pack25519, "pack25519");
    function verify32(x2, y3) {
      let d3 = 0;
      for (let i22 = 0; i22 < 32; i22++) {
        d3 |= x2[i22] ^ y3[i22];
      }
      return (1 & d3 - 1 >>> 8) - 1;
    }
    __name(verify32, "verify32");
    __name2(verify32, "verify32");
    function neq25519(a3, b2) {
      const c2 = new Uint8Array(32);
      const d3 = new Uint8Array(32);
      pack25519(c2, a3);
      pack25519(d3, b2);
      return verify32(c2, d3);
    }
    __name(neq25519, "neq25519");
    __name2(neq25519, "neq25519");
    function par25519(a3) {
      const d3 = new Uint8Array(32);
      pack25519(d3, a3);
      return d3[0] & 1;
    }
    __name(par25519, "par25519");
    __name2(par25519, "par25519");
    function unpack25519(o, n) {
      for (let i22 = 0; i22 < 16; i22++) {
        o[i22] = n[2 * i22] + (n[2 * i22 + 1] << 8);
      }
      o[15] &= 32767;
    }
    __name(unpack25519, "unpack25519");
    __name2(unpack25519, "unpack25519");
    function add32(o, a3, b2) {
      for (let i22 = 0; i22 < 16; i22++) {
        o[i22] = a3[i22] + b2[i22];
      }
    }
    __name(add32, "add3");
    __name2(add32, "add");
    function sub(o, a3, b2) {
      for (let i22 = 0; i22 < 16; i22++) {
        o[i22] = a3[i22] - b2[i22];
      }
    }
    __name(sub, "sub");
    __name2(sub, "sub");
    function mul32(o, a3, b2) {
      let v, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v = a3[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b22;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a3[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b22;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a3[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b22;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a3[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b22;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a3[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b22;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a3[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b22;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a3[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b22;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a3[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b22;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a3[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b22;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a3[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b22;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a3[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b22;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a3[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b22;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a3[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b22;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a3[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b22;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a3[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b22;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a3[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b22;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    __name(mul32, "mul3");
    __name2(mul32, "mul");
    function square(o, a3) {
      mul32(o, a3, a3);
    }
    __name(square, "square");
    __name2(square, "square");
    function inv25519(o, i22) {
      const c2 = gf();
      let a3;
      for (a3 = 0; a3 < 16; a3++) {
        c2[a3] = i22[a3];
      }
      for (a3 = 253; a3 >= 0; a3--) {
        square(c2, c2);
        if (a3 !== 2 && a3 !== 4) {
          mul32(c2, c2, i22);
        }
      }
      for (a3 = 0; a3 < 16; a3++) {
        o[a3] = c2[a3];
      }
    }
    __name(inv25519, "inv25519");
    __name2(inv25519, "inv25519");
    function pow2523(o, i22) {
      const c2 = gf();
      let a3;
      for (a3 = 0; a3 < 16; a3++) {
        c2[a3] = i22[a3];
      }
      for (a3 = 250; a3 >= 0; a3--) {
        square(c2, c2);
        if (a3 !== 1) {
          mul32(c2, c2, i22);
        }
      }
      for (a3 = 0; a3 < 16; a3++) {
        o[a3] = c2[a3];
      }
    }
    __name(pow2523, "pow2523");
    __name2(pow2523, "pow2523");
    function edadd(p, q2) {
      const a3 = gf(), b2 = gf(), c2 = gf(), d3 = gf(), e2 = gf(), f = gf(), g2 = gf(), h3 = gf(), t2 = gf();
      sub(a3, p[1], p[0]);
      sub(t2, q2[1], q2[0]);
      mul32(a3, a3, t2);
      add32(b2, p[0], p[1]);
      add32(t2, q2[0], q2[1]);
      mul32(b2, b2, t2);
      mul32(c2, p[3], q2[3]);
      mul32(c2, c2, D22);
      mul32(d3, p[2], q2[2]);
      add32(d3, d3, d3);
      sub(e2, b2, a3);
      sub(f, d3, c2);
      add32(g2, d3, c2);
      add32(h3, b2, a3);
      mul32(p[0], e2, f);
      mul32(p[1], h3, g2);
      mul32(p[2], g2, f);
      mul32(p[3], e2, h3);
    }
    __name(edadd, "edadd");
    __name2(edadd, "edadd");
    function cswap(p, q2, b2) {
      for (let i22 = 0; i22 < 4; i22++) {
        sel25519(p[i22], q2[i22], b2);
      }
    }
    __name(cswap, "cswap");
    __name2(cswap, "cswap");
    function pack3(r2, p) {
      const tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      mul32(tx, p[0], zi);
      mul32(ty, p[1], zi);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    __name(pack3, "pack");
    __name2(pack3, "pack");
    function scalarmult(p, q2, s3) {
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (let i22 = 255; i22 >= 0; --i22) {
        const b2 = s3[i22 / 8 | 0] >> (i22 & 7) & 1;
        cswap(p, q2, b2);
        edadd(q2, p);
        edadd(p, p);
        cswap(p, q2, b2);
      }
    }
    __name(scalarmult, "scalarmult");
    __name2(scalarmult, "scalarmult");
    function scalarbase(p, s3) {
      const q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      mul32(q2[3], X2, Y2);
      scalarmult(p, q2, s3);
    }
    __name(scalarbase, "scalarbase");
    __name2(scalarbase, "scalarbase");
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d3 = (0, sha512_1.hash)(seed);
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p = [gf(), gf(), gf(), gf()];
      scalarbase(p, d3);
      pack3(publicKey, p);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    __name(generateKeyPairFromSeed2, "generateKeyPairFromSeed2");
    __name2(generateKeyPairFromSeed2, "generateKeyPairFromSeed");
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair2(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    __name(generateKeyPair2, "generateKeyPair2");
    __name2(generateKeyPair2, "generateKeyPair");
    exports.generateKeyPair = generateKeyPair2;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    __name(extractPublicKeyFromSecretKey, "extractPublicKeyFromSecretKey");
    __name2(extractPublicKeyFromSecretKey, "extractPublicKeyFromSecretKey");
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L2 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r2, x2) {
      let carry;
      let i22;
      let j;
      let k2;
      for (i22 = 63; i22 >= 32; --i22) {
        carry = 0;
        for (j = i22 - 32, k2 = i22 - 12; j < k2; ++j) {
          x2[j] += carry - 16 * x2[i22] * L2[j - (i22 - 32)];
          carry = Math.floor((x2[j] + 128) / 256);
          x2[j] -= carry * 256;
        }
        x2[j] += carry;
        x2[i22] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x2[j] += carry - (x2[31] >> 4) * L2[j];
        carry = x2[j] >> 8;
        x2[j] &= 255;
      }
      for (j = 0; j < 32; j++) {
        x2[j] -= carry * L2[j];
      }
      for (i22 = 0; i22 < 32; i22++) {
        x2[i22 + 1] += x2[i22] >> 8;
        r2[i22] = x2[i22] & 255;
      }
    }
    __name(modL, "modL");
    __name2(modL, "modL");
    function reduce(r2) {
      const x2 = new Float64Array(64);
      for (let i22 = 0; i22 < 64; i22++) {
        x2[i22] = r2[i22];
      }
      for (let i22 = 0; i22 < 64; i22++) {
        r2[i22] = 0;
      }
      modL(r2, x2);
    }
    __name(reduce, "reduce");
    __name2(reduce, "reduce");
    function sign5(secretKey, message) {
      const x2 = new Float64Array(64);
      const p = [gf(), gf(), gf(), gf()];
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const signature22 = new Uint8Array(64);
      signature22.set(d3.subarray(32), 32);
      const hs = new sha512_1.SHA512();
      hs.update(signature22.subarray(32));
      hs.update(message);
      const r2 = hs.digest();
      hs.clean();
      reduce(r2);
      scalarbase(p, r2);
      pack3(signature22, p);
      hs.reset();
      hs.update(signature22.subarray(0, 32));
      hs.update(secretKey.subarray(32));
      hs.update(message);
      const h3 = hs.digest();
      reduce(h3);
      for (let i22 = 0; i22 < 32; i22++) {
        x2[i22] = r2[i22];
      }
      for (let i22 = 0; i22 < 32; i22++) {
        for (let j = 0; j < 32; j++) {
          x2[i22 + j] += h3[i22] * d3[j];
        }
      }
      modL(signature22.subarray(32), x2);
      return signature22;
    }
    __name(sign5, "sign5");
    __name2(sign5, "sign");
    exports.sign = sign5;
    function unpackneg(r2, p) {
      const t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p);
      square(num, r2[1]);
      mul32(den, num, D2);
      sub(num, num, r2[2]);
      add32(den, r2[2], den);
      square(den2, den);
      square(den4, den2);
      mul32(den6, den4, den2);
      mul32(t2, den6, num);
      mul32(t2, t2, den);
      pow2523(t2, t2);
      mul32(t2, t2, num);
      mul32(t2, t2, den);
      mul32(t2, t2, den);
      mul32(r2[0], t2, den);
      square(chk, r2[0]);
      mul32(chk, chk, den);
      if (neq25519(chk, num)) {
        mul32(r2[0], r2[0], I2);
      }
      square(chk, r2[0]);
      mul32(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p[31] >> 7) {
        sub(r2[0], gf0, r2[0]);
      }
      mul32(r2[3], r2[0], r2[1]);
      return 0;
    }
    __name(unpackneg, "unpackneg");
    __name2(unpackneg, "unpackneg");
    function verify4(publicKey, message, signature22) {
      const t2 = new Uint8Array(32);
      const p = [gf(), gf(), gf(), gf()];
      const q2 = [gf(), gf(), gf(), gf()];
      if (signature22.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q2, publicKey)) {
        return false;
      }
      const hs = new sha512_1.SHA512();
      hs.update(signature22.subarray(0, 32));
      hs.update(publicKey);
      hs.update(message);
      const h3 = hs.digest();
      reduce(h3);
      scalarmult(p, q2, h3);
      scalarbase(q2, signature22.subarray(32));
      edadd(p, q2);
      pack3(t2, p);
      if (verify32(signature22, t2)) {
        return false;
      }
      return true;
    }
    __name(verify4, "verify4");
    __name2(verify4, "verify");
    exports.verify = verify4;
    function convertPublicKeyToX255192(publicKey) {
      let q2 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q2, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a3 = gf();
      let b2 = gf();
      let y3 = q2[1];
      add32(a3, gf1, y3);
      sub(b2, gf1, y3);
      inv25519(b2, b2);
      mul32(a3, a3, b2);
      let z2 = new Uint8Array(32);
      pack25519(z2, a3);
      return z2;
    }
    __name(convertPublicKeyToX255192, "convertPublicKeyToX255192");
    __name2(convertPublicKeyToX255192, "convertPublicKeyToX25519");
    exports.convertPublicKeyToX25519 = convertPublicKeyToX255192;
    function convertSecretKeyToX255192(secretKey) {
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const o = new Uint8Array(d3.subarray(0, 32));
      (0, wipe_1.wipe)(d3);
      return o;
    }
    __name(convertSecretKeyToX255192, "convertSecretKeyToX255192");
    __name2(convertSecretKeyToX255192, "convertSecretKeyToX25519");
    exports.convertSecretKeyToX25519 = convertSecretKeyToX255192;
  }
});
var require_canonicalize = __commonJS2({
  "../../node_modules/.pnpm/canonicalize@1.0.8/node_modules/canonicalize/lib/canonicalize.js"(exports, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function serialize22(object) {
      if (object === null || typeof object !== "object" || object.toJSON != null) {
        return JSON.stringify(object);
      }
      if (Array.isArray(object)) {
        return "[" + object.reduce((t2, cv, ci) => {
          const comma = ci === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return t2 + comma + serialize22(value);
        }, "") + "]";
      }
      return "{" + Object.keys(object).sort().reduce((t2, cv, ci) => {
        if (object[cv] === void 0 || typeof object[cv] === "symbol") {
          return t2;
        }
        const comma = t2.length === 0 ? "" : ",";
        return t2 + comma + serialize22(cv) + ":" + serialize22(object[cv]);
      }, "") + "}";
    }, "serialize2"), "serialize");
  }
});
var require_x25519 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+x25519@1.0.3/node_modules/@stablelib/x25519/lib/x25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random();
    var wipe_1 = require_wipe();
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32;
    function gf(init4) {
      const r2 = new Float64Array(16);
      if (init4) {
        for (let i22 = 0; i22 < init4.length; i22++) {
          r2[i22] = init4[i22];
        }
      }
      return r2;
    }
    __name(gf, "gf");
    __name2(gf, "gf");
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      let c2 = 1;
      for (let i22 = 0; i22 < 16; i22++) {
        let v = o[i22] + c2 + 65535;
        c2 = Math.floor(v / 65536);
        o[i22] = v - c2 * 65536;
      }
      o[0] += c2 - 1 + 37 * (c2 - 1);
    }
    __name(car25519, "car25519");
    __name2(car25519, "car25519");
    function sel25519(p, q2, b2) {
      const c2 = ~(b2 - 1);
      for (let i22 = 0; i22 < 16; i22++) {
        const t2 = c2 & (p[i22] ^ q2[i22]);
        p[i22] ^= t2;
        q2[i22] ^= t2;
      }
    }
    __name(sel25519, "sel25519");
    __name2(sel25519, "sel25519");
    function pack25519(o, n) {
      const m3 = gf();
      const t2 = gf();
      for (let i22 = 0; i22 < 16; i22++) {
        t2[i22] = n[i22];
      }
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (let j = 0; j < 2; j++) {
        m3[0] = t2[0] - 65517;
        for (let i22 = 1; i22 < 15; i22++) {
          m3[i22] = t2[i22] - 65535 - (m3[i22 - 1] >> 16 & 1);
          m3[i22 - 1] &= 65535;
        }
        m3[15] = t2[15] - 32767 - (m3[14] >> 16 & 1);
        const b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t2, m3, 1 - b2);
      }
      for (let i22 = 0; i22 < 16; i22++) {
        o[2 * i22] = t2[i22] & 255;
        o[2 * i22 + 1] = t2[i22] >> 8;
      }
    }
    __name(pack25519, "pack25519");
    __name2(pack25519, "pack25519");
    function unpack25519(o, n) {
      for (let i22 = 0; i22 < 16; i22++) {
        o[i22] = n[2 * i22] + (n[2 * i22 + 1] << 8);
      }
      o[15] &= 32767;
    }
    __name(unpack25519, "unpack25519");
    __name2(unpack25519, "unpack25519");
    function add32(o, a3, b2) {
      for (let i22 = 0; i22 < 16; i22++) {
        o[i22] = a3[i22] + b2[i22];
      }
    }
    __name(add32, "add3");
    __name2(add32, "add");
    function sub(o, a3, b2) {
      for (let i22 = 0; i22 < 16; i22++) {
        o[i22] = a3[i22] - b2[i22];
      }
    }
    __name(sub, "sub");
    __name2(sub, "sub");
    function mul32(o, a3, b2) {
      let v, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v = a3[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b22;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a3[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b22;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a3[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b22;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a3[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b22;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a3[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b22;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a3[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b22;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a3[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b22;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a3[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b22;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a3[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b22;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a3[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b22;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a3[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b22;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a3[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b22;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a3[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b22;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a3[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b22;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a3[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b22;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a3[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b22;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    __name(mul32, "mul3");
    __name2(mul32, "mul");
    function square(o, a3) {
      mul32(o, a3, a3);
    }
    __name(square, "square");
    __name2(square, "square");
    function inv25519(o, inp) {
      const c2 = gf();
      for (let i22 = 0; i22 < 16; i22++) {
        c2[i22] = inp[i22];
      }
      for (let i22 = 253; i22 >= 0; i22--) {
        square(c2, c2);
        if (i22 !== 2 && i22 !== 4) {
          mul32(c2, c2, inp);
        }
      }
      for (let i22 = 0; i22 < 16; i22++) {
        o[i22] = c2[i22];
      }
    }
    __name(inv25519, "inv25519");
    __name2(inv25519, "inv25519");
    function scalarMult(n, p) {
      const z2 = new Uint8Array(32);
      const x2 = new Float64Array(80);
      const a3 = gf(), b2 = gf(), c2 = gf(), d3 = gf(), e2 = gf(), f = gf();
      for (let i22 = 0; i22 < 31; i22++) {
        z2[i22] = n[i22];
      }
      z2[31] = n[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x2, p);
      for (let i22 = 0; i22 < 16; i22++) {
        b2[i22] = x2[i22];
      }
      a3[0] = d3[0] = 1;
      for (let i22 = 254; i22 >= 0; --i22) {
        const r2 = z2[i22 >>> 3] >>> (i22 & 7) & 1;
        sel25519(a3, b2, r2);
        sel25519(c2, d3, r2);
        add32(e2, a3, c2);
        sub(a3, a3, c2);
        add32(c2, b2, d3);
        sub(b2, b2, d3);
        square(d3, e2);
        square(f, a3);
        mul32(a3, c2, a3);
        mul32(c2, b2, e2);
        add32(e2, a3, c2);
        sub(a3, a3, c2);
        square(b2, a3);
        sub(c2, d3, f);
        mul32(a3, c2, _121665);
        add32(a3, a3, d3);
        mul32(c2, c2, a3);
        mul32(a3, d3, f);
        mul32(d3, b2, x2);
        square(b2, e2);
        sel25519(a3, b2, r2);
        sel25519(c2, d3, r2);
      }
      for (let i22 = 0; i22 < 16; i22++) {
        x2[i22 + 16] = a3[i22];
        x2[i22 + 32] = c2[i22];
        x2[i22 + 48] = b2[i22];
        x2[i22 + 64] = d3[i22];
      }
      const x32 = x2.subarray(32);
      const x16 = x2.subarray(16);
      inv25519(x32, x32);
      mul32(x16, x16, x32);
      const q2 = new Uint8Array(32);
      pack25519(q2, x16);
      return q2;
    }
    __name(scalarMult, "scalarMult");
    __name2(scalarMult, "scalarMult");
    exports.scalarMult = scalarMult;
    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }
    __name(scalarMultBase, "scalarMultBase");
    __name2(scalarMultBase, "scalarMultBase");
    exports.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    __name(generateKeyPairFromSeed2, "generateKeyPairFromSeed2");
    __name2(generateKeyPairFromSeed2, "generateKeyPairFromSeed");
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair2(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    __name(generateKeyPair2, "generateKeyPair2");
    __name2(generateKeyPair2, "generateKeyPair");
    exports.generateKeyPair = generateKeyPair2;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros2 = 0;
        for (let i22 = 0; i22 < result.length; i22++) {
          zeros2 |= result[i22];
        }
        if (zeros2 === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    __name(sharedKey2, "sharedKey2");
    __name2(sharedKey2, "sharedKey");
    exports.sharedKey = sharedKey2;
  }
});
var require_chacha = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+chacha@1.0.1/node_modules/@stablelib/chacha/lib/chacha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key22) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key22[3] << 24 | key22[2] << 16 | key22[1] << 8 | key22[0];
      var j5 = key22[7] << 24 | key22[6] << 16 | key22[5] << 8 | key22[4];
      var j6 = key22[11] << 24 | key22[10] << 16 | key22[9] << 8 | key22[8];
      var j7 = key22[15] << 24 | key22[14] << 16 | key22[13] << 8 | key22[12];
      var j8 = key22[19] << 24 | key22[18] << 16 | key22[17] << 8 | key22[16];
      var j9 = key22[23] << 24 | key22[22] << 16 | key22[21] << 8 | key22[20];
      var j10 = key22[27] << 24 | key22[26] << 16 | key22[25] << 8 | key22[24];
      var j11 = key22[31] << 24 | key22[30] << 16 | key22[29] << 8 | key22[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i22 = 0; i22 < ROUNDS; i22 += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    __name(core, "core");
    __name2(core, "core");
    function streamXOR(key22, nonce, src2, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key22.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src2.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i22 = 0; i22 < src2.length; i22 += 64) {
        core(block, nc, key22);
        for (var j = i22; j < i22 + 64 && j < src2.length; j++) {
          dst[j] = src2[j] ^ block[j - i22];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    __name(streamXOR, "streamXOR");
    __name2(streamXOR, "streamXOR");
    exports.streamXOR = streamXOR;
    function stream(key22, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key22, nonce, dst, dst, nonceInplaceCounterLength);
    }
    __name(stream, "stream");
    __name2(stream, "stream");
    exports.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
    __name(incrementCounter, "incrementCounter");
    __name2(incrementCounter, "incrementCounter");
  }
});
var require_xchacha20 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+xchacha20@1.0.1/node_modules/@stablelib/xchacha20/lib/xchacha20.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var chacha_1 = require_chacha();
    var ROUNDS = 20;
    function streamXOR(key22, nonce, src2, dst) {
      if (nonce.length !== 24) {
        throw new Error("XChaCha20 nonce must be 24 bytes");
      }
      var subkey = hchacha(key22, nonce.subarray(0, 16), new Uint8Array(32));
      var modifiedNonce = new Uint8Array(12);
      modifiedNonce.set(nonce.subarray(16), 4);
      var result = chacha_1.streamXOR(subkey, modifiedNonce, src2, dst);
      wipe_1.wipe(subkey);
      return result;
    }
    __name(streamXOR, "streamXOR");
    __name2(streamXOR, "streamXOR");
    exports.streamXOR = streamXOR;
    function stream(key22, nonce, dst) {
      wipe_1.wipe(dst);
      return streamXOR(key22, nonce, dst, dst);
    }
    __name(stream, "stream");
    __name2(stream, "stream");
    exports.stream = stream;
    function hchacha(key22, src2, dst) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key22[3] << 24 | key22[2] << 16 | key22[1] << 8 | key22[0];
      var j5 = key22[7] << 24 | key22[6] << 16 | key22[5] << 8 | key22[4];
      var j6 = key22[11] << 24 | key22[10] << 16 | key22[9] << 8 | key22[8];
      var j7 = key22[15] << 24 | key22[14] << 16 | key22[13] << 8 | key22[12];
      var j8 = key22[19] << 24 | key22[18] << 16 | key22[17] << 8 | key22[16];
      var j9 = key22[23] << 24 | key22[22] << 16 | key22[21] << 8 | key22[20];
      var j10 = key22[27] << 24 | key22[26] << 16 | key22[25] << 8 | key22[24];
      var j11 = key22[31] << 24 | key22[30] << 16 | key22[29] << 8 | key22[28];
      var j12 = src2[3] << 24 | src2[2] << 16 | src2[1] << 8 | src2[0];
      var j13 = src2[7] << 24 | src2[6] << 16 | src2[5] << 8 | src2[4];
      var j14 = src2[11] << 24 | src2[10] << 16 | src2[9] << 8 | src2[8];
      var j15 = src2[15] << 24 | src2[14] << 16 | src2[13] << 8 | src2[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i22 = 0; i22 < ROUNDS; i22 += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0, dst, 0);
      binary_1.writeUint32LE(x1, dst, 4);
      binary_1.writeUint32LE(x2, dst, 8);
      binary_1.writeUint32LE(x3, dst, 12);
      binary_1.writeUint32LE(x12, dst, 16);
      binary_1.writeUint32LE(x13, dst, 20);
      binary_1.writeUint32LE(x14, dst, 24);
      binary_1.writeUint32LE(x15, dst, 28);
      return dst;
    }
    __name(hchacha, "hchacha");
    __name2(hchacha, "hchacha");
    exports.hchacha = hchacha;
  }
});
var require_constant_time = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+constant-time@1.0.1/node_modules/@stablelib/constant-time/lib/constant-time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    __name(select, "select");
    __name2(select, "select");
    exports.select = select;
    function lessOrEqual(a3, b2) {
      return (a3 | 0) - (b2 | 0) - 1 >>> 31 & 1;
    }
    __name(lessOrEqual, "lessOrEqual");
    __name2(lessOrEqual, "lessOrEqual");
    exports.lessOrEqual = lessOrEqual;
    function compare4(a3, b2) {
      if (a3.length !== b2.length) {
        return 0;
      }
      var result = 0;
      for (var i22 = 0; i22 < a3.length; i22++) {
        result |= a3[i22] ^ b2[i22];
      }
      return 1 & result - 1 >>> 8;
    }
    __name(compare4, "compare4");
    __name2(compare4, "compare");
    exports.compare = compare4;
    function equal(a3, b2) {
      if (a3.length === 0 || b2.length === 0) {
        return false;
      }
      return compare4(a3, b2) !== 0;
    }
    __name(equal, "equal");
    __name2(equal, "equal");
    exports.equal = equal;
  }
});
var require_poly1305 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+poly1305@1.0.1/node_modules/@stablelib/poly1305/lib/poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 16;
    var Poly1305 = function() {
      function Poly13052(key22) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key22[0] | key22[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key22[2] | key22[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key22[4] | key22[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key22[6] | key22[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key22[8] | key22[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key22[10] | key22[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key22[12] | key22[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key22[14] | key22[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key22[16] | key22[17] << 8;
        this._pad[1] = key22[18] | key22[19] << 8;
        this._pad[2] = key22[20] | key22[21] << 8;
        this._pad[3] = key22[22] | key22[23] << 8;
        this._pad[4] = key22[24] | key22[25] << 8;
        this._pad[5] = key22[26] | key22[27] << 8;
        this._pad[6] = key22[28] | key22[29] << 8;
        this._pad[7] = key22[30] | key22[31] << 8;
      }
      __name(Poly13052, "Poly13052");
      __name2(Poly13052, "Poly1305");
      Poly13052.prototype._blocks = function(m3, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
          var t0 = m3[mpos + 0] | m3[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m3[mpos + 2] | m3[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m3[mpos + 4] | m3[mpos + 5] << 8;
          h22 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m3[mpos + 6] | m3[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m3[mpos + 8] | m3[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m3[mpos + 10] | m3[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m3[mpos + 12] | m3[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m3[mpos + 14] | m3[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c2 = 0;
          var d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h22 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          var d22 = c2;
          d22 += h0 * r2;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h3 * (5 * r9);
          d22 += h4 * (5 * r8);
          c2 = d22 >>> 13;
          d22 &= 8191;
          d22 += h5 * (5 * r7);
          d22 += h6 * (5 * r6);
          d22 += h7 * (5 * r5);
          d22 += h8 * (5 * r4);
          d22 += h9 * (5 * r3);
          c2 += d22 >>> 13;
          d22 &= 8191;
          var d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h22 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h22 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h22 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h22 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h22 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h22 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h22 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h22;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g2 = new Uint16Array(10);
        var c2;
        var mask;
        var f;
        var i22;
        if (this._leftover) {
          i22 = this._leftover;
          this._buffer[i22++] = 1;
          for (; i22 < 16; i22++) {
            this._buffer[i22] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i22 = 2; i22 < 10; i22++) {
          this._h[i22] += c2;
          c2 = this._h[i22] >>> 13;
          this._h[i22] &= 8191;
        }
        this._h[0] += c2 * 5;
        c2 = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c2;
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c2;
        g2[0] = this._h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i22 = 1; i22 < 10; i22++) {
          g2[i22] = this._h[i22] + c2;
          c2 = g2[i22] >>> 13;
          g2[i22] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i22 = 0; i22 < 10; i22++) {
          g2[i22] &= mask;
        }
        mask = ~mask;
        for (i22 = 0; i22 < 10; i22++) {
          this._h[i22] = this._h[i22] & mask | g2[i22];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 65535;
        for (i22 = 1; i22 < 8; i22++) {
          f = (this._h[i22] + this._pad[i22] | 0) + (f >>> 16) | 0;
          this._h[i22] = f & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m3) {
        var mpos = 0;
        var bytes = m3.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes) {
            want = bytes;
          }
          for (var i22 = 0; i22 < want; i22++) {
            this._buffer[this._leftover + i22] = m3[mpos + i22];
          }
          bytes -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this._blocks(m3, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (var i22 = 0; i22 < bytes; i22++) {
            this._buffer[this._leftover + i22] = m3[mpos + i22];
          }
          this._leftover += bytes;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }();
    exports.Poly1305 = Poly1305;
    function oneTimeAuth(key22, data) {
      var h3 = new Poly1305(key22);
      h3.update(data);
      var digest2 = h3.digest();
      h3.clean();
      return digest2;
    }
    __name(oneTimeAuth, "oneTimeAuth");
    __name2(oneTimeAuth, "oneTimeAuth");
    exports.oneTimeAuth = oneTimeAuth;
    function equal(a3, b2) {
      if (a3.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a3, b2);
    }
    __name(equal, "equal");
    __name2(equal, "equal");
    exports.equal = equal;
  }
});
var require_chacha20poly1305 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+chacha20poly1305@1.0.1/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = function() {
      function ChaCha20Poly13052(key22) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key22.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key22);
      }
      __name(ChaCha20Poly13052, "ChaCha20Poly13052");
      __name2(ChaCha20Poly13052, "ChaCha20Poly1305");
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h3 = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h3.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h3.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h3.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h3.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length2 = new Uint8Array(8);
        if (associatedData) {
          binary_1.writeUint64LE(associatedData.length, length2);
        }
        h3.update(length2);
        binary_1.writeUint64LE(ciphertext.length, length2);
        h3.update(length2);
        var tag = h3.digest();
        for (var i22 = 0; i22 < tag.length; i22++) {
          tagOut[i22] = tag[i22];
        }
        h3.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length2);
      };
      return ChaCha20Poly13052;
    }();
    exports.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});
var require_xchacha20poly1305 = __commonJS2({
  "../../node_modules/.pnpm/@stablelib+xchacha20poly1305@1.0.1/node_modules/@stablelib/xchacha20poly1305/lib/xchacha20poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var xchacha20_1 = require_xchacha20();
    var chacha20poly1305_1 = require_chacha20poly1305();
    var wipe_1 = require_wipe();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 24;
    exports.TAG_LENGTH = 16;
    var XChaCha20Poly13052 = function() {
      function XChaCha20Poly13053(key22) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key22.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key22);
      }
      __name(XChaCha20Poly13053, "XChaCha20Poly13053");
      __name2(XChaCha20Poly13053, "XChaCha20Poly1305");
      XChaCha20Poly13053.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length !== 24) {
          throw new Error("XChaCha20Poly1305: incorrect nonce length");
        }
        var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
        var modifiedNonce = new Uint8Array(12);
        modifiedNonce.set(nonce.subarray(16), 4);
        var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
        var result = chaChaPoly.seal(modifiedNonce, plaintext, associatedData, dst);
        wipe_1.wipe(subKey);
        wipe_1.wipe(modifiedNonce);
        chaChaPoly.clean();
        return result;
      };
      XChaCha20Poly13053.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length !== 24) {
          throw new Error("XChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
        var modifiedNonce = new Uint8Array(12);
        modifiedNonce.set(nonce.subarray(16), 4);
        var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
        var result = chaChaPoly.open(modifiedNonce, sealed, associatedData, dst);
        wipe_1.wipe(subKey);
        wipe_1.wipe(modifiedNonce);
        chaChaPoly.clean();
        return result;
      };
      XChaCha20Poly13053.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      return XChaCha20Poly13053;
    }();
    exports.XChaCha20Poly1305 = XChaCha20Poly13052;
  }
});
var require_identifiers = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/identifiers.js"(exports, module2) {
    module2.exports = {
      ALT: 1,
      CAT: 2,
      REP: 3,
      RNM: 4,
      TRG: 5,
      TBS: 6,
      TLS: 7,
      UDT: 11,
      AND: 12,
      NOT: 13,
      BKR: 14,
      BKA: 15,
      BKN: 16,
      ABG: 17,
      AEN: 18,
      ACTIVE: 100,
      MATCH: 101,
      EMPTY: 102,
      NOMATCH: 103,
      SEM_PRE: 200,
      SEM_POST: 201,
      SEM_OK: 300,
      SEM_SKIP: 301,
      ATTR_N: 400,
      ATTR_R: 401,
      ATTR_MR: 402,
      LOOKAROUND_NONE: 500,
      LOOKAROUND_AHEAD: 501,
      LOOKAROUND_BEHIND: 502,
      BKR_MODE_UM: 601,
      BKR_MODE_PM: 602,
      BKR_MODE_CS: 603,
      BKR_MODE_CI: 604
    };
  }
});
var require_style = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/style.js"(exports, module2) {
    module2.exports = {
      CLASS_MONOSPACE: "apg-mono",
      CLASS_ACTIVE: "apg-active",
      CLASS_EMPTY: "apg-empty",
      CLASS_MATCH: "apg-match",
      CLASS_NOMATCH: "apg-nomatch",
      CLASS_LOOKAHEAD: "apg-lh-match",
      CLASS_LOOKBEHIND: "apg-lb-match",
      CLASS_REMAINDER: "apg-remainder",
      CLASS_CTRLCHAR: "apg-ctrl-char",
      CLASS_LINEEND: "apg-line-end",
      CLASS_ERROR: "apg-error",
      CLASS_PHRASE: "apg-phrase",
      CLASS_EMPTYPHRASE: "apg-empty-phrase",
      CLASS_STATE: "apg-state",
      CLASS_STATS: "apg-stats",
      CLASS_TRACE: "apg-trace",
      CLASS_GRAMMAR: "apg-grammar",
      CLASS_RULES: "apg-rules",
      CLASS_RULESLINK: "apg-rules-link",
      CLASS_ATTRIBUTES: "apg-attrs"
    };
  }
});
var require_transformers = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-conv-api/transformers.js"(exports) {
    "use strict;";
    var thisThis = exports;
    var NON_SHORTEST = 4294967292;
    var TRAILING = 4294967293;
    var RANGE = 4294967294;
    var ILL_FORMED = 4294967295;
    var mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];
    var ascii2 = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0A",
      "0B",
      "0C",
      "0D",
      "0E",
      "0F",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1A",
      "1B",
      "1C",
      "1D",
      "1E",
      "1F",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2A",
      "2B",
      "2C",
      "2D",
      "2E",
      "2F",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3A",
      "3B",
      "3C",
      "3D",
      "3E",
      "3F",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4A",
      "4B",
      "4C",
      "4D",
      "4E",
      "4F",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5A",
      "5B",
      "5C",
      "5D",
      "5E",
      "5F",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6A",
      "6B",
      "6C",
      "6D",
      "6E",
      "6F",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7A",
      "7B",
      "7C",
      "7D",
      "7E",
      "7F",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8A",
      "8B",
      "8C",
      "8D",
      "8E",
      "8F",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9A",
      "9B",
      "9C",
      "9D",
      "9E",
      "9F",
      "A0",
      "A1",
      "A2",
      "A3",
      "A4",
      "A5",
      "A6",
      "A7",
      "A8",
      "A9",
      "AA",
      "AB",
      "AC",
      "AD",
      "AE",
      "AF",
      "B0",
      "B1",
      "B2",
      "B3",
      "B4",
      "B5",
      "B6",
      "B7",
      "B8",
      "B9",
      "BA",
      "BB",
      "BC",
      "BD",
      "BE",
      "BF",
      "C0",
      "C1",
      "C2",
      "C3",
      "C4",
      "C5",
      "C6",
      "C7",
      "C8",
      "C9",
      "CA",
      "CB",
      "CC",
      "CD",
      "CE",
      "CF",
      "D0",
      "D1",
      "D2",
      "D3",
      "D4",
      "D5",
      "D6",
      "D7",
      "D8",
      "D9",
      "DA",
      "DB",
      "DC",
      "DD",
      "DE",
      "DF",
      "E0",
      "E1",
      "E2",
      "E3",
      "E4",
      "E5",
      "E6",
      "E7",
      "E8",
      "E9",
      "EA",
      "EB",
      "EC",
      "ED",
      "EE",
      "EF",
      "F0",
      "F1",
      "F2",
      "F3",
      "F4",
      "F5",
      "F6",
      "F7",
      "F8",
      "F9",
      "FA",
      "FB",
      "FC",
      "FD",
      "FE",
      "FF"
    ];
    var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("");
    var base64codes = [];
    base64chars.forEach((char) => {
      base64codes.push(char.charCodeAt(0));
    });
    exports.utf8 = {
      encode(chars) {
        const bytes = [];
        chars.forEach((char) => {
          if (char >= 0 && char <= 127) {
            bytes.push(char);
          } else if (char <= 2047) {
            bytes.push(192 + (char >> 6 & mask[5]));
            bytes.push(128 + (char & mask[6]));
          } else if (char < 55296 || char > 57343 && char <= 65535) {
            bytes.push(224 + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else if (char >= 65536 && char <= 1114111) {
            const u2 = char >> 16 & mask[5];
            bytes.push(240 + (u2 >> 2));
            bytes.push(128 + ((u2 & mask[2]) << 4) + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else {
            throw new RangeError(`utf8.encode: character out of range: char: ${char}`);
          }
        });
        return Buffer.from(bytes);
      },
      decode(buf2, bom) {
        function bytes22(b12, b2) {
          if ((b2 & 192) !== 128) {
            return TRAILING;
          }
          const x2 = ((b12 & mask[5]) << 6) + (b2 & mask[6]);
          if (x2 < 128) {
            return NON_SHORTEST;
          }
          return x2;
        }
        __name(bytes22, "bytes2");
        __name2(bytes22, "bytes2");
        function bytes3(b12, b2, b3) {
          if ((b3 & 192) !== 128 || (b2 & 192) !== 128) {
            return TRAILING;
          }
          const x2 = ((b12 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);
          if (x2 < 2048) {
            return NON_SHORTEST;
          }
          if (x2 >= 55296 && x2 <= 57343) {
            return RANGE;
          }
          return x2;
        }
        __name(bytes3, "bytes3");
        __name2(bytes3, "bytes3");
        function bytes4(b12, b2, b3, b4) {
          if ((b4 & 192) !== 128 || (b3 & 192) !== 128 || (b2 & 192) !== 128) {
            return TRAILING;
          }
          const x2 = (((b12 & mask[3]) << 2) + (b2 >> 4 & mask[2]) << 16) + ((b2 & mask[4]) << 12) + ((b3 & mask[6]) << 6) + (b4 & mask[6]);
          if (x2 < 65536) {
            return NON_SHORTEST;
          }
          if (x2 > 1114111) {
            return RANGE;
          }
          return x2;
        }
        __name(bytes4, "bytes4");
        __name2(bytes4, "bytes4");
        let c2;
        let b1;
        let i1;
        let i22;
        let i3;
        let inc;
        const len = buf2.length;
        let i4 = bom ? 3 : 0;
        const chars = [];
        while (i4 < len) {
          b1 = buf2[i4];
          c2 = ILL_FORMED;
          const TRUE = true;
          while (TRUE) {
            if (b1 >= 0 && b1 <= 127) {
              c2 = b1;
              inc = 1;
              break;
            }
            i1 = i4 + 1;
            if (i1 < len && b1 >= 194 && b1 <= 223) {
              c2 = bytes22(b1, buf2[i1]);
              inc = 2;
              break;
            }
            i22 = i4 + 2;
            if (i22 < len && b1 >= 224 && b1 <= 239) {
              c2 = bytes3(b1, buf2[i1], buf2[i22]);
              inc = 3;
              break;
            }
            i3 = i4 + 3;
            if (i3 < len && b1 >= 240 && b1 <= 244) {
              c2 = bytes4(b1, buf2[i1], buf2[i22], buf2[i3]);
              inc = 4;
              break;
            }
            break;
          }
          if (c2 > 1114111) {
            const at = `byte[${i4}]`;
            if (c2 === ILL_FORMED) {
              throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);
            }
            if (c2 === TRAILING) {
              throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);
            }
            if (c2 === RANGE) {
              throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);
            }
            if (c2 === NON_SHORTEST) {
              throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);
            }
            throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);
          }
          chars.push(c2);
          i4 += inc;
        }
        return chars;
      }
    };
    exports.utf16be = {
      encode(chars) {
        const bytes = [];
        let char;
        let h3;
        let l;
        for (let i22 = 0; i22 < chars.length; i22 += 1) {
          char = chars[i22];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char >> 8 & mask[8]);
            bytes.push(char & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l = char - 65536;
            h3 = 55296 + (l >> 10);
            l = 56320 + (l & mask[10]);
            bytes.push(h3 >> 8 & mask[8]);
            bytes.push(h3 & mask[8]);
            bytes.push(l >> 8 & mask[8]);
            bytes.push(l & mask[8]);
          } else {
            throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i22}]: ${char}`);
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf2, bom) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        const len = buf2.length;
        let i22 = bom ? 2 : 0;
        let j = 0;
        let c2;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i22 < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i22 + 1;
            if (i1 < len) {
              high = (buf2[i22] << 8) + buf2[i1];
              if (high < 55296 || high > 57343) {
                c2 = high;
                inc = 2;
                break;
              }
              i3 = i22 + 3;
              if (i3 < len) {
                low = (buf2[i22 + 2] << 8) + buf2[i3];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c2 = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i22}]`);
          }
          chars[j++] = c2;
          i22 += inc;
        }
        return chars;
      }
    };
    exports.utf16le = {
      encode(chars) {
        const bytes = [];
        let char;
        let h3;
        let l;
        for (let i22 = 0; i22 < chars.length; i22 += 1) {
          char = chars[i22];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char & mask[8]);
            bytes.push(char >> 8 & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l = char - 65536;
            h3 = 55296 + (l >> 10);
            l = 56320 + (l & mask[10]);
            bytes.push(h3 & mask[8]);
            bytes.push(h3 >> 8 & mask[8]);
            bytes.push(l & mask[8]);
            bytes.push(l >> 8 & mask[8]);
          } else {
            throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i22}]: ${char}`);
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf2, bom) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        const len = buf2.length;
        let i22 = bom ? 2 : 0;
        let j = 0;
        let c2;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i22 < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i22 + 1;
            if (i1 < len) {
              high = (buf2[i1] << 8) + buf2[i22];
              if (high < 55296 || high > 57343) {
                c2 = high;
                inc = 2;
                break;
              }
              i3 = i22 + 3;
              if (i3 < len) {
                low = (buf2[i3] << 8) + buf2[i22 + 2];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c2 = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i22}]`);
          }
          chars[j++] = c2;
          i22 += inc;
        }
        return chars;
      }
    };
    exports.utf32be = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i22 = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i22 / 4}]: ${char}`);
          }
          buf2[i22++] = char >> 24 & mask[8];
          buf2[i22++] = char >> 16 & mask[8];
          buf2[i22++] = char >> 8 & mask[8];
          buf2[i22++] = char & mask[8];
        });
        return buf2;
      },
      decode(buf2, bom) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        let i22 = bom ? 4 : 0;
        for (; i22 < buf2.length; i22 += 4) {
          const char = (buf2[i22] << 24) + (buf2[i22 + 1] << 16) + (buf2[i22 + 2] << 8) + buf2[i22 + 3];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i22 / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.utf32le = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i22 = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i22 / 4}]: ${char}`);
          }
          buf2[i22++] = char & mask[8];
          buf2[i22++] = char >> 8 & mask[8];
          buf2[i22++] = char >> 16 & mask[8];
          buf2[i22++] = char >> 24 & mask[8];
        });
        return buf2;
      },
      decode(buf2, bom) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        let i22 = bom ? 4 : 0;
        for (; i22 < buf2.length; i22 += 4) {
          const char = (buf2[i22 + 3] << 24) + (buf2[i22 + 2] << 16) + (buf2[i22 + 1] << 8) + buf2[i22];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i22 / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.uint7 = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length);
        for (let i22 = 0; i22 < chars.length; i22 += 1) {
          if (chars[i22] > 127) {
            throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i22}]: ${chars[i22]}`);
          }
          buf2[i22] = chars[i22];
        }
        return buf2;
      },
      decode(buf2) {
        const chars = [];
        for (let i22 = 0; i22 < buf2.length; i22 += 1) {
          if (buf2[i22] > 127) {
            throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i22}]: ${buf2[i22]}`);
          }
          chars[i22] = buf2[i22];
        }
        return chars;
      }
    };
    exports.uint8 = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length);
        for (let i22 = 0; i22 < chars.length; i22 += 1) {
          if (chars[i22] > 255) {
            throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i22}]: ${chars[i22]}`);
          }
          buf2[i22] = chars[i22];
        }
        return buf2;
      },
      decode(buf2) {
        const chars = [];
        for (let i22 = 0; i22 < buf2.length; i22 += 1) {
          chars[i22] = buf2[i22];
        }
        return chars;
      }
    };
    exports.uint16be = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 2);
        let i22 = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i22 / 2}]: ${char}`);
          }
          buf2[i22++] = char >> 8 & mask[8];
          buf2[i22++] = char & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i22 = 0; i22 < buf2.length; i22 += 2) {
          chars.push((buf2[i22] << 8) + buf2[i22 + 1]);
        }
        return chars;
      }
    };
    exports.uint16le = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 2);
        let i22 = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i22 / 2}]: ${char}`);
          }
          buf2[i22++] = char & mask[8];
          buf2[i22++] = char >> 8 & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i22 = 0; i22 < buf2.length; i22 += 2) {
          chars.push((buf2[i22 + 1] << 8) + buf2[i22]);
        }
        return chars;
      }
    };
    exports.uint32be = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i22 = 0;
        chars.forEach((char) => {
          buf2[i22++] = char >> 24 & mask[8];
          buf2[i22++] = char >> 16 & mask[8];
          buf2[i22++] = char >> 8 & mask[8];
          buf2[i22++] = char & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i22 = 0; i22 < buf2.length; i22 += 4) {
          chars.push((buf2[i22] << 24) + (buf2[i22 + 1] << 16) + (buf2[i22 + 2] << 8) + buf2[i22 + 3]);
        }
        return chars;
      }
    };
    exports.uint32le = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i22 = 0;
        chars.forEach((char) => {
          buf2[i22++] = char & mask[8];
          buf2[i22++] = char >> 8 & mask[8];
          buf2[i22++] = char >> 16 & mask[8];
          buf2[i22++] = char >> 24 & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i22 = 0; i22 < buf2.length; i22 += 4) {
          chars.push((buf2[i22 + 3] << 24) + (buf2[i22 + 2] << 16) + (buf2[i22 + 1] << 8) + buf2[i22]);
        }
        return chars;
      }
    };
    exports.string = {
      encode(chars) {
        return thisThis.utf16le.encode(chars).toString("utf16le");
      },
      decode(str) {
        return thisThis.utf16le.decode(Buffer.from(str, "utf16le"), 0);
      }
    };
    exports.escaped = {
      encode(chars) {
        const bytes = [];
        for (let i22 = 0; i22 < chars.length; i22 += 1) {
          const char = chars[i22];
          if (char === 96) {
            bytes.push(char);
            bytes.push(char);
          } else if (char === 10) {
            bytes.push(char);
          } else if (char >= 32 && char <= 126) {
            bytes.push(char);
          } else {
            let str = "";
            if (char >= 0 && char <= 31) {
              str += `\`x${ascii2[char]}`;
            } else if (char >= 127 && char <= 255) {
              str += `\`x${ascii2[char]}`;
            } else if (char >= 256 && char <= 65535) {
              str += `\`u${ascii2[char >> 8 & mask[8]]}${ascii2[char & mask[8]]}`;
            } else if (char >= 65536 && char <= 4294967295) {
              str += "`u{";
              const digit = char >> 24 & mask[8];
              if (digit > 0) {
                str += ascii2[digit];
              }
              str += `${ascii2[char >> 16 & mask[8]] + ascii2[char >> 8 & mask[8]] + ascii2[char & mask[8]]}}`;
            } else {
              throw new Error("escape.encode(char): char > 0xffffffff not allowed");
            }
            const buf2 = Buffer.from(str);
            buf2.forEach((b2) => {
              bytes.push(b2);
            });
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf2) {
        function isHex2(hex) {
          if (hex >= 48 && hex <= 57 || hex >= 65 && hex <= 70 || hex >= 97 && hex <= 102) {
            return true;
          }
          return false;
        }
        __name(isHex2, "isHex2");
        __name2(isHex2, "isHex");
        function getx(i3, len2, bufArg) {
          const ret2 = { char: null, nexti: i3 + 2, error: true };
          if (i3 + 1 < len2) {
            if (isHex2(bufArg[i3]) && isHex2(bufArg[i3 + 1])) {
              const str = String.fromCodePoint(bufArg[i3], bufArg[i3 + 1]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        __name(getx, "getx");
        __name2(getx, "getx");
        function getu(i3, len2, bufArg) {
          const ret2 = { char: null, nexti: i3 + 4, error: true };
          if (i3 + 3 < len2) {
            if (isHex2(bufArg[i3]) && isHex2(bufArg[i3 + 1]) && isHex2(bufArg[i3 + 2]) && isHex2(bufArg[i3 + 3])) {
              const str = String.fromCodePoint(bufArg[i3], bufArg[i3 + 1], bufArg[i3 + 2], bufArg[i3 + 3]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        __name(getu, "getu");
        __name2(getu, "getu");
        function getU(i3, len2, bufArg) {
          const ret2 = { char: null, nexti: i3 + 4, error: true };
          let str = "";
          while (i3 < len2 && isHex2(bufArg[i3])) {
            str += String.fromCodePoint(bufArg[i3]);
            i3 += 1;
          }
          ret2.char = parseInt(str, 16);
          if (bufArg[i3] === 125 && !Number.isNaN(ret2.char)) {
            ret2.error = false;
          }
          ret2.nexti = i3 + 1;
          return ret2;
        }
        __name(getU, "getU");
        __name2(getU, "getU");
        const chars = [];
        const len = buf2.length;
        let i1;
        let ret;
        let error;
        let i22 = 0;
        while (i22 < len) {
          const TRUE = true;
          while (TRUE) {
            error = true;
            if (buf2[i22] !== 96) {
              chars.push(buf2[i22]);
              i22 += 1;
              error = false;
              break;
            }
            i1 = i22 + 1;
            if (i1 >= len) {
              break;
            }
            if (buf2[i1] === 96) {
              chars.push(96);
              i22 += 2;
              error = false;
              break;
            }
            if (buf2[i1] === 120) {
              ret = getx(i1 + 1, len, buf2);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i22 = ret.nexti;
              error = false;
              break;
            }
            if (buf2[i1] === 117) {
              if (buf2[i1 + 1] === 123) {
                ret = getU(i1 + 2, len, buf2);
                if (ret.error) {
                  break;
                }
                chars.push(ret.char);
                i22 = ret.nexti;
                error = false;
                break;
              }
              ret = getu(i1 + 1, len, buf2);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i22 = ret.nexti;
              error = false;
              break;
            }
            break;
          }
          if (error) {
            throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i22}]`);
          }
        }
        return chars;
      }
    };
    var CR = 13;
    var LF = 10;
    exports.lineEnds = {
      crlf(chars) {
        const lfchars = [];
        let i22 = 0;
        while (i22 < chars.length) {
          switch (chars[i22]) {
            case CR:
              if (i22 + 1 < chars.length && chars[i22 + 1] === LF) {
                i22 += 2;
              } else {
                i22 += 1;
              }
              lfchars.push(CR);
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(CR);
              lfchars.push(LF);
              i22 += 1;
              break;
            default:
              lfchars.push(chars[i22]);
              i22 += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(CR);
          lfchars.push(LF);
        }
        return lfchars;
      },
      lf(chars) {
        const lfchars = [];
        let i22 = 0;
        while (i22 < chars.length) {
          switch (chars[i22]) {
            case CR:
              if (i22 + 1 < chars.length && chars[i22 + 1] === LF) {
                i22 += 2;
              } else {
                i22 += 1;
              }
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(LF);
              i22 += 1;
              break;
            default:
              lfchars.push(chars[i22]);
              i22 += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(LF);
        }
        return lfchars;
      }
    };
    exports.base64 = {
      encode(buf2) {
        if (buf2.length === 0) {
          return Buffer.alloc(0);
        }
        let i22;
        let j;
        let n;
        let tail = buf2.length % 3;
        tail = tail > 0 ? 3 - tail : 0;
        let units = (buf2.length + tail) / 3;
        const base642 = Buffer.alloc(units * 4);
        if (tail > 0) {
          units -= 1;
        }
        i22 = 0;
        j = 0;
        for (let u2 = 0; u2 < units; u2 += 1) {
          n = buf2[i22++] << 16;
          n += buf2[i22++] << 8;
          n += buf2[i22++];
          base642[j++] = base64codes[n >> 18 & mask[6]];
          base642[j++] = base64codes[n >> 12 & mask[6]];
          base642[j++] = base64codes[n >> 6 & mask[6]];
          base642[j++] = base64codes[n & mask[6]];
        }
        if (tail === 0) {
          return base642;
        }
        if (tail === 1) {
          n = buf2[i22++] << 16;
          n += buf2[i22] << 8;
          base642[j++] = base64codes[n >> 18 & mask[6]];
          base642[j++] = base64codes[n >> 12 & mask[6]];
          base642[j++] = base64codes[n >> 6 & mask[6]];
          base642[j] = base64codes[64];
          return base642;
        }
        if (tail === 2) {
          n = buf2[i22] << 16;
          base642[j++] = base64codes[n >> 18 & mask[6]];
          base642[j++] = base64codes[n >> 12 & mask[6]];
          base642[j++] = base64codes[64];
          base642[j] = base64codes[64];
          return base642;
        }
        return void 0;
      },
      decode(codes) {
        function validate7(buf3) {
          const chars = [];
          let tail2 = 0;
          for (let i3 = 0; i3 < buf3.length; i3 += 1) {
            const char = buf3[i3];
            const TRUE = true;
            while (TRUE) {
              if (char === 32 || char === 9 || char === 10 || char === 13) {
                break;
              }
              if (char >= 65 && char <= 90) {
                chars.push(char - 65);
                break;
              }
              if (char >= 97 && char <= 122) {
                chars.push(char - 71);
                break;
              }
              if (char >= 48 && char <= 57) {
                chars.push(char + 4);
                break;
              }
              if (char === 43) {
                chars.push(62);
                break;
              }
              if (char === 47) {
                chars.push(63);
                break;
              }
              if (char === 61) {
                chars.push(64);
                tail2 += 1;
                break;
              }
              throw new RangeError(`base64.decode: invalid character buf[${i3}]: ${char}`);
            }
          }
          if (chars.length % 4 > 0) {
            throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);
          }
          switch (tail2) {
            case 0:
              break;
            case 1:
              if (chars[chars.length - 1] !== 64) {
                throw new RangeError("base64.decode: one tail character found: not last character");
              }
              break;
            case 2:
              if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {
                throw new RangeError("base64.decode: two tail characters found: not last characters");
              }
              break;
            default:
              throw new RangeError(`base64.decode: more than two tail characters found: ${tail2}`);
          }
          return { tail: tail2, buf: Buffer.from(chars) };
        }
        __name(validate7, "validate7");
        __name2(validate7, "validate");
        if (codes.length === 0) {
          return Buffer.alloc(0);
        }
        const val = validate7(codes);
        const { tail } = val;
        const base642 = val.buf;
        let i22;
        let j;
        let n;
        let units = base642.length / 4;
        const buf2 = Buffer.alloc(units * 3 - tail);
        if (tail > 0) {
          units -= 1;
        }
        j = 0;
        i22 = 0;
        for (let u2 = 0; u2 < units; u2 += 1) {
          n = base642[i22++] << 18;
          n += base642[i22++] << 12;
          n += base642[i22++] << 6;
          n += base642[i22++];
          buf2[j++] = n >> 16 & mask[8];
          buf2[j++] = n >> 8 & mask[8];
          buf2[j++] = n & mask[8];
        }
        if (tail === 1) {
          n = base642[i22++] << 18;
          n += base642[i22++] << 12;
          n += base642[i22] << 6;
          buf2[j++] = n >> 16 & mask[8];
          buf2[j] = n >> 8 & mask[8];
        }
        if (tail === 2) {
          n = base642[i22++] << 18;
          n += base642[i22++] << 12;
          buf2[j] = n >> 16 & mask[8];
        }
        return buf2;
      },
      toString(buf2) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf2.length}`);
        }
        let str = "";
        let lineLen = 0;
        function buildLine(c1, c2, c3, c4) {
          switch (lineLen) {
            case 76:
              str += `\r
${c1}${c2}${c3}${c4}`;
              lineLen = 4;
              break;
            case 75:
              str += `${c1}\r
${c2}${c3}${c4}`;
              lineLen = 3;
              break;
            case 74:
              str += `${c1 + c2}\r
${c3}${c4}`;
              lineLen = 2;
              break;
            case 73:
              str += `${c1 + c2 + c3}\r
${c4}`;
              lineLen = 1;
              break;
            default:
              str += c1 + c2 + c3 + c4;
              lineLen += 4;
              break;
          }
        }
        __name(buildLine, "buildLine");
        __name2(buildLine, "buildLine");
        function validate7(c2) {
          if (c2 >= 65 && c2 <= 90) {
            return true;
          }
          if (c2 >= 97 && c2 <= 122) {
            return true;
          }
          if (c2 >= 48 && c2 <= 57) {
            return true;
          }
          if (c2 === 43) {
            return true;
          }
          if (c2 === 47) {
            return true;
          }
          if (c2 === 61) {
            return true;
          }
          return false;
        }
        __name(validate7, "validate7");
        __name2(validate7, "validate");
        for (let i22 = 0; i22 < buf2.length; i22 += 4) {
          for (let j = i22; j < i22 + 4; j += 1) {
            if (!validate7(buf2[j])) {
              throw new RangeError(`base64.toString: buf[${j}]: ${buf2[j]} : not valid base64 character code`);
            }
          }
          buildLine(
            String.fromCharCode(buf2[i22]),
            String.fromCharCode(buf2[i22 + 1]),
            String.fromCharCode(buf2[i22 + 2]),
            String.fromCharCode(buf2[i22 + 3])
          );
        }
        return str;
      }
    };
  }
});
var require_converter = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-conv-api/converter.js"(exports) {
    "use strict;";
    var thisThis = exports;
    var trans = require_transformers();
    var UTF8 = "UTF8";
    var UTF16 = "UTF16";
    var UTF16BE = "UTF16BE";
    var UTF16LE = "UTF16LE";
    var UTF32 = "UTF32";
    var UTF32BE = "UTF32BE";
    var UTF32LE = "UTF32LE";
    var UINT7 = "UINT7";
    var ASCII = "ASCII";
    var BINARY = "BINARY";
    var UINT8 = "UINT8";
    var UINT16 = "UINT16";
    var UINT16LE = "UINT16LE";
    var UINT16BE = "UINT16BE";
    var UINT32 = "UINT32";
    var UINT32LE = "UINT32LE";
    var UINT32BE = "UINT32BE";
    var ESCAPED = "ESCAPED";
    var STRING = "STRING";
    var bom8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bom82(src2) {
      src2.type = UTF8;
      const buf2 = src2.data;
      src2.bom = 0;
      if (buf2.length >= 3) {
        if (buf2[0] === 239 && buf2[1] === 187 && buf2[2] === 191) {
          src2.bom = 3;
        }
      }
    }, "bom82"), "bom8");
    var bom16 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bom162(src2) {
      const buf2 = src2.data;
      src2.bom = 0;
      switch (src2.type) {
        case UTF16:
          src2.type = UTF16BE;
          if (buf2.length >= 2) {
            if (buf2[0] === 254 && buf2[1] === 255) {
              src2.bom = 2;
            } else if (buf2[0] === 255 && buf2[1] === 254) {
              src2.type = UTF16LE;
              src2.bom = 2;
            }
          }
          break;
        case UTF16BE:
          src2.type = UTF16BE;
          if (buf2.length >= 2) {
            if (buf2[0] === 254 && buf2[1] === 255) {
              src2.bom = 2;
            } else if (buf2[0] === 255 && buf2[1] === 254) {
              throw new TypeError(`src type: "${UTF16BE}" specified but BOM is for "${UTF16LE}"`);
            }
          }
          break;
        case UTF16LE:
          src2.type = UTF16LE;
          if (buf2.length >= 0) {
            if (buf2[0] === 254 && buf2[1] === 255) {
              throw new TypeError(`src type: "${UTF16LE}" specified but BOM is for "${UTF16BE}"`);
            } else if (buf2[0] === 255 && buf2[1] === 254) {
              src2.bom = 2;
            }
          }
          break;
        default:
          throw new TypeError(`UTF16 BOM: src type "${src2.type}" unrecognized`);
      }
    }, "bom162"), "bom16");
    var bom32 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bom322(src2) {
      const buf2 = src2.data;
      src2.bom = 0;
      switch (src2.type) {
        case UTF32:
          src2.type = UTF32BE;
          if (buf2.length >= 4) {
            if (buf2[0] === 0 && buf2[1] === 0 && buf2[2] === 254 && buf2[3] === 255) {
              src2.bom = 4;
            }
            if (buf2[0] === 255 && buf2[1] === 254 && buf2[2] === 0 && buf2[3] === 0) {
              src2.type = UTF32LE;
              src2.bom = 4;
            }
          }
          break;
        case UTF32BE:
          src2.type = UTF32BE;
          if (buf2.length >= 4) {
            if (buf2[0] === 0 && buf2[1] === 0 && buf2[2] === 254 && buf2[3] === 255) {
              src2.bom = 4;
            }
            if (buf2[0] === 255 && buf2[1] === 254 && buf2[2] === 0 && buf2[3] === 0) {
              throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}"`);
            }
          }
          break;
        case UTF32LE:
          src2.type = UTF32LE;
          if (buf2.length >= 4) {
            if (buf2[0] === 0 && buf2[1] === 0 && buf2[2] === 254 && buf2[3] === 255) {
              throw new TypeError(`src type: "${UTF32LE}" specified but BOM is for "${UTF32BE}"`);
            }
            if (buf2[0] === 255 && buf2[1] === 254 && buf2[2] === 0 && buf2[3] === 0) {
              src2.bom = 4;
            }
          }
          break;
        default:
          throw new TypeError(`UTF32 BOM: src type "${src2.type}" unrecognized`);
      }
    }, "bom322"), "bom32");
    var validateSrc = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validateSrc2(type, data) {
      function getType(typeArg) {
        const ret2 = {
          type: "",
          base64: false
        };
        const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;
        const result = rx.exec(typeArg);
        if (result) {
          if (result[2]) {
            ret2.type = result[2].toUpperCase();
          }
          if (result[1]) {
            ret2.base64 = true;
          }
        }
        return ret2;
      }
      __name(getType, "getType");
      __name2(getType, "getType");
      if (typeof type !== "string" || type === "") {
        throw new TypeError(`type: "${type}" not recognized`);
      }
      const ret = getType(type.toUpperCase());
      if (ret.base64) {
        if (ret.type === STRING) {
          throw new TypeError(`type: "${type} "BASE64:" prefix not allowed with type ${STRING}`);
        }
        if (Buffer.isBuffer(data)) {
          ret.data = trans.base64.decode(data);
        } else if (typeof data === "string") {
          const buf2 = Buffer.from(data, "ascii");
          ret.data = trans.base64.decode(buf2);
        } else {
          throw new TypeError(`type: "${type} unrecognized data type: typeof(data): ${typeof data}`);
        }
      } else {
        ret.data = data;
      }
      switch (ret.type) {
        case UTF8:
          bom8(ret);
          break;
        case UTF16:
        case UTF16BE:
        case UTF16LE:
          bom16(ret);
          break;
        case UTF32:
        case UTF32BE:
        case UTF32LE:
          bom32(ret);
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case STRING:
        case ESCAPED:
          break;
        default:
          throw new TypeError(`type: "${type}" not recognized`);
      }
      if (ret.type === STRING) {
        if (typeof ret.data !== "string") {
          throw new TypeError(`type: "${type}" but data is not a string`);
        }
      } else if (!Buffer.isBuffer(ret.data)) {
        throw new TypeError(`type: "${type}" but data is not a Buffer`);
      }
      return ret;
    }, "validateSrc2"), "validateSrc");
    var validateDst = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validateDst2(type, chars) {
      function getType(typeArg) {
        let fix;
        let rem;
        const ret2 = {
          crlf: false,
          lf: false,
          base64: false,
          type: ""
        };
        const TRUE = true;
        while (TRUE) {
          rem = typeArg;
          fix = typeArg.slice(0, 5);
          if (fix === "CRLF:") {
            ret2.crlf = true;
            rem = typeArg.slice(5);
            break;
          }
          fix = typeArg.slice(0, 3);
          if (fix === "LF:") {
            ret2.lf = true;
            rem = typeArg.slice(3);
            break;
          }
          break;
        }
        fix = rem.split(":");
        if (fix.length === 1) {
          ret2.type = fix[0];
        } else if (fix.length === 2 && fix[1] === "BASE64") {
          ret2.base64 = true;
          ret2.type = fix[0];
        }
        return ret2;
      }
      __name(getType, "getType");
      __name2(getType, "getType");
      if (!Array.isArray(chars)) {
        throw new TypeError(`dst chars: not array: "${typeof chars}`);
      }
      if (typeof type !== "string") {
        throw new TypeError(`dst type: not string: "${typeof type}`);
      }
      const ret = getType(type.toUpperCase());
      switch (ret.type) {
        case UTF8:
        case UTF16BE:
        case UTF16LE:
        case UTF32BE:
        case UTF32LE:
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case ESCAPED:
          break;
        case STRING:
          if (ret.base64) {
            throw new TypeError(`":BASE64" suffix not allowed with type ${STRING}`);
          }
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UTF16:
          ret.type = UTF16BE;
          break;
        case UTF32:
          ret.type = UTF32BE;
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        default:
          throw new TypeError(`dst type unrecognized: "${type}" : must have form [crlf:|lf:]type[:base64]`);
      }
      return ret;
    }, "validateDst2"), "validateDst");
    var encode16 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encode17(type, chars) {
      switch (type) {
        case UTF8:
          return trans.utf8.encode(chars);
        case UTF16BE:
          return trans.utf16be.encode(chars);
        case UTF16LE:
          return trans.utf16le.encode(chars);
        case UTF32BE:
          return trans.utf32be.encode(chars);
        case UTF32LE:
          return trans.utf32le.encode(chars);
        case UINT7:
          return trans.uint7.encode(chars);
        case UINT8:
          return trans.uint8.encode(chars);
        case UINT16BE:
          return trans.uint16be.encode(chars);
        case UINT16LE:
          return trans.uint16le.encode(chars);
        case UINT32BE:
          return trans.uint32be.encode(chars);
        case UINT32LE:
          return trans.uint32le.encode(chars);
        case STRING:
          return trans.string.encode(chars);
        case ESCAPED:
          return trans.escaped.encode(chars);
        default:
          throw new TypeError(`encode type "${type}" not recognized`);
      }
    }, "encode17"), "encode");
    var decode13 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function decode14(src2) {
      switch (src2.type) {
        case UTF8:
          return trans.utf8.decode(src2.data, src2.bom);
        case UTF16LE:
          return trans.utf16le.decode(src2.data, src2.bom);
        case UTF16BE:
          return trans.utf16be.decode(src2.data, src2.bom);
        case UTF32BE:
          return trans.utf32be.decode(src2.data, src2.bom);
        case UTF32LE:
          return trans.utf32le.decode(src2.data, src2.bom);
        case UINT7:
          return trans.uint7.decode(src2.data);
        case UINT8:
          return trans.uint8.decode(src2.data);
        case UINT16BE:
          return trans.uint16be.decode(src2.data);
        case UINT16LE:
          return trans.uint16le.decode(src2.data);
        case UINT32BE:
          return trans.uint32be.decode(src2.data);
        case UINT32LE:
          return trans.uint32le.decode(src2.data);
        case STRING:
          return trans.string.decode(src2.data);
        case ESCAPED:
          return trans.escaped.decode(src2.data);
        default:
          throw new TypeError(`decode type "${src2.type}" not recognized`);
      }
    }, "decode14"), "decode");
    exports.decode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportsDecode(type, data) {
      const src2 = validateSrc(type, data);
      return decode13(src2);
    }, "exportsDecode"), "exportsDecode");
    exports.encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportsEncode(type, chars) {
      let c2;
      let buf2;
      const dst = validateDst(type, chars);
      if (dst.crlf) {
        c2 = trans.lineEnds.crlf(chars);
        buf2 = encode16(dst.type, c2);
      } else if (dst.lf) {
        c2 = trans.lineEnds.lf(chars);
        buf2 = encode16(dst.type, c2);
      } else {
        buf2 = encode16(dst.type, chars);
      }
      if (dst.base64) {
        buf2 = trans.base64.encode(buf2);
      }
      return buf2;
    }, "exportsEncode"), "exportsEncode");
    exports.convert = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convert(srcType, srcData, dstType) {
      return thisThis.encode(dstType, thisThis.decode(srcType, srcData));
    }, "convert"), "convert");
  }
});
var require_emitcss = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/emitcss.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function emittcss() {
      return "/* This file automatically generated by jsonToless() and LESS. */\n.apg-mono {\n  font-family: monospace;\n}\n.apg-active {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-match {\n  font-weight: bold;\n  color: #264BFF;\n}\n.apg-empty {\n  font-weight: bold;\n  color: #0fbd0f;\n}\n.apg-nomatch {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-lh-match {\n  font-weight: bold;\n  color: #1A97BA;\n}\n.apg-lb-match {\n  font-weight: bold;\n  color: #5F1687;\n}\n.apg-remainder {\n  font-weight: bold;\n  color: #999999;\n}\n.apg-ctrl-char {\n  font-weight: bolder;\n  font-style: italic;\n  font-size: 0.6em;\n}\n.apg-line-end {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-error {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-phrase {\n  color: #000000;\n  background-color: #8caae6;\n}\n.apg-empty-phrase {\n  color: #0fbd0f;\n}\ntable.apg-state {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th,\ntable.apg-state td {\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th:nth-last-child(2),\ntable.apg-state td:nth-last-child(2) {\n  text-align: right;\n}\ntable.apg-state caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-stats {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats th,\ntable.apg-stats td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace th,\ntable.apg-trace td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace th:last-child,\ntable.apg-trace th:nth-last-child(2),\ntable.apg-trace td:last-child,\ntable.apg-trace td:nth-last-child(2) {\n  text-align: left;\n}\ntable.apg-grammar {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-grammar th,\ntable.apg-grammar td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar th:last-child,\ntable.apg-grammar td:last-child {\n  text-align: left;\n}\ntable.apg-rules {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-rules th,\ntable.apg-rules td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules a {\n  color: #003399 !important;\n}\ntable.apg-rules a:hover {\n  color: #8caae6 !important;\n}\ntable.apg-attrs {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-attrs th,\ntable.apg-attrs td {\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs th:nth-child(1),\ntable.apg-attrs th:nth-child(2),\ntable.apg-attrs th:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs td:nth-child(1),\ntable.apg-attrs td:nth-child(2),\ntable.apg-attrs td:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs a {\n  color: #003399 !important;\n}\ntable.apg-attrs a:hover {\n  color: #8caae6 !important;\n}\n";
    }, "emittcss"), "emittcss");
  }
});
var require_utilities = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/utilities.js"(exports) {
    var style = require_style();
    var converter = require_converter();
    var emitCss = require_emitcss();
    var id2 = require_identifiers();
    var thisFileName = "utilities.js: ";
    var thisThis = exports;
    var getBounds = /* @__PURE__ */ __name2(function(length2, begArg, len) {
      let end;
      let beg = begArg;
      const TRUE = true;
      while (TRUE) {
        if (length2 <= 0) {
          beg = 0;
          end = 0;
          break;
        }
        if (typeof beg !== "number") {
          beg = 0;
          end = length2;
          break;
        }
        if (beg >= length2) {
          beg = length2;
          end = length2;
          break;
        }
        if (typeof len !== "number") {
          end = length2;
          break;
        }
        end = beg + len;
        if (end > length2) {
          end = length2;
          break;
        }
        break;
      }
      return {
        beg,
        end
      };
    }, "getBounds");
    exports.htmlToPage = function(html, titleArg) {
      let title;
      if (typeof html !== "string") {
        throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);
      }
      if (typeof titleArg !== "string") {
        title = "htmlToPage";
      } else {
        title = titleArg;
      }
      let page = "";
      page += "<!DOCTYPE html>\n";
      page += '<html lang="en">\n';
      page += "<head>\n";
      page += '<meta charset="utf-8">\n';
      page += `<title>${title}</title>
`;
      page += "<style>\n";
      page += emitCss();
      page += "</style>\n";
      page += "</head>\n<body>\n";
      page += `<p>${new Date()}</p>
`;
      page += html;
      page += "</body>\n</html>\n";
      return page;
    };
    exports.parserResultToHtml = function(result, caption) {
      let cap = null;
      if (typeof caption === "string" && caption !== "") {
        cap = caption;
      }
      let success;
      let state;
      if (result.success === true) {
        success = `<span class="${style.CLASS_MATCH}">true</span>`;
      } else {
        success = `<span class="${style.CLASS_NOMATCH}">false</span>`;
      }
      if (result.state === id2.EMPTY) {
        state = `<span class="${style.CLASS_EMPTY}">EMPTY</span>`;
      } else if (result.state === id2.MATCH) {
        state = `<span class="${style.CLASS_MATCH}">MATCH</span>`;
      } else if (result.state === id2.NOMATCH) {
        state = `<span class="${style.CLASS_NOMATCH}">NOMATCH</span>`;
      } else {
        state = `<span class="${style.CLASS_NOMATCH}">unrecognized</span>`;
      }
      let html = "";
      html += `<table class="${style.CLASS_STATE}">
`;
      if (cap) {
        html += `<caption>${cap}</caption>
`;
      }
      html += "<tr><th>state item</th><th>value</th><th>description</th></tr>\n";
      html += `<tr><td>parser success</td><td>${success}</td>
`;
      html += `<td><span class="${style.CLASS_MATCH}">true</span> if the parse succeeded,
`;
      html += ` <span class="${style.CLASS_NOMATCH}">false</span> otherwise`;
      html += "<br><i>NOTE: for success, entire string must be matched</i></td></tr>\n";
      html += `<tr><td>parser state</td><td>${state}</td>
`;
      html += `<td><span class="${style.CLASS_EMPTY}">EMPTY</span>, `;
      html += `<span class="${style.CLASS_MATCH}">MATCH</span> or 
`;
      html += `<span class="${style.CLASS_NOMATCH}">NOMATCH</span></td></tr>
`;
      html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>
`;
      html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>
`;
      html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>
`;
      html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>
`;
      html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>
`;
      html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>
`;
      html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>
`;
      html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>
`;
      html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>
`;
      html += "</table>\n";
      return html;
    };
    exports.charsToString = function(chars, phraseIndex, phraseLength) {
      let beg;
      let end;
      if (typeof phraseIndex === "number") {
        if (phraseIndex >= chars.length) {
          return "";
        }
        beg = phraseIndex < 0 ? 0 : phraseIndex;
      } else {
        beg = 0;
      }
      if (typeof phraseLength === "number") {
        if (phraseLength <= 0) {
          return "";
        }
        end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;
      } else {
        end = chars.length;
      }
      if (beg < end) {
        return converter.encode("UTF16LE", chars.slice(beg, end)).toString("utf16le");
      }
      return "";
    };
    exports.stringToChars = function(string2) {
      return converter.decode("STRING", string2);
    };
    exports.opcodeToString = function(type) {
      let ret = "unknown";
      switch (type) {
        case id2.ALT:
          ret = "ALT";
          break;
        case id2.CAT:
          ret = "CAT";
          break;
        case id2.RNM:
          ret = "RNM";
          break;
        case id2.UDT:
          ret = "UDT";
          break;
        case id2.AND:
          ret = "AND";
          break;
        case id2.NOT:
          ret = "NOT";
          break;
        case id2.REP:
          ret = "REP";
          break;
        case id2.TRG:
          ret = "TRG";
          break;
        case id2.TBS:
          ret = "TBS";
          break;
        case id2.TLS:
          ret = "TLS";
          break;
        case id2.BKR:
          ret = "BKR";
          break;
        case id2.BKA:
          ret = "BKA";
          break;
        case id2.BKN:
          ret = "BKN";
          break;
        case id2.ABG:
          ret = "ABG";
          break;
        case id2.AEN:
          ret = "AEN";
          break;
        default:
          throw new Error("unrecognized opcode");
      }
      return ret;
    };
    exports.stateToString = function(state) {
      let ret = "unknown";
      switch (state) {
        case id2.ACTIVE:
          ret = "ACTIVE";
          break;
        case id2.MATCH:
          ret = "MATCH";
          break;
        case id2.EMPTY:
          ret = "EMPTY";
          break;
        case id2.NOMATCH:
          ret = "NOMATCH";
          break;
        default:
          throw new Error("unrecognized state");
      }
      return ret;
    };
    exports.asciiChars = [
      "NUL",
      "SOH",
      "STX",
      "ETX",
      "EOT",
      "ENQ",
      "ACK",
      "BEL",
      "BS",
      "TAB",
      "LF",
      "VT",
      "FF",
      "CR",
      "SO",
      "SI",
      "DLE",
      "DC1",
      "DC2",
      "DC3",
      "DC4",
      "NAK",
      "SYN",
      "ETB",
      "CAN",
      "EM",
      "SUB",
      "ESC",
      "FS",
      "GS",
      "RS",
      "US",
      "&nbsp;",
      "!",
      "&#34;",
      "#",
      "$",
      "%",
      "&#38;",
      "&#39;",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ":",
      ";",
      "&#60;",
      "=",
      "&#62;",
      "?",
      "@",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "[",
      "&#92;",
      "]",
      "^",
      "_",
      "`",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "{",
      "|",
      "}",
      "~",
      "DEL"
    ];
    exports.charToHex = function(char) {
      let ch = char.toString(16).toUpperCase();
      switch (ch.length) {
        case 1:
        case 3:
        case 7:
          ch = `0${ch}`;
          break;
        case 2:
        case 6:
          ch = `00${ch}`;
          break;
        case 4:
          break;
        case 5:
          ch = `000${ch}`;
          break;
        default:
          throw new Error("unrecognized option");
      }
      return ch;
    };
    exports.charsToDec = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += chars[bounds.beg];
        for (let i22 = bounds.beg + 1; i22 < bounds.end; i22 += 1) {
          ret += `,${chars[i22]}`;
        }
      }
      return ret;
    };
    exports.charsToHex = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\x${thisThis.charToHex(chars[bounds.beg])}`;
        for (let i22 = bounds.beg + 1; i22 < bounds.end; i22 += 1) {
          ret += `,\\x${thisThis.charToHex(chars[i22])}`;
        }
      }
      return ret;
    };
    exports.charsToHtmlEntities = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i22 = bounds.beg; i22 < bounds.end; i22 += 1) {
          ret += `&#x${chars[i22].toString(16)};`;
        }
      }
      return ret;
    };
    function isUnicode(char) {
      if (char >= 55296 && char <= 57343) {
        return false;
      }
      if (char > 1114111) {
        return false;
      }
      return true;
    }
    __name(isUnicode, "isUnicode");
    __name2(isUnicode, "isUnicode");
    exports.charsToUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i22 = bounds.beg; i22 < bounds.end; i22 += 1) {
          if (isUnicode(chars[i22])) {
            ret += `&#${chars[i22]};`;
          } else {
            ret += ` U+${thisThis.charToHex(chars[i22])}`;
          }
        }
      }
      return ret;
    };
    exports.charsToJsUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\u${thisThis.charToHex(chars[bounds.beg])}`;
        for (let i22 = bounds.beg + 1; i22 < bounds.end; i22 += 1) {
          ret += `,\\u${thisThis.charToHex(chars[i22])}`;
        }
      }
      return ret;
    };
    exports.charsToAscii = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      for (let i22 = bounds.beg; i22 < bounds.end; i22 += 1) {
        const char = chars[i22];
        if (char >= 32 && char <= 126) {
          ret += String.fromCharCode(char);
        } else {
          ret += `\\x${thisThis.charToHex(char)}`;
        }
      }
      return ret;
    };
    exports.charsToAsciiHtml = function(chars, beg, len) {
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);
      }
      let html = "";
      let char;
      const bounds = getBounds(chars.length, beg, len);
      for (let i22 = bounds.beg; i22 < bounds.end; i22 += 1) {
        char = chars[i22];
        if (char < 32 || char === 127) {
          html += `<span class="${style.CLASS_CTRLCHAR}">${thisThis.asciiChars[char]}</span>`;
        } else if (char > 127) {
          html += `<span class="${style.CLASS_CTRLCHAR}">U+${thisThis.charToHex(char)}</span>`;
        } else {
          html += thisThis.asciiChars[char];
        }
      }
      return html;
    };
    exports.stringToAsciiHtml = function(str) {
      const chars = converter.decode("STRING", str);
      return this.charsToAsciiHtml(chars);
    };
  }
});
var require_ast = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/ast.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportsAst() {
      const id2 = require_identifiers();
      const utils = require_utilities();
      const thisFileName = "ast.js: ";
      const that = this;
      let rules = null;
      let udts = null;
      let chars = null;
      let nodeCount = 0;
      const nodesDefined = [];
      const nodeCallbacks = [];
      const stack = [];
      const records = [];
      this.callbacks = [];
      this.astObject = "astObject";
      this.init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init4(rulesIn, udtsIn, charsIn) {
        stack.length = 0;
        records.length = 0;
        nodesDefined.length = 0;
        nodeCount = 0;
        rules = rulesIn;
        udts = udtsIn;
        chars = charsIn;
        let i22;
        const list = [];
        for (i22 = 0; i22 < rules.length; i22 += 1) {
          list.push(rules[i22].lower);
        }
        for (i22 = 0; i22 < udts.length; i22 += 1) {
          list.push(udts[i22].lower);
        }
        nodeCount = rules.length + udts.length;
        for (i22 = 0; i22 < nodeCount; i22 += 1) {
          nodesDefined[i22] = false;
          nodeCallbacks[i22] = null;
        }
        for (const index in that.callbacks) {
          const lower = index.toLowerCase();
          i22 = list.indexOf(lower);
          if (i22 < 0) {
            throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);
          }
          if (typeof that.callbacks[index] === "function") {
            nodesDefined[i22] = true;
            nodeCallbacks[i22] = that.callbacks[index];
          }
          if (that.callbacks[index] === true) {
            nodesDefined[i22] = true;
          }
        }
      }, "init4"), "init");
      this.ruleDefined = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ruleDefined(index) {
        return nodesDefined[index] !== false;
      }, "ruleDefined"), "ruleDefined");
      this.udtDefined = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function udtDefined(index) {
        return nodesDefined[rules.length + index] !== false;
      }, "udtDefined"), "udtDefined");
      this.down = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function down(callbackIndex, name3) {
        const thisIndex = records.length;
        stack.push(thisIndex);
        records.push({
          name: name3,
          thisIndex,
          thatIndex: null,
          state: id2.SEM_PRE,
          callbackIndex,
          phraseIndex: null,
          phraseLength: null,
          stack: stack.length
        });
        return thisIndex;
      }, "down"), "down");
      this.up = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function up(callbackIndex, name3, phraseIndex, phraseLength) {
        const thisIndex = records.length;
        const thatIndex = stack.pop();
        records.push({
          name: name3,
          thisIndex,
          thatIndex,
          state: id2.SEM_POST,
          callbackIndex,
          phraseIndex,
          phraseLength,
          stack: stack.length
        });
        records[thatIndex].thatIndex = thisIndex;
        records[thatIndex].phraseIndex = phraseIndex;
        records[thatIndex].phraseLength = phraseLength;
        return thisIndex;
      }, "up"), "up");
      this.translate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function translate(data) {
        let ret;
        let callback;
        let record;
        for (let i22 = 0; i22 < records.length; i22 += 1) {
          record = records[i22];
          callback = nodeCallbacks[record.callbackIndex];
          if (record.state === id2.SEM_PRE) {
            if (callback !== null) {
              ret = callback(id2.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);
              if (ret === id2.SEM_SKIP) {
                i22 = record.thatIndex;
              }
            }
          } else if (callback !== null) {
            callback(id2.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);
          }
        }
      }, "translate"), "translate");
      this.setLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function setLength(length2) {
        records.length = length2;
        if (length2 > 0) {
          stack.length = records[length2 - 1].stack;
        } else {
          stack.length = 0;
        }
      }, "setLength"), "setLength");
      this.getLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getLength22() {
        return records.length;
      }, "getLength2"), "getLength");
      function indent(n) {
        let ret = "";
        for (let i22 = 0; i22 < n; i22 += 1) {
          ret += " ";
        }
        return ret;
      }
      __name(indent, "indent");
      __name2(indent, "indent");
      this.toXml = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toSml(modeArg) {
        let display = utils.charsToDec;
        let caption = "decimal integer character codes";
        if (typeof modeArg === "string" && modeArg.length >= 3) {
          const mode = modeArg.slice(0, 3).toLowerCase();
          if (mode === "asc") {
            display = utils.charsToAscii;
            caption = "ASCII for printing characters, hex for non-printing";
          } else if (mode === "hex") {
            display = utils.charsToHex;
            caption = "hexadecimal integer character codes";
          } else if (mode === "uni") {
            display = utils.charsToUnicode;
            caption = "Unicode UTF-32 integer character codes";
          }
        }
        let xml = "";
        let depth = 0;
        xml += '<?xml version="1.0" encoding="utf-8"?>\n';
        xml += `<root nodes="${records.length / 2}" characters="${chars.length}">
`;
        xml += `<!-- input string, ${caption} -->
`;
        xml += indent(depth + 2);
        xml += display(chars);
        xml += "\n";
        records.forEach((rec) => {
          if (rec.state === id2.SEM_PRE) {
            depth += 1;
            xml += indent(depth);
            xml += `<node name="${rec.name}" index="${rec.phraseIndex}" length="${rec.phraseLength}">
`;
            xml += indent(depth + 2);
            xml += display(chars, rec.phraseIndex, rec.phraseLength);
            xml += "\n";
          } else {
            xml += indent(depth);
            xml += `</node><!-- name="${rec.name}" -->
`;
            depth -= 1;
          }
        });
        xml += "</root>\n";
        return xml;
      }, "toSml"), "toSml");
      this.phrases = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function phrases() {
        const obj = {};
        let i22;
        let record;
        for (i22 = 0; i22 < records.length; i22 += 1) {
          record = records[i22];
          if (record.state === id2.SEM_PRE) {
            if (!Array.isArray(obj[record.name])) {
              obj[record.name] = [];
            }
            obj[record.name].push({
              index: record.phraseIndex,
              length: record.phraseLength
            });
          }
        }
        return obj;
      }, "phrases"), "phrases");
    }, "exportsAst"), "exportsAst");
  }
});
var require_circular_buffer = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/circular-buffer.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportsCircularBuffer() {
      "use strict;";
      const thisFileName = "circular-buffer.js: ";
      let itemIndex = -1;
      let maxListSize = 0;
      this.init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init4(size) {
        if (typeof size !== "number" || size <= 0) {
          throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);
        }
        maxListSize = Math.ceil(size);
        itemIndex = -1;
      }, "init4"), "init");
      this.increment = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function increment() {
        itemIndex += 1;
        return (itemIndex + maxListSize) % maxListSize;
      }, "increment"), "increment");
      this.maxSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function maxSize() {
        return maxListSize;
      }, "maxSize"), "maxSize");
      this.items = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function items() {
        return itemIndex + 1;
      }, "items"), "items");
      this.getListIndex = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getListIndex(item) {
        if (itemIndex === -1) {
          return -1;
        }
        if (item < 0 || item > itemIndex) {
          return -1;
        }
        if (itemIndex - item >= maxListSize) {
          return -1;
        }
        return (item + maxListSize) % maxListSize;
      }, "getListIndex"), "getListIndex");
      this.forEach = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function forEach(fn) {
        if (itemIndex === -1) {
          return;
        }
        if (itemIndex < maxListSize) {
          for (let i22 = 0; i22 <= itemIndex; i22 += 1) {
            fn(i22, i22);
          }
          return;
        }
        for (let i22 = itemIndex - maxListSize + 1; i22 <= itemIndex; i22 += 1) {
          const listIndex = (i22 + maxListSize) % maxListSize;
          fn(listIndex, i22);
        }
      }, "forEach"), "forEach");
    }, "exportsCircularBuffer"), "exportsCircularBuffer");
  }
});
var require_parser = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/parser.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parser() {
      const id2 = require_identifiers();
      const utils = require_utilities();
      const thisFileName = "parser.js: ";
      const thisThis = this;
      let opExecute;
      this.ast = null;
      this.stats = null;
      this.trace = null;
      this.callbacks = [];
      let opcodes = null;
      let chars = null;
      let charsBegin;
      let charsLength;
      let charsEnd;
      let lookAround;
      let treeDepth = 0;
      let maxTreeDepth = 0;
      let nodeHits = 0;
      let ruleCallbacks = null;
      let udtCallbacks = null;
      let rules = null;
      let udts = null;
      let syntaxData = null;
      let maxMatched = 0;
      let limitTreeDepth = Infinity;
      let limitNodeHits = Infinity;
      const evaluateRule = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function evaluateRule2(ruleIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateRule(): `;
        if (ruleIndex >= rules.length) {
          throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length: length2 } = opcodes;
        opcodes.push({
          type: id2.RNM,
          index: ruleIndex
        });
        opExecute(length2, phraseIndex, sysData);
        opcodes.pop();
      }, "evaluateRule2"), "evaluateRule");
      const evaluateUdt = /* @__PURE__ */ __name2(function(udtIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateUdt(): `;
        if (udtIndex >= udts.length) {
          throw new Error(`${functionName}udt index: ${udtIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length: length2 } = opcodes;
        opcodes.push({
          type: id2.UDT,
          empty: udts[udtIndex].empty,
          index: udtIndex
        });
        opExecute(length2, phraseIndex, sysData);
        opcodes.pop();
      }, "evaluateUdt");
      const clear = /* @__PURE__ */ __name2(function() {
        treeDepth = 0;
        maxTreeDepth = 0;
        nodeHits = 0;
        maxMatched = 0;
        lookAround = [
          {
            lookAround: id2.LOOKAROUND_NONE,
            anchor: 0,
            charsEnd: 0,
            charsLength: 0
          }
        ];
        rules = null;
        udts = null;
        chars = null;
        charsBegin = 0;
        charsLength = 0;
        charsEnd = 0;
        ruleCallbacks = null;
        udtCallbacks = null;
        syntaxData = null;
        opcodes = null;
      }, "clear");
      const backRef = /* @__PURE__ */ __name2(function() {
        const stack = [];
        const init4 = /* @__PURE__ */ __name2(function() {
          const obj = {};
          rules.forEach((rule) => {
            if (rule.isBkr) {
              obj[rule.lower] = null;
            }
          });
          if (udts.length > 0) {
            udts.forEach((udt) => {
              if (udt.isBkr) {
                obj[udt.lower] = null;
              }
            });
          }
          stack.push(obj);
        }, "init");
        const copy = /* @__PURE__ */ __name2(function() {
          const top = stack[stack.length - 1];
          const obj = {};
          for (const name3 in top) {
            obj[name3] = top[name3];
          }
          return obj;
        }, "copy");
        this.push = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function push() {
          stack.push(copy());
        }, "push"), "push");
        this.pop = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pop(lengthArg) {
          let length2 = lengthArg;
          if (!length2) {
            length2 = stack.length - 1;
          }
          if (length2 < 1 || length2 > stack.length) {
            throw new Error(`${thisFileName}backRef.pop(): bad length: ${length2}`);
          }
          stack.length = length2;
          return stack[stack.length - 1];
        }, "pop"), "pop");
        this.length = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function length2() {
          return stack.length;
        }, "length2"), "length");
        this.savePhrase = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function savePhrase(name3, index, length2) {
          stack[stack.length - 1][name3] = {
            phraseIndex: index,
            phraseLength: length2
          };
        }, "savePhrase"), "savePhrase");
        this.getPhrase = function(name3) {
          return stack[stack.length - 1][name3];
        };
        init4();
      }, "backRef");
      const systemData = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function systemData2() {
        const thisData = this;
        this.state = id2.ACTIVE;
        this.phraseLength = 0;
        this.ruleIndex = 0;
        this.udtIndex = 0;
        this.lookAround = lookAround[lookAround.length - 1];
        this.uFrame = new backRef();
        this.pFrame = new backRef();
        this.evaluateRule = evaluateRule;
        this.evaluateUdt = evaluateUdt;
        this.refresh = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function refresh() {
          thisData.state = id2.ACTIVE;
          thisData.phraseLength = 0;
          thisData.lookAround = lookAround[lookAround.length - 1];
        }, "refresh"), "refresh");
      }, "systemData2"), "systemData");
      const lookAroundValue = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lookAroundValue2() {
        return lookAround[lookAround.length - 1];
      }, "lookAroundValue2"), "lookAroundValue");
      const inLookAround = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inLookAround2() {
        return lookAround.length > 1;
      }, "inLookAround2"), "inLookAround");
      const inLookBehind = /* @__PURE__ */ __name2(function() {
        return lookAround[lookAround.length - 1].lookAround === id2.LOOKAROUND_BEHIND;
      }, "inLookBehind");
      const initializeAst = /* @__PURE__ */ __name2(function() {
        const functionName = `${thisFileName}initializeAst(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.ast === void 0) {
            thisThis.ast = null;
            break;
          }
          if (thisThis.ast === null) {
            break;
          }
          if (thisThis.ast.astObject !== "astObject") {
            throw new Error(`${functionName}ast object not recognized`);
          }
          break;
        }
        if (thisThis.ast !== null) {
          thisThis.ast.init(rules, udts, chars);
        }
      }, "initializeAst");
      const initializeTrace = /* @__PURE__ */ __name2(function() {
        const functionName = `${thisFileName}initializeTrace(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.trace === void 0) {
            thisThis.trace = null;
            break;
          }
          if (thisThis.trace === null) {
            break;
          }
          if (thisThis.trace.traceObject !== "traceObject") {
            throw new Error(`${functionName}trace object not recognized`);
          }
          break;
        }
        if (thisThis.trace !== null) {
          thisThis.trace.init(rules, udts, chars);
        }
      }, "initializeTrace");
      const initializeStats = /* @__PURE__ */ __name2(function() {
        const functionName = `${thisFileName}initializeStats(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.stats === void 0) {
            thisThis.stats = null;
            break;
          }
          if (thisThis.stats === null) {
            break;
          }
          if (thisThis.stats.statsObject !== "statsObject") {
            throw new Error(`${functionName}stats object not recognized`);
          }
          break;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.init(rules, udts);
        }
      }, "initializeStats");
      const initializeGrammar = /* @__PURE__ */ __name2(function(grammar) {
        const functionName = `${thisFileName}initializeGrammar(): `;
        if (!grammar) {
          throw new Error(`${functionName}grammar object undefined`);
        }
        if (grammar.grammarObject !== "grammarObject") {
          throw new Error(`${functionName}bad grammar object`);
        }
        rules = grammar.rules;
        udts = grammar.udts;
      }, "initializeGrammar");
      const initializeStartRule = /* @__PURE__ */ __name2(function(startRule) {
        const functionName = `${thisFileName}initializeStartRule(): `;
        let start = null;
        if (typeof startRule === "number") {
          if (startRule >= rules.length) {
            throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);
          }
          start = startRule;
        } else if (typeof startRule === "string") {
          const lower = startRule.toLowerCase();
          for (let i22 = 0; i22 < rules.length; i22 += 1) {
            if (lower === rules[i22].lower) {
              start = rules[i22].index;
              break;
            }
          }
          if (start === null) {
            throw new Error(`${functionName}start rule name '${startRule}' not recognized`);
          }
        } else {
          throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);
        }
        return start;
      }, "initializeStartRule");
      const initializeInputChars = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function initializeInputChars2(inputArg, begArg, lenArg) {
        const functionName = `${thisFileName}initializeInputChars(): `;
        let input = inputArg;
        let beg = begArg;
        let len = lenArg;
        if (input === void 0) {
          throw new Error(`${functionName}input string is undefined`);
        }
        if (input === null) {
          throw new Error(`${functionName}input string is null`);
        }
        if (typeof input === "string") {
          input = utils.stringToChars(input);
        } else if (!Array.isArray(input)) {
          throw new Error(`${functionName}input string is not a string or array`);
        }
        if (input.length > 0) {
          if (typeof input[0] !== "number") {
            throw new Error(`${functionName}input string not an array of integers`);
          }
        }
        if (typeof beg !== "number") {
          beg = 0;
        } else {
          beg = Math.floor(beg);
          if (beg < 0 || beg > input.length) {
            throw new Error(`${functionName}input beginning index out of range: ${beg}`);
          }
        }
        if (typeof len !== "number") {
          len = input.length - beg;
        } else {
          len = Math.floor(len);
          if (len < 0 || len > input.length - beg) {
            throw new Error(`${functionName}input length out of range: ${len}`);
          }
        }
        chars = input;
        charsBegin = beg;
        charsLength = len;
        charsEnd = charsBegin + charsLength;
      }, "initializeInputChars2"), "initializeInputChars");
      const initializeCallbacks = /* @__PURE__ */ __name2(function() {
        const functionName = `${thisFileName}initializeCallbacks(): `;
        let i22;
        ruleCallbacks = [];
        udtCallbacks = [];
        for (i22 = 0; i22 < rules.length; i22 += 1) {
          ruleCallbacks[i22] = null;
        }
        for (i22 = 0; i22 < udts.length; i22 += 1) {
          udtCallbacks[i22] = null;
        }
        let func;
        const list = [];
        for (i22 = 0; i22 < rules.length; i22 += 1) {
          list.push(rules[i22].lower);
        }
        for (i22 = 0; i22 < udts.length; i22 += 1) {
          list.push(udts[i22].lower);
        }
        for (const index in thisThis.callbacks) {
          i22 = list.indexOf(index.toLowerCase());
          if (i22 < 0) {
            throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);
          }
          func = thisThis.callbacks[index];
          if (!func) {
            func = null;
          }
          if (typeof func === "function" || func === null) {
            if (i22 < rules.length) {
              ruleCallbacks[i22] = func;
            } else {
              udtCallbacks[i22 - rules.length] = func;
            }
          } else {
            throw new Error(
              `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`
            );
          }
        }
        for (i22 = 0; i22 < udts.length; i22 += 1) {
          if (udtCallbacks[i22] === null) {
            throw new Error(
              `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i22].lower}] not a function reference`
            );
          }
        }
      }, "initializeCallbacks");
      this.setMaxTreeDepth = function(depth) {
        if (typeof depth !== "number") {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
        limitTreeDepth = Math.floor(depth);
        if (limitTreeDepth <= 0) {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
      };
      this.setMaxNodeHits = function(hits) {
        if (typeof hits !== "number") {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
        limitNodeHits = Math.floor(hits);
        if (limitNodeHits <= 0) {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
      };
      const privateParse = /* @__PURE__ */ __name2(function(grammar, startRuleArg, callbackData) {
        let success;
        const functionName = `${thisFileName}parse(): `;
        initializeGrammar(grammar);
        const startRule = initializeStartRule(startRuleArg);
        initializeCallbacks();
        initializeTrace();
        initializeStats();
        initializeAst();
        const sysData = new systemData();
        if (!(callbackData === void 0 || callbackData === null)) {
          syntaxData = callbackData;
        }
        opcodes = [
          {
            type: id2.RNM,
            index: startRule
          }
        ];
        opExecute(0, charsBegin, sysData);
        opcodes = null;
        switch (sysData.state) {
          case id2.ACTIVE:
            throw new Error(`${functionName}final state should never be 'ACTIVE'`);
          case id2.NOMATCH:
            success = false;
            break;
          case id2.EMPTY:
          case id2.MATCH:
            if (sysData.phraseLength === charsLength) {
              success = true;
            } else {
              success = false;
            }
            break;
          default:
            throw new Error("unrecognized state");
        }
        return {
          success,
          state: sysData.state,
          length: charsLength,
          matched: sysData.phraseLength,
          maxMatched,
          maxTreeDepth,
          nodeHits,
          inputLength: chars.length,
          subBegin: charsBegin,
          subEnd: charsEnd,
          subLength: charsLength
        };
      }, "privateParse");
      this.parseSubstring = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {
        clear();
        initializeInputChars(inputChars, inputIndex, inputLength);
        return privateParse(grammar, startRule, callbackData);
      }, "parseSubstring"), "parseSubstring");
      this.parse = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parse3(grammar, startRule, inputChars, callbackData) {
        clear();
        initializeInputChars(inputChars, 0, inputChars.length);
        return privateParse(grammar, startRule, callbackData);
      }, "parse3"), "parse");
      const opALT = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        for (let i22 = 0; i22 < op.children.length; i22 += 1) {
          opExecute(op.children[i22], phraseIndex, sysData);
          if (sysData.state !== id2.NOMATCH) {
            break;
          }
        }
      }, "opALT");
      const opCAT = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catPhrase;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catPhrase = 0;
        for (let i22 = 0; i22 < op.children.length; i22 += 1) {
          opExecute(op.children[i22], catCharIndex, sysData);
          if (sysData.state === id2.NOMATCH) {
            success = false;
            break;
          } else {
            catCharIndex += sysData.phraseLength;
            catPhrase += sysData.phraseLength;
          }
        }
        if (success) {
          sysData.state = catPhrase === 0 ? id2.EMPTY : id2.MATCH;
          sysData.phraseLength = catPhrase;
        } else {
          sysData.state = id2.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opCAT");
      const opREP = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex >= charsEnd) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id2.NOMATCH) {
            break;
          }
          if (sysData.state === id2.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex += sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id2.EMPTY) {
          sysData.state = repPhrase === 0 ? id2.EMPTY : id2.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id2.EMPTY : id2.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id2.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opREP");
      const validateRnmCallbackResult = /* @__PURE__ */ __name2(function(rule, sysData, charsLeft, down) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id2.ACTIVE:
            if (down !== true) {
              throw new Error(
                `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`
              );
            }
            break;
          case id2.EMPTY:
            sysData.phraseLength = 0;
            break;
          case id2.MATCH:
            if (sysData.phraseLength === 0) {
              sysData.state = id2.EMPTY;
            }
            break;
          case id2.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(
              `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`
            );
        }
      }, "validateRnmCallbackResult");
      const opRNM = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astDefined;
        let savedOpcodes;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const rule = rules[op.index];
        const callback = ruleCallbacks[rule.index];
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);
          if (astDefined) {
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(op.index, rules[op.index].name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        if (callback === null) {
          savedOpcodes = opcodes;
          opcodes = rule.opcodes;
          opExecute(0, phraseIndex, sysData);
          opcodes = savedOpcodes;
        } else {
          const charsLeft = charsEnd - phraseIndex;
          sysData.ruleIndex = rule.index;
          callback(sysData, chars, phraseIndex, syntaxData);
          validateRnmCallbackResult(rule, sysData, charsLeft, true);
          if (sysData.state === id2.ACTIVE) {
            savedOpcodes = opcodes;
            opcodes = rule.opcodes;
            opExecute(0, phraseIndex, sysData);
            opcodes = savedOpcodes;
            sysData.ruleIndex = rule.index;
            callback(sysData, chars, phraseIndex, syntaxData);
            validateRnmCallbackResult(rule, sysData, charsLeft, false);
          }
        }
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id2.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id2.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (rule.isBkr) {
            sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
          }
        }
      }, "opRNM");
      const validateUdtCallbackResult = /* @__PURE__ */ __name2(function(udt, sysData, charsLeft) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id2.ACTIVE:
            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);
          case id2.EMPTY:
            if (udt.empty === false) {
              throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
            } else {
              sysData.phraseLength = 0;
            }
            break;
          case id2.MATCH:
            if (sysData.phraseLength === 0) {
              if (udt.empty === false) {
                throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
              } else {
                sysData.state = id2.EMPTY;
              }
            }
            break;
          case id2.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(
              `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`
            );
        }
      }, "validateUdtCallbackResult");
      const opUDT = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astIndex;
        let astDefined;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const udt = udts[op.index];
        sysData.UdtIndex = udt.index;
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);
          if (astDefined) {
            astIndex = rules.length + op.index;
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(astIndex, udt.name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        const charsLeft = charsEnd - phraseIndex;
        udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);
        validateUdtCallbackResult(udt, sysData, charsLeft);
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id2.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id2.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (udt.isBkr) {
            sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
          }
        }
      }, "opUDT");
      const opAND = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id2.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id2.EMPTY:
            sysData.state = id2.EMPTY;
            break;
          case id2.MATCH:
            sysData.state = id2.EMPTY;
            break;
          case id2.NOMATCH:
            sysData.state = id2.NOMATCH;
            break;
          default:
            throw new Error(`opAND: invalid state ${sysData.state}`);
        }
      }, "opAND");
      const opNOT = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id2.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id2.EMPTY:
          case id2.MATCH:
            sysData.state = id2.NOMATCH;
            break;
          case id2.NOMATCH:
            sysData.state = id2.EMPTY;
            break;
          default:
            throw new Error(`opNOT: invalid state ${sysData.state}`);
        }
      }, "opNOT");
      const opTRG = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id2.NOMATCH;
        if (phraseIndex < charsEnd) {
          if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {
            sysData.state = id2.MATCH;
            sysData.phraseLength = 1;
          }
        }
      }, "opTRG");
      const opTBS = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let i22;
        const op = opcodes[opIndex];
        const len = op.string.length;
        sysData.state = id2.NOMATCH;
        if (phraseIndex + len <= charsEnd) {
          for (i22 = 0; i22 < len; i22 += 1) {
            if (chars[phraseIndex + i22] !== op.string[i22]) {
              return;
            }
          }
          sysData.state = id2.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTBS");
      const opTLS = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let i22;
        let code3;
        const op = opcodes[opIndex];
        sysData.state = id2.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id2.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          for (i22 = 0; i22 < len; i22 += 1) {
            code3 = chars[phraseIndex + i22];
            if (code3 >= 65 && code3 <= 90) {
              code3 += 32;
            }
            if (code3 !== op.string[i22]) {
              return;
            }
          }
          sysData.state = id2.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTLS");
      const opABG = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        sysData.state = id2.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === 0 ? id2.EMPTY : id2.NOMATCH;
      }, "opABG");
      const opAEN = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        sysData.state = id2.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === chars.length ? id2.EMPTY : id2.NOMATCH;
      }, "opAEN");
      const opBKR = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let i22;
        let code3;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id2.NOMATCH;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame = op.bkrMode === id2.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id2.BKR_MODE_CI;
        if (frame === null) {
          return;
        }
        const lmIndex = frame.phraseIndex;
        const len = frame.phraseLength;
        if (len === 0) {
          sysData.state = id2.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          if (insensitive) {
            for (i22 = 0; i22 < len; i22 += 1) {
              code3 = chars[phraseIndex + i22];
              lmcode = chars[lmIndex + i22];
              if (code3 >= 65 && code3 <= 90) {
                code3 += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code3 !== lmcode) {
                return;
              }
            }
            sysData.state = id2.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i22 = 0; i22 < len; i22 += 1) {
              code3 = chars[phraseIndex + i22];
              lmcode = chars[lmIndex + i22];
              if (code3 !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id2.MATCH;
          sysData.phraseLength = len;
        }
      }, "opBKR");
      const opBKA = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id2.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id2.EMPTY:
            sysData.state = id2.EMPTY;
            break;
          case id2.MATCH:
            sysData.state = id2.EMPTY;
            break;
          case id2.NOMATCH:
            sysData.state = id2.NOMATCH;
            break;
          default:
            throw new Error(`opBKA: invalid state ${sysData.state}`);
        }
      }, "opBKA");
      const opBKN = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id2.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id2.EMPTY:
          case id2.MATCH:
            sysData.state = id2.NOMATCH;
            break;
          case id2.NOMATCH:
            sysData.state = id2.EMPTY;
            break;
          default:
            throw new Error(`opBKN: invalid state ${sysData.state}`);
        }
      }, "opBKN");
      const opCATBehind = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catMatched;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catMatched = 0;
        for (let i22 = op.children.length - 1; i22 >= 0; i22 -= 1) {
          opExecute(op.children[i22], catCharIndex, sysData);
          catCharIndex -= sysData.phraseLength;
          catMatched += sysData.phraseLength;
          if (sysData.state === id2.NOMATCH) {
            success = false;
            break;
          }
        }
        if (success) {
          sysData.state = catMatched === 0 ? id2.EMPTY : id2.MATCH;
          sysData.phraseLength = catMatched;
        } else {
          sysData.state = id2.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opCATBehind");
      const opREPBehind = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex <= 0) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id2.NOMATCH) {
            break;
          }
          if (sysData.state === id2.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex -= sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id2.EMPTY) {
          sysData.state = repPhrase === 0 ? id2.EMPTY : id2.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id2.EMPTY : id2.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id2.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opREPBehind");
      const opTRGBehind = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id2.NOMATCH;
        sysData.phraseLength = 0;
        if (phraseIndex > 0) {
          const char = chars[phraseIndex - 1];
          if (op.min <= char && char <= op.max) {
            sysData.state = id2.MATCH;
            sysData.phraseLength = 1;
          }
        }
      }, "opTRGBehind");
      const opTBSBehind = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let i22;
        const op = opcodes[opIndex];
        sysData.state = id2.NOMATCH;
        const len = op.string.length;
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (i22 = 0; i22 < len; i22 += 1) {
            if (chars[beg + i22] !== op.string[i22]) {
              return;
            }
          }
          sysData.state = id2.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTBSBehind");
      const opTLSBehind = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let char;
        const op = opcodes[opIndex];
        sysData.state = id2.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id2.EMPTY;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (let i22 = 0; i22 < len; i22 += 1) {
            char = chars[beg + i22];
            if (char >= 65 && char <= 90) {
              char += 32;
            }
            if (char !== op.string[i22]) {
              return;
            }
          }
          sysData.state = id2.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTLSBehind");
      const opBKRBehind = /* @__PURE__ */ __name2(function(opIndex, phraseIndex, sysData) {
        let i22;
        let code3;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id2.NOMATCH;
        sysData.phraseLength = 0;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame = op.bkrMode === id2.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id2.BKR_MODE_CI;
        if (frame === null) {
          return;
        }
        const lmIndex = frame.phraseIndex;
        const len = frame.phraseLength;
        if (len === 0) {
          sysData.state = id2.EMPTY;
          sysData.phraseLength = 0;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          if (insensitive) {
            for (i22 = 0; i22 < len; i22 += 1) {
              code3 = chars[beg + i22];
              lmcode = chars[lmIndex + i22];
              if (code3 >= 65 && code3 <= 90) {
                code3 += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code3 !== lmcode) {
                return;
              }
            }
            sysData.state = id2.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i22 = 0; i22 < len; i22 += 1) {
              code3 = chars[beg + i22];
              lmcode = chars[lmIndex + i22];
              if (code3 !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id2.MATCH;
          sysData.phraseLength = len;
        }
      }, "opBKRBehind");
      opExecute = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function opExecuteFunc(opIndex, phraseIndex, sysData) {
        let ret = true;
        const op = opcodes[opIndex];
        nodeHits += 1;
        if (nodeHits > limitNodeHits) {
          throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);
        }
        treeDepth += 1;
        if (treeDepth > maxTreeDepth) {
          maxTreeDepth = treeDepth;
          if (maxTreeDepth > limitTreeDepth) {
            throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);
          }
        }
        sysData.refresh();
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        if (inLookBehind()) {
          switch (op.type) {
            case id2.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id2.CAT:
              opCATBehind(opIndex, phraseIndex, sysData);
              break;
            case id2.REP:
              opREPBehind(opIndex, phraseIndex, sysData);
              break;
            case id2.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id2.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id2.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id2.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id2.TRG:
              opTRGBehind(opIndex, phraseIndex, sysData);
              break;
            case id2.TBS:
              opTBSBehind(opIndex, phraseIndex, sysData);
              break;
            case id2.TLS:
              opTLSBehind(opIndex, phraseIndex, sysData);
              break;
            case id2.BKR:
              opBKRBehind(opIndex, phraseIndex, sysData);
              break;
            case id2.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id2.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id2.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id2.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        } else {
          switch (op.type) {
            case id2.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id2.CAT:
              opCAT(opIndex, phraseIndex, sysData);
              break;
            case id2.REP:
              opREP(opIndex, phraseIndex, sysData);
              break;
            case id2.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id2.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id2.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id2.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id2.TRG:
              opTRG(opIndex, phraseIndex, sysData);
              break;
            case id2.TBS:
              opTBS(opIndex, phraseIndex, sysData);
              break;
            case id2.TLS:
              opTLS(opIndex, phraseIndex, sysData);
              break;
            case id2.BKR:
              opBKR(opIndex, phraseIndex, sysData);
              break;
            case id2.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id2.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id2.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id2.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        }
        if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {
          maxMatched = phraseIndex + sysData.phraseLength;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.collect(op, sysData);
        }
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        treeDepth -= 1;
        return ret;
      }, "opExecuteFunc"), "opExecuteFunc");
    }, "parser"), "parser");
  }
});
var require_stats = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/stats.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function statsFunc() {
      const id2 = require_identifiers();
      const utils = require_utilities();
      const style = require_style();
      const thisFileName = "stats.js: ";
      let rules = [];
      let udts = [];
      const stats = [];
      let totals;
      const ruleStats = [];
      const udtStats = [];
      this.statsObject = "statsObject";
      const nameId = "stats";
      const sortAlpha = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sortAlpha2(lhs, rhs) {
        if (lhs.lower < rhs.lower) {
          return -1;
        }
        if (lhs.lower > rhs.lower) {
          return 1;
        }
        return 0;
      }, "sortAlpha2"), "sortAlpha");
      const sortHits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sortHits2(lhs, rhs) {
        if (lhs.total < rhs.total) {
          return 1;
        }
        if (lhs.total > rhs.total) {
          return -1;
        }
        return sortAlpha(lhs, rhs);
      }, "sortHits2"), "sortHits");
      const sortIndex = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sortIndex2(lhs, rhs) {
        if (lhs.index < rhs.index) {
          return -1;
        }
        if (lhs.index > rhs.index) {
          return 1;
        }
        return 0;
      }, "sortIndex2"), "sortIndex");
      const EmptyStat = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function EmptyStat2() {
        this.empty = 0;
        this.match = 0;
        this.nomatch = 0;
        this.total = 0;
      }, "EmptyStat2"), "EmptyStat");
      const clear = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function clear2() {
        stats.length = 0;
        totals = new EmptyStat();
        stats[id2.ALT] = new EmptyStat();
        stats[id2.CAT] = new EmptyStat();
        stats[id2.REP] = new EmptyStat();
        stats[id2.RNM] = new EmptyStat();
        stats[id2.TRG] = new EmptyStat();
        stats[id2.TBS] = new EmptyStat();
        stats[id2.TLS] = new EmptyStat();
        stats[id2.UDT] = new EmptyStat();
        stats[id2.AND] = new EmptyStat();
        stats[id2.NOT] = new EmptyStat();
        stats[id2.BKR] = new EmptyStat();
        stats[id2.BKA] = new EmptyStat();
        stats[id2.BKN] = new EmptyStat();
        stats[id2.ABG] = new EmptyStat();
        stats[id2.AEN] = new EmptyStat();
        ruleStats.length = 0;
        for (let i22 = 0; i22 < rules.length; i22 += 1) {
          ruleStats.push({
            empty: 0,
            match: 0,
            nomatch: 0,
            total: 0,
            name: rules[i22].name,
            lower: rules[i22].lower,
            index: rules[i22].index
          });
        }
        if (udts.length > 0) {
          udtStats.length = 0;
          for (let i22 = 0; i22 < udts.length; i22 += 1) {
            udtStats.push({
              empty: 0,
              match: 0,
              nomatch: 0,
              total: 0,
              name: udts[i22].name,
              lower: udts[i22].lower,
              index: udts[i22].index
            });
          }
        }
      }, "clear2"), "clear");
      const incStat = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function incStat2(stat, state) {
        stat.total += 1;
        switch (state) {
          case id2.EMPTY:
            stat.empty += 1;
            break;
          case id2.MATCH:
            stat.match += 1;
            break;
          case id2.NOMATCH:
            stat.nomatch += 1;
            break;
          default:
            throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);
        }
      }, "incStat2"), "incStat");
      const displayRow = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function displayRow2(name3, stat) {
        let html = "";
        html += "<tr>";
        html += `<td class="${style.CLASS_ACTIVE}">${name3}</td>`;
        html += `<td class="${style.CLASS_EMPTY}">${stat.empty}</td>`;
        html += `<td class="${style.CLASS_MATCH}">${stat.match}</td>`;
        html += `<td class="${style.CLASS_NOMATCH}">${stat.nomatch}</td>`;
        html += `<td class="${style.CLASS_ACTIVE}">${stat.total}</td>`;
        html += "</tr>\n";
        return html;
      }, "displayRow2"), "displayRow");
      const displayOpsOnly = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function displayOpsOnly2() {
        let html = "";
        html += displayRow("ALT", stats[id2.ALT]);
        html += displayRow("CAT", stats[id2.CAT]);
        html += displayRow("REP", stats[id2.REP]);
        html += displayRow("RNM", stats[id2.RNM]);
        html += displayRow("TRG", stats[id2.TRG]);
        html += displayRow("TBS", stats[id2.TBS]);
        html += displayRow("TLS", stats[id2.TLS]);
        html += displayRow("UDT", stats[id2.UDT]);
        html += displayRow("AND", stats[id2.AND]);
        html += displayRow("NOT", stats[id2.NOT]);
        html += displayRow("BKR", stats[id2.BKR]);
        html += displayRow("BKA", stats[id2.BKA]);
        html += displayRow("BKN", stats[id2.BKN]);
        html += displayRow("ABG", stats[id2.ABG]);
        html += displayRow("AEN", stats[id2.AEN]);
        html += displayRow("totals", totals);
        return html;
      }, "displayOpsOnly2"), "displayOpsOnly");
      const displayRules = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function displayRules2() {
        let html = "";
        html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
        html += "<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\n";
        for (let i22 = 0; i22 < rules.length; i22 += 1) {
          if (ruleStats[i22].total > 0) {
            html += "<tr>";
            html += `<td class="${style.CLASS_ACTIVE}">${ruleStats[i22].name}</td>`;
            html += `<td class="${style.CLASS_EMPTY}">${ruleStats[i22].empty}</td>`;
            html += `<td class="${style.CLASS_MATCH}">${ruleStats[i22].match}</td>`;
            html += `<td class="${style.CLASS_NOMATCH}">${ruleStats[i22].nomatch}</td>`;
            html += `<td class="${style.CLASS_ACTIVE}">${ruleStats[i22].total}</td>`;
            html += "</tr>\n";
          }
        }
        if (udts.length > 0) {
          html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
          html += "<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\n";
          for (let i22 = 0; i22 < udts.length; i22 += 1) {
            if (udtStats[i22].total > 0) {
              html += "<tr>";
              html += `<td class="${style.CLASS_ACTIVE}">${udtStats[i22].name}</td>`;
              html += `<td class="${style.CLASS_EMPTY}">${udtStats[i22].empty}</td>`;
              html += `<td class="${style.CLASS_MATCH}">${udtStats[i22].match}</td>`;
              html += `<td class="${style.CLASS_NOMATCH}">${udtStats[i22].nomatch}</td>`;
              html += `<td class="${style.CLASS_ACTIVE}">${udtStats[i22].total}</td>`;
              html += "</tr>\n";
            }
          }
        }
        return html;
      }, "displayRules2"), "displayRules");
      this.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate7(name3) {
        let ret = false;
        if (typeof name3 === "string" && nameId === name3) {
          ret = true;
        }
        return ret;
      }, "validate7"), "validate");
      this.init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init4(inputRules, inputUdts) {
        rules = inputRules;
        udts = inputUdts;
        clear();
      }, "init4"), "init");
      this.collect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function collect(op, result) {
        incStat(totals, result.state, result.phraseLength);
        incStat(stats[op.type], result.state, result.phraseLength);
        if (op.type === id2.RNM) {
          incStat(ruleStats[op.index], result.state, result.phraseLength);
        }
        if (op.type === id2.UDT) {
          incStat(udtStats[op.index], result.state, result.phraseLength);
        }
      }, "collect"), "collect");
      this.toHtml = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toHtml(type, caption) {
        let html = "";
        html += `<table class="${style.CLASS_STATS}">
`;
        if (typeof caption === "string") {
          html += `<caption>${caption}</caption>
`;
        }
        html += `<tr><th class="${style.CLASS_ACTIVE}">ops</th>
`;
        html += `<th class="${style.CLASS_EMPTY}">EMPTY</th>
`;
        html += `<th class="${style.CLASS_MATCH}">MATCH</th>
`;
        html += `<th class="${style.CLASS_NOMATCH}">NOMATCH</th>
`;
        html += `<th class="${style.CLASS_ACTIVE}">totals</th></tr>
`;
        const test = true;
        while (test) {
          if (type === void 0) {
            html += displayOpsOnly();
            break;
          }
          if (type === null) {
            html += displayOpsOnly();
            break;
          }
          if (type === "ops") {
            html += displayOpsOnly();
            break;
          }
          if (type === "index") {
            ruleStats.sort(sortIndex);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type === "hits") {
            ruleStats.sort(sortHits);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type === "alpha") {
            ruleStats.sort(sortAlpha);
            if (udtStats.length > 0) {
              udtStats.sort(sortAlpha);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          break;
        }
        html += "</table>\n";
        return html;
      }, "toHtml"), "toHtml");
      this.toHtmlPage = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toHtmlPage(type, caption, title) {
        return utils.htmlToPage(this.toHtml(type, caption), title);
      }, "toHtmlPage"), "toHtmlPage");
    }, "statsFunc"), "statsFunc");
  }
});
var require_trace = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/trace.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportTrace() {
      const utils = require_utilities();
      const style = require_style();
      const circular = new (require_circular_buffer())();
      const id2 = require_identifiers();
      const thisFileName = "trace.js: ";
      const that = this;
      const MODE_HEX = 16;
      const MODE_DEC = 10;
      const MODE_ASCII = 8;
      const MODE_UNICODE = 32;
      const MAX_PHRASE = 80;
      const MAX_TLS = 5;
      const records = [];
      let maxRecords = 5e3;
      let lastRecord = -1;
      let filteredRecords = 0;
      let treeDepth = 0;
      const recordStack = [];
      let chars = null;
      let rules = null;
      let udts = null;
      const operatorFilter = [];
      const ruleFilter = [];
      const PHRASE_END = `<span class="${style.CLASS_LINEEND}">&bull;</span>`;
      const PHRASE_CONTINUE = `<span class="${style.CLASS_LINEEND}">&hellip;</span>`;
      const PHRASE_EMPTY = `<span class="${style.CLASS_EMPTY}">&#120634;</span>`;
      const initOperatorFilter = /* @__PURE__ */ __name2(function() {
        const setOperators = /* @__PURE__ */ __name2(function(set) {
          operatorFilter[id2.ALT] = set;
          operatorFilter[id2.CAT] = set;
          operatorFilter[id2.REP] = set;
          operatorFilter[id2.TLS] = set;
          operatorFilter[id2.TBS] = set;
          operatorFilter[id2.TRG] = set;
          operatorFilter[id2.AND] = set;
          operatorFilter[id2.NOT] = set;
          operatorFilter[id2.BKR] = set;
          operatorFilter[id2.BKA] = set;
          operatorFilter[id2.BKN] = set;
          operatorFilter[id2.ABG] = set;
          operatorFilter[id2.AEN] = set;
        }, "setOperators");
        let items = 0;
        for (const name3 in that.filter.operators) {
          items += 1;
        }
        if (items === 0) {
          setOperators(false);
          return;
        }
        for (const name3 in that.filter.operators) {
          const upper = name3.toUpperCase();
          if (upper === "<ALL>") {
            setOperators(true);
            return;
          }
          if (upper === "<NONE>") {
            setOperators(false);
            return;
          }
        }
        setOperators(false);
        for (const name3 in that.filter.operators) {
          const upper = name3.toUpperCase();
          if (upper === "ALT") {
            operatorFilter[id2.ALT] = that.filter.operators[name3] === true;
          } else if (upper === "CAT") {
            operatorFilter[id2.CAT] = that.filter.operators[name3] === true;
          } else if (upper === "REP") {
            operatorFilter[id2.REP] = that.filter.operators[name3] === true;
          } else if (upper === "AND") {
            operatorFilter[id2.AND] = that.filter.operators[name3] === true;
          } else if (upper === "NOT") {
            operatorFilter[id2.NOT] = that.filter.operators[name3] === true;
          } else if (upper === "TLS") {
            operatorFilter[id2.TLS] = that.filter.operators[name3] === true;
          } else if (upper === "TBS") {
            operatorFilter[id2.TBS] = that.filter.operators[name3] === true;
          } else if (upper === "TRG") {
            operatorFilter[id2.TRG] = that.filter.operators[name3] === true;
          } else if (upper === "BKR") {
            operatorFilter[id2.BKR] = that.filter.operators[name3] === true;
          } else if (upper === "BKA") {
            operatorFilter[id2.BKA] = that.filter.operators[name3] === true;
          } else if (upper === "BKN") {
            operatorFilter[id2.BKN] = that.filter.operators[name3] === true;
          } else if (upper === "ABG") {
            operatorFilter[id2.ABG] = that.filter.operators[name3] === true;
          } else if (upper === "AEN") {
            operatorFilter[id2.AEN] = that.filter.operators[name3] === true;
          } else {
            throw new Error(
              `${thisFileName}initOpratorFilter: '${name3}' not a valid operator name. Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`
            );
          }
        }
      }, "initOperatorFilter");
      const initRuleFilter = /* @__PURE__ */ __name2(function() {
        const setRules = /* @__PURE__ */ __name2(function(set) {
          operatorFilter[id2.RNM] = set;
          operatorFilter[id2.UDT] = set;
          const count = rules.length + udts.length;
          ruleFilter.length = 0;
          for (let i3 = 0; i3 < count; i3 += 1) {
            ruleFilter.push(set);
          }
        }, "setRules");
        let items;
        let i22;
        const list = [];
        for (i22 = 0; i22 < rules.length; i22 += 1) {
          list.push(rules[i22].lower);
        }
        for (i22 = 0; i22 < udts.length; i22 += 1) {
          list.push(udts[i22].lower);
        }
        ruleFilter.length = 0;
        items = 0;
        for (const name3 in that.filter.rules) {
          items += 1;
        }
        if (items === 0) {
          setRules(true);
          return;
        }
        for (const name3 in that.filter.rules) {
          const lower = name3.toLowerCase();
          if (lower === "<all>") {
            setRules(true);
            return;
          }
          if (lower === "<none>") {
            setRules(false);
            return;
          }
        }
        setRules(false);
        operatorFilter[id2.RNM] = true;
        operatorFilter[id2.UDT] = true;
        for (const name3 in that.filter.rules) {
          const lower = name3.toLowerCase();
          i22 = list.indexOf(lower);
          if (i22 < 0) {
            throw new Error(`${thisFileName}initRuleFilter: '${name3}' not a valid rule or udt name`);
          }
          ruleFilter[i22] = that.filter.rules[name3] === true;
        }
      }, "initRuleFilter");
      this.traceObject = "traceObject";
      this.filter = {
        operators: [],
        rules: []
      };
      this.setMaxRecords = function(max, last2) {
        lastRecord = -1;
        if (typeof max === "number" && max > 0) {
          maxRecords = Math.ceil(max);
        } else {
          maxRecords = 0;
          return;
        }
        if (typeof last2 === "number") {
          lastRecord = Math.floor(last2);
          if (lastRecord < 0) {
            lastRecord = -1;
          }
        }
      };
      this.getMaxRecords = function() {
        return maxRecords;
      };
      this.getLastRecord = function() {
        return lastRecord;
      };
      this.init = function(rulesIn, udtsIn, charsIn) {
        records.length = 0;
        recordStack.length = 0;
        filteredRecords = 0;
        treeDepth = 0;
        chars = charsIn;
        rules = rulesIn;
        udts = udtsIn;
        initOperatorFilter();
        initRuleFilter();
        circular.init(maxRecords);
      };
      const filterOps = /* @__PURE__ */ __name2(function(op) {
        let ret = false;
        if (op.type === id2.RNM) {
          if (operatorFilter[op.type] && ruleFilter[op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else if (op.type === id2.UDT) {
          if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else {
          ret = operatorFilter[op.type];
        }
        return ret;
      }, "filterOps");
      const filterRecords = /* @__PURE__ */ __name2(function(record) {
        if (lastRecord === -1) {
          return true;
        }
        if (record <= lastRecord) {
          return true;
        }
        return false;
      }, "filterRecords");
      this.down = function(op, state, offset, length2, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          recordStack.push(filteredRecords);
          records[circular.increment()] = {
            dirUp: false,
            depth: treeDepth,
            thisLine: filteredRecords,
            thatLine: void 0,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length2,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
          treeDepth += 1;
        }
      };
      this.up = function(op, state, offset, length2, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          const thisLine = filteredRecords;
          const thatLine = recordStack.pop();
          const thatRecord = circular.getListIndex(thatLine);
          if (thatRecord !== -1) {
            records[thatRecord].thatLine = thisLine;
          }
          treeDepth -= 1;
          records[circular.increment()] = {
            dirUp: true,
            depth: treeDepth,
            thisLine,
            thatLine,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length2,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
        }
      };
      const toTreeObj = /* @__PURE__ */ __name2(function() {
        function nodeOpcode(node2, opcode) {
          let name3;
          let casetype;
          let modetype;
          if (opcode) {
            node2.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };
            node2.opData = void 0;
            switch (opcode.type) {
              case id2.RNM:
                node2.opData = rules[opcode.index].name;
                break;
              case id2.UDT:
                node2.opData = udts[opcode.index].name;
                break;
              case id2.BKR:
                if (opcode.index < rules.length) {
                  name3 = rules[opcode.index].name;
                } else {
                  name3 = udts[opcode.index - rules.length].name;
                }
                casetype = opcode.bkrCase === id2.BKR_MODE_CI ? "%i" : "%s";
                modetype = opcode.bkrMode === id2.BKR_MODE_UM ? "%u" : "%p";
                node2.opData = `\\\\${casetype}${modetype}${name3}`;
                break;
              case id2.TLS:
                node2.opData = [];
                for (let i22 = 0; i22 < opcode.string.length; i22 += 1) {
                  node2.opData.push(opcode.string[i22]);
                }
                break;
              case id2.TBS:
                node2.opData = [];
                for (let i22 = 0; i22 < opcode.string.length; i22 += 1) {
                  node2.opData.push(opcode.string[i22]);
                }
                break;
              case id2.TRG:
                node2.opData = [opcode.min, opcode.max];
                break;
              case id2.REP:
                node2.opData = [opcode.min, opcode.max];
                break;
              default:
                throw new Error("unrecognized opcode");
            }
          } else {
            node2.op = { id: void 0, name: void 0 };
            node2.opData = void 0;
          }
        }
        __name(nodeOpcode, "nodeOpcode");
        __name2(nodeOpcode, "nodeOpcode");
        function nodePhrase(state, index, length2) {
          if (state === id2.MATCH) {
            return {
              index,
              length: length2
            };
          }
          if (state === id2.NOMATCH) {
            return {
              index,
              length: 0
            };
          }
          if (state === id2.EMPTY) {
            return {
              index,
              length: 0
            };
          }
          return null;
        }
        __name(nodePhrase, "nodePhrase");
        __name2(nodePhrase, "nodePhrase");
        let nodeId = -1;
        function nodeDown(parent2, record2, depth2) {
          const node2 = {
            id: nodeId++,
            branch: -1,
            parent: parent2,
            up: false,
            down: false,
            depth: depth2,
            children: []
          };
          if (record2) {
            node2.down = true;
            node2.state = { id: record2.state, name: utils.stateToString(record2.state) };
            node2.phrase = null;
            nodeOpcode(node2, record2.opcode);
          } else {
            node2.state = { id: void 0, name: void 0 };
            node2.phrase = nodePhrase();
            nodeOpcode(node2, void 0);
          }
          return node2;
        }
        __name(nodeDown, "nodeDown");
        __name2(nodeDown, "nodeDown");
        function nodeUp(node2, record2) {
          if (record2) {
            node2.up = true;
            node2.state = { id: record2.state, name: utils.stateToString(record2.state) };
            node2.phrase = nodePhrase(record2.state, record2.phraseIndex, record2.phraseLength);
            if (!node2.down) {
              nodeOpcode(node2, record2.opcode);
            }
          }
        }
        __name(nodeUp, "nodeUp");
        __name2(nodeUp, "nodeUp");
        let leafNodes = 0;
        let depth = -1;
        let branchCount = 1;
        function walk(node2) {
          depth += 1;
          node2.branch = branchCount;
          if (depth > treeDepth) {
            treeDepth = depth;
          }
          if (node2.children.length === 0) {
            leafNodes += 1;
          } else {
            for (let i22 = 0; i22 < node2.children.length; i22 += 1) {
              if (i22 > 0) {
                branchCount += 1;
              }
              node2.children[i22].leftMost = false;
              node2.children[i22].rightMost = false;
              if (node2.leftMost) {
                node2.children[i22].leftMost = i22 === 0;
              }
              if (node2.rightMost) {
                node2.children[i22].rightMost = i22 === node2.children.length - 1;
              }
              walk(node2.children[i22]);
            }
          }
          depth -= 1;
        }
        __name(walk, "walk");
        __name2(walk, "walk");
        function display(node2, offset) {
          let name3;
          const obj2 = {};
          obj2.id = node2.id;
          obj2.branch = node2.branch;
          obj2.leftMost = node2.leftMost;
          obj2.rightMost = node2.rightMost;
          name3 = node2.state.name ? node2.state.name : "ACTIVE";
          obj2.state = { id: node2.state.id, name: name3 };
          name3 = node2.op.name ? node2.op.name : "?";
          obj2.op = { id: node2.op.id, name: name3 };
          if (typeof node2.opData === "string") {
            obj2.opData = node2.opData;
          } else if (Array.isArray(node2.opData)) {
            obj2.opData = [];
            for (let i22 = 0; i22 < node2.opData.length; i22 += 1) {
              obj2.opData[i22] = node2.opData[i22];
            }
          } else {
            obj2.opData = void 0;
          }
          if (node2.phrase) {
            obj2.phrase = { index: node2.phrase.index, length: node2.phrase.length };
          } else {
            obj2.phrase = null;
          }
          obj2.depth = node2.depth;
          obj2.children = [];
          for (let i22 = 0; i22 < node2.children.length; i22 += 1) {
            const c2 = i22 !== node2.children.length - 1;
            obj2.children[i22] = display(node2.children[i22], offset, c2);
          }
          return obj2;
        }
        __name(display, "display");
        __name2(display, "display");
        const branch = [];
        let root;
        let node;
        let parent;
        let record;
        let firstRecord = true;
        const dummy = nodeDown(null, null, -1);
        branch.push(dummy);
        node = dummy;
        circular.forEach((lineIndex) => {
          record = records[lineIndex];
          if (firstRecord) {
            firstRecord = false;
            if (record.depth > 0) {
              const num = record.dirUp ? record.depth + 1 : record.depth;
              for (let i22 = 0; i22 < num; i22 += 1) {
                parent = node;
                node = nodeDown(node, null, i22);
                branch.push(node);
                parent.children.push(node);
              }
            }
          }
          if (record.dirUp) {
            node = branch.pop();
            nodeUp(node, record);
            node = branch[branch.length - 1];
          } else {
            parent = node;
            node = nodeDown(node, record, record.depth);
            branch.push(node);
            parent.children.push(node);
          }
        });
        while (branch.length > 1) {
          node = branch.pop();
          nodeUp(node, null);
        }
        if (dummy.children.length === 0) {
          throw new Error("trace.toTree(): parse tree has no nodes");
        }
        if (branch.length === 0) {
          throw new Error("trace.toTree(): integrity check: dummy root node disappeared?");
        }
        root = dummy.children[0];
        let prev = root;
        while (root && !root.down && !root.up) {
          prev = root;
          root = root.children[0];
        }
        root = prev;
        root.leftMost = true;
        root.rightMost = true;
        walk(root);
        root.branch = 0;
        const obj = {};
        obj.string = [];
        for (let i22 = 0; i22 < chars.length; i22 += 1) {
          obj.string[i22] = chars[i22];
        }
        obj.rules = [];
        for (let i22 = 0; i22 < rules.length; i22 += 1) {
          obj.rules[i22] = rules[i22].name;
        }
        obj.udts = [];
        for (let i22 = 0; i22 < udts.length; i22 += 1) {
          obj.udts[i22] = udts[i22].name;
        }
        obj.id = {};
        obj.id.ALT = { id: id2.ALT, name: "ALT" };
        obj.id.CAT = { id: id2.CAT, name: "CAT" };
        obj.id.REP = { id: id2.REP, name: "REP" };
        obj.id.RNM = { id: id2.RNM, name: "RNM" };
        obj.id.TLS = { id: id2.TLS, name: "TLS" };
        obj.id.TBS = { id: id2.TBS, name: "TBS" };
        obj.id.TRG = { id: id2.TRG, name: "TRG" };
        obj.id.UDT = { id: id2.UDT, name: "UDT" };
        obj.id.AND = { id: id2.AND, name: "AND" };
        obj.id.NOT = { id: id2.NOT, name: "NOT" };
        obj.id.BKR = { id: id2.BKR, name: "BKR" };
        obj.id.BKA = { id: id2.BKA, name: "BKA" };
        obj.id.BKN = { id: id2.BKN, name: "BKN" };
        obj.id.ABG = { id: id2.ABG, name: "ABG" };
        obj.id.AEN = { id: id2.AEN, name: "AEN" };
        obj.id.ACTIVE = { id: id2.ACTIVE, name: "ACTIVE" };
        obj.id.MATCH = { id: id2.MATCH, name: "MATCH" };
        obj.id.EMPTY = { id: id2.EMPTY, name: "EMPTY" };
        obj.id.NOMATCH = { id: id2.NOMATCH, name: "NOMATCH" };
        obj.treeDepth = treeDepth;
        obj.leafNodes = leafNodes;
        let branchesIncomplete;
        if (root.down) {
          if (root.up) {
            branchesIncomplete = "none";
          } else {
            branchesIncomplete = "right";
          }
        } else if (root.up) {
          branchesIncomplete = "left";
        } else {
          branchesIncomplete = "both";
        }
        obj.branchesIncomplete = branchesIncomplete;
        obj.tree = display(root, root.depth, false);
        return obj;
      }, "toTreeObj");
      this.toTree = function(stringify3) {
        const obj = toTreeObj();
        if (stringify3) {
          return JSON.stringify(obj);
        }
        return obj;
      };
      this.toHtmlPage = function(mode, caption, title) {
        return utils.htmlToPage(this.toHtml(mode, caption), title);
      };
      const htmlHeader = /* @__PURE__ */ __name2(function(mode, caption) {
        let modeName;
        switch (mode) {
          case MODE_HEX:
            modeName = "hexadecimal";
            break;
          case MODE_DEC:
            modeName = "decimal";
            break;
          case MODE_ASCII:
            modeName = "ASCII";
            break;
          case MODE_UNICODE:
            modeName = "UNICODE";
            break;
          default:
            throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);
        }
        let header = "";
        header += `<p>display mode: ${modeName}</p>
`;
        header += `<table class="${style.CLASS_TRACE}">
`;
        if (typeof caption === "string") {
          header += `<caption>${caption}</caption>`;
        }
        return header;
      }, "htmlHeader");
      const htmlFooter = /* @__PURE__ */ __name2(function() {
        let footer = "";
        footer += "</table>\n";
        footer += `<p class="${style.CLASS_MONOSPACE}">legend:<br>
`;
        footer += "(a)&nbsp;-&nbsp;line number<br>\n";
        footer += "(b)&nbsp;-&nbsp;matching line number<br>\n";
        footer += "(c)&nbsp;-&nbsp;phrase offset<br>\n";
        footer += "(d)&nbsp;-&nbsp;phrase length<br>\n";
        footer += "(e)&nbsp;-&nbsp;tree depth<br>\n";
        footer += "(f)&nbsp;-&nbsp;operator state<br>\n";
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_ACTIVE}">&darr;</span>&nbsp;&nbsp;phrase opened<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_MATCH}">&uarr;M</span> phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_EMPTY}">&uarr;E</span> empty phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_NOMATCH}">&uarr;N</span> phrase not matched<br>
`;
        footer += "operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\n";
        footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_MATCH}">matched characters</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_LOOKAHEAD}">matched characters in look ahead mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_LOOKBEHIND}">matched characters in look behind mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_REMAINDER}">remainder characters(not yet examined by parser)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_CTRLCHAR}">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>
`;
        footer += "</p>\n";
        footer += `<p class="${style.CLASS_MONOSPACE}">
`;
        footer += "<sup>&dagger;</sup>original ABNF operators:<br>\n";
        footer += "ALT - alternation<br>\n";
        footer += "CAT - concatenation<br>\n";
        footer += "REP - repetition<br>\n";
        footer += "RNM - rule name<br>\n";
        footer += "TRG - terminal range<br>\n";
        footer += "TLS - terminal literal string (case insensitive)<br>\n";
        footer += "TBS - terminal binary string (case sensitive)<br>\n";
        footer += "<br>\n";
        footer += "<sup>&Dagger;</sup>super set SABNF operators:<br>\n";
        footer += "UDT - user-defined terminal<br>\n";
        footer += "AND - positive look ahead<br>\n";
        footer += "NOT - negative look ahead<br>\n";
        footer += "BKA - positive look behind<br>\n";
        footer += "BKN - negative look behind<br>\n";
        footer += "BKR - back reference<br>\n";
        footer += "ABG - anchor - begin of input string<br>\n";
        footer += "AEN - anchor - end of input string<br>\n";
        footer += "</p>\n";
        return footer;
      }, "htmlFooter");
      this.indent = function(depth) {
        let html = "";
        for (let i22 = 0; i22 < depth; i22 += 1) {
          html += ".";
        }
        return html;
      };
      const displayTrg = /* @__PURE__ */ __name2(function(mode, op) {
        let html = "";
        if (op.type === id2.TRG) {
          if (mode === MODE_HEX || mode === MODE_UNICODE) {
            let hex = op.min.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html += mode === MODE_HEX ? "%x" : "U+";
            html += hex;
            hex = op.max.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html += `&ndash;${hex}`;
          } else {
            html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          }
        }
        return html;
      }, "displayTrg");
      const displayRep = /* @__PURE__ */ __name2(function(mode, op) {
        let html = "";
        if (op.type === id2.REP) {
          if (mode === MODE_HEX) {
            let hex = op.min.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html = `x${hex}`;
            if (op.max < Infinity) {
              hex = op.max.toString(16).toUpperCase();
              if (hex.length % 2 !== 0) {
                hex = `0${hex}`;
              }
            } else {
              hex = "inf";
            }
            html += `&ndash;${hex}`;
          } else if (op.max < Infinity) {
            html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          } else {
            html = `${op.min.toString(10)}&ndash;inf`;
          }
        }
        return html;
      }, "displayRep");
      const displayTbs = /* @__PURE__ */ __name2(function(mode, op) {
        let html = "";
        if (op.type === id2.TBS) {
          const len = Math.min(op.string.length, MAX_TLS * 2);
          if (mode === MODE_HEX || mode === MODE_UNICODE) {
            html += mode === MODE_HEX ? "%x" : "U+";
            for (let i22 = 0; i22 < len; i22 += 1) {
              let hex;
              if (i22 > 0) {
                html += ".";
              }
              hex = op.string[i22].toString(16).toUpperCase();
              if (hex.length % 2 !== 0) {
                hex = `0${hex}`;
              }
              html += hex;
            }
          } else {
            html = "%d";
            for (let i22 = 0; i22 < len; i22 += 1) {
              if (i22 > 0) {
                html += ".";
              }
              html += op.string[i22].toString(10);
            }
          }
          if (len < op.string.length) {
            html += PHRASE_CONTINUE;
          }
        }
        return html;
      }, "displayTbs");
      const displayTls = /* @__PURE__ */ __name2(function(mode, op) {
        let html = "";
        if (op.type === id2.TLS) {
          const len = Math.min(op.string.length, MAX_TLS);
          if (mode === MODE_HEX || mode === MODE_DEC) {
            let charu;
            let charl;
            let base4;
            if (mode === MODE_HEX) {
              html = "%x";
              base4 = 16;
            } else {
              html = "%d";
              base4 = 10;
            }
            for (let i22 = 0; i22 < len; i22 += 1) {
              if (i22 > 0) {
                html += ".";
              }
              charl = op.string[i22];
              if (charl >= 97 && charl <= 122) {
                charu = charl - 32;
                html += `${charu.toString(base4)}/${charl.toString(base4)}`.toUpperCase();
              } else if (charl >= 65 && charl <= 90) {
                charu = charl;
                charl += 32;
                html += `${charu.toString(base4)}/${charl.toString(base4)}`.toUpperCase();
              } else {
                html += charl.toString(base4).toUpperCase();
              }
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
          } else {
            html = '"';
            for (let i22 = 0; i22 < len; i22 += 1) {
              html += utils.asciiChars[op.string[i22]];
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
            html += '"';
          }
        }
        return html;
      }, "displayTls");
      const subPhrase = /* @__PURE__ */ __name2(function(mode, charsArg, index, length2, prev) {
        if (length2 === 0) {
          return "";
        }
        let phrase = "";
        const comma = prev ? "," : "";
        switch (mode) {
          case MODE_HEX:
            phrase = comma + utils.charsToHex(charsArg, index, length2);
            break;
          case MODE_DEC:
            if (prev) {
              return `,${utils.charsToDec(charsArg, index, length2)}`;
            }
            phrase = comma + utils.charsToDec(charsArg, index, length2);
            break;
          case MODE_UNICODE:
            phrase = utils.charsToUnicode(charsArg, index, length2);
            break;
          case MODE_ASCII:
          default:
            phrase = utils.charsToAsciiHtml(charsArg, index, length2);
            break;
        }
        return phrase;
      }, "subPhrase");
      const displayBehind = /* @__PURE__ */ __name2(function(mode, charsArg, state, index, length2, anchor) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanBehind = `<span class="${style.CLASS_LOOKBEHIND}">`;
        const spanRemainder = `<span class="${style.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id2.EMPTY:
            html += PHRASE_EMPTY;
          case id2.NOMATCH:
          case id2.MATCH:
          case id2.ACTIVE:
            beg1 = index - length2;
            len1 = anchor - beg1;
            beg2 = anchor;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanBehind;
          html += subPhrase(mode, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      }, "displayBehind");
      const displayForward = /* @__PURE__ */ __name2(function(mode, charsArg, state, index, length2, spanAhead) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanRemainder = `<span class="${style.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id2.EMPTY:
            html += PHRASE_EMPTY;
          case id2.NOMATCH:
          case id2.ACTIVE:
            beg1 = index;
            len1 = 0;
            beg2 = index;
            len2 = charsArg.length - beg2;
            break;
          case id2.MATCH:
            beg1 = index;
            len1 = length2;
            beg2 = index + len1;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanAhead;
          html += subPhrase(mode, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      }, "displayForward");
      const displayAhead = /* @__PURE__ */ __name2(function(mode, charsArg, state, index, length2) {
        const spanAhead = `<span class="${style.CLASS_LOOKAHEAD}">`;
        return displayForward(mode, charsArg, state, index, length2, spanAhead);
      }, "displayAhead");
      const displayNone = /* @__PURE__ */ __name2(function(mode, charsArg, state, index, length2) {
        const spanAhead = `<span class="${style.CLASS_MATCH}">`;
        return displayForward(mode, charsArg, state, index, length2, spanAhead);
      }, "displayNone");
      const htmlTable = /* @__PURE__ */ __name2(function(mode) {
        if (rules === null) {
          return "";
        }
        let html = "";
        let thisLine;
        let thatLine;
        let lookAhead;
        let lookBehind;
        let lookAround;
        let anchor;
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        circular.forEach((lineIndex) => {
          const line = records[lineIndex];
          thisLine = line.thisLine;
          thatLine = line.thatLine !== void 0 ? line.thatLine : "--";
          lookAhead = false;
          lookBehind = false;
          lookAround = false;
          if (line.lookAround === id2.LOOKAROUND_AHEAD) {
            lookAhead = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id2.AND || line.opcode.type === id2.NOT) {
            lookAhead = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          if (line.lookAround === id2.LOOKAROUND_BEHIND) {
            lookBehind = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id2.BKA || line.opcode.type === id2.BKN) {
            lookBehind = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          html += "<tr>";
          html += `<td>${thisLine}</td><td>${thatLine}</td>`;
          html += `<td>${line.phraseIndex}</td>`;
          html += `<td>${line.phraseLength}</td>`;
          html += `<td>${line.depth}</td>`;
          html += "<td>";
          switch (line.state) {
            case id2.ACTIVE:
              html += `<span class="${style.CLASS_ACTIVE}">&darr;&nbsp;</span>`;
              break;
            case id2.MATCH:
              html += `<span class="${style.CLASS_MATCH}">&uarr;M</span>`;
              break;
            case id2.NOMATCH:
              html += `<span class="${style.CLASS_NOMATCH}">&uarr;N</span>`;
              break;
            case id2.EMPTY:
              html += `<span class="${style.CLASS_EMPTY}">&uarr;E</span>`;
              break;
            default:
              html += `<span class="${style.CLASS_ACTIVE}">--</span>`;
              break;
          }
          html += "</td>";
          html += "<td>";
          html += that.indent(line.depth);
          if (lookAhead) {
            html += `<span class="${style.CLASS_LOOKAHEAD}">`;
          } else if (lookBehind) {
            html += `<span class="${style.CLASS_LOOKBEHIND}">`;
          }
          html += utils.opcodeToString(line.opcode.type);
          if (line.opcode.type === id2.RNM) {
            html += `(${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id2.BKR) {
            const casetype = line.opcode.bkrCase === id2.BKR_MODE_CI ? "%i" : "%s";
            const modetype = line.opcode.bkrMode === id2.BKR_MODE_UM ? "%u" : "%p";
            html += `(\\${casetype}${modetype}${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id2.UDT) {
            html += `(${udts[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id2.TRG) {
            html += `(${displayTrg(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id2.TBS) {
            html += `(${displayTbs(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id2.TLS) {
            html += `(${displayTls(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id2.REP) {
            html += `(${displayRep(mode, line.opcode)}) `;
          }
          if (lookAround) {
            html += "</span>";
          }
          html += "</td>";
          html += "<td>";
          if (lookBehind) {
            html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);
          } else if (lookAhead) {
            html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);
          } else {
            html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);
          }
          html += "</td></tr>\n";
        });
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        html += "</table>\n";
        return html;
      }, "htmlTable");
      this.toHtml = function(modearg, caption) {
        let mode = MODE_ASCII;
        if (typeof modearg === "string" && modearg.length >= 3) {
          const modein = modearg.toLowerCase().slice(0, 3);
          if (modein === "hex") {
            mode = MODE_HEX;
          } else if (modein === "dec") {
            mode = MODE_DEC;
          } else if (modein === "uni") {
            mode = MODE_UNICODE;
          }
        }
        let html = "";
        html += htmlHeader(mode, caption);
        html += htmlTable(mode);
        html += htmlFooter();
        return html;
      };
    }, "exportTrace"), "exportTrace");
  }
});
var require_node_exports = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-lib/node-exports.js"(exports, module2) {
    module2.exports = {
      ast: require_ast(),
      circular: require_circular_buffer(),
      ids: require_identifiers(),
      parser: require_parser(),
      stats: require_stats(),
      trace: require_trace(),
      utils: require_utilities(),
      emitcss: require_emitcss(),
      style: require_style()
    };
  }
});
var require_scanner_grammar = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/scanner-grammar.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function grammar() {
      this.grammarObject = "grammarObject";
      this.rules = [];
      this.rules[0] = { name: "file", lower: "file", index: 0, isBkr: false };
      this.rules[1] = { name: "line", lower: "line", index: 1, isBkr: false };
      this.rules[2] = { name: "line-text", lower: "line-text", index: 2, isBkr: false };
      this.rules[3] = { name: "last-line", lower: "last-line", index: 3, isBkr: false };
      this.rules[4] = { name: "valid", lower: "valid", index: 4, isBkr: false };
      this.rules[5] = { name: "invalid", lower: "invalid", index: 5, isBkr: false };
      this.rules[6] = { name: "end", lower: "end", index: 6, isBkr: false };
      this.rules[7] = { name: "CRLF", lower: "crlf", index: 7, isBkr: false };
      this.rules[8] = { name: "LF", lower: "lf", index: 8, isBkr: false };
      this.rules[9] = { name: "CR", lower: "cr", index: 9, isBkr: false };
      this.udts = [];
      this.rules[0].opcodes = [];
      this.rules[0].opcodes[0] = { type: 2, children: [1, 3] };
      this.rules[0].opcodes[1] = { type: 3, min: 0, max: Infinity };
      this.rules[0].opcodes[2] = { type: 4, index: 1 };
      this.rules[0].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[0].opcodes[4] = { type: 4, index: 3 };
      this.rules[1].opcodes = [];
      this.rules[1].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[1].opcodes[1] = { type: 4, index: 2 };
      this.rules[1].opcodes[2] = { type: 4, index: 6 };
      this.rules[2].opcodes = [];
      this.rules[2].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[2].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[2].opcodes[2] = { type: 4, index: 4 };
      this.rules[2].opcodes[3] = { type: 4, index: 5 };
      this.rules[3].opcodes = [];
      this.rules[3].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[3].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[3].opcodes[2] = { type: 4, index: 4 };
      this.rules[3].opcodes[3] = { type: 4, index: 5 };
      this.rules[4].opcodes = [];
      this.rules[4].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[4].opcodes[1] = { type: 5, min: 32, max: 126 };
      this.rules[4].opcodes[2] = { type: 6, string: [9] };
      this.rules[5].opcodes = [];
      this.rules[5].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[5].opcodes[1] = { type: 5, min: 0, max: 8 };
      this.rules[5].opcodes[2] = { type: 5, min: 11, max: 12 };
      this.rules[5].opcodes[3] = { type: 5, min: 14, max: 31 };
      this.rules[5].opcodes[4] = { type: 5, min: 127, max: 4294967295 };
      this.rules[6].opcodes = [];
      this.rules[6].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[6].opcodes[1] = { type: 4, index: 7 };
      this.rules[6].opcodes[2] = { type: 4, index: 8 };
      this.rules[6].opcodes[3] = { type: 4, index: 9 };
      this.rules[7].opcodes = [];
      this.rules[7].opcodes[0] = { type: 6, string: [13, 10] };
      this.rules[8].opcodes = [];
      this.rules[8].opcodes[0] = { type: 6, string: [10] };
      this.rules[9].opcodes = [];
      this.rules[9].opcodes[0] = { type: 6, string: [13] };
      this.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
        let str = "";
        str += "file = *line [last-line]\n";
        str += "line = line-text end\n";
        str += "line-text = *(valid/invalid)\n";
        str += "last-line = 1*(valid/invalid)\n";
        str += "valid = %d32-126 / %d9\n";
        str += "invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\n";
        str += "end = CRLF / LF / CR\n";
        str += "CRLF = %d13.10\n";
        str += "LF = %d10\n";
        str += "CR = %d13\n";
        return str;
      }, "toString6"), "toString");
    }, "grammar"), "grammar");
  }
});
var require_scanner_callbacks = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/scanner-callbacks.js"(exports) {
    var ids = require_identifiers();
    var utils = require_utilities();
    function semLine(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endLength = 0;
        data.textLength = 0;
        data.invalidCount = 0;
      } else {
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount,
          textLength: data.textLength,
          endType: data.endType,
          invalidChars: data.invalidCount
        });
      }
      return ids.SEM_OK;
    }
    __name(semLine, "semLine");
    __name2(semLine, "semLine");
    function semLineText(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.textLength = phraseCount;
      }
      return ids.SEM_OK;
    }
    __name(semLineText, "semLineText");
    __name2(semLineText, "semLineText");
    function semLastLine(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endLength = 0;
        data.textLength = 0;
        data.invalidCount = 0;
      } else if (data.strict) {
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount,
          textLength: phraseCount,
          endType: "none",
          invalidChars: data.invalidCount
        });
        data.errors.push({
          line: data.lineNo,
          char: phraseIndex + phraseCount,
          msg: "no line end on last line - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
        });
      } else {
        chars.push(10);
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount + 1,
          textLength: phraseCount,
          endType: "LF",
          invalidChars: data.invalidCount
        });
      }
      return ids.SEM_OK;
    }
    __name(semLastLine, "semLastLine");
    __name2(semLastLine, "semLastLine");
    function semInvalid(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.errors.push({
          line: data.lineNo,
          char: phraseIndex,
          msg: `invalid character found '\\x${utils.charToHex(chars[phraseIndex])}'`
        });
      }
      return ids.SEM_OK;
    }
    __name(semInvalid, "semInvalid");
    __name2(semInvalid, "semInvalid");
    function semEnd(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_POST) {
        data.lineNo += 1;
      }
      return ids.SEM_OK;
    }
    __name(semEnd, "semEnd");
    __name2(semEnd, "semEnd");
    function semLF(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "LF";
        if (data.strict) {
          data.errors.push({
            line: data.lineNo,
            char: phraseIndex,
            msg: "line end character LF(\\n, \\x0A) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
          });
        }
      }
      return ids.SEM_OK;
    }
    __name(semLF, "semLF");
    __name2(semLF, "semLF");
    function semCR(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "CR";
        if (data.strict) {
          data.errors.push({
            line: data.lineNo,
            char: phraseIndex,
            msg: "line end character CR(\\r, \\x0D) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
          });
        }
      }
      return ids.SEM_OK;
    }
    __name(semCR, "semCR");
    __name2(semCR, "semCR");
    function semCRLF(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "CRLF";
      }
      return ids.SEM_OK;
    }
    __name(semCRLF, "semCRLF");
    __name2(semCRLF, "semCRLF");
    var callbacks = [];
    callbacks.line = semLine;
    callbacks["line-text"] = semLineText;
    callbacks["last-line"] = semLastLine;
    callbacks.invalid = semInvalid;
    callbacks.end = semEnd;
    callbacks.lf = semLF;
    callbacks.cr = semCR;
    callbacks.crlf = semCRLF;
    exports.callbacks = callbacks;
  }
});
var require_scanner = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/scanner.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exfn(chars, errors, strict, trace) {
      const thisFileName = "scanner.js: ";
      const apglib = require_node_exports();
      const grammar = new (require_scanner_grammar())();
      const { callbacks } = require_scanner_callbacks();
      const lines = [];
      const parser = new apglib.parser();
      parser.ast = new apglib.ast();
      parser.ast.callbacks = callbacks;
      if (trace) {
        if (trace.traceObject !== "traceObject") {
          throw new TypeError(`${thisFileName}trace argument is not a trace object`);
        }
        parser.trace = trace;
      }
      const test = parser.parse(grammar, "file", chars);
      if (test.success !== true) {
        errors.push({
          line: 0,
          char: 0,
          msg: "syntax analysis error analyzing input SABNF grammar"
        });
        return;
      }
      const data = {
        lines,
        lineNo: 0,
        errors,
        strict: !!strict
      };
      parser.ast.translate(data);
      return lines;
    }, "exfn"), "exfn");
  }
});
var require_syntax_callbacks = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/syntax-callbacks.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exfn() {
      const thisFileName = "syntax-callbacks.js: ";
      const apglib = require_node_exports();
      const id2 = apglib.ids;
      let topAlt;
      const synFile = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function synFile2(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            data.altStack = [];
            data.repCount = 0;
            break;
          case id2.EMPTY:
            data.errors.push({
              line: 0,
              char: 0,
              msg: "grammar file is empty"
            });
            break;
          case id2.MATCH:
            if (data.ruleCount === 0) {
              data.errors.push({
                line: 0,
                char: 0,
                msg: "no rules defined"
              });
            }
            break;
          case id2.NOMATCH:
            throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synFile2"), "synFile");
      const synRule = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            data.altStack.length = 0;
            topAlt = {
              groupOpen: null,
              groupError: false,
              optionOpen: null,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          case id2.EMPTY:
            throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            data.ruleCount += 1;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRule");
      const synRuleError = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Unrecognized SABNF line. Invalid rule, comment or blank line."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRuleError");
      const synRuleNameError = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Rule names must be alphanum and begin with alphabetic character."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRuleNameError");
      const synDefinedAsError = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Expected '=' or '=/'. Not found."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synDefinedAsError");
      const synAndOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "AND operator(&) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synAndOp");
      const synNotOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "NOT operator(!) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synNotOp");
      const synBkaOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Positive look-behind operator(&&) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBkaOp");
      const synBknOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Negative look-behind operator(!!) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBknOp");
      const synAbgOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Beginning of string anchor(%^) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synAbgOp");
      const synAenOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "End of string anchor(%$) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synAenOp");
      const synBkrOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              const name3 = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Back reference operator(${name3}) found - strict ABNF specified.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBkrOp");
      const synUdtOp = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.strict) {
              const name3 = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `UDT operator found(${name3}) - strict ABNF specified.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synUdtOp");
      const synTlsOpen = /* @__PURE__ */ __name2(function(result, chars, phraseIndex) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            topAlt.tlsOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synTlsOpen");
      const synTlsString = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            data.stringTabChar = false;
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)"
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synTlsString");
      const synStringTab = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            data.stringTabChar = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synStringTab");
      const synTlsClose = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.tlsOpen),
              char: topAlt.tlsOpen,
              msg: 'Case-insensitive literal string("...") opened but not closed.'
            });
            topAlt.basicError = true;
            topAlt.tlsOpen = null;
            break;
          case id2.MATCH:
            topAlt.tlsOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synTlsClose");
      const synClsOpen = /* @__PURE__ */ __name2(function(result, chars, phraseIndex) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            topAlt.clsOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synClsOpen");
      const synClsString = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            data.stringTabChar = false;
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in literal string."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synClsString");
      const synClsClose = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.clsOpen),
              char: topAlt.clsOpen,
              msg: "Case-sensitive literal string('...') opened but not closed."
            });
            topAlt.clsOpen = null;
            topAlt.basicError = true;
            break;
          case id2.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, topAlt.clsOpen),
                char: topAlt.clsOpen,
                msg: "Case-sensitive string operator('...') found - strict ABNF specified."
              });
            }
            topAlt.clsOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synClsClose");
      const synProsValOpen = /* @__PURE__ */ __name2(function(result, chars, phraseIndex) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            topAlt.prosValOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synProsValOpen");
      const synProsValString = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            data.stringTabChar = false;
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in prose value string."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synProsValString");
      const synProsValClose = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.prosValOpen),
              char: topAlt.prosValOpen,
              msg: "Prose value operator(<...>) opened but not closed."
            });
            topAlt.basicError = true;
            topAlt.prosValOpen = null;
            break;
          case id2.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.prosValOpen),
              char: topAlt.prosValOpen,
              msg: "Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar."
            });
            topAlt.prosValOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synProsValClose");
      const synGroupOpen = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            topAlt = {
              groupOpen: phraseIndex,
              groupError: false,
              optionOpen: null,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synGroupOpen");
      const synGroupClose = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.groupOpen),
              char: topAlt.groupOpen,
              msg: 'Group "(...)" opened but not closed.'
            });
            topAlt = data.altStack.pop();
            topAlt.groupError = true;
            break;
          case id2.MATCH:
            topAlt = data.altStack.pop();
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synGroupClose");
      const synOptionOpen = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            topAlt = {
              groupOpen: null,
              groupError: false,
              optionOpen: phraseIndex,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synOptionOpen");
      const synOptionClose = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.optionOpen),
              char: topAlt.optionOpen,
              msg: 'Option "[...]" opened but not closed.'
            });
            topAlt = data.altStack.pop();
            topAlt.optionError = true;
            break;
          case id2.MATCH:
            topAlt = data.altStack.pop();
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synOptionClose");
      const synBasicElementError = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (topAlt.basicError === false) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Unrecognized SABNF element."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBasicElementError");
      const synLineEnd = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            if (result.phraseLength === 1 && data.strict) {
              const end = chars[phraseIndex] === 13 ? "CR" : "LF";
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synLineEnd");
      const synLineEndError = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            break;
          case id2.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Unrecognized grammar element or characters."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synLineEndError");
      const synRepetition = /* @__PURE__ */ __name2(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id2.ACTIVE:
            break;
          case id2.EMPTY:
            break;
          case id2.NOMATCH:
            data.repCount += 1;
            break;
          case id2.MATCH:
            data.repCount += 1;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRepetition");
      this.callbacks = [];
      this.callbacks.andop = synAndOp;
      this.callbacks.basicelementerr = synBasicElementError;
      this.callbacks.clsclose = synClsClose;
      this.callbacks.clsopen = synClsOpen;
      this.callbacks.clsstring = synClsString;
      this.callbacks.definedaserror = synDefinedAsError;
      this.callbacks.file = synFile;
      this.callbacks.groupclose = synGroupClose;
      this.callbacks.groupopen = synGroupOpen;
      this.callbacks.lineenderror = synLineEndError;
      this.callbacks.lineend = synLineEnd;
      this.callbacks.notop = synNotOp;
      this.callbacks.optionclose = synOptionClose;
      this.callbacks.optionopen = synOptionOpen;
      this.callbacks.prosvalclose = synProsValClose;
      this.callbacks.prosvalopen = synProsValOpen;
      this.callbacks.prosvalstring = synProsValString;
      this.callbacks.repetition = synRepetition;
      this.callbacks.rule = synRule;
      this.callbacks.ruleerror = synRuleError;
      this.callbacks.rulenameerror = synRuleNameError;
      this.callbacks.stringtab = synStringTab;
      this.callbacks.tlsclose = synTlsClose;
      this.callbacks.tlsopen = synTlsOpen;
      this.callbacks.tlsstring = synTlsString;
      this.callbacks.udtop = synUdtOp;
      this.callbacks.bkaop = synBkaOp;
      this.callbacks.bknop = synBknOp;
      this.callbacks.bkrop = synBkrOp;
      this.callbacks.abgop = synAbgOp;
      this.callbacks.aenop = synAenOp;
    }, "exfn"), "exfn");
  }
});
var require_semantic_callbacks = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/semantic-callbacks.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exfn() {
      const apglib = require_node_exports();
      const id2 = apglib.ids;
      const NameList = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function NameList2() {
        this.names = [];
        this.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(name3) {
          let ret = -1;
          const find = this.get(name3);
          if (find === -1) {
            ret = {
              name: name3,
              lower: name3.toLowerCase(),
              index: this.names.length
            };
            this.names.push(ret);
          }
          return ret;
        }, "add3"), "add");
        this.get = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function get2(name3) {
          let ret = -1;
          const lower = name3.toLowerCase();
          for (let i22 = 0; i22 < this.names.length; i22 += 1) {
            if (this.names[i22].lower === lower) {
              ret = this.names[i22];
              break;
            }
          }
          return ret;
        }, "get2"), "get");
      }, "NameList2"), "NameList");
      const decnum = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function decnum2(chars, beg, len) {
        let num = 0;
        for (let i22 = beg; i22 < beg + len; i22 += 1) {
          num = 10 * num + chars[i22] - 48;
        }
        return num;
      }, "decnum2"), "decnum");
      const binnum = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function binnum2(chars, beg, len) {
        let num = 0;
        for (let i22 = beg; i22 < beg + len; i22 += 1) {
          num = 2 * num + chars[i22] - 48;
        }
        return num;
      }, "binnum2"), "binnum");
      const hexnum = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function hexnum2(chars, beg, len) {
        let num = 0;
        for (let i22 = beg; i22 < beg + len; i22 += 1) {
          let digit = chars[i22];
          if (digit >= 48 && digit <= 57) {
            digit -= 48;
          } else if (digit >= 65 && digit <= 70) {
            digit -= 55;
          } else if (digit >= 97 && digit <= 102) {
            digit -= 87;
          } else {
            throw new Error("hexnum out of range");
          }
          num = 16 * num + digit;
        }
        return num;
      }, "hexnum2"), "hexnum");
      function semFile(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.ruleNames = new NameList();
          data.udtNames = new NameList();
          data.rules = [];
          data.udts = [];
          data.rulesLineMap = [];
          data.opcodes = [];
          data.altStack = [];
          data.topStack = null;
          data.topRule = null;
        } else if (state === id2.SEM_POST) {
          let nameObj;
          data.rules.forEach((rule) => {
            rule.isBkr = false;
            rule.opcodes.forEach((op) => {
              if (op.type === id2.RNM) {
                nameObj = data.ruleNames.get(op.index.name);
                if (nameObj === -1) {
                  data.errors.push({
                    line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),
                    char: op.index.phraseIndex,
                    msg: `Rule name '${op.index.name}' used but not defined.`
                  });
                  op.index = -1;
                } else {
                  op.index = nameObj.index;
                }
              }
            });
          });
          data.udts.forEach((udt) => {
            udt.isBkr = false;
          });
          data.rules.forEach((rule) => {
            rule.opcodes.forEach((op) => {
              if (op.type === id2.BKR) {
                rule.hasBkr = true;
                nameObj = data.ruleNames.get(op.index.name);
                if (nameObj !== -1) {
                  data.rules[nameObj.index].isBkr = true;
                  op.index = nameObj.index;
                } else {
                  nameObj = data.udtNames.get(op.index.name);
                  if (nameObj !== -1) {
                    data.udts[nameObj.index].isBkr = true;
                    op.index = data.rules.length + nameObj.index;
                  } else {
                    data.errors.push({
                      line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),
                      char: op.index.phraseIndex,
                      msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`
                    });
                    op.index = -1;
                  }
                }
              }
            });
          });
        }
        return ret;
      }
      __name(semFile, "semFile");
      __name2(semFile, "semFile");
      function semRule(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.altStack.length = 0;
          data.topStack = null;
          data.rulesLineMap.push({
            line: data.findLine(data.lines, phraseIndex, data.charsLength),
            char: phraseIndex
          });
        }
        return ret;
      }
      __name(semRule, "semRule");
      __name2(semRule, "semRule");
      function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.ruleName = "";
          data.definedas = "";
        } else if (state === id2.SEM_POST) {
          let ruleName;
          if (data.definedas === "=") {
            ruleName = data.ruleNames.add(data.ruleName);
            if (ruleName === -1) {
              data.definedas = null;
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Rule name '${data.ruleName}' previously defined.`
              });
            } else {
              data.topRule = {
                name: ruleName.name,
                lower: ruleName.lower,
                opcodes: [],
                index: ruleName.index
              };
              data.rules.push(data.topRule);
              data.opcodes = data.topRule.opcodes;
            }
          } else {
            ruleName = data.ruleNames.get(data.ruleName);
            if (ruleName === -1) {
              data.definedas = null;
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`
              });
            } else {
              data.topRule = data.rules[ruleName.index];
              data.opcodes = data.topRule.opcodes;
            }
          }
        }
        return ret;
      }
      __name(semRuleLookup, "semRuleLookup");
      __name2(semRuleLookup, "semRuleLookup");
      function semAlternation(state, chars, phraseIndex, phraseCount, data) {
        let ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          const TRUE = true;
          while (TRUE) {
            if (data.definedas === null) {
              ret = id2.SEM_SKIP;
              break;
            }
            if (data.topStack === null) {
              if (data.definedas === "=") {
                data.topStack = {
                  alt: {
                    type: id2.ALT,
                    children: []
                  },
                  cat: null
                };
                data.altStack.push(data.topStack);
                data.opcodes.push(data.topStack.alt);
                break;
              }
              data.topStack = {
                alt: data.opcodes[0],
                cat: null
              };
              data.altStack.push(data.topStack);
              break;
            }
            data.topStack = {
              alt: {
                type: id2.ALT,
                children: []
              },
              cat: null
            };
            data.altStack.push(data.topStack);
            data.opcodes.push(data.topStack.alt);
            break;
          }
        } else if (state === id2.SEM_POST) {
          data.altStack.pop();
          if (data.altStack.length > 0) {
            data.topStack = data.altStack[data.altStack.length - 1];
          } else {
            data.topStack = null;
          }
        }
        return ret;
      }
      __name(semAlternation, "semAlternation");
      __name2(semAlternation, "semAlternation");
      function semConcatenation(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.topStack.alt.children.push(data.opcodes.length);
          data.topStack.cat = {
            type: id2.CAT,
            children: []
          };
          data.opcodes.push(data.topStack.cat);
        } else if (state === id2.SEM_POST) {
          data.topStack.cat = null;
        }
        return ret;
      }
      __name(semConcatenation, "semConcatenation");
      __name2(semConcatenation, "semConcatenation");
      function semRepetition(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.topStack.cat.children.push(data.opcodes.length);
        }
        return ret;
      }
      __name(semRepetition, "semRepetition");
      __name2(semRepetition, "semRepetition");
      function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.REP,
            min: 0,
            max: 1,
            char: phraseIndex
          });
        }
        return ret;
      }
      __name(semOptionOpen, "semOptionOpen");
      __name2(semOptionOpen, "semOptionOpen");
      function semRuleName(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semRuleName, "semRuleName");
      __name2(semRuleName, "semRuleName");
      function semDefined(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.definedas = "=";
        }
        return ret;
      }
      __name(semDefined, "semDefined");
      __name2(semDefined, "semDefined");
      function semIncAlt(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.definedas = "=/";
        }
        return ret;
      }
      __name(semIncAlt, "semIncAlt");
      __name2(semIncAlt, "semIncAlt");
      function semRepOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.min = 0;
          data.max = Infinity;
          data.topRep = {
            type: id2.REP,
            min: 0,
            max: Infinity
          };
          data.opcodes.push(data.topRep);
        } else if (state === id2.SEM_POST) {
          if (data.min > data.max) {
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`
            });
          }
          data.topRep.min = data.min;
          data.topRep.max = data.max;
        }
        return ret;
      }
      __name(semRepOp, "semRepOp");
      __name2(semRepOp, "semRepOp");
      function semRepMin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.min = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semRepMin, "semRepMin");
      __name2(semRepMin, "semRepMin");
      function semRepMax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semRepMax, "semRepMax");
      __name2(semRepMax, "semRepMax");
      function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
          data.min = data.max;
        }
        return ret;
      }
      __name(semRepMinMax, "semRepMinMax");
      __name2(semRepMinMax, "semRepMinMax");
      function semAndOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.AND
          });
        }
        return ret;
      }
      __name(semAndOp, "semAndOp");
      __name2(semAndOp, "semAndOp");
      function semNotOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.NOT
          });
        }
        return ret;
      }
      __name(semNotOp, "semNotOp");
      __name2(semNotOp, "semNotOp");
      function semRnmOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.RNM,
            index: {
              phraseIndex,
              name: apglib.utils.charsToString(chars, phraseIndex, phraseCount)
            }
          });
        }
        return ret;
      }
      __name(semRnmOp, "semRnmOp");
      __name2(semRnmOp, "semRnmOp");
      function semAbgOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.ABG
          });
        }
        return ret;
      }
      __name(semAbgOp, "semAbgOp");
      __name2(semAbgOp, "semAbgOp");
      function semAenOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.AEN
          });
        }
        return ret;
      }
      __name(semAenOp, "semAenOp");
      __name2(semAenOp, "semAenOp");
      function semBkaOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.BKA
          });
        }
        return ret;
      }
      __name(semBkaOp, "semBkaOp");
      __name2(semBkaOp, "semBkaOp");
      function semBknOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.BKN
          });
        }
        return ret;
      }
      __name(semBknOp, "semBknOp");
      __name2(semBknOp, "semBknOp");
      function semBkrOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.ci = true;
          data.cs = false;
          data.um = true;
          data.pm = false;
        } else if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.BKR,
            bkrCase: data.cs === true ? id2.BKR_MODE_CS : id2.BKR_MODE_CI,
            bkrMode: data.pm === true ? id2.BKR_MODE_PM : id2.BKR_MODE_UM,
            index: {
              phraseIndex: data.bkrname.phraseIndex,
              name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength)
            }
          });
        }
        return ret;
      }
      __name(semBkrOp, "semBkrOp");
      __name2(semBkrOp, "semBkrOp");
      function semBkrCi(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.ci = true;
        }
        return ret;
      }
      __name(semBkrCi, "semBkrCi");
      __name2(semBkrCi, "semBkrCi");
      function semBkrCs(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.cs = true;
        }
        return ret;
      }
      __name(semBkrCs, "semBkrCs");
      __name2(semBkrCs, "semBkrCs");
      function semBkrUm(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.um = true;
        }
        return ret;
      }
      __name(semBkrUm, "semBkrUm");
      __name2(semBkrUm, "semBkrUm");
      function semBkrPm(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.pm = true;
        }
        return ret;
      }
      __name(semBkrPm, "semBkrPm");
      __name2(semBkrPm, "semBkrPm");
      function semBkrName(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.bkrname = {
            phraseIndex,
            phraseLength: phraseCount
          };
        }
        return ret;
      }
      __name(semBkrName, "semBkrName");
      __name2(semBkrName, "semBkrName");
      function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          const name3 = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
          let udtName = data.udtNames.add(name3);
          if (udtName === -1) {
            udtName = data.udtNames.get(name3);
            if (udtName === -1) {
              throw new Error("semUdtEmpty: name look up error");
            }
          } else {
            data.udts.push({
              name: udtName.name,
              lower: udtName.lower,
              index: udtName.index,
              empty: true
            });
          }
          data.opcodes.push({
            type: id2.UDT,
            empty: true,
            index: udtName.index
          });
        }
        return ret;
      }
      __name(semUdtEmpty, "semUdtEmpty");
      __name2(semUdtEmpty, "semUdtEmpty");
      function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          const name3 = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
          let udtName = data.udtNames.add(name3);
          if (udtName === -1) {
            udtName = data.udtNames.get(name3);
            if (udtName === -1) {
              throw new Error("semUdtNonEmpty: name look up error");
            }
          } else {
            data.udts.push({
              name: udtName.name,
              lower: udtName.lower,
              index: udtName.index,
              empty: false
            });
          }
          data.opcodes.push({
            type: id2.UDT,
            empty: false,
            index: udtName.index,
            syntax: null,
            semantic: null
          });
        }
        return ret;
      }
      __name(semUdtNonEmpty, "semUdtNonEmpty");
      __name2(semUdtNonEmpty, "semUdtNonEmpty");
      function semTlsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.tlscase = true;
        }
        return ret;
      }
      __name(semTlsOp, "semTlsOp");
      __name2(semTlsOp, "semTlsOp");
      function semTlsCase(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {
            data.tlscase = false;
          }
        }
        return ret;
      }
      __name(semTlsCase, "semTlsCase");
      __name2(semTlsCase, "semTlsCase");
      function semTlsString(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          if (data.tlscase) {
            const str = chars.slice(phraseIndex, phraseIndex + phraseCount);
            for (let i22 = 0; i22 < str.length; i22 += 1) {
              if (str[i22] >= 65 && str[i22] <= 90) {
                str[i22] += 32;
              }
            }
            data.opcodes.push({
              type: id2.TLS,
              string: str
            });
          } else {
            data.opcodes.push({
              type: id2.TBS,
              string: chars.slice(phraseIndex, phraseIndex + phraseCount)
            });
          }
        }
        return ret;
      }
      __name(semTlsString, "semTlsString");
      __name2(semTlsString, "semTlsString");
      function semClsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          if (phraseCount <= 2) {
            data.opcodes.push({
              type: id2.TLS,
              string: []
            });
          } else {
            data.opcodes.push({
              type: id2.TBS,
              string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1)
            });
          }
        }
        return ret;
      }
      __name(semClsOp, "semClsOp");
      __name2(semClsOp, "semClsOp");
      function semTbsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.tbsstr = [];
        } else if (state === id2.SEM_POST) {
          data.opcodes.push({
            type: id2.TBS,
            string: data.tbsstr
          });
        }
        return ret;
      }
      __name(semTbsOp, "semTbsOp");
      __name2(semTbsOp, "semTbsOp");
      function semTrgOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_PRE) {
          data.min = 0;
          data.max = 0;
        } else if (state === id2.SEM_POST) {
          if (data.min > data.max) {
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`
            });
          }
          data.opcodes.push({
            type: id2.TRG,
            min: data.min,
            max: data.max
          });
        }
        return ret;
      }
      __name(semTrgOp, "semTrgOp");
      __name2(semTrgOp, "semTrgOp");
      function semDmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.min = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semDmin, "semDmin");
      __name2(semDmin, "semDmin");
      function semDmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semDmax, "semDmax");
      __name2(semDmax, "semDmax");
      function semBmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.min = binnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semBmin, "semBmin");
      __name2(semBmin, "semBmin");
      function semBmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.max = binnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semBmax, "semBmax");
      __name2(semBmax, "semBmax");
      function semXmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.min = hexnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semXmin, "semXmin");
      __name2(semXmin, "semXmin");
      function semXmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.max = hexnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semXmax, "semXmax");
      __name2(semXmax, "semXmax");
      function semDstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      __name(semDstring, "semDstring");
      __name2(semDstring, "semDstring");
      function semBstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      __name(semBstring, "semBstring");
      __name2(semBstring, "semBstring");
      function semXstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id2.SEM_OK;
        if (state === id2.SEM_POST) {
          data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      __name(semXstring, "semXstring");
      __name2(semXstring, "semXstring");
      this.callbacks = [];
      this.callbacks.abgop = semAbgOp;
      this.callbacks.aenop = semAenOp;
      this.callbacks.alternation = semAlternation;
      this.callbacks.andop = semAndOp;
      this.callbacks.bmax = semBmax;
      this.callbacks.bmin = semBmin;
      this.callbacks.bkaop = semBkaOp;
      this.callbacks.bknop = semBknOp;
      this.callbacks.bkrop = semBkrOp;
      this.callbacks["bkr-name"] = semBkrName;
      this.callbacks.bstring = semBstring;
      this.callbacks.clsop = semClsOp;
      this.callbacks.ci = semBkrCi;
      this.callbacks.cs = semBkrCs;
      this.callbacks.um = semBkrUm;
      this.callbacks.pm = semBkrPm;
      this.callbacks.concatenation = semConcatenation;
      this.callbacks.defined = semDefined;
      this.callbacks.dmax = semDmax;
      this.callbacks.dmin = semDmin;
      this.callbacks.dstring = semDstring;
      this.callbacks.file = semFile;
      this.callbacks.incalt = semIncAlt;
      this.callbacks.notop = semNotOp;
      this.callbacks.optionopen = semOptionOpen;
      this.callbacks["rep-max"] = semRepMax;
      this.callbacks["rep-min"] = semRepMin;
      this.callbacks["rep-min-max"] = semRepMinMax;
      this.callbacks.repetition = semRepetition;
      this.callbacks.repop = semRepOp;
      this.callbacks.rnmop = semRnmOp;
      this.callbacks.rule = semRule;
      this.callbacks.rulelookup = semRuleLookup;
      this.callbacks.rulename = semRuleName;
      this.callbacks.tbsop = semTbsOp;
      this.callbacks.tlscase = semTlsCase;
      this.callbacks.tlsstring = semTlsString;
      this.callbacks.tlsop = semTlsOp;
      this.callbacks.trgop = semTrgOp;
      this.callbacks["udt-empty"] = semUdtEmpty;
      this.callbacks["udt-non-empty"] = semUdtNonEmpty;
      this.callbacks.xmax = semXmax;
      this.callbacks.xmin = semXmin;
      this.callbacks.xstring = semXstring;
    }, "exfn"), "exfn");
  }
});
var require_sabnf_grammar = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/sabnf-grammar.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function grammar() {
      this.grammarObject = "grammarObject";
      this.rules = [];
      this.rules[0] = { name: "File", lower: "file", index: 0, isBkr: false };
      this.rules[1] = { name: "BlankLine", lower: "blankline", index: 1, isBkr: false };
      this.rules[2] = { name: "Rule", lower: "rule", index: 2, isBkr: false };
      this.rules[3] = { name: "RuleLookup", lower: "rulelookup", index: 3, isBkr: false };
      this.rules[4] = { name: "RuleNameTest", lower: "rulenametest", index: 4, isBkr: false };
      this.rules[5] = { name: "RuleName", lower: "rulename", index: 5, isBkr: false };
      this.rules[6] = { name: "RuleNameError", lower: "rulenameerror", index: 6, isBkr: false };
      this.rules[7] = { name: "DefinedAsTest", lower: "definedastest", index: 7, isBkr: false };
      this.rules[8] = { name: "DefinedAsError", lower: "definedaserror", index: 8, isBkr: false };
      this.rules[9] = { name: "DefinedAs", lower: "definedas", index: 9, isBkr: false };
      this.rules[10] = { name: "Defined", lower: "defined", index: 10, isBkr: false };
      this.rules[11] = { name: "IncAlt", lower: "incalt", index: 11, isBkr: false };
      this.rules[12] = { name: "RuleError", lower: "ruleerror", index: 12, isBkr: false };
      this.rules[13] = { name: "LineEndError", lower: "lineenderror", index: 13, isBkr: false };
      this.rules[14] = { name: "Alternation", lower: "alternation", index: 14, isBkr: false };
      this.rules[15] = { name: "Concatenation", lower: "concatenation", index: 15, isBkr: false };
      this.rules[16] = { name: "Repetition", lower: "repetition", index: 16, isBkr: false };
      this.rules[17] = { name: "Modifier", lower: "modifier", index: 17, isBkr: false };
      this.rules[18] = { name: "Predicate", lower: "predicate", index: 18, isBkr: false };
      this.rules[19] = { name: "BasicElement", lower: "basicelement", index: 19, isBkr: false };
      this.rules[20] = { name: "BasicElementErr", lower: "basicelementerr", index: 20, isBkr: false };
      this.rules[21] = { name: "Group", lower: "group", index: 21, isBkr: false };
      this.rules[22] = { name: "GroupError", lower: "grouperror", index: 22, isBkr: false };
      this.rules[23] = { name: "GroupOpen", lower: "groupopen", index: 23, isBkr: false };
      this.rules[24] = { name: "GroupClose", lower: "groupclose", index: 24, isBkr: false };
      this.rules[25] = { name: "Option", lower: "option", index: 25, isBkr: false };
      this.rules[26] = { name: "OptionError", lower: "optionerror", index: 26, isBkr: false };
      this.rules[27] = { name: "OptionOpen", lower: "optionopen", index: 27, isBkr: false };
      this.rules[28] = { name: "OptionClose", lower: "optionclose", index: 28, isBkr: false };
      this.rules[29] = { name: "RnmOp", lower: "rnmop", index: 29, isBkr: false };
      this.rules[30] = { name: "BkrOp", lower: "bkrop", index: 30, isBkr: false };
      this.rules[31] = { name: "bkrModifier", lower: "bkrmodifier", index: 31, isBkr: false };
      this.rules[32] = { name: "cs", lower: "cs", index: 32, isBkr: false };
      this.rules[33] = { name: "ci", lower: "ci", index: 33, isBkr: false };
      this.rules[34] = { name: "um", lower: "um", index: 34, isBkr: false };
      this.rules[35] = { name: "pm", lower: "pm", index: 35, isBkr: false };
      this.rules[36] = { name: "bkr-name", lower: "bkr-name", index: 36, isBkr: false };
      this.rules[37] = { name: "rname", lower: "rname", index: 37, isBkr: false };
      this.rules[38] = { name: "uname", lower: "uname", index: 38, isBkr: false };
      this.rules[39] = { name: "ename", lower: "ename", index: 39, isBkr: false };
      this.rules[40] = { name: "UdtOp", lower: "udtop", index: 40, isBkr: false };
      this.rules[41] = { name: "udt-non-empty", lower: "udt-non-empty", index: 41, isBkr: false };
      this.rules[42] = { name: "udt-empty", lower: "udt-empty", index: 42, isBkr: false };
      this.rules[43] = { name: "RepOp", lower: "repop", index: 43, isBkr: false };
      this.rules[44] = { name: "AltOp", lower: "altop", index: 44, isBkr: false };
      this.rules[45] = { name: "CatOp", lower: "catop", index: 45, isBkr: false };
      this.rules[46] = { name: "StarOp", lower: "starop", index: 46, isBkr: false };
      this.rules[47] = { name: "AndOp", lower: "andop", index: 47, isBkr: false };
      this.rules[48] = { name: "NotOp", lower: "notop", index: 48, isBkr: false };
      this.rules[49] = { name: "BkaOp", lower: "bkaop", index: 49, isBkr: false };
      this.rules[50] = { name: "BknOp", lower: "bknop", index: 50, isBkr: false };
      this.rules[51] = { name: "AbgOp", lower: "abgop", index: 51, isBkr: false };
      this.rules[52] = { name: "AenOp", lower: "aenop", index: 52, isBkr: false };
      this.rules[53] = { name: "TrgOp", lower: "trgop", index: 53, isBkr: false };
      this.rules[54] = { name: "TbsOp", lower: "tbsop", index: 54, isBkr: false };
      this.rules[55] = { name: "TlsOp", lower: "tlsop", index: 55, isBkr: false };
      this.rules[56] = { name: "TlsCase", lower: "tlscase", index: 56, isBkr: false };
      this.rules[57] = { name: "TlsOpen", lower: "tlsopen", index: 57, isBkr: false };
      this.rules[58] = { name: "TlsClose", lower: "tlsclose", index: 58, isBkr: false };
      this.rules[59] = { name: "TlsString", lower: "tlsstring", index: 59, isBkr: false };
      this.rules[60] = { name: "StringTab", lower: "stringtab", index: 60, isBkr: false };
      this.rules[61] = { name: "ClsOp", lower: "clsop", index: 61, isBkr: false };
      this.rules[62] = { name: "ClsOpen", lower: "clsopen", index: 62, isBkr: false };
      this.rules[63] = { name: "ClsClose", lower: "clsclose", index: 63, isBkr: false };
      this.rules[64] = { name: "ClsString", lower: "clsstring", index: 64, isBkr: false };
      this.rules[65] = { name: "ProsVal", lower: "prosval", index: 65, isBkr: false };
      this.rules[66] = { name: "ProsValOpen", lower: "prosvalopen", index: 66, isBkr: false };
      this.rules[67] = { name: "ProsValString", lower: "prosvalstring", index: 67, isBkr: false };
      this.rules[68] = { name: "ProsValClose", lower: "prosvalclose", index: 68, isBkr: false };
      this.rules[69] = { name: "rep-min", lower: "rep-min", index: 69, isBkr: false };
      this.rules[70] = { name: "rep-min-max", lower: "rep-min-max", index: 70, isBkr: false };
      this.rules[71] = { name: "rep-max", lower: "rep-max", index: 71, isBkr: false };
      this.rules[72] = { name: "rep-num", lower: "rep-num", index: 72, isBkr: false };
      this.rules[73] = { name: "dString", lower: "dstring", index: 73, isBkr: false };
      this.rules[74] = { name: "xString", lower: "xstring", index: 74, isBkr: false };
      this.rules[75] = { name: "bString", lower: "bstring", index: 75, isBkr: false };
      this.rules[76] = { name: "Dec", lower: "dec", index: 76, isBkr: false };
      this.rules[77] = { name: "Hex", lower: "hex", index: 77, isBkr: false };
      this.rules[78] = { name: "Bin", lower: "bin", index: 78, isBkr: false };
      this.rules[79] = { name: "dmin", lower: "dmin", index: 79, isBkr: false };
      this.rules[80] = { name: "dmax", lower: "dmax", index: 80, isBkr: false };
      this.rules[81] = { name: "bmin", lower: "bmin", index: 81, isBkr: false };
      this.rules[82] = { name: "bmax", lower: "bmax", index: 82, isBkr: false };
      this.rules[83] = { name: "xmin", lower: "xmin", index: 83, isBkr: false };
      this.rules[84] = { name: "xmax", lower: "xmax", index: 84, isBkr: false };
      this.rules[85] = { name: "dnum", lower: "dnum", index: 85, isBkr: false };
      this.rules[86] = { name: "bnum", lower: "bnum", index: 86, isBkr: false };
      this.rules[87] = { name: "xnum", lower: "xnum", index: 87, isBkr: false };
      this.rules[88] = { name: "alphanum", lower: "alphanum", index: 88, isBkr: false };
      this.rules[89] = { name: "owsp", lower: "owsp", index: 89, isBkr: false };
      this.rules[90] = { name: "wsp", lower: "wsp", index: 90, isBkr: false };
      this.rules[91] = { name: "space", lower: "space", index: 91, isBkr: false };
      this.rules[92] = { name: "comment", lower: "comment", index: 92, isBkr: false };
      this.rules[93] = { name: "LineEnd", lower: "lineend", index: 93, isBkr: false };
      this.rules[94] = { name: "LineContinue", lower: "linecontinue", index: 94, isBkr: false };
      this.udts = [];
      this.rules[0].opcodes = [];
      this.rules[0].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[0].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[0].opcodes[2] = { type: 4, index: 1 };
      this.rules[0].opcodes[3] = { type: 4, index: 2 };
      this.rules[0].opcodes[4] = { type: 4, index: 12 };
      this.rules[1].opcodes = [];
      this.rules[1].opcodes[0] = { type: 2, children: [1, 5, 7] };
      this.rules[1].opcodes[1] = { type: 3, min: 0, max: Infinity };
      this.rules[1].opcodes[2] = { type: 1, children: [3, 4] };
      this.rules[1].opcodes[3] = { type: 6, string: [32] };
      this.rules[1].opcodes[4] = { type: 6, string: [9] };
      this.rules[1].opcodes[5] = { type: 3, min: 0, max: 1 };
      this.rules[1].opcodes[6] = { type: 4, index: 92 };
      this.rules[1].opcodes[7] = { type: 4, index: 93 };
      this.rules[2].opcodes = [];
      this.rules[2].opcodes[0] = { type: 2, children: [1, 2, 3, 4] };
      this.rules[2].opcodes[1] = { type: 4, index: 3 };
      this.rules[2].opcodes[2] = { type: 4, index: 89 };
      this.rules[2].opcodes[3] = { type: 4, index: 14 };
      this.rules[2].opcodes[4] = { type: 1, children: [5, 8] };
      this.rules[2].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[2].opcodes[6] = { type: 4, index: 89 };
      this.rules[2].opcodes[7] = { type: 4, index: 93 };
      this.rules[2].opcodes[8] = { type: 2, children: [9, 10] };
      this.rules[2].opcodes[9] = { type: 4, index: 13 };
      this.rules[2].opcodes[10] = { type: 4, index: 93 };
      this.rules[3].opcodes = [];
      this.rules[3].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[3].opcodes[1] = { type: 4, index: 4 };
      this.rules[3].opcodes[2] = { type: 4, index: 89 };
      this.rules[3].opcodes[3] = { type: 4, index: 7 };
      this.rules[4].opcodes = [];
      this.rules[4].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[4].opcodes[1] = { type: 4, index: 5 };
      this.rules[4].opcodes[2] = { type: 4, index: 6 };
      this.rules[5].opcodes = [];
      this.rules[5].opcodes[0] = { type: 4, index: 88 };
      this.rules[6].opcodes = [];
      this.rules[6].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[6].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[6].opcodes[2] = { type: 5, min: 33, max: 60 };
      this.rules[6].opcodes[3] = { type: 5, min: 62, max: 126 };
      this.rules[7].opcodes = [];
      this.rules[7].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[7].opcodes[1] = { type: 4, index: 9 };
      this.rules[7].opcodes[2] = { type: 4, index: 8 };
      this.rules[8].opcodes = [];
      this.rules[8].opcodes[0] = { type: 3, min: 1, max: 2 };
      this.rules[8].opcodes[1] = { type: 5, min: 33, max: 126 };
      this.rules[9].opcodes = [];
      this.rules[9].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[9].opcodes[1] = { type: 4, index: 11 };
      this.rules[9].opcodes[2] = { type: 4, index: 10 };
      this.rules[10].opcodes = [];
      this.rules[10].opcodes[0] = { type: 6, string: [61] };
      this.rules[11].opcodes = [];
      this.rules[11].opcodes[0] = { type: 6, string: [61, 47] };
      this.rules[12].opcodes = [];
      this.rules[12].opcodes[0] = { type: 2, children: [1, 6] };
      this.rules[12].opcodes[1] = { type: 3, min: 1, max: Infinity };
      this.rules[12].opcodes[2] = { type: 1, children: [3, 4, 5] };
      this.rules[12].opcodes[3] = { type: 5, min: 32, max: 126 };
      this.rules[12].opcodes[4] = { type: 6, string: [9] };
      this.rules[12].opcodes[5] = { type: 4, index: 94 };
      this.rules[12].opcodes[6] = { type: 4, index: 93 };
      this.rules[13].opcodes = [];
      this.rules[13].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[13].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[13].opcodes[2] = { type: 5, min: 32, max: 126 };
      this.rules[13].opcodes[3] = { type: 6, string: [9] };
      this.rules[13].opcodes[4] = { type: 4, index: 94 };
      this.rules[14].opcodes = [];
      this.rules[14].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[14].opcodes[1] = { type: 4, index: 15 };
      this.rules[14].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[14].opcodes[3] = { type: 2, children: [4, 5, 6] };
      this.rules[14].opcodes[4] = { type: 4, index: 89 };
      this.rules[14].opcodes[5] = { type: 4, index: 44 };
      this.rules[14].opcodes[6] = { type: 4, index: 15 };
      this.rules[15].opcodes = [];
      this.rules[15].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[15].opcodes[1] = { type: 4, index: 16 };
      this.rules[15].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[15].opcodes[3] = { type: 2, children: [4, 5] };
      this.rules[15].opcodes[4] = { type: 4, index: 45 };
      this.rules[15].opcodes[5] = { type: 4, index: 16 };
      this.rules[16].opcodes = [];
      this.rules[16].opcodes[0] = { type: 2, children: [1, 3] };
      this.rules[16].opcodes[1] = { type: 3, min: 0, max: 1 };
      this.rules[16].opcodes[2] = { type: 4, index: 17 };
      this.rules[16].opcodes[3] = { type: 1, children: [4, 5, 6, 7] };
      this.rules[16].opcodes[4] = { type: 4, index: 21 };
      this.rules[16].opcodes[5] = { type: 4, index: 25 };
      this.rules[16].opcodes[6] = { type: 4, index: 19 };
      this.rules[16].opcodes[7] = { type: 4, index: 20 };
      this.rules[17].opcodes = [];
      this.rules[17].opcodes[0] = { type: 1, children: [1, 5] };
      this.rules[17].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[17].opcodes[2] = { type: 4, index: 18 };
      this.rules[17].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[17].opcodes[4] = { type: 4, index: 43 };
      this.rules[17].opcodes[5] = { type: 4, index: 43 };
      this.rules[18].opcodes = [];
      this.rules[18].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[18].opcodes[1] = { type: 4, index: 49 };
      this.rules[18].opcodes[2] = { type: 4, index: 50 };
      this.rules[18].opcodes[3] = { type: 4, index: 47 };
      this.rules[18].opcodes[4] = { type: 4, index: 48 };
      this.rules[19].opcodes = [];
      this.rules[19].opcodes[0] = { type: 1, children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] };
      this.rules[19].opcodes[1] = { type: 4, index: 40 };
      this.rules[19].opcodes[2] = { type: 4, index: 29 };
      this.rules[19].opcodes[3] = { type: 4, index: 53 };
      this.rules[19].opcodes[4] = { type: 4, index: 54 };
      this.rules[19].opcodes[5] = { type: 4, index: 55 };
      this.rules[19].opcodes[6] = { type: 4, index: 61 };
      this.rules[19].opcodes[7] = { type: 4, index: 30 };
      this.rules[19].opcodes[8] = { type: 4, index: 51 };
      this.rules[19].opcodes[9] = { type: 4, index: 52 };
      this.rules[19].opcodes[10] = { type: 4, index: 65 };
      this.rules[20].opcodes = [];
      this.rules[20].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[20].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[20].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[20].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[20].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[20].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[21].opcodes = [];
      this.rules[21].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[21].opcodes[1] = { type: 4, index: 23 };
      this.rules[21].opcodes[2] = { type: 4, index: 14 };
      this.rules[21].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[21].opcodes[4] = { type: 4, index: 24 };
      this.rules[21].opcodes[5] = { type: 4, index: 22 };
      this.rules[22].opcodes = [];
      this.rules[22].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[22].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[22].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[22].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[22].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[22].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[23].opcodes = [];
      this.rules[23].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[23].opcodes[1] = { type: 6, string: [40] };
      this.rules[23].opcodes[2] = { type: 4, index: 89 };
      this.rules[24].opcodes = [];
      this.rules[24].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[24].opcodes[1] = { type: 4, index: 89 };
      this.rules[24].opcodes[2] = { type: 6, string: [41] };
      this.rules[25].opcodes = [];
      this.rules[25].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[25].opcodes[1] = { type: 4, index: 27 };
      this.rules[25].opcodes[2] = { type: 4, index: 14 };
      this.rules[25].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[25].opcodes[4] = { type: 4, index: 28 };
      this.rules[25].opcodes[5] = { type: 4, index: 26 };
      this.rules[26].opcodes = [];
      this.rules[26].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[26].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[26].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[26].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[26].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[26].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[27].opcodes = [];
      this.rules[27].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[27].opcodes[1] = { type: 6, string: [91] };
      this.rules[27].opcodes[2] = { type: 4, index: 89 };
      this.rules[28].opcodes = [];
      this.rules[28].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[28].opcodes[1] = { type: 4, index: 89 };
      this.rules[28].opcodes[2] = { type: 6, string: [93] };
      this.rules[29].opcodes = [];
      this.rules[29].opcodes[0] = { type: 4, index: 88 };
      this.rules[30].opcodes = [];
      this.rules[30].opcodes[0] = { type: 2, children: [1, 2, 4] };
      this.rules[30].opcodes[1] = { type: 6, string: [92] };
      this.rules[30].opcodes[2] = { type: 3, min: 0, max: 1 };
      this.rules[30].opcodes[3] = { type: 4, index: 31 };
      this.rules[30].opcodes[4] = { type: 4, index: 36 };
      this.rules[31].opcodes = [];
      this.rules[31].opcodes[0] = { type: 1, children: [1, 7, 13, 19] };
      this.rules[31].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[31].opcodes[2] = { type: 4, index: 32 };
      this.rules[31].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[4] = { type: 1, children: [5, 6] };
      this.rules[31].opcodes[5] = { type: 4, index: 34 };
      this.rules[31].opcodes[6] = { type: 4, index: 35 };
      this.rules[31].opcodes[7] = { type: 2, children: [8, 9] };
      this.rules[31].opcodes[8] = { type: 4, index: 33 };
      this.rules[31].opcodes[9] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[10] = { type: 1, children: [11, 12] };
      this.rules[31].opcodes[11] = { type: 4, index: 34 };
      this.rules[31].opcodes[12] = { type: 4, index: 35 };
      this.rules[31].opcodes[13] = { type: 2, children: [14, 15] };
      this.rules[31].opcodes[14] = { type: 4, index: 34 };
      this.rules[31].opcodes[15] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[16] = { type: 1, children: [17, 18] };
      this.rules[31].opcodes[17] = { type: 4, index: 32 };
      this.rules[31].opcodes[18] = { type: 4, index: 33 };
      this.rules[31].opcodes[19] = { type: 2, children: [20, 21] };
      this.rules[31].opcodes[20] = { type: 4, index: 35 };
      this.rules[31].opcodes[21] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[22] = { type: 1, children: [23, 24] };
      this.rules[31].opcodes[23] = { type: 4, index: 32 };
      this.rules[31].opcodes[24] = { type: 4, index: 33 };
      this.rules[32].opcodes = [];
      this.rules[32].opcodes[0] = { type: 6, string: [37, 115] };
      this.rules[33].opcodes = [];
      this.rules[33].opcodes[0] = { type: 6, string: [37, 105] };
      this.rules[34].opcodes = [];
      this.rules[34].opcodes[0] = { type: 6, string: [37, 117] };
      this.rules[35].opcodes = [];
      this.rules[35].opcodes[0] = { type: 6, string: [37, 112] };
      this.rules[36].opcodes = [];
      this.rules[36].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[36].opcodes[1] = { type: 4, index: 38 };
      this.rules[36].opcodes[2] = { type: 4, index: 39 };
      this.rules[36].opcodes[3] = { type: 4, index: 37 };
      this.rules[37].opcodes = [];
      this.rules[37].opcodes[0] = { type: 4, index: 88 };
      this.rules[38].opcodes = [];
      this.rules[38].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[38].opcodes[1] = { type: 6, string: [117, 95] };
      this.rules[38].opcodes[2] = { type: 4, index: 88 };
      this.rules[39].opcodes = [];
      this.rules[39].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[39].opcodes[1] = { type: 6, string: [101, 95] };
      this.rules[39].opcodes[2] = { type: 4, index: 88 };
      this.rules[40].opcodes = [];
      this.rules[40].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[40].opcodes[1] = { type: 4, index: 42 };
      this.rules[40].opcodes[2] = { type: 4, index: 41 };
      this.rules[41].opcodes = [];
      this.rules[41].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[41].opcodes[1] = { type: 6, string: [117, 95] };
      this.rules[41].opcodes[2] = { type: 4, index: 88 };
      this.rules[42].opcodes = [];
      this.rules[42].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[42].opcodes[1] = { type: 6, string: [101, 95] };
      this.rules[42].opcodes[2] = { type: 4, index: 88 };
      this.rules[43].opcodes = [];
      this.rules[43].opcodes[0] = { type: 1, children: [1, 5, 8, 11, 12] };
      this.rules[43].opcodes[1] = { type: 2, children: [2, 3, 4] };
      this.rules[43].opcodes[2] = { type: 4, index: 69 };
      this.rules[43].opcodes[3] = { type: 4, index: 46 };
      this.rules[43].opcodes[4] = { type: 4, index: 71 };
      this.rules[43].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[43].opcodes[6] = { type: 4, index: 69 };
      this.rules[43].opcodes[7] = { type: 4, index: 46 };
      this.rules[43].opcodes[8] = { type: 2, children: [9, 10] };
      this.rules[43].opcodes[9] = { type: 4, index: 46 };
      this.rules[43].opcodes[10] = { type: 4, index: 71 };
      this.rules[43].opcodes[11] = { type: 4, index: 46 };
      this.rules[43].opcodes[12] = { type: 4, index: 70 };
      this.rules[44].opcodes = [];
      this.rules[44].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[44].opcodes[1] = { type: 6, string: [47] };
      this.rules[44].opcodes[2] = { type: 4, index: 89 };
      this.rules[45].opcodes = [];
      this.rules[45].opcodes[0] = { type: 4, index: 90 };
      this.rules[46].opcodes = [];
      this.rules[46].opcodes[0] = { type: 6, string: [42] };
      this.rules[47].opcodes = [];
      this.rules[47].opcodes[0] = { type: 6, string: [38] };
      this.rules[48].opcodes = [];
      this.rules[48].opcodes[0] = { type: 6, string: [33] };
      this.rules[49].opcodes = [];
      this.rules[49].opcodes[0] = { type: 6, string: [38, 38] };
      this.rules[50].opcodes = [];
      this.rules[50].opcodes[0] = { type: 6, string: [33, 33] };
      this.rules[51].opcodes = [];
      this.rules[51].opcodes[0] = { type: 6, string: [37, 94] };
      this.rules[52].opcodes = [];
      this.rules[52].opcodes[0] = { type: 6, string: [37, 36] };
      this.rules[53].opcodes = [];
      this.rules[53].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[53].opcodes[1] = { type: 6, string: [37] };
      this.rules[53].opcodes[2] = { type: 1, children: [3, 8, 13] };
      this.rules[53].opcodes[3] = { type: 2, children: [4, 5, 6, 7] };
      this.rules[53].opcodes[4] = { type: 4, index: 76 };
      this.rules[53].opcodes[5] = { type: 4, index: 79 };
      this.rules[53].opcodes[6] = { type: 6, string: [45] };
      this.rules[53].opcodes[7] = { type: 4, index: 80 };
      this.rules[53].opcodes[8] = { type: 2, children: [9, 10, 11, 12] };
      this.rules[53].opcodes[9] = { type: 4, index: 77 };
      this.rules[53].opcodes[10] = { type: 4, index: 83 };
      this.rules[53].opcodes[11] = { type: 6, string: [45] };
      this.rules[53].opcodes[12] = { type: 4, index: 84 };
      this.rules[53].opcodes[13] = { type: 2, children: [14, 15, 16, 17] };
      this.rules[53].opcodes[14] = { type: 4, index: 78 };
      this.rules[53].opcodes[15] = { type: 4, index: 81 };
      this.rules[53].opcodes[16] = { type: 6, string: [45] };
      this.rules[53].opcodes[17] = { type: 4, index: 82 };
      this.rules[54].opcodes = [];
      this.rules[54].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[54].opcodes[1] = { type: 6, string: [37] };
      this.rules[54].opcodes[2] = { type: 1, children: [3, 10, 17] };
      this.rules[54].opcodes[3] = { type: 2, children: [4, 5, 6] };
      this.rules[54].opcodes[4] = { type: 4, index: 76 };
      this.rules[54].opcodes[5] = { type: 4, index: 73 };
      this.rules[54].opcodes[6] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[7] = { type: 2, children: [8, 9] };
      this.rules[54].opcodes[8] = { type: 6, string: [46] };
      this.rules[54].opcodes[9] = { type: 4, index: 73 };
      this.rules[54].opcodes[10] = { type: 2, children: [11, 12, 13] };
      this.rules[54].opcodes[11] = { type: 4, index: 77 };
      this.rules[54].opcodes[12] = { type: 4, index: 74 };
      this.rules[54].opcodes[13] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[14] = { type: 2, children: [15, 16] };
      this.rules[54].opcodes[15] = { type: 6, string: [46] };
      this.rules[54].opcodes[16] = { type: 4, index: 74 };
      this.rules[54].opcodes[17] = { type: 2, children: [18, 19, 20] };
      this.rules[54].opcodes[18] = { type: 4, index: 78 };
      this.rules[54].opcodes[19] = { type: 4, index: 75 };
      this.rules[54].opcodes[20] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[21] = { type: 2, children: [22, 23] };
      this.rules[54].opcodes[22] = { type: 6, string: [46] };
      this.rules[54].opcodes[23] = { type: 4, index: 75 };
      this.rules[55].opcodes = [];
      this.rules[55].opcodes[0] = { type: 2, children: [1, 2, 3, 4] };
      this.rules[55].opcodes[1] = { type: 4, index: 56 };
      this.rules[55].opcodes[2] = { type: 4, index: 57 };
      this.rules[55].opcodes[3] = { type: 4, index: 59 };
      this.rules[55].opcodes[4] = { type: 4, index: 58 };
      this.rules[56].opcodes = [];
      this.rules[56].opcodes[0] = { type: 3, min: 0, max: 1 };
      this.rules[56].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[56].opcodes[2] = { type: 7, string: [37, 105] };
      this.rules[56].opcodes[3] = { type: 7, string: [37, 115] };
      this.rules[57].opcodes = [];
      this.rules[57].opcodes[0] = { type: 6, string: [34] };
      this.rules[58].opcodes = [];
      this.rules[58].opcodes[0] = { type: 6, string: [34] };
      this.rules[59].opcodes = [];
      this.rules[59].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[59].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[59].opcodes[2] = { type: 5, min: 32, max: 33 };
      this.rules[59].opcodes[3] = { type: 5, min: 35, max: 126 };
      this.rules[59].opcodes[4] = { type: 4, index: 60 };
      this.rules[60].opcodes = [];
      this.rules[60].opcodes[0] = { type: 6, string: [9] };
      this.rules[61].opcodes = [];
      this.rules[61].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[61].opcodes[1] = { type: 4, index: 62 };
      this.rules[61].opcodes[2] = { type: 4, index: 64 };
      this.rules[61].opcodes[3] = { type: 4, index: 63 };
      this.rules[62].opcodes = [];
      this.rules[62].opcodes[0] = { type: 6, string: [39] };
      this.rules[63].opcodes = [];
      this.rules[63].opcodes[0] = { type: 6, string: [39] };
      this.rules[64].opcodes = [];
      this.rules[64].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[64].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[64].opcodes[2] = { type: 5, min: 32, max: 38 };
      this.rules[64].opcodes[3] = { type: 5, min: 40, max: 126 };
      this.rules[64].opcodes[4] = { type: 4, index: 60 };
      this.rules[65].opcodes = [];
      this.rules[65].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[65].opcodes[1] = { type: 4, index: 66 };
      this.rules[65].opcodes[2] = { type: 4, index: 67 };
      this.rules[65].opcodes[3] = { type: 4, index: 68 };
      this.rules[66].opcodes = [];
      this.rules[66].opcodes[0] = { type: 6, string: [60] };
      this.rules[67].opcodes = [];
      this.rules[67].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[67].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[67].opcodes[2] = { type: 5, min: 32, max: 61 };
      this.rules[67].opcodes[3] = { type: 5, min: 63, max: 126 };
      this.rules[67].opcodes[4] = { type: 4, index: 60 };
      this.rules[68].opcodes = [];
      this.rules[68].opcodes[0] = { type: 6, string: [62] };
      this.rules[69].opcodes = [];
      this.rules[69].opcodes[0] = { type: 4, index: 72 };
      this.rules[70].opcodes = [];
      this.rules[70].opcodes[0] = { type: 4, index: 72 };
      this.rules[71].opcodes = [];
      this.rules[71].opcodes[0] = { type: 4, index: 72 };
      this.rules[72].opcodes = [];
      this.rules[72].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[72].opcodes[1] = { type: 5, min: 48, max: 57 };
      this.rules[73].opcodes = [];
      this.rules[73].opcodes[0] = { type: 4, index: 85 };
      this.rules[74].opcodes = [];
      this.rules[74].opcodes[0] = { type: 4, index: 87 };
      this.rules[75].opcodes = [];
      this.rules[75].opcodes[0] = { type: 4, index: 86 };
      this.rules[76].opcodes = [];
      this.rules[76].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[76].opcodes[1] = { type: 6, string: [68] };
      this.rules[76].opcodes[2] = { type: 6, string: [100] };
      this.rules[77].opcodes = [];
      this.rules[77].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[77].opcodes[1] = { type: 6, string: [88] };
      this.rules[77].opcodes[2] = { type: 6, string: [120] };
      this.rules[78].opcodes = [];
      this.rules[78].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[78].opcodes[1] = { type: 6, string: [66] };
      this.rules[78].opcodes[2] = { type: 6, string: [98] };
      this.rules[79].opcodes = [];
      this.rules[79].opcodes[0] = { type: 4, index: 85 };
      this.rules[80].opcodes = [];
      this.rules[80].opcodes[0] = { type: 4, index: 85 };
      this.rules[81].opcodes = [];
      this.rules[81].opcodes[0] = { type: 4, index: 86 };
      this.rules[82].opcodes = [];
      this.rules[82].opcodes[0] = { type: 4, index: 86 };
      this.rules[83].opcodes = [];
      this.rules[83].opcodes[0] = { type: 4, index: 87 };
      this.rules[84].opcodes = [];
      this.rules[84].opcodes[0] = { type: 4, index: 87 };
      this.rules[85].opcodes = [];
      this.rules[85].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[85].opcodes[1] = { type: 5, min: 48, max: 57 };
      this.rules[86].opcodes = [];
      this.rules[86].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[86].opcodes[1] = { type: 5, min: 48, max: 49 };
      this.rules[87].opcodes = [];
      this.rules[87].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[87].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[87].opcodes[2] = { type: 5, min: 48, max: 57 };
      this.rules[87].opcodes[3] = { type: 5, min: 65, max: 70 };
      this.rules[87].opcodes[4] = { type: 5, min: 97, max: 102 };
      this.rules[88].opcodes = [];
      this.rules[88].opcodes[0] = { type: 2, children: [1, 4] };
      this.rules[88].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[88].opcodes[2] = { type: 5, min: 97, max: 122 };
      this.rules[88].opcodes[3] = { type: 5, min: 65, max: 90 };
      this.rules[88].opcodes[4] = { type: 3, min: 0, max: Infinity };
      this.rules[88].opcodes[5] = { type: 1, children: [6, 7, 8, 9] };
      this.rules[88].opcodes[6] = { type: 5, min: 97, max: 122 };
      this.rules[88].opcodes[7] = { type: 5, min: 65, max: 90 };
      this.rules[88].opcodes[8] = { type: 5, min: 48, max: 57 };
      this.rules[88].opcodes[9] = { type: 6, string: [45] };
      this.rules[89].opcodes = [];
      this.rules[89].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[89].opcodes[1] = { type: 4, index: 91 };
      this.rules[90].opcodes = [];
      this.rules[90].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[90].opcodes[1] = { type: 4, index: 91 };
      this.rules[91].opcodes = [];
      this.rules[91].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[91].opcodes[1] = { type: 6, string: [32] };
      this.rules[91].opcodes[2] = { type: 6, string: [9] };
      this.rules[91].opcodes[3] = { type: 4, index: 92 };
      this.rules[91].opcodes[4] = { type: 4, index: 94 };
      this.rules[92].opcodes = [];
      this.rules[92].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[92].opcodes[1] = { type: 6, string: [59] };
      this.rules[92].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[92].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[92].opcodes[4] = { type: 5, min: 32, max: 126 };
      this.rules[92].opcodes[5] = { type: 6, string: [9] };
      this.rules[93].opcodes = [];
      this.rules[93].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[93].opcodes[1] = { type: 6, string: [13, 10] };
      this.rules[93].opcodes[2] = { type: 6, string: [10] };
      this.rules[93].opcodes[3] = { type: 6, string: [13] };
      this.rules[94].opcodes = [];
      this.rules[94].opcodes[0] = { type: 2, children: [1, 5] };
      this.rules[94].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[94].opcodes[2] = { type: 6, string: [13, 10] };
      this.rules[94].opcodes[3] = { type: 6, string: [10] };
      this.rules[94].opcodes[4] = { type: 6, string: [13] };
      this.rules[94].opcodes[5] = { type: 1, children: [6, 7] };
      this.rules[94].opcodes[6] = { type: 6, string: [32] };
      this.rules[94].opcodes[7] = { type: 6, string: [9] };
      this.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
        let str = "";
        str += ";\n";
        str += "; ABNF for JavaScript APG 2.0 SABNF\n";
        str += "; RFC 5234 with some restrictions and additions.\n";
        str += "; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\n";
        str += ';  - accepts %s"string" as a case-sensitive string\n';
        str += ';  - accepts %i"string" as a case-insensitive string\n';
        str += ';  - accepts "string" as a case-insensitive string\n';
        str += ";\n";
        str += "; Some restrictions:\n";
        str += ";   1. Rules must begin at first character of each line.\n";
        str += ";      Indentations on first rule and rules thereafter are not allowed.\n";
        str += ";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\n";
        str += ";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\n";
        str += ";      However, a working parser cannot be generated from them.\n";
        str += ";\n";
        str += "; Super set (SABNF) additions:\n";
        str += ";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\n";
        str += ";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\n";
        str += ";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\n";
        str += ";      e.g. &%d13 or &rule or !(A / B)\n";
        str += ";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\n";
        str += ";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\n";
        str += ";      u_name may be used as an element but no rule definition is given.\n";
        str += ";      e.g. rule = A / u_myUdt\n";
        str += ';           A = "a"\n';
        str += ";      would be a valid grammar.\n";
        str += ";   3. Case-sensitive, single-quoted strings are accepted.\n";
        str += ";      e.g. 'abc' would be equivalent to %d97.98.99\n";
        str += ';      (kept for backward compatibility, but superseded by %s"abc")  \n';
        str += "; New 12/26/2015\n";
        str += ";   4. Look-behind operators are accepted as element prefixes.\n";
        str += ";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\n";
        str += ";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\n";
        str += ";      e.g. &&%d13 or &&rule or !!(A / B)\n";
        str += ";   5. Back reference operators, i.e. \\rulename, are accepted.\n";
        str += ";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\n";
        str += ";      to match is a phrase previously matched by the rule 'rulename'.\n";
        str += ";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\n";
        str += ";      In universal mode, \\rulename matches the last match to 'rulename' regardless of where it was found.\n";
        str += ";      In parent-frame mode, \\rulename matches only the last match found on the parent's frame or parse tree level.\n";
        str += ";      Back reference modifiers can be used to specify case and mode.\n";
        str += ";      \\A defaults to case-insensitive and universal mode, e.g. \\A === \\%i%uA\n";
        str += ";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\n";
        str += ";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\n";
        str += ";      Case and mode modifiers can appear in any order, e.g. \\%s%pA === \\%p%sA. \n";
        str += ";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\n";
        str += ";      Returns EMPTY or NOMATCH. Never consumes any characters.\n";
        str += ";   8. String end anchor, AEN(%$) matches the end of the input string location.\n";
        str += ";      Returns EMPTY or NOMATCH. Never consumes any characters.\n";
        str += ";\n";
        str += "File            = *(BlankLine / Rule / RuleError)\n";
        str += "BlankLine       = *(%d32/%d9) [comment] LineEnd\n";
        str += "Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\n";
        str += "                / (LineEndError LineEnd))\n";
        str += "RuleLookup      = RuleNameTest owsp DefinedAsTest\n";
        str += "RuleNameTest    = RuleName/RuleNameError\n";
        str += "RuleName        = alphanum\n";
        str += "RuleNameError   = 1*(%d33-60/%d62-126)\n";
        str += "DefinedAsTest   = DefinedAs / DefinedAsError\n";
        str += "DefinedAsError  = 1*2%d33-126\n";
        str += "DefinedAs       = IncAlt / Defined\n";
        str += "Defined         = %d61\n";
        str += "IncAlt          = %d61.47\n";
        str += "RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\n";
        str += "LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\n";
        str += "Alternation     = Concatenation *(owsp AltOp Concatenation)\n";
        str += "Concatenation   = Repetition *(CatOp Repetition)\n";
        str += "Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\n";
        str += "Modifier        = (Predicate [RepOp])\n";
        str += "                / RepOp\n";
        str += "Predicate       = BkaOp\n";
        str += "                / BknOp\n";
        str += "                / AndOp\n";
        str += "                / NotOp\n";
        str += "BasicElement    = UdtOp\n";
        str += "                / RnmOp\n";
        str += "                / TrgOp\n";
        str += "                / TbsOp\n";
        str += "                / TlsOp\n";
        str += "                / ClsOp\n";
        str += "                / BkrOp\n";
        str += "                / AbgOp\n";
        str += "                / AenOp\n";
        str += "                / ProsVal\n";
        str += "BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\n";
        str += "Group           = GroupOpen  Alternation (GroupClose / GroupError)\n";
        str += "GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\n";
        str += "GroupOpen       = %d40 owsp\n";
        str += "GroupClose      = owsp %d41\n";
        str += "Option          = OptionOpen Alternation (OptionClose / OptionError)\n";
        str += "OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\n";
        str += "OptionOpen      = %d91 owsp\n";
        str += "OptionClose     = owsp %d93\n";
        str += "RnmOp           = alphanum\n";
        str += "BkrOp           = %d92 [bkrModifier] bkr-name\n";
        str += "bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\n";
        str += "cs              = '%s'\n";
        str += "ci              = '%i'\n";
        str += "um              = '%u'\n";
        str += "pm              = '%p'\n";
        str += "bkr-name        = uname / ename / rname\n";
        str += "rname           = alphanum\n";
        str += "uname           = %d117.95 alphanum\n";
        str += "ename           = %d101.95 alphanum\n";
        str += "UdtOp           = udt-empty\n";
        str += "                / udt-non-empty\n";
        str += "udt-non-empty   = %d117.95 alphanum\n";
        str += "udt-empty       = %d101.95 alphanum\n";
        str += "RepOp           = (rep-min StarOp rep-max)\n";
        str += "                / (rep-min StarOp)\n";
        str += "                / (StarOp rep-max)\n";
        str += "                / StarOp\n";
        str += "                / rep-min-max\n";
        str += "AltOp           = %d47 owsp\n";
        str += "CatOp           = wsp\n";
        str += "StarOp          = %d42\n";
        str += "AndOp           = %d38\n";
        str += "NotOp           = %d33\n";
        str += "BkaOp           = %d38.38\n";
        str += "BknOp           = %d33.33\n";
        str += "AbgOp           = %d37.94\n";
        str += "AenOp           = %d37.36\n";
        str += "TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\n";
        str += "TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\n";
        str += "TlsOp           = TlsCase TlsOpen TlsString TlsClose\n";
        str += 'TlsCase         = ["%i" / "%s"]\n';
        str += "TlsOpen         = %d34\n";
        str += "TlsClose        = %d34\n";
        str += "TlsString       = *(%d32-33/%d35-126/StringTab)\n";
        str += "StringTab       = %d9\n";
        str += "ClsOp           = ClsOpen ClsString ClsClose\n";
        str += "ClsOpen         = %d39\n";
        str += "ClsClose        = %d39\n";
        str += "ClsString       = *(%d32-38/%d40-126/StringTab)\n";
        str += "ProsVal         = ProsValOpen ProsValString ProsValClose\n";
        str += "ProsValOpen     = %d60\n";
        str += "ProsValString   = *(%d32-61/%d63-126/StringTab)\n";
        str += "ProsValClose    = %d62\n";
        str += "rep-min         = rep-num\n";
        str += "rep-min-max     = rep-num\n";
        str += "rep-max         = rep-num\n";
        str += "rep-num         = 1*(%d48-57)\n";
        str += "dString         = dnum\n";
        str += "xString         = xnum\n";
        str += "bString         = bnum\n";
        str += "Dec             = (%d68/%d100)\n";
        str += "Hex             = (%d88/%d120)\n";
        str += "Bin             = (%d66/%d98)\n";
        str += "dmin            = dnum\n";
        str += "dmax            = dnum\n";
        str += "bmin            = bnum\n";
        str += "bmax            = bnum\n";
        str += "xmin            = xnum\n";
        str += "xmax            = xnum\n";
        str += "dnum            = 1*(%d48-57)\n";
        str += "bnum            = 1*%d48-49\n";
        str += "xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\n";
        str += ";\n";
        str += "; Basics\n";
        str += "alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\n";
        str += "owsp            = *space\n";
        str += "wsp             = 1*space\n";
        str += "space           = %d32\n";
        str += "                / %d9\n";
        str += "                / comment\n";
        str += "                / LineContinue\n";
        str += "comment         = %d59 *(%d32-126 / %d9)\n";
        str += "LineEnd         = %d13.10\n";
        str += "                / %d10\n";
        str += "                / %d13\n";
        str += "LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\n";
        return str;
      }, "toString6"), "toString");
    }, "grammar"), "grammar");
  }
});
var require_parser2 = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/parser.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportParser() {
      const thisFileName = "parser: ";
      const ApgLib = require_node_exports();
      const id2 = ApgLib.ids;
      const syn = new (require_syntax_callbacks())();
      const sem = new (require_semantic_callbacks())();
      const sabnfGrammar = new (require_sabnf_grammar())();
      const parser = new ApgLib.parser();
      parser.ast = new ApgLib.ast();
      parser.callbacks = syn.callbacks;
      parser.ast.callbacks = sem.callbacks;
      const findLine = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function findLine2(lines, charIndex, charLength) {
        if (charIndex < 0 || charIndex >= charLength) {
          return -1;
        }
        for (let i22 = 0; i22 < lines.length; i22 += 1) {
          if (charIndex >= lines[i22].beginChar && charIndex < lines[i22].beginChar + lines[i22].length) {
            return i22;
          }
        }
        return -1;
      }, "findLine2"), "findLine");
      const translateIndex = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function translateIndex2(map2, index) {
        let ret = -1;
        if (index < map2.length) {
          for (let i22 = index; i22 < map2.length; i22 += 1) {
            if (map2[i22] !== null) {
              ret = map2[i22];
              break;
            }
          }
        }
        return ret;
      }, "translateIndex2"), "translateIndex");
      const reduceOpcodes = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function reduceOpcodes2(rules) {
        rules.forEach((rule) => {
          const opcodes = [];
          const map2 = [];
          let reducedIndex = 0;
          rule.opcodes.forEach((op) => {
            if (op.type === id2.ALT && op.children.length === 1) {
              map2.push(null);
            } else if (op.type === id2.CAT && op.children.length === 1) {
              map2.push(null);
            } else if (op.type === id2.REP && op.min === 1 && op.max === 1) {
              map2.push(null);
            } else {
              map2.push(reducedIndex);
              opcodes.push(op);
              reducedIndex += 1;
            }
          });
          map2.push(reducedIndex);
          opcodes.forEach((op) => {
            if (op.type === id2.ALT || op.type === id2.CAT) {
              for (let i22 = 0; i22 < op.children.length; i22 += 1) {
                op.children[i22] = translateIndex(map2, op.children[i22]);
              }
            }
          });
          rule.opcodes = opcodes;
        });
      }, "reduceOpcodes2"), "reduceOpcodes");
      this.syntax = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function syntax(chars, lines, errors, strict, trace) {
        if (trace) {
          if (trace.traceObject !== "traceObject") {
            throw new TypeError(`${thisFileName}trace argument is not a trace object`);
          }
          parser.trace = trace;
        }
        const data = {};
        data.errors = errors;
        data.strict = !!strict;
        data.lines = lines;
        data.findLine = findLine;
        data.charsLength = chars.length;
        data.ruleCount = 0;
        const result = parser.parse(sabnfGrammar, "file", chars, data);
        if (!result.success) {
          errors.push({
            line: 0,
            char: 0,
            msg: "syntax analysis of input grammar failed"
          });
        }
      }, "syntax"), "syntax");
      this.semantic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function semantic(chars, lines, errors) {
        const data = {};
        data.errors = errors;
        data.lines = lines;
        data.findLine = findLine;
        data.charsLength = chars.length;
        parser.ast.translate(data);
        if (errors.length) {
          return null;
        }
        reduceOpcodes(data.rules);
        return {
          rules: data.rules,
          udts: data.udts,
          lineMap: data.rulesLineMap
        };
      }, "semantic"), "semantic");
      this.generateSource = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function generateSource(chars, lines, rules, udts, name3) {
        let source = "";
        let i22;
        let bkrname;
        let bkrlower;
        let opcodeCount = 0;
        let charCodeMin = Infinity;
        let charCodeMax = 0;
        const ruleNames = [];
        const udtNames = [];
        let alt = 0;
        let cat = 0;
        let rnm = 0;
        let udt = 0;
        let rep = 0;
        let and = 0;
        let not = 0;
        let tls = 0;
        let tbs = 0;
        let trg = 0;
        let bkr = 0;
        let bka = 0;
        let bkn = 0;
        let abg = 0;
        let aen = 0;
        rules.forEach((rule) => {
          ruleNames.push(rule.lower);
          opcodeCount += rule.opcodes.length;
          rule.opcodes.forEach((op) => {
            switch (op.type) {
              case id2.ALT:
                alt += 1;
                break;
              case id2.CAT:
                cat += 1;
                break;
              case id2.RNM:
                rnm += 1;
                break;
              case id2.UDT:
                udt += 1;
                break;
              case id2.REP:
                rep += 1;
                break;
              case id2.AND:
                and += 1;
                break;
              case id2.NOT:
                not += 1;
                break;
              case id2.BKA:
                bka += 1;
                break;
              case id2.BKN:
                bkn += 1;
                break;
              case id2.BKR:
                bkr += 1;
                break;
              case id2.ABG:
                abg += 1;
                break;
              case id2.AEN:
                aen += 1;
                break;
              case id2.TLS:
                tls += 1;
                for (i22 = 0; i22 < op.string.length; i22 += 1) {
                  if (op.string[i22] < charCodeMin) {
                    charCodeMin = op.string[i22];
                  }
                  if (op.string[i22] > charCodeMax) {
                    charCodeMax = op.string[i22];
                  }
                }
                break;
              case id2.TBS:
                tbs += 1;
                for (i22 = 0; i22 < op.string.length; i22 += 1) {
                  if (op.string[i22] < charCodeMin) {
                    charCodeMin = op.string[i22];
                  }
                  if (op.string[i22] > charCodeMax) {
                    charCodeMax = op.string[i22];
                  }
                }
                break;
              case id2.TRG:
                trg += 1;
                if (op.min < charCodeMin) {
                  charCodeMin = op.min;
                }
                if (op.max > charCodeMax) {
                  charCodeMax = op.max;
                }
                break;
              default:
                throw new Error("generateSource: unrecognized opcode");
            }
          });
        });
        ruleNames.sort();
        if (udts.length > 0) {
          udts.forEach((udtFunc) => {
            udtNames.push(udtFunc.lower);
          });
          udtNames.sort();
        }
        let funcname = "module.exports";
        if (name3 && typeof name3 === "string") {
          funcname = `let ${name3}`;
        }
        source += "// copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved<br>\n";
        source += "//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n";
        source += "//\n";
        source += "// Generated by apg-js, Version 4.0.0 [apg-js](https://github.com/ldthomas/apg-js)\n";
        source += `${funcname} = function grammar(){
`;
        source += "  // ```\n";
        source += "  // SUMMARY\n";
        source += `  //      rules = ${rules.length}
`;
        source += `  //       udts = ${udts.length}
`;
        source += `  //    opcodes = ${opcodeCount}
`;
        source += "  //        ---   ABNF original opcodes\n";
        source += `  //        ALT = ${alt}
`;
        source += `  //        CAT = ${cat}
`;
        source += `  //        REP = ${rep}
`;
        source += `  //        RNM = ${rnm}
`;
        source += `  //        TLS = ${tls}
`;
        source += `  //        TBS = ${tbs}
`;
        source += `  //        TRG = ${trg}
`;
        source += "  //        ---   SABNF superset opcodes\n";
        source += `  //        UDT = ${udt}
`;
        source += `  //        AND = ${and}
`;
        source += `  //        NOT = ${not}
`;
        source += `  //        BKA = ${bka}
`;
        source += `  //        BKN = ${bkn}
`;
        source += `  //        BKR = ${bkr}
`;
        source += `  //        ABG = ${abg}
`;
        source += `  //        AEN = ${aen}
`;
        source += "  // characters = [";
        if (tls + tbs + trg === 0) {
          source += " none defined ]";
        } else {
          source += `${charCodeMin} - ${charCodeMax}]`;
        }
        if (udt > 0) {
          source += " + user defined";
        }
        source += "\n";
        source += "  // ```\n";
        source += "  /* OBJECT IDENTIFIER (for internal parser use) */\n";
        source += "  this.grammarObject = 'grammarObject';\n";
        source += "\n";
        source += "  /* RULES */\n";
        source += "  this.rules = [];\n";
        rules.forEach((rule, ii) => {
          let thisRule = "  this.rules[";
          thisRule += ii;
          thisRule += "] = {name: '";
          thisRule += rule.name;
          thisRule += "', lower: '";
          thisRule += rule.lower;
          thisRule += "', index: ";
          thisRule += rule.index;
          thisRule += ", isBkr: ";
          thisRule += rule.isBkr;
          thisRule += "};\n";
          source += thisRule;
        });
        source += "\n";
        source += "  /* UDTS */\n";
        source += "  this.udts = [];\n";
        if (udts.length > 0) {
          udts.forEach((udtFunc, ii) => {
            let thisUdt = "  this.udts[";
            thisUdt += ii;
            thisUdt += "] = {name: '";
            thisUdt += udtFunc.name;
            thisUdt += "', lower: '";
            thisUdt += udtFunc.lower;
            thisUdt += "', index: ";
            thisUdt += udtFunc.index;
            thisUdt += ", empty: ";
            thisUdt += udtFunc.empty;
            thisUdt += ", isBkr: ";
            thisUdt += udtFunc.isBkr;
            thisUdt += "};\n";
            source += thisUdt;
          });
        }
        source += "\n";
        source += "  /* OPCODES */\n";
        rules.forEach((rule, ruleIndex) => {
          if (ruleIndex > 0) {
            source += "\n";
          }
          source += `  /* ${rule.name} */
`;
          source += `  this.rules[${ruleIndex}].opcodes = [];
`;
          rule.opcodes.forEach((op, opIndex) => {
            let prefix;
            switch (op.type) {
              case id2.ALT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, children: [${op.children.toString()}]};// ALT
`;
                break;
              case id2.CAT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, children: [${op.children.toString()}]};// CAT
`;
                break;
              case id2.RNM:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}};// RNM(${rules[op.index].name})
`;
                break;
              case id2.BKR:
                if (op.index >= rules.length) {
                  bkrname = udts[op.index - rules.length].name;
                  bkrlower = udts[op.index - rules.length].lower;
                } else {
                  bkrname = rules[op.index].name;
                  bkrlower = rules[op.index].lower;
                }
                prefix = "%i";
                if (op.bkrCase === id2.BKR_MODE_CS) {
                  prefix = "%s";
                }
                if (op.bkrMode === id2.BKR_MODE_UM) {
                  prefix += "%u";
                } else {
                  prefix += "%p";
                }
                bkrname = prefix + bkrname;
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}, lower: '${bkrlower}', bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode}};// BKR(\\${bkrname})
`;
                break;
              case id2.UDT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, empty: ${op.empty}, index: ${op.index}};// UDT(${udts[op.index].name})
`;
                break;
              case id2.REP:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// REP
`;
                break;
              case id2.AND:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AND
`;
                break;
              case id2.NOT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// NOT
`;
                break;
              case id2.ABG:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// ABG(%^)
`;
                break;
              case id2.AEN:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AEN(%$)
`;
                break;
              case id2.BKA:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKA
`;
                break;
              case id2.BKN:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKN
`;
                break;
              case id2.TLS:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, string: [${op.string.toString()}]};// TLS
`;
                break;
              case id2.TBS:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, string: [${op.string.toString()}]};// TBS
`;
                break;
              case id2.TRG:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// TRG
`;
                break;
              default:
                throw new Error("parser.js: ~143: unrecognized opcode");
            }
          });
        });
        source += "\n";
        source += "  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n";
        source += "  this.toString = function toString(){\n";
        source += '    let str = "";\n';
        let str;
        lines.forEach((line) => {
          const end = line.beginChar + line.length;
          str = "";
          source += '    str += "';
          for (let ii = line.beginChar; ii < end; ii += 1) {
            switch (chars[ii]) {
              case 9:
                str = " ";
                break;
              case 10:
                str = "\\n";
                break;
              case 13:
                str = "\\r";
                break;
              case 34:
                str = '\\"';
                break;
              case 92:
                str = "\\\\";
                break;
              default:
                str = String.fromCharCode(chars[ii]);
                break;
            }
            source += str;
          }
          source += '";\n';
        });
        source += "    return str;\n";
        source += "  }\n";
        source += "}\n";
        return source;
      }, "generateSource"), "generateSource");
      this.generateObject = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function generateObject(stringArg, rules, udts) {
        const obj = {};
        const ruleNames = [];
        const udtNames = [];
        const string2 = stringArg.slice(0);
        obj.grammarObject = "grammarObject";
        rules.forEach((rule) => {
          ruleNames.push(rule.lower);
        });
        ruleNames.sort();
        if (udts.length > 0) {
          udts.forEach((udtFunc) => {
            udtNames.push(udtFunc.lower);
          });
          udtNames.sort();
        }
        obj.callbacks = [];
        ruleNames.forEach((name3) => {
          obj.callbacks[name3] = false;
        });
        if (udts.length > 0) {
          udtNames.forEach((name3) => {
            obj.callbacks[name3] = false;
          });
        }
        obj.rules = rules;
        obj.udts = udts;
        obj.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toStringFunc() {
          return string2;
        }, "toStringFunc"), "toStringFunc");
        return obj;
      }, "generateObject"), "generateObject");
    }, "exportParser"), "exportParser");
  }
});
var require_rule_attributes = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/rule-attributes.js"(exports, module2) {
    module2.exports = (/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportRuleAttributes() {
      const id2 = require_identifiers();
      const thisFile = "rule-attributes.js";
      let state = null;
      function isEmptyOnly(attr) {
        if (attr.left || attr.nested || attr.right || attr.cyclic) {
          return false;
        }
        return attr.empty;
      }
      __name(isEmptyOnly, "isEmptyOnly");
      __name2(isEmptyOnly, "isEmptyOnly");
      function isRecursive(attr) {
        if (attr.left || attr.nested || attr.right || attr.cyclic) {
          return true;
        }
        return false;
      }
      __name(isRecursive, "isRecursive");
      __name2(isRecursive, "isRecursive");
      function isCatNested(attrs, count) {
        let i22 = 0;
        let j = 0;
        let k2 = 0;
        for (i22 = 0; i22 < count; i22 += 1) {
          if (attrs[i22].nested) {
            return true;
          }
        }
        for (i22 = 0; i22 < count; i22 += 1) {
          if (attrs[i22].right && !attrs[i22].leaf) {
            for (j = i22 + 1; j < count; j += 1) {
              if (!isEmptyOnly(attrs[j])) {
                return true;
              }
            }
          }
        }
        for (i22 = count - 1; i22 >= 0; i22 -= 1) {
          if (attrs[i22].left && !attrs[i22].leaf) {
            for (j = i22 - 1; j >= 0; j -= 1) {
              if (!isEmptyOnly(attrs[j])) {
                return true;
              }
            }
          }
        }
        for (i22 = 0; i22 < count; i22 += 1) {
          if (!attrs[i22].empty && !isRecursive(attrs[i22])) {
            for (j = i22 + 1; j < count; j += 1) {
              if (isRecursive(attrs[j])) {
                for (k2 = j + 1; k2 < count; k2 += 1) {
                  if (!attrs[k2].empty && !isRecursive(attrs[k2])) {
                    return true;
                  }
                }
              }
            }
          }
        }
        return false;
      }
      __name(isCatNested, "isCatNested");
      __name2(isCatNested, "isCatNested");
      function isCatCyclic(attrs, count) {
        for (let i22 = 0; i22 < count; i22 += 1) {
          if (!attrs[i22].cyclic) {
            return false;
          }
        }
        return true;
      }
      __name(isCatCyclic, "isCatCyclic");
      __name2(isCatCyclic, "isCatCyclic");
      function isCatLeft(attrs, count) {
        for (let i22 = 0; i22 < count; i22 += 1) {
          if (attrs[i22].left) {
            return true;
          }
          if (!attrs[i22].empty) {
            return false;
          }
        }
        return false;
      }
      __name(isCatLeft, "isCatLeft");
      __name2(isCatLeft, "isCatLeft");
      function isCatRight(attrs, count) {
        for (let i22 = count - 1; i22 >= 0; i22 -= 1) {
          if (attrs[i22].right) {
            return true;
          }
          if (!attrs[i22].empty) {
            return false;
          }
        }
        return false;
      }
      __name(isCatRight, "isCatRight");
      __name2(isCatRight, "isCatRight");
      function isCatEmpty(attrs, count) {
        for (let i22 = 0; i22 < count; i22 += 1) {
          if (!attrs[i22].empty) {
            return false;
          }
        }
        return true;
      }
      __name(isCatEmpty, "isCatEmpty");
      __name2(isCatEmpty, "isCatEmpty");
      function isCatFinite(attrs, count) {
        for (let i22 = 0; i22 < count; i22 += 1) {
          if (!attrs[i22].finite) {
            return false;
          }
        }
        return true;
      }
      __name(isCatFinite, "isCatFinite");
      __name2(isCatFinite, "isCatFinite");
      function cat(stateArg, opcodes, opIndex, iAttr) {
        let i22 = 0;
        const opCat = opcodes[opIndex];
        const count = opCat.children.length;
        const childAttrs = [];
        for (i22 = 0; i22 < count; i22 += 1) {
          childAttrs.push(stateArg.attrGen());
        }
        for (i22 = 0; i22 < count; i22 += 1) {
          opEval(stateArg, opcodes, opCat.children[i22], childAttrs[i22]);
        }
        iAttr.left = isCatLeft(childAttrs, count);
        iAttr.right = isCatRight(childAttrs, count);
        iAttr.nested = isCatNested(childAttrs, count);
        iAttr.empty = isCatEmpty(childAttrs, count);
        iAttr.finite = isCatFinite(childAttrs, count);
        iAttr.cyclic = isCatCyclic(childAttrs, count);
      }
      __name(cat, "cat");
      __name2(cat, "cat");
      function alt(stateArg, opcodes, opIndex, iAttr) {
        let i22 = 0;
        const opAlt = opcodes[opIndex];
        const count = opAlt.children.length;
        const childAttrs = [];
        for (i22 = 0; i22 < count; i22 += 1) {
          childAttrs.push(stateArg.attrGen());
        }
        for (i22 = 0; i22 < count; i22 += 1) {
          opEval(stateArg, opcodes, opAlt.children[i22], childAttrs[i22]);
        }
        iAttr.left = false;
        iAttr.right = false;
        iAttr.nested = false;
        iAttr.empty = false;
        iAttr.finite = false;
        iAttr.cyclic = false;
        for (i22 = 0; i22 < count; i22 += 1) {
          if (childAttrs[i22].left) {
            iAttr.left = true;
          }
          if (childAttrs[i22].nested) {
            iAttr.nested = true;
          }
          if (childAttrs[i22].right) {
            iAttr.right = true;
          }
          if (childAttrs[i22].empty) {
            iAttr.empty = true;
          }
          if (childAttrs[i22].finite) {
            iAttr.finite = true;
          }
          if (childAttrs[i22].cyclic) {
            iAttr.cyclic = true;
          }
        }
      }
      __name(alt, "alt");
      __name2(alt, "alt");
      function bkr(stateArg, opcodes, opIndex, iAttr) {
        const opBkr = opcodes[opIndex];
        if (opBkr.index >= stateArg.ruleCount) {
          iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;
          iAttr.finite = true;
        } else {
          ruleAttrsEval(stateArg, opBkr.index, iAttr);
          iAttr.left = false;
          iAttr.nested = false;
          iAttr.right = false;
          iAttr.cyclic = false;
        }
      }
      __name(bkr, "bkr");
      __name2(bkr, "bkr");
      function opEval(stateArg, opcodes, opIndex, iAttr) {
        stateArg.attrInit(iAttr);
        const opi = opcodes[opIndex];
        switch (opi.type) {
          case id2.ALT:
            alt(stateArg, opcodes, opIndex, iAttr);
            break;
          case id2.CAT:
            cat(stateArg, opcodes, opIndex, iAttr);
            break;
          case id2.REP:
            opEval(stateArg, opcodes, opIndex + 1, iAttr);
            if (opi.min === 0) {
              iAttr.empty = true;
              iAttr.finite = true;
            }
            break;
          case id2.RNM:
            ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);
            break;
          case id2.BKR:
            bkr(stateArg, opcodes, opIndex, iAttr);
            break;
          case id2.AND:
          case id2.NOT:
          case id2.BKA:
          case id2.BKN:
            opEval(stateArg, opcodes, opIndex + 1, iAttr);
            iAttr.empty = true;
            break;
          case id2.TLS:
            iAttr.empty = !opcodes[opIndex].string.length;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id2.TBS:
          case id2.TRG:
            iAttr.empty = false;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id2.UDT:
            iAttr.empty = opi.empty;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id2.ABG:
          case id2.AEN:
            iAttr.empty = true;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          default:
            throw new Error(`unknown opcode type: ${opi}`);
        }
      }
      __name(opEval, "opEval");
      __name2(opEval, "opEval");
      function ruleAttrsEval(stateArg, ruleIndex, iAttr) {
        const attri = stateArg.attrsWorking[ruleIndex];
        if (attri.isComplete) {
          stateArg.attrCopy(iAttr, attri);
        } else if (!attri.isOpen) {
          attri.isOpen = true;
          opEval(stateArg, attri.rule.opcodes, 0, iAttr);
          attri.left = iAttr.left;
          attri.right = iAttr.right;
          attri.nested = iAttr.nested;
          attri.empty = iAttr.empty;
          attri.finite = iAttr.finite;
          attri.cyclic = iAttr.cyclic;
          attri.leaf = false;
          attri.isOpen = false;
          attri.isComplete = true;
        } else if (ruleIndex === stateArg.startRule) {
          if (ruleIndex === stateArg.startRule) {
            iAttr.left = true;
            iAttr.right = true;
            iAttr.cyclic = true;
            iAttr.leaf = true;
          }
        } else {
          iAttr.finite = true;
        }
      }
      __name(ruleAttrsEval, "ruleAttrsEval");
      __name2(ruleAttrsEval, "ruleAttrsEval");
      const ruleAttributes = /* @__PURE__ */ __name2((stateArg) => {
        state = stateArg;
        let i22 = 0;
        let j = 0;
        const iAttr = state.attrGen();
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          for (j = 0; j < state.ruleCount; j += 1) {
            state.attrInit(state.attrsWorking[j]);
          }
          state.startRule = i22;
          ruleAttrsEval(state, i22, iAttr);
          state.attrCopy(state.attrs[i22], state.attrsWorking[i22]);
        }
        state.attributesComplete = true;
        let attri = null;
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          attri = state.attrs[i22];
          if (attri.left || !attri.finite || attri.cyclic) {
            const temp = state.attrGen(attri.rule);
            state.attrCopy(temp, attri);
            state.attrsErrors.push(temp);
            state.attrsErrorCount += 1;
          }
        }
      }, "ruleAttributes");
      const truth = /* @__PURE__ */ __name2((val) => val ? "t" : "f", "truth");
      const tError = /* @__PURE__ */ __name2((val) => val ? "e" : "f", "tError");
      const fError = /* @__PURE__ */ __name2((val) => val ? "t" : "e", "fError");
      const showAttr = /* @__PURE__ */ __name2((seq, index, attr, dep) => {
        let str = `${seq}:${index}:`;
        str += `${tError(attr.left)} `;
        str += `${truth(attr.nested)} `;
        str += `${truth(attr.right)} `;
        str += `${tError(attr.cyclic)} `;
        str += `${fError(attr.finite)} `;
        str += `${truth(attr.empty)}:`;
        str += `${state.typeToString(dep.recursiveType)}:`;
        str += dep.recursiveType === id2.ATTR_MR ? dep.groupNumber : "-";
        str += `:${attr.rule.name}
`;
        return str;
      }, "showAttr");
      const showLegend = /* @__PURE__ */ __name2(() => {
        let str = "LEGEND - t=true, f=false, e=error\n";
        str += "sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\n";
        return str;
      }, "showLegend");
      const showAttributeErrors = /* @__PURE__ */ __name2(() => {
        let attri = null;
        let depi = null;
        let str = "";
        str += "RULE ATTRIBUTES WITH ERRORS\n";
        str += showLegend();
        if (state.attrsErrorCount) {
          for (let i22 = 0; i22 < state.attrsErrorCount; i22 += 1) {
            attri = state.attrsErrors[i22];
            depi = state.ruleDeps[attri.rule.index];
            str += showAttr(i22, attri.rule.index, attri, depi);
          }
        } else {
          str += "<none>\n";
        }
        return str;
      }, "showAttributeErrors");
      const show = /* @__PURE__ */ __name2((type) => {
        let i22 = 0;
        let ii = 0;
        let attri = null;
        let depi = null;
        let str = "";
        let { ruleIndexes } = state;
        if (type === 97) {
          ruleIndexes = state.ruleAlphaIndexes;
        } else if (type === 116) {
          ruleIndexes = state.ruleTypeIndexes;
        }
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          ii = ruleIndexes[i22];
          attri = state.attrs[ii];
          depi = state.ruleDeps[ii];
          str += showAttr(i22, ii, attri, depi);
        }
        return str;
      }, "show");
      const showAttributes = /* @__PURE__ */ __name2((order = "index") => {
        if (!state.attributesComplete) {
          throw new Error(`${thisFile}:showAttributes: attributes not available`);
        }
        let str = "";
        const leader = "RULE ATTRIBUTES\n";
        if (order.charCodeAt(0) === 97) {
          str += "alphabetical by rule name\n";
          str += leader;
          str += showLegend();
          str += show(97);
        } else if (order.charCodeAt(0) === 116) {
          str += "ordered by rule type\n";
          str += leader;
          str += showLegend();
          str += show(116);
        } else {
          str += "ordered by rule index\n";
          str += leader;
          str += showLegend();
          str += show();
        }
        return str;
      }, "showAttributes");
      return { ruleAttributes, showAttributes, showAttributeErrors };
    }, "exportRuleAttributes"), "exportRuleAttributes"))();
  }
});
var require_rule_dependencies = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/rule-dependencies.js"(exports, module2) {
    module2.exports = (() => {
      const id2 = require_identifiers();
      let state = null;
      const scan = /* @__PURE__ */ __name2((ruleCount, ruleDeps, index, isScanned) => {
        let i22 = 0;
        let j = 0;
        const rdi = ruleDeps[index];
        isScanned[index] = true;
        const op = rdi.rule.opcodes;
        for (i22 = 0; i22 < op.length; i22 += 1) {
          const opi = op[i22];
          if (opi.type === id2.RNM) {
            rdi.refersTo[opi.index] = true;
            if (!isScanned[opi.index]) {
              scan(ruleCount, ruleDeps, opi.index, isScanned);
            }
            for (j = 0; j < ruleCount; j += 1) {
              if (ruleDeps[opi.index].refersTo[j]) {
                rdi.refersTo[j] = true;
              }
            }
          } else if (opi.type === id2.UDT) {
            rdi.refersToUdt[opi.index] = true;
          } else if (opi.type === id2.BKR) {
            if (opi.index < ruleCount) {
              rdi.refersTo[opi.index] = true;
              if (!isScanned[opi.index]) {
                scan(ruleCount, ruleDeps, opi.index, isScanned);
              }
            } else {
              rdi.refersToUdt[ruleCount - opi.index] = true;
            }
          }
        }
      }, "scan");
      const ruleDependencies = /* @__PURE__ */ __name2((stateArg) => {
        state = stateArg;
        let i22 = 0;
        let j = 0;
        let groupCount = 0;
        let rdi = null;
        let rdj = null;
        let newGroup = false;
        state.dependenciesComplete = false;
        const isScanned = state.falseArray(state.ruleCount);
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          state.falsifyArray(isScanned);
          scan(state.ruleCount, state.ruleDeps, i22, isScanned);
        }
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          for (j = 0; j < state.ruleCount; j += 1) {
            if (i22 !== j) {
              if (state.ruleDeps[j].refersTo[i22]) {
                state.ruleDeps[i22].referencedBy[j] = true;
              }
            }
          }
        }
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          state.ruleDeps[i22].recursiveType = id2.ATTR_N;
          if (state.ruleDeps[i22].refersTo[i22]) {
            state.ruleDeps[i22].recursiveType = id2.ATTR_R;
          }
        }
        groupCount = -1;
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          rdi = state.ruleDeps[i22];
          if (rdi.recursiveType === id2.ATTR_R) {
            newGroup = true;
            for (j = 0; j < state.ruleCount; j += 1) {
              if (i22 !== j) {
                rdj = state.ruleDeps[j];
                if (rdj.recursiveType === id2.ATTR_R) {
                  if (rdi.refersTo[j] && rdj.refersTo[i22]) {
                    if (newGroup) {
                      groupCount += 1;
                      rdi.recursiveType = id2.ATTR_MR;
                      rdi.groupNumber = groupCount;
                      newGroup = false;
                    }
                    rdj.recursiveType = id2.ATTR_MR;
                    rdj.groupNumber = groupCount;
                  }
                }
              }
            }
          }
        }
        state.isMutuallyRecursive = groupCount > -1;
        state.ruleAlphaIndexes.sort(state.compRulesAlpha);
        state.ruleTypeIndexes.sort(state.compRulesAlpha);
        state.ruleTypeIndexes.sort(state.compRulesType);
        if (state.isMutuallyRecursive) {
          state.ruleTypeIndexes.sort(state.compRulesGroup);
        }
        if (state.udtCount) {
          state.udtAlphaIndexes.sort(state.compUdtsAlpha);
        }
        state.dependenciesComplete = true;
      }, "ruleDependencies");
      const show = /* @__PURE__ */ __name2((type = null) => {
        let i22 = 0;
        let j = 0;
        let count = 0;
        let startSeg = 0;
        const maxRule = state.ruleCount - 1;
        const maxUdt = state.udtCount - 1;
        const lineLength = 100;
        let str = "";
        let pre = "";
        const toArrow = "=> ";
        const byArrow = "<= ";
        let first2 = false;
        let rdi = null;
        let { ruleIndexes } = state;
        let { udtIndexes } = state;
        if (type === 97) {
          ruleIndexes = state.ruleAlphaIndexes;
          udtIndexes = state.udtAlphaIndexes;
        } else if (type === 116) {
          ruleIndexes = state.ruleTypeIndexes;
          udtIndexes = state.udtAlphaIndexes;
        }
        for (i22 = 0; i22 < state.ruleCount; i22 += 1) {
          rdi = state.ruleDeps[ruleIndexes[i22]];
          pre = `${ruleIndexes[i22]}:${state.typeToString(rdi.recursiveType)}:`;
          if (state.isMutuallyRecursive) {
            pre += rdi.groupNumber > -1 ? rdi.groupNumber : "-";
            pre += ":";
          }
          pre += " ";
          str += `${pre + state.rules[ruleIndexes[i22]].name}
`;
          first2 = true;
          count = 0;
          startSeg = str.length;
          str += pre;
          for (j = 0; j < state.ruleCount; j += 1) {
            if (rdi.refersTo[ruleIndexes[j]]) {
              if (first2) {
                str += toArrow;
                first2 = false;
                str += state.ruleDeps[ruleIndexes[j]].rule.name;
              } else {
                str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;
              }
              count += 1;
            }
            if (str.length - startSeg > lineLength && j !== maxRule) {
              str += `
${pre}${toArrow}`;
              startSeg = str.length;
            }
          }
          if (state.udtCount) {
            for (j = 0; j < state.udtCount; j += 1) {
              if (rdi.refersToUdt[udtIndexes[j]]) {
                if (first2) {
                  str += toArrow;
                  first2 = false;
                  str += state.udts[udtIndexes[j]].name;
                } else {
                  str += `, ${state.udts[udtIndexes[j]].name}`;
                }
                count += 1;
              }
              if (str.length - startSeg > lineLength && j !== maxUdt) {
                str += `
${pre}${toArrow}`;
                startSeg = str.length;
              }
            }
          }
          if (count === 0) {
            str += "=> <none>\n";
          }
          if (first2 === false) {
            str += "\n";
          }
          first2 = true;
          count = 0;
          startSeg = str.length;
          str += pre;
          for (j = 0; j < state.ruleCount; j += 1) {
            if (rdi.referencedBy[ruleIndexes[j]]) {
              if (first2) {
                str += byArrow;
                first2 = false;
                str += state.ruleDeps[ruleIndexes[j]].rule.name;
              } else {
                str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;
              }
              count += 1;
            }
            if (str.length - startSeg > lineLength && j !== maxRule) {
              str += `
${pre}${toArrow}`;
              startSeg = str.length;
            }
          }
          if (count === 0) {
            str += "<= <none>\n";
          }
          if (first2 === false) {
            str += "\n";
          }
          str += "\n";
        }
        return str;
      }, "show");
      const showRuleDependencies = /* @__PURE__ */ __name2((order = "index") => {
        let str = "RULE DEPENDENCIES(index:type:[group number:])\n";
        str += "=> refers to rule names\n";
        str += "<= referenced by rule names\n";
        if (!state.dependenciesComplete) {
          return str;
        }
        if (order.charCodeAt(0) === 97) {
          str += "alphabetical by rule name\n";
          str += show(97);
        } else if (order.charCodeAt(0) === 116) {
          str += "ordered by rule type\n";
          str += show(116);
        } else {
          str += "ordered by rule index\n";
          str += show(null);
        }
        return str;
      }, "showRuleDependencies");
      return { ruleDependencies, showRuleDependencies };
    })();
  }
});
var require_attributes = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/attributes.js"(exports, module2) {
    module2.exports = (/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exportAttributes() {
      const id2 = require_identifiers();
      const { ruleAttributes, showAttributes, showAttributeErrors } = require_rule_attributes();
      const { ruleDependencies, showRuleDependencies } = require_rule_dependencies();
      class State {
        constructor(rules, udts) {
          this.rules = rules;
          this.udts = udts;
          this.ruleCount = rules.length;
          this.udtCount = udts.length;
          this.startRule = 0;
          this.dependenciesComplete = false;
          this.attributesComplete = false;
          this.isMutuallyRecursive = false;
          this.ruleIndexes = this.indexArray(this.ruleCount);
          this.ruleAlphaIndexes = this.indexArray(this.ruleCount);
          this.ruleTypeIndexes = this.indexArray(this.ruleCount);
          this.udtIndexes = this.indexArray(this.udtCount);
          this.udtAlphaIndexes = this.indexArray(this.udtCount);
          this.attrsErrorCount = 0;
          this.attrs = [];
          this.attrsErrors = [];
          this.attrsWorking = [];
          this.ruleDeps = [];
          for (let i22 = 0; i22 < this.ruleCount; i22 += 1) {
            this.attrs.push(this.attrGen(this.rules[i22]));
            this.attrsWorking.push(this.attrGen(this.rules[i22]));
            this.ruleDeps.push(this.rdGen(rules[i22], this.ruleCount, this.udtCount));
          }
          this.compRulesAlpha = this.compRulesAlpha.bind(this);
          this.compUdtsAlpha = this.compUdtsAlpha.bind(this);
          this.compRulesType = this.compRulesType.bind(this);
          this.compRulesGroup = this.compRulesGroup.bind(this);
        }
        attrGen(rule) {
          return {
            left: false,
            nested: false,
            right: false,
            empty: false,
            finite: false,
            cyclic: false,
            leaf: false,
            isOpen: false,
            isComplete: false,
            rule
          };
        }
        attrInit(attr) {
          attr.left = false;
          attr.nested = false;
          attr.right = false;
          attr.empty = false;
          attr.finite = false;
          attr.cyclic = false;
          attr.leaf = false;
          attr.isOpen = false;
          attr.isComplete = false;
        }
        attrCopy(dst, src2) {
          dst.left = src2.left;
          dst.nested = src2.nested;
          dst.right = src2.right;
          dst.empty = src2.empty;
          dst.finite = src2.finite;
          dst.cyclic = src2.cyclic;
          dst.leaf = src2.leaf;
          dst.isOpen = src2.isOpen;
          dst.isComplete = src2.isComplete;
          dst.rule = src2.rule;
        }
        rdGen(rule, ruleCount, udtCount) {
          const ret = {
            rule,
            recursiveType: id2.ATTR_N,
            groupNumber: -1,
            refersTo: this.falseArray(ruleCount),
            refersToUdt: this.falseArray(udtCount),
            referencedBy: this.falseArray(ruleCount)
          };
          return ret;
        }
        typeToString(recursiveType) {
          switch (recursiveType) {
            case id2.ATTR_N:
              return " N";
            case id2.ATTR_R:
              return " R";
            case id2.ATTR_MR:
              return "MR";
            default:
              return "UNKNOWN";
          }
        }
        falseArray(length2) {
          const ret = [];
          if (length2 > 0) {
            for (let i22 = 0; i22 < length2; i22 += 1) {
              ret.push(false);
            }
          }
          return ret;
        }
        falsifyArray(a3) {
          for (let i22 = 0; i22 < a3.length; i22 += 1) {
            a3[i22] = false;
          }
        }
        indexArray(length2) {
          const ret = [];
          if (length2 > 0) {
            for (let i22 = 0; i22 < length2; i22 += 1) {
              ret.push(i22);
            }
          }
          return ret;
        }
        compRulesAlpha(left, right) {
          if (this.rules[left].lower < this.rules[right].lower) {
            return -1;
          }
          if (this.rules[left].lower > this.rules[right].lower) {
            return 1;
          }
          return 0;
        }
        compUdtsAlpha(left, right) {
          if (this.udts[left].lower < this.udts[right].lower) {
            return -1;
          }
          if (this.udts[left].lower > this.udts[right].lower) {
            return 1;
          }
          return 0;
        }
        compRulesType(left, right) {
          if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {
            return -1;
          }
          if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {
            return 1;
          }
          return 0;
        }
        compRulesGroup(left, right) {
          if (this.ruleDeps[left].recursiveType === id2.ATTR_MR && this.ruleDeps[right].recursiveType === id2.ATTR_MR) {
            if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {
              return -1;
            }
            if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {
              return 1;
            }
          }
          return 0;
        }
      }
      __name(State, "State");
      __name2(State, "State");
      const attributes = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function attributes2(rules = [], udts = [], lineMap = [], errors = []) {
        const state = new State(rules, udts);
        ruleDependencies(state);
        ruleAttributes(state);
        if (state.attrsErrorCount) {
          errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });
        }
        return state.attrsErrorCount;
      }, "attributes2"), "attributes");
      return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };
    }, "exportAttributes"), "exportAttributes"))();
  }
});
var require_show_rules = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/show-rules.js"(exports, module2) {
    module2.exports = (/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exfn() {
      const thisFileName = "show-rules.js";
      const showRules = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function showRules2(rulesIn = [], udtsIn = [], order = "index") {
        const thisFuncName = "showRules";
        let alphaArray = [];
        let udtAlphaArray = [];
        const indexArray = [];
        const udtIndexArray = [];
        const rules = rulesIn;
        const udts = udtsIn;
        const ruleCount = rulesIn.length;
        const udtCount = udtsIn.length;
        let str = "RULE/UDT NAMES";
        let i22;
        function compRulesAlpha(left, right) {
          if (rules[left].lower < rules[right].lower) {
            return -1;
          }
          if (rules[left].lower > rules[right].lower) {
            return 1;
          }
          return 0;
        }
        __name(compRulesAlpha, "compRulesAlpha");
        __name2(compRulesAlpha, "compRulesAlpha");
        function compUdtsAlpha(left, right) {
          if (udts[left].lower < udts[right].lower) {
            return -1;
          }
          if (udts[left].lower > udts[right].lower) {
            return 1;
          }
          return 0;
        }
        __name(compUdtsAlpha, "compUdtsAlpha");
        __name2(compUdtsAlpha, "compUdtsAlpha");
        if (!(Array.isArray(rulesIn) && rulesIn.length)) {
          throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);
        }
        if (!Array.isArray(udtsIn)) {
          throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);
        }
        for (i22 = 0; i22 < ruleCount; i22 += 1) {
          indexArray.push(i22);
        }
        alphaArray = indexArray.slice(0);
        alphaArray.sort(compRulesAlpha);
        if (udtCount) {
          for (i22 = 0; i22 < udtCount; i22 += 1) {
            udtIndexArray.push(i22);
          }
          udtAlphaArray = udtIndexArray.slice(0);
          udtAlphaArray.sort(compUdtsAlpha);
        }
        if (order.charCodeAt(0) === 97) {
          str += " - alphabetical by rule/UDT name\n";
          for (i22 = 0; i22 < ruleCount; i22 += 1) {
            str += `${i22}: ${alphaArray[i22]}: ${rules[alphaArray[i22]].name}
`;
          }
          if (udtCount) {
            for (i22 = 0; i22 < udtCount; i22 += 1) {
              str += `${i22}: ${udtAlphaArray[i22]}: ${udts[udtAlphaArray[i22]].name}
`;
            }
          }
        } else {
          str += " - ordered by rule/UDT index\n";
          for (i22 = 0; i22 < ruleCount; i22 += 1) {
            str += `${i22}: ${rules[i22].name}
`;
          }
          if (udtCount) {
            for (i22 = 0; i22 < udtCount; i22 += 1) {
              str += `${i22}: ${udts[i22].name}
`;
            }
          }
        }
        return str;
      }, "showRules2"), "showRules");
      return showRules;
    }, "exfn"), "exfn"))();
  }
});
var require_api = __commonJS2({
  "../../node_modules/.pnpm/apg-js@4.1.3/node_modules/apg-js/src/apg-api/api.js"(exports, module2) {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function api(src2) {
      const thisFileName = "api.js: ";
      const thisObject = this;
      const apglib = require_node_exports();
      const converter = require_converter();
      const scanner = require_scanner();
      const parser = new (require_parser2())();
      const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = require_attributes();
      const showRules = require_show_rules();
      const abnfToHtml = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function abnfToHtml2(chars, beg, len) {
        const NORMAL = 0;
        const CONTROL = 1;
        const INVALID2 = 2;
        const CONTROL_BEG = `<span class="${apglib.style.CLASS_CTRLCHAR}">`;
        const CONTROL_END = "</span>";
        const INVALID_BEG = `<span class="${apglib.style.CLASS_NOMATCH}">`;
        const INVALID_END = "</span>";
        let end;
        let html = "";
        const TRUE = true;
        while (TRUE) {
          if (!Array.isArray(chars) || chars.length === 0) {
            break;
          }
          if (typeof beg !== "number") {
            throw new Error("abnfToHtml: beg must be type number");
          }
          if (beg >= chars.length) {
            break;
          }
          if (typeof len !== "number" || beg + len >= chars.length) {
            end = chars.length;
          } else {
            end = beg + len;
          }
          let state = NORMAL;
          for (let i22 = beg; i22 < end; i22 += 1) {
            const ch = chars[i22];
            if (ch >= 32 && ch <= 126) {
              if (state === CONTROL) {
                html += CONTROL_END;
                state = NORMAL;
              } else if (state === INVALID2) {
                html += INVALID_END;
                state = NORMAL;
              }
              switch (ch) {
                case 32:
                  html += "&nbsp;";
                  break;
                case 60:
                  html += "&lt;";
                  break;
                case 62:
                  html += "&gt;";
                  break;
                case 38:
                  html += "&amp;";
                  break;
                case 34:
                  html += "&quot;";
                  break;
                case 39:
                  html += "&#039;";
                  break;
                case 92:
                  html += "&#092;";
                  break;
                default:
                  html += String.fromCharCode(ch);
                  break;
              }
            } else if (ch === 9 || ch === 10 || ch === 13) {
              if (state === NORMAL) {
                html += CONTROL_BEG;
                state = CONTROL;
              } else if (state === INVALID2) {
                html += INVALID_END + CONTROL_BEG;
                state = CONTROL;
              }
              if (ch === 9) {
                html += "TAB";
              }
              if (ch === 10) {
                html += "LF";
              }
              if (ch === 13) {
                html += "CR";
              }
            } else {
              if (state === NORMAL) {
                html += INVALID_BEG;
                state = INVALID2;
              } else if (state === CONTROL) {
                html += CONTROL_END + INVALID_BEG;
                state = INVALID2;
              }
              html += `\\x${apglib.utils.charToHex(ch)}`;
            }
          }
          if (state === INVALID2) {
            html += INVALID_END;
          }
          if (state === CONTROL) {
            html += CONTROL_END;
          }
          break;
        }
        return html;
      }, "abnfToHtml2"), "abnfToHtml");
      const abnfToAscii = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function abnfToAscii2(chars, beg, len) {
        let str = "";
        for (let i22 = beg; i22 < beg + len; i22 += 1) {
          const ch = chars[i22];
          if (ch >= 32 && ch <= 126) {
            str += String.fromCharCode(ch);
          } else {
            switch (ch) {
              case 9:
                str += "\\t";
                break;
              case 10:
                str += "\\n";
                break;
              case 13:
                str += "\\r";
                break;
              default:
                str += "\\unknown";
                break;
            }
          }
        }
        return str;
      }, "abnfToAscii2"), "abnfToAscii");
      const linesToAscii = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function linesToAscii2(lines) {
        let str = "Annotated Input Grammar";
        lines.forEach((val) => {
          str += "\n";
          str += `line no: ${val.lineNo}`;
          str += ` : char index: ${val.beginChar}`;
          str += ` : length: ${val.length}`;
          str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;
        });
        str += "\n";
        return str;
      }, "linesToAscii2"), "linesToAscii");
      const linesToHtml = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function linesToHtml2(lines) {
        let html = "";
        html += `<table class="${apglib.style.CLASS_GRAMMAR}">
`;
        const title = "Annotated Input Grammar";
        html += `<caption>${title}</caption>
`;
        html += "<tr>";
        html += "<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>";
        html += "</tr>\n";
        lines.forEach((val) => {
          html += "<tr>";
          html += `<td>${val.lineNo}`;
          html += `</td><td>${val.beginChar}`;
          html += `</td><td>${val.length}`;
          html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;
          html += "</td>";
          html += "</tr>\n";
        });
        html += "</table>\n";
        return html;
      }, "linesToHtml2"), "linesToHtml");
      const errorsToHtml = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function errorsToHtml2(errors, lines, chars, title) {
        const [style] = apglib;
        let html = "";
        const errorArrow = `<span class="${style.CLASS_NOMATCH}">&raquo;</span>`;
        html += `<p><table class="${style.CLASS_GRAMMAR}">
`;
        if (title && typeof title === "string") {
          html += `<caption>${title}</caption>
`;
        }
        html += "<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\n";
        errors.forEach((val) => {
          let line;
          let relchar;
          let beg;
          let end;
          let text;
          let prefix = "";
          let suffix = "";
          if (lines.length === 0) {
            text = errorArrow;
            relchar = 0;
          } else {
            line = lines[val.line];
            beg = line.beginChar;
            if (val.char > beg) {
              prefix = abnfToHtml(chars, beg, val.char - beg);
            }
            beg = val.char;
            end = line.beginChar + line.length;
            if (beg < end) {
              suffix = abnfToHtml(chars, beg, end - beg);
            }
            text = prefix + errorArrow + suffix;
            relchar = val.char - line.beginChar;
            html += "<tr>";
            html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;
            html += "</tr>\n";
            html += "<tr>";
            html += `<td colspan="3"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;
            html += "</tr>\n";
          }
        });
        html += "</table></p>\n";
        return html;
      }, "errorsToHtml2"), "errorsToHtml");
      const errorsToAscii = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function errorsToAscii2(errors, lines, chars) {
        let str;
        let line;
        let beg;
        let len;
        str = "";
        errors.forEach((error) => {
          line = lines[error.line];
          str += `${line.lineNo}: `;
          str += `${line.beginChar}: `;
          str += `${error.char - line.beginChar}: `;
          beg = line.beginChar;
          len = error.char - line.beginChar;
          str += abnfToAscii(chars, beg, len);
          str += " >> ";
          beg = error.char;
          len = line.beginChar + line.length - error.char;
          str += abnfToAscii(chars, beg, len);
          str += "\n";
          str += `${line.lineNo}: `;
          str += `${line.beginChar}: `;
          str += `${error.char - line.beginChar}: `;
          str += "error: ";
          str += error.msg;
          str += "\n";
        });
        return str;
      }, "errorsToAscii2"), "errorsToAscii");
      let isScanned = false;
      let isParsed = false;
      let isTranslated = false;
      let haveAttributes = false;
      let attributeErrors = 0;
      let lineMap;
      this.errors = [];
      if (Buffer.isBuffer(src2)) {
        this.chars = converter.decode("BINARY", src2);
      } else if (Array.isArray(src2)) {
        this.chars = src2.slice();
      } else if (typeof src2 === "string") {
        this.chars = converter.decode("STRING", src2);
      } else {
        throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);
      }
      this.sabnf = converter.encode("STRING", this.chars);
      this.scan = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function scan(strict, trace) {
        this.lines = scanner(this.chars, this.errors, strict, trace);
        isScanned = true;
      }, "scan"), "scan");
      this.parse = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parse3(strict, trace) {
        if (!isScanned) {
          throw new Error(`${thisFileName}grammar not scanned`);
        }
        parser.syntax(this.chars, this.lines, this.errors, strict, trace);
        isParsed = true;
      }, "parse3"), "parse");
      this.translate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function translate() {
        if (!isParsed) {
          throw new Error(`${thisFileName}grammar not scanned and parsed`);
        }
        const ret = parser.semantic(this.chars, this.lines, this.errors);
        if (this.errors.length === 0) {
          this.rules = ret.rules;
          this.udts = ret.udts;
          lineMap = ret.lineMap;
          isTranslated = true;
        }
      }, "translate"), "translate");
      this.attributes = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function attrs() {
        if (!isTranslated) {
          throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);
        }
        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);
        haveAttributes = true;
        return attributeErrors;
      }, "attrs"), "attrs");
      this.generate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function generate3(strict) {
        this.lines = scanner(this.chars, this.errors, strict);
        if (this.errors.length) {
          return;
        }
        parser.syntax(this.chars, this.lines, this.errors, strict);
        if (this.errors.length) {
          return;
        }
        const ret = parser.semantic(this.chars, this.lines, this.errors);
        if (this.errors.length) {
          return;
        }
        this.rules = ret.rules;
        this.udts = ret.udts;
        lineMap = ret.lineMap;
        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);
        haveAttributes = true;
      }, "generate3"), "generate");
      this.displayRules = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function displayRules(order = "index") {
        if (!isTranslated) {
          throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);
        }
        return showRules(this.rules, this.udts, order);
      }, "displayRules"), "displayRules");
      this.displayRuleDependencies = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function displayRuleDependencies(order = "index") {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        return showRuleDependencies(order);
      }, "displayRuleDependencies"), "displayRuleDependencies");
      this.displayAttributes = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function displayAttributes(order = "index") {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          showAttributeErrors(order);
        }
        return showAttributes(order);
      }, "displayAttributes"), "displayAttributes");
      this.displayAttributeErrors = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function displayAttributeErrors() {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        return showAttributeErrors();
      }, "displayAttributeErrors"), "displayAttributeErrors");
      this.toSource = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toSource(name3) {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);
        }
        return parser.generateSource(this.chars, this.lines, this.rules, this.udts, name3);
      }, "toSource"), "toSource");
      this.toObject = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toObject() {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);
        }
        return parser.generateObject(this.sabnf, this.rules, this.udts);
      }, "toObject"), "toObject");
      this.errorsToAscii = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function errorsToAsciiFunc() {
        return errorsToAscii(this.errors, this.lines, this.chars);
      }, "errorsToAsciiFunc"), "errorsToAsciiFunc");
      this.errorsToHtml = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function errorsToHtmlFunc(title) {
        return errorsToHtml(this.errors, this.lines, this.chars, title);
      }, "errorsToHtmlFunc"), "errorsToHtmlFunc");
      this.linesToAscii = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function linesToAsciiFunc() {
        return linesToAscii(this.lines);
      }, "linesToAsciiFunc"), "linesToAsciiFunc");
      this.linesToHtml = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function linesToHtmlFunc() {
        return linesToHtml(this.lines);
      }, "linesToHtmlFunc"), "linesToHtmlFunc");
    }, "api"), "api");
  }
});
var require_bn22 = __commonJS2({
  "../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js"(exports, module2) {
    (function(module3, exports2) {
      "use strict";
      function assert22(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      __name(assert22, "assert2");
      __name2(assert22, "assert");
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = /* @__PURE__ */ __name2(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      __name(inherits, "inherits");
      __name2(inherits, "inherits");
      function BN32(number, base4, endian) {
        if (BN32.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base4 === "le" || base4 === "be") {
            endian = base4;
            base4 = 10;
          }
          this._init(number || 0, base4 || 10, endian || "be");
        }
      }
      __name(BN32, "BN3");
      __name2(BN32, "BN");
      if (typeof module3 === "object") {
        module3.exports = BN32;
      } else {
        exports2.BN = BN32;
      }
      BN32.BN = BN32;
      BN32.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer2().Buffer;
        }
      } catch (e2) {
      }
      BN32.isBN = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isBN(num) {
        if (num instanceof BN32) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN32.wordSize && Array.isArray(num.words);
      }, "isBN"), "isBN");
      BN32.max = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, "max"), "max");
      BN32.min = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, "min"), "min");
      BN32.prototype._init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init4(number, base4, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base4, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base4, endian);
        }
        if (base4 === "hex") {
          base4 = 16;
        }
        assert22(base4 === (base4 | 0) && base4 >= 2 && base4 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base4 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base4, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base4, endian);
            }
          }
        }
      }, "init4"), "init");
      BN32.prototype._initNumber = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _initNumber(number, base4, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert22(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base4, endian);
      }, "_initNumber"), "_initNumber");
      BN32.prototype._initArray = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _initArray(number, base4, endian) {
        assert22(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i22 = 0; i22 < this.length; i22++) {
          this.words[i22] = 0;
        }
        var j, w2;
        var off = 0;
        if (endian === "be") {
          for (i22 = number.length - 1, j = 0; i22 >= 0; i22 -= 3) {
            w2 = number[i22] | number[i22 - 1] << 8 | number[i22 - 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i22 = 0, j = 0; i22 < number.length; i22 += 3) {
            w2 = number[i22] | number[i22 + 1] << 8 | number[i22 + 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      }, "_initArray"), "_initArray");
      function parseHex4Bits(string2, index) {
        var c2 = string2.charCodeAt(index);
        if (c2 >= 48 && c2 <= 57) {
          return c2 - 48;
        } else if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          assert22(false, "Invalid character in " + string2);
        }
      }
      __name(parseHex4Bits, "parseHex4Bits");
      __name2(parseHex4Bits, "parseHex4Bits");
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      __name(parseHexByte, "parseHexByte");
      __name2(parseHexByte, "parseHexByte");
      BN32.prototype._parseHex = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i22 = 0; i22 < this.length; i22++) {
          this.words[i22] = 0;
        }
        var off = 0;
        var j = 0;
        var w2;
        if (endian === "be") {
          for (i22 = number.length - 1; i22 >= start; i22 -= 2) {
            w2 = parseHexByte(number, start, i22) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i22 = parseLength % 2 === 0 ? start + 1 : start; i22 < number.length; i22 += 2) {
            w2 = parseHexByte(number, start, i22) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      }, "_parseHex"), "_parseHex");
      function parseBase(str, start, end, mul32) {
        var r2 = 0;
        var b2 = 0;
        var len = Math.min(str.length, end);
        for (var i22 = start; i22 < len; i22++) {
          var c2 = str.charCodeAt(i22) - 48;
          r2 *= mul32;
          if (c2 >= 49) {
            b2 = c2 - 49 + 10;
          } else if (c2 >= 17) {
            b2 = c2 - 17 + 10;
          } else {
            b2 = c2;
          }
          assert22(c2 >= 0 && b2 < mul32, "Invalid character");
          r2 += b2;
        }
        return r2;
      }
      __name(parseBase, "parseBase");
      __name2(parseBase, "parseBase");
      BN32.prototype._parseBase = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _parseBase(number, base4, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base4) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base4 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i22 = start; i22 < end; i22 += limbLen) {
          word = parseBase(number, i22, i22 + limbLen, base4);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i22, number.length, base4);
          for (i22 = 0; i22 < mod2; i22++) {
            pow *= base4;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      }, "_parseBase"), "_parseBase");
      BN32.prototype.copy = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function copy(dest) {
        dest.words = new Array(this.length);
        for (var i22 = 0; i22 < this.length; i22++) {
          dest.words[i22] = this.words[i22];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      }, "copy"), "copy");
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      __name(move, "move");
      __name2(move, "move");
      BN32.prototype._move = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _move(dest) {
        move(dest, this);
      }, "_move"), "_move");
      BN32.prototype.clone = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function clone() {
        var r2 = new BN32(null);
        this.copy(r2);
        return r2;
      }, "clone"), "clone");
      BN32.prototype._expand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      }, "_expand"), "_expand");
      BN32.prototype._strip = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      }, "strip"), "strip");
      BN32.prototype._normSign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      }, "_normSign"), "_normSign");
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN32.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect5;
        } catch (e2) {
          BN32.prototype.inspect = inspect5;
        }
      } else {
        BN32.prototype.inspect = inspect5;
      }
      function inspect5() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      __name(inspect5, "inspect5");
      __name2(inspect5, "inspect");
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN32.prototype.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6(base4, padding2) {
        base4 = base4 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base4 === 16 || base4 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i22 = 0; i22 < this.length; i22++) {
            var w2 = this.words[i22];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i22--;
            }
            if (carry !== 0 || i22 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base4 === (base4 | 0) && base4 >= 2 && base4 <= 36) {
          var groupSize = groupSizes[base4];
          var groupBase = groupBases[base4];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modrn(groupBase).toString(base4);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert22(false, "Base should be between 2 and 36");
      }, "toString6"), "toString");
      BN32.prototype.toNumber = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert22(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      }, "toNumber"), "toNumber");
      BN32.prototype.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
        return this.toString(16, 2);
      }, "toJSON2"), "toJSON");
      if (Buffer3) {
        BN32.prototype.toBuffer = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toBuffer(endian, length2) {
          return this.toArrayLike(Buffer3, endian, length2);
        }, "toBuffer"), "toBuffer");
      }
      BN32.prototype.toArray = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      }, "toArray"), "toArray");
      var allocate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      }, "allocate2"), "allocate");
      BN32.prototype.toArrayLike = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert22(byteLength <= reqLength, "byte array longer than desired length");
        assert22(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      }, "toArrayLike"), "toArrayLike");
      BN32.prototype._toArrayLikeLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i22 = 0, shift = 0; i22 < this.length; i22++) {
          var word = this.words[i22] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      }, "_toArrayLikeLE"), "_toArrayLikeLE");
      BN32.prototype._toArrayLikeBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i22 = 0, shift = 0; i22 < this.length; i22++) {
          var word = this.words[i22] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      }, "_toArrayLikeBE"), "_toArrayLikeBE");
      if (Math.clz32) {
        BN32.prototype._countBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _countBits(w2) {
          return 32 - Math.clz32(w2);
        }, "_countBits"), "_countBits");
      } else {
        BN32.prototype._countBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _countBits(w2) {
          var t2 = w2;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        }, "_countBits"), "_countBits");
      }
      BN32.prototype._zeroBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _zeroBits(w2) {
        if (w2 === 0)
          return 26;
        var t2 = w2;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      }, "_zeroBits"), "_zeroBits");
      BN32.prototype.bitLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      }, "bitLength"), "bitLength");
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = num.words[off] >>> wbit & 1;
        }
        return w2;
      }
      __name(toBitArray, "toBitArray");
      __name2(toBitArray, "toBitArray");
      BN32.prototype.zeroBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i22 = 0; i22 < this.length; i22++) {
          var b2 = this._zeroBits(this.words[i22]);
          r2 += b2;
          if (b2 !== 26)
            break;
        }
        return r2;
      }, "zeroBits"), "zeroBits");
      BN32.prototype.byteLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, "byteLength"), "byteLength");
      BN32.prototype.toTwos = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      }, "toTwos"), "toTwos");
      BN32.prototype.fromTwos = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      }, "fromTwos"), "fromTwos");
      BN32.prototype.isNeg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isNeg() {
        return this.negative !== 0;
      }, "isNeg"), "isNeg");
      BN32.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg32() {
        return this.clone().ineg();
      }, "neg3"), "neg");
      BN32.prototype.ineg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      }, "ineg"), "ineg");
      BN32.prototype.iuor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i22 = 0; i22 < num.length; i22++) {
          this.words[i22] = this.words[i22] | num.words[i22];
        }
        return this._strip();
      }, "iuor"), "iuor");
      BN32.prototype.ior = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ior(num) {
        assert22((this.negative | num.negative) === 0);
        return this.iuor(num);
      }, "ior"), "ior");
      BN32.prototype.or = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, "or2"), "or");
      BN32.prototype.uor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, "uor"), "uor");
      BN32.prototype.iuand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i22 = 0; i22 < b2.length; i22++) {
          this.words[i22] = this.words[i22] & num.words[i22];
        }
        this.length = b2.length;
        return this._strip();
      }, "iuand"), "iuand");
      BN32.prototype.iand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iand(num) {
        assert22((this.negative | num.negative) === 0);
        return this.iuand(num);
      }, "iand"), "iand");
      BN32.prototype.and = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, "and"), "and");
      BN32.prototype.uand = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, "uand"), "uand");
      BN32.prototype.iuxor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iuxor(num) {
        var a3;
        var b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        for (var i22 = 0; i22 < b2.length; i22++) {
          this.words[i22] = a3.words[i22] ^ b2.words[i22];
        }
        if (this !== a3) {
          for (; i22 < a3.length; i22++) {
            this.words[i22] = a3.words[i22];
          }
        }
        this.length = a3.length;
        return this._strip();
      }, "iuxor"), "iuxor");
      BN32.prototype.ixor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ixor(num) {
        assert22((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }, "ixor"), "ixor");
      BN32.prototype.xor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, "xor2"), "xor");
      BN32.prototype.uxor = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, "uxor"), "uxor");
      BN32.prototype.inotn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inotn(width) {
        assert22(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i22 = 0; i22 < bytesNeeded; i22++) {
          this.words[i22] = ~this.words[i22] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i22] = ~this.words[i22] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      }, "inotn"), "inotn");
      BN32.prototype.notn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function notn(width) {
        return this.clone().inotn(width);
      }, "notn"), "notn");
      BN32.prototype.setn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function setn(bit, val) {
        assert22(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      }, "setn"), "setn");
      BN32.prototype.iadd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a3, b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i22 = 0; i22 < b2.length; i22++) {
          r2 = (a3.words[i22] | 0) + (b2.words[i22] | 0) + carry;
          this.words[i22] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i22 < a3.length; i22++) {
          r2 = (a3.words[i22] | 0) + carry;
          this.words[i22] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i22 < a3.length; i22++) {
            this.words[i22] = a3.words[i22];
          }
        }
        return this;
      }, "iadd"), "iadd");
      BN32.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, "add3"), "add");
      BN32.prototype.isub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b2;
        if (cmp > 0) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i22 = 0; i22 < b2.length; i22++) {
          r2 = (a3.words[i22] | 0) - (b2.words[i22] | 0) + carry;
          carry = r2 >> 26;
          this.words[i22] = r2 & 67108863;
        }
        for (; carry !== 0 && i22 < a3.length; i22++) {
          r2 = (a3.words[i22] | 0) + carry;
          carry = r2 >> 26;
          this.words[i22] = r2 & 67108863;
        }
        if (carry === 0 && i22 < a3.length && a3 !== this) {
          for (; i22 < a3.length; i22++) {
            this.words[i22] = a3.words[i22];
          }
        }
        this.length = Math.max(this.length, i22);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this._strip();
      }, "isub"), "isub");
      BN32.prototype.sub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sub(num) {
        return this.clone().isub(num);
      }, "sub"), "sub");
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a3 * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i22 = k2 - j | 0;
            a3 = self2.words[i22] | 0;
            b2 = num.words[j] | 0;
            r2 = a3 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      __name(smallMulTo, "smallMulTo");
      __name2(smallMulTo, "smallMulTo");
      var comb10MulTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c2 !== 0) {
          o[19] = c2;
          out.length++;
        }
        return out;
      }, "comb10MulTo2"), "comb10MulTo");
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i22 = k2 - j;
            var a3 = self2.words[i22] | 0;
            var b2 = num.words[j] | 0;
            var r2 = a3 * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      __name(bigMulTo, "bigMulTo");
      __name2(bigMulTo, "bigMulTo");
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      __name(jumboMulTo, "jumboMulTo");
      __name2(jumboMulTo, "jumboMulTo");
      BN32.prototype.mulTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      }, "mulTo"), "mulTo");
      function FFTM(x2, y3) {
        this.x = x2;
        this.y = y3;
      }
      __name(FFTM, "FFTM");
      __name2(FFTM, "FFTM");
      FFTM.prototype.makeRBT = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function makeRBT(N10) {
        var t2 = new Array(N10);
        var l = BN32.prototype._countBits(N10) - 1;
        for (var i22 = 0; i22 < N10; i22++) {
          t2[i22] = this.revBin(i22, l, N10);
        }
        return t2;
      }, "makeRBT"), "makeRBT");
      FFTM.prototype.revBin = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function revBin(x2, l, N10) {
        if (x2 === 0 || x2 === N10 - 1)
          return x2;
        var rb = 0;
        for (var i22 = 0; i22 < l; i22++) {
          rb |= (x2 & 1) << l - i22 - 1;
          x2 >>= 1;
        }
        return rb;
      }, "revBin"), "revBin");
      FFTM.prototype.permute = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function permute(rbt, rws, iws, rtws, itws, N10) {
        for (var i22 = 0; i22 < N10; i22++) {
          rtws[i22] = rws[rbt[i22]];
          itws[i22] = iws[rbt[i22]];
        }
      }, "permute"), "permute");
      FFTM.prototype.transform = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function transform(rws, iws, rtws, itws, N10, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N10);
        for (var s3 = 1; s3 < N10; s3 <<= 1) {
          var l = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N10; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s3; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s3];
              var io = itws[p + j + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s3] = re - ro;
              itws[p + j + s3] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      }, "transform"), "transform");
      FFTM.prototype.guessLen13b = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function guessLen13b(n, m3) {
        var N10 = Math.max(m3, n) | 1;
        var odd = N10 & 1;
        var i22 = 0;
        for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
          i22++;
        }
        return 1 << i22 + 1 + odd;
      }, "guessLen13b"), "guessLen13b");
      FFTM.prototype.conjugate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function conjugate(rws, iws, N10) {
        if (N10 <= 1)
          return;
        for (var i22 = 0; i22 < N10 / 2; i22++) {
          var t2 = rws[i22];
          rws[i22] = rws[N10 - i22 - 1];
          rws[N10 - i22 - 1] = t2;
          t2 = iws[i22];
          iws[i22] = -iws[N10 - i22 - 1];
          iws[N10 - i22 - 1] = -t2;
        }
      }, "conjugate"), "conjugate");
      FFTM.prototype.normalize13b = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function normalize13b(ws, N10) {
        var carry = 0;
        for (var i22 = 0; i22 < N10 / 2; i22++) {
          var w2 = Math.round(ws[2 * i22 + 1] / N10) * 8192 + Math.round(ws[2 * i22] / N10) + carry;
          ws[i22] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      }, "normalize13b"), "normalize13b");
      FFTM.prototype.convert13b = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convert13b(ws, len, rws, N10) {
        var carry = 0;
        for (var i22 = 0; i22 < len; i22++) {
          carry = carry + (ws[i22] | 0);
          rws[2 * i22] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i22 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i22 = 2 * len; i22 < N10; ++i22) {
          rws[i22] = 0;
        }
        assert22(carry === 0);
        assert22((carry & ~8191) === 0);
      }, "convert13b"), "convert13b");
      FFTM.prototype.stub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function stub(N10) {
        var ph = new Array(N10);
        for (var i22 = 0; i22 < N10; i22++) {
          ph[i22] = 0;
        }
        return ph;
      }, "stub"), "stub");
      FFTM.prototype.mulp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulp(x2, y3, out) {
        var N10 = 2 * this.guessLen13b(x2.length, y3.length);
        var rbt = this.makeRBT(N10);
        var _2 = this.stub(N10);
        var rws = new Array(N10);
        var rwst = new Array(N10);
        var iwst = new Array(N10);
        var nrws = new Array(N10);
        var nrwst = new Array(N10);
        var niwst = new Array(N10);
        var rmws = out.words;
        rmws.length = N10;
        this.convert13b(x2.words, x2.length, rws, N10);
        this.convert13b(y3.words, y3.length, nrws, N10);
        this.transform(rws, _2, rwst, iwst, N10, rbt);
        this.transform(nrws, _2, nrwst, niwst, N10, rbt);
        for (var i22 = 0; i22 < N10; i22++) {
          var rx = rwst[i22] * nrwst[i22] - iwst[i22] * niwst[i22];
          iwst[i22] = rwst[i22] * niwst[i22] + iwst[i22] * nrwst[i22];
          rwst[i22] = rx;
        }
        this.conjugate(rwst, iwst, N10);
        this.transform(rwst, iwst, rmws, _2, N10, rbt);
        this.conjugate(rmws, _2, N10);
        this.normalize13b(rmws, N10);
        out.negative = x2.negative ^ y3.negative;
        out.length = x2.length + y3.length;
        return out._strip();
      }, "mulp"), "mulp");
      BN32.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(num) {
        var out = new BN32(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }, "mul3"), "mul");
      BN32.prototype.mulf = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulf(num) {
        var out = new BN32(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }, "mulf"), "mulf");
      BN32.prototype.imul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imul(num) {
        return this.clone().mulTo(num, this);
      }, "imul"), "imul");
      BN32.prototype.imuln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert22(typeof num === "number");
        assert22(num < 67108864);
        var carry = 0;
        for (var i22 = 0; i22 < this.length; i22++) {
          var w2 = (this.words[i22] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i22] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i22] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      }, "imuln"), "imuln");
      BN32.prototype.muln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function muln(num) {
        return this.clone().imuln(num);
      }, "muln"), "muln");
      BN32.prototype.sqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqr() {
        return this.mul(this);
      }, "sqr"), "sqr");
      BN32.prototype.isqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isqr() {
        return this.imul(this.clone());
      }, "isqr"), "isqr");
      BN32.prototype.pow = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0)
          return new BN32(1);
        var res = this;
        for (var i22 = 0; i22 < w2.length; i22++, res = res.sqr()) {
          if (w2[i22] !== 0)
            break;
        }
        if (++i22 < w2.length) {
          for (var q2 = res.sqr(); i22 < w2.length; i22++, q2 = q2.sqr()) {
            if (w2[i22] === 0)
              continue;
            res = res.mul(q2);
          }
        }
        return res;
      }, "pow"), "pow");
      BN32.prototype.iushln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iushln(bits) {
        assert22(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s3 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i22;
        if (r2 !== 0) {
          var carry = 0;
          for (i22 = 0; i22 < this.length; i22++) {
            var newCarry = this.words[i22] & carryMask;
            var c2 = (this.words[i22] | 0) - newCarry << r2;
            this.words[i22] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i22] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i22 = this.length - 1; i22 >= 0; i22--) {
            this.words[i22 + s3] = this.words[i22];
          }
          for (i22 = 0; i22 < s3; i22++) {
            this.words[i22] = 0;
          }
          this.length += s3;
        }
        return this._strip();
      }, "iushln"), "iushln");
      BN32.prototype.ishln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ishln(bits) {
        assert22(this.negative === 0);
        return this.iushln(bits);
      }, "ishln"), "ishln");
      BN32.prototype.iushrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iushrn(bits, hint, extended) {
        assert22(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r2 = bits % 26;
        var s3 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h3 -= s3;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i22 = 0; i22 < s3; i22++) {
            maskedWords.words[i22] = this.words[i22];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i22 = 0; i22 < this.length; i22++) {
            this.words[i22] = this.words[i22 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i22 = this.length - 1; i22 >= 0 && (carry !== 0 || i22 >= h3); i22--) {
          var word = this.words[i22] | 0;
          this.words[i22] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      }, "iushrn"), "iushrn");
      BN32.prototype.ishrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ishrn(bits, hint, extended) {
        assert22(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }, "ishrn"), "ishrn");
      BN32.prototype.shln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function shln(bits) {
        return this.clone().ishln(bits);
      }, "shln"), "shln");
      BN32.prototype.ushln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ushln(bits) {
        return this.clone().iushln(bits);
      }, "ushln"), "ushln");
      BN32.prototype.shrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function shrn(bits) {
        return this.clone().ishrn(bits);
      }, "shrn"), "shrn");
      BN32.prototype.ushrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, "ushrn"), "ushrn");
      BN32.prototype.testn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function testn(bit) {
        assert22(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s3 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s3)
          return false;
        var w2 = this.words[s3];
        return !!(w2 & q2);
      }, "testn"), "testn");
      BN32.prototype.imaskn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imaskn(bits) {
        assert22(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s3 = (bits - r2) / 26;
        assert22(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r2 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      }, "imaskn"), "imaskn");
      BN32.prototype.maskn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function maskn(bits) {
        return this.clone().imaskn(bits);
      }, "maskn"), "maskn");
      BN32.prototype.iaddn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iaddn(num) {
        assert22(typeof num === "number");
        assert22(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      }, "iaddn"), "iaddn");
      BN32.prototype._iaddn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _iaddn(num) {
        this.words[0] += num;
        for (var i22 = 0; i22 < this.length && this.words[i22] >= 67108864; i22++) {
          this.words[i22] -= 67108864;
          if (i22 === this.length - 1) {
            this.words[i22 + 1] = 1;
          } else {
            this.words[i22 + 1]++;
          }
        }
        this.length = Math.max(this.length, i22 + 1);
        return this;
      }, "_iaddn"), "_iaddn");
      BN32.prototype.isubn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isubn(num) {
        assert22(typeof num === "number");
        assert22(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i22 = 0; i22 < this.length && this.words[i22] < 0; i22++) {
            this.words[i22] += 67108864;
            this.words[i22 + 1] -= 1;
          }
        }
        return this._strip();
      }, "isubn"), "isubn");
      BN32.prototype.addn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function addn(num) {
        return this.clone().iaddn(num);
      }, "addn"), "addn");
      BN32.prototype.subn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function subn(num) {
        return this.clone().isubn(num);
      }, "subn"), "subn");
      BN32.prototype.iabs = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iabs() {
        this.negative = 0;
        return this;
      }, "iabs"), "iabs");
      BN32.prototype.abs = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function abs2() {
        return this.clone().iabs();
      }, "abs2"), "abs");
      BN32.prototype._ishlnsubmul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _ishlnsubmul(num, mul32, shift) {
        var len = num.length + shift;
        var i22;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i22 = 0; i22 < num.length; i22++) {
          w2 = (this.words[i22 + shift] | 0) + carry;
          var right = (num.words[i22] | 0) * mul32;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i22 + shift] = w2 & 67108863;
        }
        for (; i22 < this.length - shift; i22++) {
          w2 = (this.words[i22 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i22 + shift] = w2 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert22(carry === -1);
        carry = 0;
        for (i22 = 0; i22 < this.length; i22++) {
          w2 = -(this.words[i22] | 0) + carry;
          carry = w2 >> 26;
          this.words[i22] = w2 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      }, "_ishlnsubmul"), "_ishlnsubmul");
      BN32.prototype._wordDiv = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a3.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m3 = a3.length - b2.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN32(null);
          q2.length = m3 + 1;
          q2.words = new Array(q2.length);
          for (var i22 = 0; i22 < q2.length; i22++) {
            q2.words[i22] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b2, 1, m3);
        if (diff.negative === 0) {
          a3 = diff;
          if (q2) {
            q2.words[m3] = 1;
          }
        }
        for (var j = m3 - 1; j >= 0; j--) {
          var qj = (a3.words[b2.length + j] | 0) * 67108864 + (a3.words[b2.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b2, qj, j);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b2, 1, j);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j] = qj;
          }
        }
        if (q2) {
          q2._strip();
        }
        a3._strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a3
        };
      }, "_wordDiv"), "_wordDiv");
      BN32.prototype.divmod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function divmod(num, mode, positive) {
        assert22(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN32(0),
            mod: new BN32(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN32(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN32(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN32(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      }, "divmod"), "divmod");
      BN32.prototype.div = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function div(num) {
        return this.divmod(num, "div", false).div;
      }, "div"), "div");
      BN32.prototype.mod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      }, "mod2"), "mod");
      BN32.prototype.umod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, "umod"), "umod");
      BN32.prototype.divRound = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, "divRound"), "divRound");
      BN32.prototype.modrn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert22(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i22 = this.length - 1; i22 >= 0; i22--) {
          acc = (p * acc + (this.words[i22] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      }, "modrn"), "modrn");
      BN32.prototype.modn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function modn(num) {
        return this.modrn(num);
      }, "modn"), "modn");
      BN32.prototype.idivn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert22(num <= 67108863);
        var carry = 0;
        for (var i22 = this.length - 1; i22 >= 0; i22--) {
          var w2 = (this.words[i22] | 0) + carry * 67108864;
          this.words[i22] = w2 / num | 0;
          carry = w2 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      }, "idivn"), "idivn");
      BN32.prototype.divn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function divn(num) {
        return this.clone().idivn(num);
      }, "divn"), "divn");
      BN32.prototype.egcd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function egcd(p) {
        assert22(p.negative === 0);
        assert22(!p.isZero());
        var x2 = this;
        var y3 = p.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p);
        } else {
          x2 = x2.clone();
        }
        var A = new BN32(1);
        var B2 = new BN32(0);
        var C = new BN32(0);
        var D2 = new BN32(1);
        var g2 = 0;
        while (x2.isEven() && y3.isEven()) {
          x2.iushrn(1);
          y3.iushrn(1);
          ++g2;
        }
        var yp = y3.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i22 = 0, im = 1; (x2.words[0] & im) === 0 && i22 < 26; ++i22, im <<= 1)
            ;
          if (i22 > 0) {
            x2.iushrn(i22);
            while (i22-- > 0) {
              if (A.isOdd() || B2.isOdd()) {
                A.iadd(yp);
                B2.isub(xp);
              }
              A.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y3.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y3.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D2.isOdd()) {
                C.iadd(yp);
                D2.isub(xp);
              }
              C.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y3) >= 0) {
            x2.isub(y3);
            A.isub(C);
            B2.isub(D2);
          } else {
            y3.isub(x2);
            C.isub(A);
            D2.isub(B2);
          }
        }
        return {
          a: C,
          b: D2,
          gcd: y3.iushln(g2)
        };
      }, "egcd"), "egcd");
      BN32.prototype._invmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _invmp(p) {
        assert22(p.negative === 0);
        assert22(!p.isZero());
        var a3 = this;
        var b2 = p.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN32(1);
        var x2 = new BN32(0);
        var delta = b2.clone();
        while (a3.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i22 = 0, im = 1; (a3.words[0] & im) === 0 && i22 < 26; ++i22, im <<= 1)
            ;
          if (i22 > 0) {
            a3.iushrn(i22);
            while (i22-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b2.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a3.cmp(b2) >= 0) {
            a3.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a3);
            x2.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      }, "_invmp"), "_invmp");
      BN32.prototype.gcd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b2 = num.clone();
        a3.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a3.isEven() && b2.isEven(); shift++) {
          a3.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a3.cmp(b2);
          if (r2 < 0) {
            var t2 = a3;
            a3 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a3.isub(b2);
        } while (true);
        return b2.iushln(shift);
      }, "gcd"), "gcd");
      BN32.prototype.invm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function invm(num) {
        return this.egcd(num).a.umod(num);
      }, "invm"), "invm");
      BN32.prototype.isEven = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isEven() {
        return (this.words[0] & 1) === 0;
      }, "isEven"), "isEven");
      BN32.prototype.isOdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isOdd() {
        return (this.words[0] & 1) === 1;
      }, "isOdd"), "isOdd");
      BN32.prototype.andln = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function andln(num) {
        return this.words[0] & num;
      }, "andln"), "andln");
      BN32.prototype.bincn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bincn(bit) {
        assert22(typeof bit === "number");
        var r2 = bit % 26;
        var s3 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q2;
          return this;
        }
        var carry = q2;
        for (var i22 = s3; carry !== 0 && i22 < this.length; i22++) {
          var w2 = this.words[i22] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i22] = w2;
        }
        if (carry !== 0) {
          this.words[i22] = carry;
          this.length++;
        }
        return this;
      }, "bincn"), "bincn");
      BN32.prototype.isZero = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, "isZero"), "isZero");
      BN32.prototype.cmpn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert22(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmpn"), "cmpn");
      BN32.prototype.cmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmp"), "cmp");
      BN32.prototype.ucmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i22 = this.length - 1; i22 >= 0; i22--) {
          var a3 = this.words[i22] | 0;
          var b2 = num.words[i22] | 0;
          if (a3 === b2)
            continue;
          if (a3 < b2) {
            res = -1;
          } else if (a3 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      }, "ucmp"), "ucmp");
      BN32.prototype.gtn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gtn(num) {
        return this.cmpn(num) === 1;
      }, "gtn"), "gtn");
      BN32.prototype.gt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gt(num) {
        return this.cmp(num) === 1;
      }, "gt"), "gt");
      BN32.prototype.gten = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gten(num) {
        return this.cmpn(num) >= 0;
      }, "gten"), "gten");
      BN32.prototype.gte = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function gte(num) {
        return this.cmp(num) >= 0;
      }, "gte"), "gte");
      BN32.prototype.ltn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ltn(num) {
        return this.cmpn(num) === -1;
      }, "ltn"), "ltn");
      BN32.prototype.lt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lt(num) {
        return this.cmp(num) === -1;
      }, "lt"), "lt");
      BN32.prototype.lten = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lten(num) {
        return this.cmpn(num) <= 0;
      }, "lten"), "lten");
      BN32.prototype.lte = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lte(num) {
        return this.cmp(num) <= 0;
      }, "lte"), "lte");
      BN32.prototype.eqn = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eqn(num) {
        return this.cmpn(num) === 0;
      }, "eqn"), "eqn");
      BN32.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq42(num) {
        return this.cmp(num) === 0;
      }, "eq4"), "eq");
      BN32.red = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function red(num) {
        return new Red(num);
      }, "red"), "red");
      BN32.prototype.toRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toRed(ctx) {
        assert22(!this.red, "Already a number in reduction context");
        assert22(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      }, "toRed"), "toRed");
      BN32.prototype.fromRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromRed() {
        assert22(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      }, "fromRed"), "fromRed");
      BN32.prototype._forceRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _forceRed(ctx) {
        this.red = ctx;
        return this;
      }, "_forceRed"), "_forceRed");
      BN32.prototype.forceRed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function forceRed(ctx) {
        assert22(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      }, "forceRed"), "forceRed");
      BN32.prototype.redAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redAdd(num) {
        assert22(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      }, "redAdd"), "redAdd");
      BN32.prototype.redIAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redIAdd(num) {
        assert22(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      }, "redIAdd"), "redIAdd");
      BN32.prototype.redSub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redSub(num) {
        assert22(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      }, "redSub"), "redSub");
      BN32.prototype.redISub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redISub(num) {
        assert22(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      }, "redISub"), "redISub");
      BN32.prototype.redShl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redShl(num) {
        assert22(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      }, "redShl"), "redShl");
      BN32.prototype.redMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redMul(num) {
        assert22(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      }, "redMul"), "redMul");
      BN32.prototype.redIMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redIMul(num) {
        assert22(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      }, "redIMul"), "redIMul");
      BN32.prototype.redSqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redSqr() {
        assert22(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      }, "redSqr"), "redSqr");
      BN32.prototype.redISqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redISqr() {
        assert22(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      }, "redISqr"), "redISqr");
      BN32.prototype.redSqrt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redSqrt() {
        assert22(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      }, "redSqrt"), "redSqrt");
      BN32.prototype.redInvm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redInvm() {
        assert22(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      }, "redInvm"), "redInvm");
      BN32.prototype.redNeg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redNeg() {
        assert22(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      }, "redNeg"), "redNeg");
      BN32.prototype.redPow = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function redPow(num) {
        assert22(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      }, "redPow"), "redPow");
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name3, p) {
        this.name = name3;
        this.p = new BN32(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN32(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      __name(MPrime, "MPrime");
      __name2(MPrime, "MPrime");
      MPrime.prototype._tmp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _tmp() {
        var tmp = new BN32(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      }, "_tmp"), "_tmp");
      MPrime.prototype.ireduce = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      }, "ireduce"), "ireduce");
      MPrime.prototype.split = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, "split"), "split");
      MPrime.prototype.imulK = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imulK(num) {
        return num.imul(this.k);
      }, "imulK"), "imulK");
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      __name(K256, "K256");
      __name2(K256, "K256");
      inherits(K256, MPrime);
      K256.prototype.split = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i22 = 0; i22 < outLen; i22++) {
          output.words[i22] = input.words[i22];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i22 = 10; i22 < input.length; i22++) {
          var next = input.words[i22] | 0;
          input.words[i22 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i22 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      }, "split"), "split");
      K256.prototype.imulK = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i22 = 0; i22 < num.length; i22++) {
          var w2 = num.words[i22] | 0;
          lo += w2 * 977;
          num.words[i22] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      }, "imulK"), "imulK");
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      __name(P224, "P224");
      __name2(P224, "P224");
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      __name(P192, "P192");
      __name2(P192, "P192");
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      __name(P25519, "P25519");
      __name2(P25519, "P25519");
      inherits(P25519, MPrime);
      P25519.prototype.imulK = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imulK(num) {
        var carry = 0;
        for (var i22 = 0; i22 < num.length; i22++) {
          var hi = (num.words[i22] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i22] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      }, "imulK"), "imulK");
      BN32._prime = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function prime(name3) {
        if (primes[name3])
          return primes[name3];
        var prime2;
        if (name3 === "k256") {
          prime2 = new K256();
        } else if (name3 === "p224") {
          prime2 = new P224();
        } else if (name3 === "p192") {
          prime2 = new P192();
        } else if (name3 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name3);
        }
        primes[name3] = prime2;
        return prime2;
      }, "prime"), "prime");
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN32._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert22(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      __name(Red, "Red");
      __name2(Red, "Red");
      Red.prototype._verify1 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _verify1(a3) {
        assert22(a3.negative === 0, "red works only with positives");
        assert22(a3.red, "red works only with red numbers");
      }, "_verify1"), "_verify1");
      Red.prototype._verify2 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _verify2(a3, b2) {
        assert22((a3.negative | b2.negative) === 0, "red works only with positives");
        assert22(
          a3.red && a3.red === b2.red,
          "red works only with red numbers"
        );
      }, "_verify2"), "_verify2");
      Red.prototype.imod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        move(a3, a3.umod(this.m)._forceRed(this));
        return a3;
      }, "imod"), "imod");
      Red.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg32(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      }, "neg3"), "neg");
      Red.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add32(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      }, "add3"), "add");
      Red.prototype.iadd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function iadd(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      }, "iadd"), "iadd");
      Red.prototype.sub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      }, "sub"), "sub");
      Red.prototype.isub = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      }, "isub"), "isub");
      Red.prototype.shl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      }, "shl"), "shl");
      Red.prototype.imul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imul(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.imul(b2));
      }, "imul"), "imul");
      Red.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.mul(b2));
      }, "mul3"), "mul");
      Red.prototype.isqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isqr(a3) {
        return this.imul(a3, a3.clone());
      }, "isqr"), "isqr");
      Red.prototype.sqr = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqr(a3) {
        return this.mul(a3, a3);
      }, "sqr"), "sqr");
      Red.prototype.sqrt = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert22(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN32(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q2 = this.m.subn(1);
        var s3 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s3++;
          q2.iushrn(1);
        }
        assert22(!q2.isZero());
        var one = new BN32(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN32(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c2 = this.pow(z2, q2);
        var r2 = this.pow(a3, q2.addn(1).iushrn(1));
        var t2 = this.pow(a3, q2);
        var m3 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i22 = 0; tmp.cmp(one) !== 0; i22++) {
            tmp = tmp.redSqr();
          }
          assert22(i22 < m3);
          var b2 = this.pow(c2, new BN32(1).iushln(m3 - i22 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m3 = i22;
        }
        return r2;
      }, "sqrt"), "sqrt");
      Red.prototype.invm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      }, "invm"), "invm");
      Red.prototype.pow = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pow(a3, num) {
        if (num.isZero())
          return new BN32(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN32(1).toRed(this);
        wnd[1] = a3;
        for (var i22 = 2; i22 < wnd.length; i22++) {
          wnd[i22] = this.mul(wnd[i22 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i22 = num.length - 1; i22 >= 0; i22--) {
          var word = num.words[i22];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i22 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      }, "pow"), "pow");
      Red.prototype.convertTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      }, "convertTo"), "convertTo");
      Red.prototype.convertFrom = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }, "convertFrom"), "convertFrom");
      BN32.mont = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mont(num) {
        return new Mont(num);
      }, "mont"), "mont");
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN32(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      __name(Mont, "Mont");
      __name2(Mont, "Mont");
      inherits(Mont, Red);
      Mont.prototype.convertTo = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, "convertTo"), "convertTo");
      Mont.prototype.convertFrom = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      }, "convertFrom"), "convertFrom");
      Mont.prototype.imul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function imul(a3, b2) {
        if (a3.isZero() || b2.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t2 = a3.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      }, "imul"), "imul");
      Mont.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul32(a3, b2) {
        if (a3.isZero() || b2.isZero())
          return new BN32(0)._forceRed(this);
        var t2 = a3.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      }, "mul3"), "mul");
      Mont.prototype.invm = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      }, "invm"), "invm");
    })(typeof module2 === "undefined" || module2, exports);
  }
});
var require_encode = __commonJS2({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports, module2) {
    module2.exports = encode16;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode16(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode16.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode16.bytes = offset - oldOffset + 1;
      return out;
    }
    __name(encode16, "encode16");
    __name2(encode16, "encode");
  }
});
var require_decode = __commonJS2({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports, module2) {
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b2 = buf2[counter++];
        res += shift < 28 ? (b2 & REST2) << shift : (b2 & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b2 >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
    __name(read2, "read2");
    __name2(read2, "read");
  }
});
var require_length = __commonJS2({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports, module2) {
    var N13 = Math.pow(2, 7);
    var N23 = Math.pow(2, 14);
    var N33 = Math.pow(2, 21);
    var N43 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});
var require_varint = __commonJS2({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});
var require_fast_json_stable_stringify = __commonJS2({
  "../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a3, b2) {
            var aobj = { key: a3, value: node[a3] };
            var bobj = { key: b2, value: node[b2] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return (/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function stringify3(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i22, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i22 = 0; i22 < node.length; i22++) {
            if (i22)
              out += ",";
            out += stringify3(node[i22]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i22 = 0; i22 < keys.length; i22++) {
          var key22 = keys[i22];
          var value = stringify3(node[key22]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key22) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }, "stringify3"), "stringify"))(data);
    };
  }
});
var require_lodash2 = __commonJS2({
  "../../node_modules/.pnpm/lodash.clonedeep@4.5.0/node_modules/lodash.clonedeep/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER22 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map2, pair) {
      map2.set(pair[0], pair[1]);
      return map2;
    }
    __name(addMapEntry, "addMapEntry");
    __name2(addMapEntry, "addMapEntry");
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    __name(addSetEntry, "addSetEntry");
    __name2(addSetEntry, "addSetEntry");
    function arrayEach(array, iteratee) {
      var index = -1, length2 = array ? array.length : 0;
      while (++index < length2) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    __name2(arrayEach, "arrayEach");
    function arrayPush(array, values) {
      var index = -1, length2 = values.length, offset = array.length;
      while (++index < length2) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    __name2(arrayPush, "arrayPush");
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length2 = array ? array.length : 0;
      if (initAccum && length2) {
        accumulator = array[++index];
      }
      while (++index < length2) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    __name2(arrayReduce, "arrayReduce");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    __name2(baseTimes, "baseTimes");
    function getValue(object, key22) {
      return object == null ? void 0 : object[key22];
    }
    __name(getValue, "getValue");
    __name2(getValue, "getValue");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    __name2(isHostObject, "isHostObject");
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key22) {
        result[++index] = [key22, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    __name2(mapToArray, "mapToArray");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    __name2(overArg, "overArg");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    __name2(setToArray, "setToArray");
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer3 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash, "Hash");
    __name2(Hash, "Hash");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    __name(hashClear, "hashClear");
    __name2(hashClear, "hashClear");
    function hashDelete(key22) {
      return this.has(key22) && delete this.__data__[key22];
    }
    __name(hashDelete, "hashDelete");
    __name2(hashDelete, "hashDelete");
    function hashGet(key22) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key22];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key22) ? data[key22] : void 0;
    }
    __name(hashGet, "hashGet");
    __name2(hashGet, "hashGet");
    function hashHas(key22) {
      var data = this.__data__;
      return nativeCreate ? data[key22] !== void 0 : hasOwnProperty2.call(data, key22);
    }
    __name(hashHas, "hashHas");
    __name2(hashHas, "hashHas");
    function hashSet(key22, value) {
      var data = this.__data__;
      data[key22] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    __name2(hashSet, "hashSet");
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    __name2(ListCache, "ListCache");
    function listCacheClear() {
      this.__data__ = [];
    }
    __name(listCacheClear, "listCacheClear");
    __name2(listCacheClear, "listCacheClear");
    function listCacheDelete(key22) {
      var data = this.__data__, index = assocIndexOf(data, key22);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    __name2(listCacheDelete, "listCacheDelete");
    function listCacheGet(key22) {
      var data = this.__data__, index = assocIndexOf(data, key22);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    __name2(listCacheGet, "listCacheGet");
    function listCacheHas(key22) {
      return assocIndexOf(this.__data__, key22) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    __name2(listCacheHas, "listCacheHas");
    function listCacheSet(key22, value) {
      var data = this.__data__, index = assocIndexOf(data, key22);
      if (index < 0) {
        data.push([key22, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    __name2(listCacheSet, "listCacheSet");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    __name2(MapCache, "MapCache");
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    __name2(mapCacheClear, "mapCacheClear");
    function mapCacheDelete(key22) {
      return getMapData(this, key22)["delete"](key22);
    }
    __name(mapCacheDelete, "mapCacheDelete");
    __name2(mapCacheDelete, "mapCacheDelete");
    function mapCacheGet(key22) {
      return getMapData(this, key22).get(key22);
    }
    __name(mapCacheGet, "mapCacheGet");
    __name2(mapCacheGet, "mapCacheGet");
    function mapCacheHas(key22) {
      return getMapData(this, key22).has(key22);
    }
    __name(mapCacheHas, "mapCacheHas");
    __name2(mapCacheHas, "mapCacheHas");
    function mapCacheSet(key22, value) {
      getMapData(this, key22).set(key22, value);
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    __name2(mapCacheSet, "mapCacheSet");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    __name(Stack, "Stack");
    __name2(Stack, "Stack");
    function stackClear() {
      this.__data__ = new ListCache();
    }
    __name(stackClear, "stackClear");
    __name2(stackClear, "stackClear");
    function stackDelete(key22) {
      return this.__data__["delete"](key22);
    }
    __name(stackDelete, "stackDelete");
    __name2(stackDelete, "stackDelete");
    function stackGet(key22) {
      return this.__data__.get(key22);
    }
    __name(stackGet, "stackGet");
    __name2(stackGet, "stackGet");
    function stackHas(key22) {
      return this.__data__.has(key22);
    }
    __name(stackHas, "stackHas");
    __name2(stackHas, "stackHas");
    function stackSet(key22, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key22, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key22, value);
      return this;
    }
    __name(stackSet, "stackSet");
    __name2(stackSet, "stackSet");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length2 = result.length, skipIndexes = !!length2;
      for (var key22 in value) {
        if ((inherited || hasOwnProperty2.call(value, key22)) && !(skipIndexes && (key22 == "length" || isIndex(key22, length2)))) {
          result.push(key22);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    __name2(arrayLikeKeys, "arrayLikeKeys");
    function assignValue(object, key22, value) {
      var objValue = object[key22];
      if (!(hasOwnProperty2.call(object, key22) && eq42(objValue, value)) || value === void 0 && !(key22 in object)) {
        object[key22] = value;
      }
    }
    __name(assignValue, "assignValue");
    __name2(assignValue, "assignValue");
    function assocIndexOf(array, key22) {
      var length2 = array.length;
      while (length2--) {
        if (eq42(array[length2][0], key22)) {
          return length2;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    __name2(assocIndexOf, "assocIndexOf");
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    __name(baseAssign, "baseAssign");
    __name2(baseAssign, "baseAssign");
    function baseClone(value, isDeep, isFull, customizer, key22, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key22, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer3(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, isDeep, isFull, customizer, key3, value, stack));
      });
      return result;
    }
    __name(baseClone, "baseClone");
    __name2(baseClone, "baseClone");
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    __name(baseCreate, "baseCreate");
    __name2(baseCreate, "baseCreate");
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    __name(baseGetAllKeys, "baseGetAllKeys");
    __name2(baseGetAllKeys, "baseGetAllKeys");
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    __name(baseGetTag, "baseGetTag");
    __name2(baseGetTag, "baseGetTag");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    __name2(baseIsNative, "baseIsNative");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key22 in Object(object)) {
        if (hasOwnProperty2.call(object, key22) && key22 != "constructor") {
          result.push(key22);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    __name2(baseKeys, "baseKeys");
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var result = new buffer2.constructor(buffer2.length);
      buffer2.copy(result);
      return result;
    }
    __name(cloneBuffer, "cloneBuffer");
    __name2(cloneBuffer, "cloneBuffer");
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    __name(cloneArrayBuffer, "cloneArrayBuffer");
    __name2(cloneArrayBuffer, "cloneArrayBuffer");
    function cloneDataView(dataView2, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(dataView2.buffer) : dataView2.buffer;
      return new dataView2.constructor(buffer2, dataView2.byteOffset, dataView2.byteLength);
    }
    __name(cloneDataView, "cloneDataView");
    __name2(cloneDataView, "cloneDataView");
    function cloneMap(map2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
      return arrayReduce(array, addMapEntry, new map2.constructor());
    }
    __name(cloneMap, "cloneMap");
    __name2(cloneMap, "cloneMap");
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    __name(cloneRegExp, "cloneRegExp");
    __name2(cloneRegExp, "cloneRegExp");
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    __name(cloneSet, "cloneSet");
    __name2(cloneSet, "cloneSet");
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    __name(cloneSymbol, "cloneSymbol");
    __name2(cloneSymbol, "cloneSymbol");
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    __name(cloneTypedArray, "cloneTypedArray");
    __name2(cloneTypedArray, "cloneTypedArray");
    function copyArray(source, array) {
      var index = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index < length2) {
        array[index] = source[index];
      }
      return array;
    }
    __name(copyArray, "copyArray");
    __name2(copyArray, "copyArray");
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length2 = props.length;
      while (++index < length2) {
        var key22 = props[index];
        var newValue = customizer ? customizer(object[key22], source[key22], key22, object, source) : void 0;
        assignValue(object, key22, newValue === void 0 ? source[key22] : newValue);
      }
      return object;
    }
    __name(copyObject, "copyObject");
    __name2(copyObject, "copyObject");
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    __name(copySymbols, "copySymbols");
    __name2(copySymbols, "copySymbols");
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    __name(getAllKeys, "getAllKeys");
    __name2(getAllKeys, "getAllKeys");
    function getMapData(map2, key22) {
      var data = map2.__data__;
      return isKeyable(key22) ? data[typeof key22 == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    __name2(getMapData, "getMapData");
    function getNative(object, key22) {
      var value = getValue(object, key22);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    __name2(getNative, "getNative");
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name2(function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    function initCloneArray(array) {
      var length2 = array.length, result = array.constructor(length2);
      if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    __name(initCloneArray, "initCloneArray");
    __name2(initCloneArray, "initCloneArray");
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    __name(initCloneObject, "initCloneObject");
    __name2(initCloneObject, "initCloneObject");
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    __name(initCloneByTag, "initCloneByTag");
    __name2(initCloneByTag, "initCloneByTag");
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER22 : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    __name(isIndex, "isIndex");
    __name2(isIndex, "isIndex");
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    __name2(isKeyable, "isKeyable");
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    __name2(isMasked, "isMasked");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    __name2(isPrototype, "isPrototype");
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    __name2(toSource, "toSource");
    function cloneDeep6(value) {
      return baseClone(value, true, true);
    }
    __name(cloneDeep6, "cloneDeep6");
    __name2(cloneDeep6, "cloneDeep");
    function eq42(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq42, "eq4");
    __name2(eq42, "eq");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    __name2(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike2, "isArrayLike2");
    __name2(isArrayLike2, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    __name2(isArrayLikeObject, "isArrayLikeObject");
    var isBuffer3 = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction2");
    __name2(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER22;
    }
    __name(isLength, "isLength");
    __name2(isLength, "isLength");
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    __name2(isObject, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    __name2(isObjectLike, "isObjectLike");
    function keys(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    __name2(keys, "keys");
    function stubArray() {
      return [];
    }
    __name(stubArray, "stubArray");
    __name2(stubArray, "stubArray");
    function stubFalse() {
      return false;
    }
    __name(stubFalse, "stubFalse");
    __name2(stubFalse, "stubFalse");
    module2.exports = cloneDeep6;
  }
});
var require_tslib = __commonJS2({
  "../../node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends3;
    var __assign2;
    var __rest2;
    var __decorate8;
    var __param2;
    var __esDecorate2;
    var __runInitializers2;
    var __propKey2;
    var __setFunctionName2;
    var __metadata4;
    var __awaiter22;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id2, v) {
          return exports2[id2] = previous ? previous(id2, v) : v;
        };
      }
      __name(createExporter, "createExporter");
      __name2(createExporter, "createExporter");
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d3[p] = b2[p];
      };
      __extends3 = /* @__PURE__ */ __name2(function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        __name(__, "__");
        __name2(__, "__");
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      }, "__extends");
      __assign2 = Object.assign || function(t2) {
        for (var s3, i22 = 1, n = arguments.length; i22 < n; i22++) {
          s3 = arguments[i22];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest2 = /* @__PURE__ */ __name2(function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i22 = 0, p = Object.getOwnPropertySymbols(s3); i22 < p.length; i22++) {
            if (e2.indexOf(p[i22]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i22]))
              t2[p[i22]] = s3[p[i22]];
          }
        return t2;
      }, "__rest");
      __decorate8 = /* @__PURE__ */ __name2(function(decorators, target, key22, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key22) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key22, desc);
        else
          for (var i22 = decorators.length - 1; i22 >= 0; i22--)
            if (d3 = decorators[i22])
              r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key22, r2) : d3(target, key22)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key22, r2), r2;
      }, "__decorate");
      __param2 = /* @__PURE__ */ __name2(function(paramIndex, decorator) {
        return function(target, key22) {
          decorator(target, key22, paramIndex);
        };
      }, "__param");
      __esDecorate2 = /* @__PURE__ */ __name2(function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
          if (f !== void 0 && typeof f !== "function")
            throw new TypeError("Function expected");
          return f;
        }
        __name(accept, "accept");
        __name2(accept, "accept");
        var kind = contextIn.kind, key22 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _2, done = false;
        for (var i22 = decorators.length - 1; i22 >= 0; i22--) {
          var context2 = {};
          for (var p in contextIn)
            context2[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access)
            context2.access[p] = contextIn.access[p];
          context2.addInitializer = function(f) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
          };
          var result = (0, decorators[i22])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key22], context2);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_2 = accept(result.get))
              descriptor.get = _2;
            if (_2 = accept(result.set))
              descriptor.set = _2;
            if (_2 = accept(result.init))
              initializers.push(_2);
          } else if (_2 = accept(result)) {
            if (kind === "field")
              initializers.push(_2);
            else
              descriptor[key22] = _2;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      }, "__esDecorate");
      __runInitializers2 = /* @__PURE__ */ __name2(function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i22 = 0; i22 < initializers.length; i22++) {
          value = useValue ? initializers[i22].call(thisArg, value) : initializers[i22].call(thisArg);
        }
        return useValue ? value : void 0;
      }, "__runInitializers");
      __propKey2 = /* @__PURE__ */ __name2(function(x2) {
        return typeof x2 === "symbol" ? x2 : "".concat(x2);
      }, "__propKey");
      __setFunctionName2 = /* @__PURE__ */ __name2(function(f, name3, prefix) {
        if (typeof name3 === "symbol")
          name3 = name3.description ? "[".concat(name3.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name3) : name3 });
      }, "__setFunctionName");
      __metadata4 = /* @__PURE__ */ __name2(function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      }, "__metadata");
      __awaiter22 = /* @__PURE__ */ __name2(function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        __name(adopt, "adopt");
        __name2(adopt, "adopt");
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          __name(fulfilled, "fulfilled");
          __name2(fulfilled, "fulfilled");
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          __name(rejected, "rejected");
          __name2(rejected, "rejected");
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          __name(step, "step");
          __name2(step, "step");
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }, "__awaiter");
      __generator2 = /* @__PURE__ */ __name2(function(thisArg, body) {
        var _2 = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f, y3, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        __name(verb, "verb");
        __name2(verb, "verb");
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
            try {
              if (f = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
                return t2;
              if (y3 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _2.label++;
                  return { value: op[1], done: false };
                case 5:
                  _2.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _2.ops.pop();
                  _2.trys.pop();
                  continue;
                default:
                  if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _2 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _2.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _2.label < t2[1]) {
                    _2.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _2.label < t2[2]) {
                    _2.label = t2[2];
                    _2.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _2.ops.pop();
                  _2.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _2);
            } catch (e2) {
              op = [6, e2];
              y3 = 0;
            } finally {
              f = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
        __name(step, "step");
        __name2(step, "step");
      }, "__generator");
      __exportStar2 = /* @__PURE__ */ __name2(function(m3, o) {
        for (var p in m3)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m3, p);
      }, "__exportStar");
      __createBinding2 = Object.create ? function(o, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m3, k2);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m3[k2];
      };
      __values2 = /* @__PURE__ */ __name2(function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i22 = 0;
        if (m3)
          return m3.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i22 >= o.length)
                o = void 0;
              return { value: o && o[i22++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, "__values");
      __read2 = /* @__PURE__ */ __name2(function(o, n) {
        var m3 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m3)
          return o;
        var i22 = m3.call(o), r2, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i22.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m3 = i22["return"]))
              m3.call(i22);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      }, "__read");
      __spread2 = /* @__PURE__ */ __name2(function() {
        for (var ar = [], i22 = 0; i22 < arguments.length; i22++)
          ar = ar.concat(__read2(arguments[i22]));
        return ar;
      }, "__spread");
      __spreadArrays2 = /* @__PURE__ */ __name2(function() {
        for (var s3 = 0, i22 = 0, il = arguments.length; i22 < il; i22++)
          s3 += arguments[i22].length;
        for (var r2 = Array(s3), k2 = 0, i22 = 0; i22 < il; i22++)
          for (var a3 = arguments[i22], j = 0, jl = a3.length; j < jl; j++, k2++)
            r2[k2] = a3[j];
        return r2;
      }, "__spreadArrays");
      __spreadArray2 = /* @__PURE__ */ __name2(function(to, from4, pack3) {
        if (pack3 || arguments.length === 2)
          for (var i22 = 0, l = from4.length, ar; i22 < l; i22++) {
            if (ar || !(i22 in from4)) {
              if (!ar)
                ar = Array.prototype.slice.call(from4, 0, i22);
              ar[i22] = from4[i22];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from4));
      }, "__spreadArray");
      __await2 = /* @__PURE__ */ __name2(function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      }, "__await");
      __asyncGenerator2 = /* @__PURE__ */ __name2(function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i22, q2 = [];
        return i22 = {}, verb("next"), verb("throw"), verb("return"), i22[Symbol.asyncIterator] = function() {
          return this;
        }, i22;
        function verb(n) {
          if (g2[n])
            i22[n] = function(v) {
              return new Promise(function(a3, b2) {
                q2.push([n, v, a3, b2]) > 1 || resume(n, v);
              });
            };
        }
        __name(verb, "verb");
        __name2(verb, "verb");
        function resume(n, v) {
          try {
            step(g2[n](v));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        __name(resume, "resume");
        __name2(resume, "resume");
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        __name(step, "step");
        __name2(step, "step");
        function fulfill(value) {
          resume("next", value);
        }
        __name(fulfill, "fulfill");
        __name2(fulfill, "fulfill");
        function reject(value) {
          resume("throw", value);
        }
        __name(reject, "reject");
        __name2(reject, "reject");
        function settle(f, v) {
          if (f(v), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
        __name(settle, "settle");
        __name2(settle, "settle");
      }, "__asyncGenerator");
      __asyncDelegator2 = /* @__PURE__ */ __name2(function(o) {
        var i22, p;
        return i22 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i22[Symbol.iterator] = function() {
          return this;
        }, i22;
        function verb(n, f) {
          i22[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: false } : f ? f(v) : v;
          } : f;
        }
        __name(verb, "verb");
        __name2(verb, "verb");
      }, "__asyncDelegator");
      __asyncValues2 = /* @__PURE__ */ __name2(function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o[Symbol.asyncIterator], i22;
        return m3 ? m3.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i22 = {}, verb("next"), verb("throw"), verb("return"), i22[Symbol.asyncIterator] = function() {
          return this;
        }, i22);
        function verb(n) {
          i22[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        __name(verb, "verb");
        __name2(verb, "verb");
        function settle(resolve, reject, d3, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d3 });
          }, reject);
        }
        __name(settle, "settle");
        __name2(settle, "settle");
      }, "__asyncValues");
      __makeTemplateObject2 = /* @__PURE__ */ __name2(function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }, "__makeTemplateObject");
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = /* @__PURE__ */ __name2(function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
              __createBinding2(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      }, "__importStar");
      __importDefault2 = /* @__PURE__ */ __name2(function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      }, "__importDefault");
      __classPrivateFieldGet3 = /* @__PURE__ */ __name2(function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      }, "__classPrivateFieldGet");
      __classPrivateFieldSet3 = /* @__PURE__ */ __name2(function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      }, "__classPrivateFieldSet");
      __classPrivateFieldIn2 = /* @__PURE__ */ __name2(function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      }, "__classPrivateFieldIn");
      exporter("__extends", __extends3);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate8);
      exporter("__param", __param2);
      exporter("__esDecorate", __esDecorate2);
      exporter("__runInitializers", __runInitializers2);
      exporter("__propKey", __propKey2);
      exporter("__setFunctionName", __setFunctionName2);
      exporter("__metadata", __metadata4);
      exporter("__awaiter", __awaiter22);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});
var require_dataloader = __commonJS2({
  "../../node_modules/.pnpm/dataloader@2.2.2/node_modules/dataloader/index.js"(exports, module2) {
    "use strict";
    var DataLoader2 = /* @__PURE__ */ function() {
      function DataLoader3(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
        this.name = getValidName(options);
      }
      __name(DataLoader3, "DataLoader3");
      __name2(DataLoader3, "DataLoader");
      var _proto = DataLoader3.prototype;
      _proto.load = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function load3(key22) {
        if (key22 === null || key22 === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key22) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key22);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key22);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      }, "load3"), "load");
      _proto.loadMany = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function loadMany(keys) {
        if (!isArrayLike2(keys)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
        }
        var loadPromises = [];
        for (var i22 = 0; i22 < keys.length; i22++) {
          loadPromises.push(this.load(keys[i22])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      }, "loadMany"), "loadMany");
      _proto.clear = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function clear(key22) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key22);
          cacheMap["delete"](cacheKey);
        }
        return this;
      }, "clear"), "clear");
      _proto.clearAll = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      }, "clearAll"), "clearAll");
      _proto.prime = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function prime(key22, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key22);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      }, "prime"), "prime");
      return DataLoader3;
    }();
    var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        process.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    __name(getCurrentBatch, "getCurrentBatch");
    __name2(getCurrentBatch, "getCurrentBatch");
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise;
      try {
        batchPromise = loader._batchLoadFn(batch.keys);
      } catch (e2) {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e2) + ".")));
      }
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike2(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i22 = 0; i22 < batch.callbacks.length; i22++) {
          var value = values[i22];
          if (value instanceof Error) {
            batch.callbacks[i22].reject(value);
          } else {
            batch.callbacks[i22].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    __name(dispatchBatch, "dispatchBatch");
    __name2(dispatchBatch, "dispatchBatch");
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i22 = 0; i22 < batch.keys.length; i22++) {
        loader.clear(batch.keys[i22]);
        batch.callbacks[i22].reject(error);
      }
    }
    __name(failedDispatch, "failedDispatch");
    __name2(failedDispatch, "failedDispatch");
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i22 = 0; i22 < batch.cacheHits.length; i22++) {
          batch.cacheHits[i22]();
        }
      }
    }
    __name(resolveCacheHits, "resolveCacheHits");
    __name2(resolveCacheHits, "resolveCacheHits");
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    __name(getValidMaxBatchSize, "getValidMaxBatchSize");
    __name2(getValidMaxBatchSize, "getValidMaxBatchSize");
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    __name(getValidBatchScheduleFn, "getValidBatchScheduleFn");
    __name2(getValidBatchScheduleFn, "getValidBatchScheduleFn");
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key22) {
          return key22;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    __name(getValidCacheKeyFn, "getValidCacheKeyFn");
    __name2(getValidCacheKeyFn, "getValidCacheKeyFn");
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    __name(getValidCacheMap, "getValidCacheMap");
    __name2(getValidCacheMap, "getValidCacheMap");
    function getValidName(options) {
      if (options && options.name) {
        return options.name;
      }
      return null;
    }
    __name(getValidName, "getValidName");
    __name2(getValidName, "getValidName");
    function isArrayLike2(x2) {
      return typeof x2 === "object" && x2 !== null && typeof x2.length === "number" && (x2.length === 0 || x2.length > 0 && Object.prototype.hasOwnProperty.call(x2, x2.length - 1));
    }
    __name(isArrayLike2, "isArrayLike2");
    __name2(isArrayLike2, "isArrayLike");
    module2.exports = DataLoader2;
  }
});
var require_src = __commonJS2({
  "../../node_modules/.pnpm/@multiformats+base-x@4.0.1/node_modules/@multiformats/base-x/src/index.js"(exports, module2) {
    "use strict";
    function base4(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i22 = 0; i22 < ALPHABET.length; i22++) {
        var x2 = ALPHABET.charAt(i22);
        var xc = x2.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x2 + " is ambiguous");
        }
        BASE_MAP[xc] = i22;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode16(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i3 = 0;
          for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i3;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      __name(encode16, "encode16");
      __name2(encode16, "encode");
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i3 = 0;
          for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i3;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      __name(decodeUnsafe, "decodeUnsafe");
      __name2(decodeUnsafe, "decodeUnsafe");
      function decode13(string2) {
        var buffer2 = decodeUnsafe(string2);
        if (buffer2) {
          return buffer2;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      __name(decode13, "decode13");
      __name2(decode13, "decode");
      return {
        encode: encode16,
        decodeUnsafe,
        decode: decode13
      };
    }
    __name(base4, "base4");
    __name2(base4, "base");
    module2.exports = base4;
  }
});
var require_util = __commonJS2({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/util.js"(exports, module2) {
    "use strict";
    var textDecoder3 = new TextDecoder();
    var decodeText = /* @__PURE__ */ __name2((bytes) => textDecoder3.decode(bytes), "decodeText");
    var textEncoder3 = new TextEncoder();
    var encodeText = /* @__PURE__ */ __name2((text) => textEncoder3.encode(text), "encodeText");
    function concat4(arrs, length2) {
      const output = new Uint8Array(length2);
      let offset = 0;
      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    __name(concat4, "concat4");
    __name2(concat4, "concat");
    module2.exports = { decodeText, encodeText, concat: concat4 };
  }
});
var require_base2 = __commonJS2({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/base.js"(exports, module2) {
    "use strict";
    var { encodeText } = require_util();
    var Base = /* @__PURE__ */ __name(class {
      constructor(name3, code3, factory, alphabet3) {
        this.name = name3;
        this.code = code3;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet3;
        this.codec = factory(alphabet3);
      }
      encode(buf2) {
        return this.codec.encode(buf2);
      }
      decode(string2) {
        for (const char of string2) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string2}'`);
          }
        }
        return this.codec.decode(string2);
      }
    }, "Base");
    __name2(Base, "Base");
    module2.exports = Base;
  }
});
var require_rfc4648 = __commonJS2({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/rfc4648.js"(exports, module2) {
    "use strict";
    var decode13 = /* @__PURE__ */ __name2((string2, alphabet3, bitsPerChar) => {
      const codes = {};
      for (let i22 = 0; i22 < alphabet3.length; ++i22) {
        codes[alphabet3[i22]] = i22;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i22 = 0; i22 < end; ++i22) {
        const value = codes[string2[i22]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string2[i22]);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    }, "decode");
    var encode16 = /* @__PURE__ */ __name2((data, alphabet3, bitsPerChar) => {
      const pad2 = alphabet3[alphabet3.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i22 = 0; i22 < data.length; ++i22) {
        buffer2 = buffer2 << 8 | data[i22];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet3[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet3[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    }, "encode");
    var rfc46482 = /* @__PURE__ */ __name2((bitsPerChar) => (alphabet3) => {
      return {
        encode(input) {
          return encode16(input, alphabet3, bitsPerChar);
        },
        decode(input) {
          return decode13(input, alphabet3, bitsPerChar);
        }
      };
    }, "rfc4648");
    module2.exports = { rfc4648: rfc46482 };
  }
});
var require_constants = __commonJS2({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/constants.js"(exports, module2) {
    "use strict";
    var baseX2 = require_src();
    var Base = require_base2();
    var { rfc4648: rfc46482 } = require_rfc4648();
    var { decodeText, encodeText } = require_util();
    var identity4 = /* @__PURE__ */ __name2(() => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    }, "identity");
    var constants = [
      ["identity", "\0", identity4, ""],
      ["base2", "0", rfc46482(1), "01"],
      ["base8", "7", rfc46482(3), "01234567"],
      ["base10", "9", baseX2, "0123456789"],
      ["base16", "f", rfc46482(4), "0123456789abcdef"],
      ["base16upper", "F", rfc46482(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc46482(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc46482(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc46482(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX2, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX2, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX2, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX2, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names2 = constants.reduce((prev, tupple) => {
      prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
      return prev;
    }, {});
    var codes = constants.reduce((prev, tupple) => {
      prev[tupple[1]] = names2[tupple[0]];
      return prev;
    }, {});
    module2.exports = {
      names: names2,
      codes
    };
  }
});
var require_src2 = __commonJS2({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/index.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var { encodeText, decodeText, concat: concat4 } = require_util();
    function multibase(nameOrCode, buf2) {
      if (!buf2) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name: name3, codeBuf } = encoding(nameOrCode);
      validEncode(name3, buf2);
      return concat4([codeBuf, buf2], codeBuf.length + buf2.length);
    }
    __name(multibase, "multibase");
    __name2(multibase, "multibase");
    function encode16(nameOrCode, buf2) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf2));
      return concat4([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    __name(encode16, "encode16");
    __name2(encode16, "encode");
    function decode13(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(data[0]);
      return enc.decode(data.substring(1));
    }
    __name(decode13, "decode13");
    __name2(decode13, "decode");
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(data[0]);
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    __name(isEncoded, "isEncoded");
    __name2(isEncoded, "isEncoded");
    function validEncode(name3, buf2) {
      const enc = encoding(name3);
      enc.decode(decodeText(buf2));
    }
    __name(validEncode, "validEncode");
    __name2(validEncode, "validEncode");
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(constants.names, nameOrCode)) {
        return constants.names[nameOrCode];
      } else if (Object.prototype.hasOwnProperty.call(constants.codes, nameOrCode)) {
        return constants.codes[nameOrCode];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    __name(encoding, "encoding");
    __name2(encoding, "encoding");
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(data[0]);
    }
    __name(encodingFromData, "encodingFromData");
    __name2(encodingFromData, "encodingFromData");
    exports = module2.exports = multibase;
    exports.encode = encode16;
    exports.decode = decode13;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    var names2 = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports.names = names2;
    exports.codes = codes;
  }
});
var require_encode2 = __commonJS2({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js"(exports, module2) {
    module2.exports = encode16;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode16(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode16.bytes = offset - oldOffset + 1;
      return out;
    }
    __name(encode16, "encode16");
    __name2(encode16, "encode");
  }
});
var require_decode2 = __commonJS2({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js"(exports, module2) {
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b2 = buf2[counter++];
        res += shift < 28 ? (b2 & REST2) << shift : (b2 & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b2 >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
    __name(read2, "read2");
    __name2(read2, "read");
  }
});
var require_length2 = __commonJS2({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js"(exports, module2) {
    var N13 = Math.pow(2, 7);
    var N23 = Math.pow(2, 14);
    var N33 = Math.pow(2, 21);
    var N43 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});
var require_varint2 = __commonJS2({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js"(exports, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});
var require_constants2 = __commonJS2({
  "../../node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/constants.js"(exports, module2) {
    "use strict";
    var names2 = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module2.exports = { names: names2 };
  }
});
var require_src3 = __commonJS2({
  "../../node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/index.js"(exports, module2) {
    "use strict";
    var multibase = require_src2();
    var varint6 = require_varint2();
    var { names: names2 } = require_constants2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS2(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS2(from_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS2(concat_exports));
    var codes = {};
    for (const key22 in names2) {
      const name3 = key22;
      codes[names2[name3]] = name3;
    }
    Object.freeze(codes);
    function toHexString(hash3) {
      if (!(hash3 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash3, "base16");
    }
    __name(toHexString, "toHexString");
    __name2(toHexString, "toHexString");
    function fromHexString(hash3) {
      return uint8ArrayFromString(hash3, "base16");
    }
    __name(fromHexString, "fromHexString");
    __name2(fromHexString, "fromHexString");
    function toB58String(hash3) {
      if (!(hash3 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash3)).slice(1);
    }
    __name(toB58String, "toB58String");
    __name2(toB58String, "toB58String");
    function fromB58String(hash3) {
      const encoded = hash3 instanceof Uint8Array ? uint8ArrayToString(hash3) : hash3;
      return multibase.decode("z" + encoded);
    }
    __name(fromB58String, "fromB58String");
    __name2(fromB58String, "fromB58String");
    function decode13(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code3 = varint6.decode(bytes);
      if (!isValidCode(code3)) {
        throw new Error(`multihash unknown function code: 0x${code3.toString(16)}`);
      }
      bytes = bytes.slice(varint6.decode.bytes);
      const len = varint6.decode(bytes);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes = bytes.slice(varint6.decode.bytes);
      if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
      }
      return {
        code: code3,
        name: codes[code3],
        length: len,
        digest: bytes
      };
    }
    __name(decode13, "decode13");
    __name2(decode13, "decode");
    function encode16(digest2, code3, length2) {
      if (!digest2 || code3 === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code3);
      if (!(digest2 instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length2 == null) {
        length2 = digest2.length;
      }
      if (length2 && digest2.length !== length2) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash3 = varint6.encode(hashfn);
      const len = varint6.encode(length2);
      return uint8ArrayConcat([hash3, len, digest2], hash3.length + len.length + digest2.length);
    }
    __name(encode16, "encode16");
    __name2(encode16, "encode");
    function coerceCode(name3) {
      let code3 = name3;
      if (typeof name3 === "string") {
        if (names2[name3] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name3}`);
        }
        code3 = names2[name3];
      }
      if (typeof code3 !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code3}`);
      }
      if (codes[code3] === void 0 && !isAppCode(code3)) {
        throw new Error(`Unrecognized function code: ${code3}`);
      }
      return code3;
    }
    __name(coerceCode, "coerceCode");
    __name2(coerceCode, "coerceCode");
    function isAppCode(code3) {
      return code3 > 0 && code3 < 16;
    }
    __name(isAppCode, "isAppCode");
    __name2(isAppCode, "isAppCode");
    function isValidCode(code3) {
      if (isAppCode(code3)) {
        return true;
      }
      if (codes[code3]) {
        return true;
      }
      return false;
    }
    __name(isValidCode, "isValidCode");
    __name2(isValidCode, "isValidCode");
    function validate7(multihash) {
      decode13(multihash);
    }
    __name(validate7, "validate7");
    __name2(validate7, "validate");
    function prefix(multihash) {
      validate7(multihash);
      return multihash.subarray(0, 2);
    }
    __name(prefix, "prefix");
    __name2(prefix, "prefix");
    module2.exports = {
      names: names2,
      codes,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode: decode13,
      encode: encode16,
      coerceCode,
      isAppCode,
      validate: validate7,
      prefix,
      isValidCode
    };
  }
});
var require_base64_js = __commonJS2({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i22 = 0, len = code3.length; i22 < len; ++i22) {
      lookup[i22] = code3[i22];
      revLookup[code3.charCodeAt(i22)] = i22;
    }
    var i22;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    __name2(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    __name2(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    __name2(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    __name2(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    __name2(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    __name2(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
    __name2(fromByteArray, "fromByteArray");
  }
});
var require_ieee754 = __commonJS2({
  "../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e2, m3;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i22 = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s3 = buffer2[offset + i22];
      i22 += d3;
      e2 = s3 & (1 << -nBits) - 1;
      s3 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i22], i22 += d3, nBits -= 8) {
      }
      m3 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m3 = m3 * 256 + buffer2[offset + i22], i22 += d3, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m3 ? NaN : (s3 ? -1 : 1) * Infinity;
      } else {
        m3 = m3 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s3 ? -1 : 1) * m3 * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e2, m3, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i22 = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m3 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m3 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m3 = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i22] = m3 & 255, i22 += d3, m3 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m3;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i22] = e2 & 255, i22 += d3, e2 /= 256, eLen -= 8) {
      }
      buffer2[offset + i22 - d3] |= s3 * 128;
    };
  }
});
var require_buffer22 = __commonJS2({
  "../../node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    __name2(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      var buf2 = new Uint8Array(length2);
      Object.setPrototypeOf(buf2, Buffer3.prototype);
      return buf2;
    }
    __name(createBuffer, "createBuffer");
    __name2(createBuffer, "createBuffer");
    function Buffer3(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from4(arg, encodingOrOffset, length2);
    }
    __name(Buffer3, "Buffer3");
    __name2(Buffer3, "Buffer");
    Buffer3.poolSize = 8192;
    function from4(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString7(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length2);
      }
      var b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length2
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from4, "from4");
    __name2(from4, "from");
    Buffer3.from = function(value, encodingOrOffset, length2) {
      return from4(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    __name(assertSize, "assertSize");
    __name2(assertSize, "assertSize");
    function alloc2(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    __name(alloc2, "alloc2");
    __name2(alloc2, "alloc");
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc2(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    __name(allocUnsafe2, "allocUnsafe2");
    __name2(allocUnsafe2, "allocUnsafe");
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString7(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length2 = byteLength(string2, encoding) | 0;
      var buf2 = createBuffer(length2);
      var actual = buf2.write(string2, encoding);
      if (actual !== length2) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    __name(fromString7, "fromString7");
    __name2(fromString7, "fromString");
    function fromArrayLike2(array) {
      var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf2 = createBuffer(length2);
      for (var i22 = 0; i22 < length2; i22 += 1) {
        buf2[i22] = array[i22] & 255;
      }
      return buf2;
    }
    __name(fromArrayLike2, "fromArrayLike2");
    __name2(fromArrayLike2, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike2(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    __name2(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf2;
      if (byteOffset === void 0 && length2 === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf2, Buffer3.prototype);
      return buf2;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    __name2(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike2(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike2(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    __name2(fromObject, "fromObject");
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    __name(checked, "checked");
    __name2(checked, "checked");
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer3.alloc(+length2);
    }
    __name(SlowBuffer, "SlowBuffer");
    __name2(SlowBuffer, "SlowBuffer");
    Buffer3.isBuffer = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isBuffer3(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
    }, "isBuffer3"), "isBuffer");
    Buffer3.compare = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function compare4(a3, b2) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer3.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
      if (!Buffer3.isBuffer(a3) || !Buffer3.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a3 === b2)
        return 0;
      var x2 = a3.length;
      var y3 = b2.length;
      for (var i22 = 0, len = Math.min(x2, y3); i22 < len; ++i22) {
        if (a3[i22] !== b2[i22]) {
          x2 = a3[i22];
          y3 = b2[i22];
          break;
        }
      }
      if (x2 < y3)
        return -1;
      if (y3 < x2)
        return 1;
      return 0;
    }, "compare4"), "compare");
    Buffer3.isEncoding = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding"), "isEncoding");
    Buffer3.concat = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function concat4(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i22;
      if (length2 === void 0) {
        length2 = 0;
        for (i22 = 0; i22 < list.length; ++i22) {
          length2 += list[i22].length;
        }
      }
      var buffer2 = Buffer3.allocUnsafe(length2);
      var pos = 0;
      for (i22 = 0; i22 < list.length; ++i22) {
        var buf2 = list[i22];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            Buffer3.from(buf2).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    }, "concat4"), "concat");
    function byteLength(string2, encoding) {
      if (Buffer3.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      var len = string2.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes2(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength, "byteLength");
    __name2(byteLength, "byteLength");
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    __name2(slowToString, "slowToString");
    Buffer3.prototype._isBuffer = true;
    function swap(b2, n, m3) {
      var i22 = b2[n];
      b2[n] = b2[m3];
      b2[m3] = i22;
    }
    __name(swap, "swap");
    __name2(swap, "swap");
    Buffer3.prototype.swap16 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i22 = 0; i22 < len; i22 += 2) {
        swap(this, i22, i22 + 1);
      }
      return this;
    }, "swap16"), "swap16");
    Buffer3.prototype.swap32 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i22 = 0; i22 < len; i22 += 4) {
        swap(this, i22, i22 + 3);
        swap(this, i22 + 1, i22 + 2);
      }
      return this;
    }, "swap32"), "swap32");
    Buffer3.prototype.swap64 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i22 = 0; i22 < len; i22 += 8) {
        swap(this, i22, i22 + 7);
        swap(this, i22 + 1, i22 + 6);
        swap(this, i22 + 2, i22 + 5);
        swap(this, i22 + 3, i22 + 4);
      }
      return this;
    }, "swap64"), "swap64");
    Buffer3.prototype.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
      var length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length2);
      return slowToString.apply(this, arguments);
    }, "toString6"), "toString");
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function equals4(b2) {
      if (!Buffer3.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer3.compare(this, b2) === 0;
    }, "equals4"), "equals");
    Buffer3.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect5() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect5"), "inspect");
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function compare4(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x2 = thisEnd - thisStart;
      var y3 = end - start;
      var len = Math.min(x2, y3);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i22 = 0; i22 < len; ++i22) {
        if (thisCopy[i22] !== targetCopy[i22]) {
          x2 = thisCopy[i22];
          y3 = targetCopy[i22];
          break;
        }
      }
      if (x2 < y3)
        return -1;
      if (y3 < x2)
        return 1;
      return 0;
    }, "compare4"), "compare");
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    __name2(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf2, i3) {
        if (indexSize === 1) {
          return buf2[i3];
        } else {
          return buf2.readUInt16BE(i3 * indexSize);
        }
      }
      __name(read2, "read2");
      __name2(read2, "read");
      var i22;
      if (dir) {
        var foundIndex = -1;
        for (i22 = byteOffset; i22 < arrLength; i22++) {
          if (read2(arr, i22) === read2(val, foundIndex === -1 ? 0 : i22 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i22;
            if (i22 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i22 -= i22 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i22 = byteOffset; i22 >= 0; i22--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read2(arr, i22 + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i22;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    __name2(arrayIndexOf, "arrayIndexOf");
    Buffer3.prototype.includes = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    }, "includes"), "includes");
    Buffer3.prototype.indexOf = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    }, "indexOf"), "indexOf");
    Buffer3.prototype.lastIndexOf = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    }, "lastIndexOf"), "lastIndexOf");
    function hexWrite(buf2, string2, offset, length2) {
      offset = Number(offset) || 0;
      var remaining = buf2.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      var strLen = string2.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      for (var i22 = 0; i22 < length2; ++i22) {
        var parsed = parseInt(string2.substr(i22 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i22;
        buf2[offset + i22] = parsed;
      }
      return i22;
    }
    __name(hexWrite, "hexWrite");
    __name2(hexWrite, "hexWrite");
    function utf8Write(buf2, string2, offset, length2) {
      return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
    }
    __name(utf8Write, "utf8Write");
    __name2(utf8Write, "utf8Write");
    function asciiWrite(buf2, string2, offset, length2) {
      return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
    }
    __name(asciiWrite, "asciiWrite");
    __name2(asciiWrite, "asciiWrite");
    function base64Write(buf2, string2, offset, length2) {
      return blitBuffer(base64ToBytes2(string2), buf2, offset, length2);
    }
    __name(base64Write, "base64Write");
    __name2(base64Write, "base64Write");
    function ucs2Write(buf2, string2, offset, length2) {
      return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
    }
    __name(ucs2Write, "ucs2Write");
    __name2(ucs2Write, "ucs2Write");
    Buffer3.prototype.write = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function write(string2, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length2);
          case "base64":
            return base64Write(this, string2, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write"), "write");
    Buffer3.prototype.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON2"), "toJSON");
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base642.fromByteArray(buf2);
      } else {
        return base642.fromByteArray(buf2.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    __name2(base64Slice, "base64Slice");
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      var res = [];
      var i22 = start;
      while (i22 < end) {
        var firstByte = buf2[i22];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i22 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i22 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i22 + 1];
              thirdByte = buf2[i22 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i22 + 1];
              thirdByte = buf2[i22 + 2];
              fourthByte = buf2[i22 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i22 += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    __name(utf8Slice2, "utf8Slice2");
    __name2(utf8Slice2, "utf8Slice");
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i22 = 0;
      while (i22 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i22, i22 += MAX_ARGUMENTS_LENGTH2)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray2, "decodeCodePointsArray2");
    __name2(decodeCodePointsArray2, "decodeCodePointsArray");
    function asciiSlice(buf2, start, end) {
      var ret = "";
      end = Math.min(buf2.length, end);
      for (var i22 = start; i22 < end; ++i22) {
        ret += String.fromCharCode(buf2[i22] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    __name2(asciiSlice, "asciiSlice");
    function latin1Slice(buf2, start, end) {
      var ret = "";
      end = Math.min(buf2.length, end);
      for (var i22 = start; i22 < end; ++i22) {
        ret += String.fromCharCode(buf2[i22]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    __name2(latin1Slice, "latin1Slice");
    function hexSlice(buf2, start, end) {
      var len = buf2.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i22 = start; i22 < end; ++i22) {
        out += hexSliceLookupTable[buf2[i22]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    __name2(hexSlice, "hexSlice");
    function utf16leSlice(buf2, start, end) {
      var bytes = buf2.slice(start, end);
      var res = "";
      for (var i22 = 0; i22 < bytes.length - 1; i22 += 2) {
        res += String.fromCharCode(bytes[i22] + bytes[i22 + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    __name2(utf16leSlice, "utf16leSlice");
    Buffer3.prototype.slice = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    }, "slice2"), "slice");
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    __name2(checkOffset, "checkOffset");
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul32 = 1;
      var i22 = 0;
      while (++i22 < byteLength2 && (mul32 *= 256)) {
        val += this[offset + i22] * mul32;
      }
      return val;
    }, "readUIntLE"), "readUIntLE");
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul32 = 1;
      while (byteLength2 > 0 && (mul32 *= 256)) {
        val += this[offset + --byteLength2] * mul32;
      }
      return val;
    }, "readUIntBE"), "readUIntBE");
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8"), "readUInt8");
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE"), "readUInt16LE");
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE"), "readUInt16BE");
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE"), "readUInt32LE");
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE"), "readUInt32BE");
    Buffer3.prototype.readIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul32 = 1;
      var i22 = 0;
      while (++i22 < byteLength2 && (mul32 *= 256)) {
        val += this[offset + i22] * mul32;
      }
      mul32 *= 128;
      if (val >= mul32)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntLE"), "readIntLE");
    Buffer3.prototype.readIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i22 = byteLength2;
      var mul32 = 1;
      var val = this[offset + --i22];
      while (i22 > 0 && (mul32 *= 256)) {
        val += this[offset + --i22] * mul32;
      }
      mul32 *= 128;
      if (val >= mul32)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntBE"), "readIntBE");
    Buffer3.prototype.readInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8"), "readInt8");
    Buffer3.prototype.readInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16LE"), "readInt16LE");
    Buffer3.prototype.readInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16BE"), "readInt16BE");
    Buffer3.prototype.readInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE"), "readInt32LE");
    Buffer3.prototype.readInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE"), "readInt32BE");
    Buffer3.prototype.readFloatLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    }, "readFloatLE"), "readFloatLE");
    Buffer3.prototype.readFloatBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    }, "readFloatBE"), "readFloatBE");
    Buffer3.prototype.readDoubleLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    }, "readDoubleLE"), "readDoubleLE");
    Buffer3.prototype.readDoubleBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    }, "readDoubleBE"), "readDoubleBE");
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    __name2(checkInt, "checkInt");
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul32 = 1;
      var i22 = 0;
      this[offset] = value & 255;
      while (++i22 < byteLength2 && (mul32 *= 256)) {
        this[offset + i22] = value / mul32 & 255;
      }
      return offset + byteLength2;
    }, "writeUIntLE"), "writeUIntLE");
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i22 = byteLength2 - 1;
      var mul32 = 1;
      this[offset + i22] = value & 255;
      while (--i22 >= 0 && (mul32 *= 256)) {
        this[offset + i22] = value / mul32 & 255;
      }
      return offset + byteLength2;
    }, "writeUIntBE"), "writeUIntBE");
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8"), "writeUInt8");
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE"), "writeUInt16LE");
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE"), "writeUInt16BE");
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE"), "writeUInt32LE");
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE"), "writeUInt32BE");
    Buffer3.prototype.writeIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i22 = 0;
      var mul32 = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i22 < byteLength2 && (mul32 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i22 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i22] = (value / mul32 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntLE"), "writeIntLE");
    Buffer3.prototype.writeIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i22 = byteLength2 - 1;
      var mul32 = 1;
      var sub = 0;
      this[offset + i22] = value & 255;
      while (--i22 >= 0 && (mul32 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i22 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i22] = (value / mul32 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntBE"), "writeIntBE");
    Buffer3.prototype.writeInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8"), "writeInt8");
    Buffer3.prototype.writeInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE"), "writeInt16LE");
    Buffer3.prototype.writeInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE"), "writeInt16BE");
    Buffer3.prototype.writeInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE"), "writeInt32LE");
    Buffer3.prototype.writeInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE"), "writeInt32BE");
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    __name2(checkIEEE754, "checkIEEE754");
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    __name2(writeFloat, "writeFloat");
    Buffer3.prototype.writeFloatLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE"), "writeFloatLE");
    Buffer3.prototype.writeFloatBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE"), "writeFloatBE");
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    __name2(writeDouble, "writeDouble");
    Buffer3.prototype.writeDoubleLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE"), "writeDoubleLE");
    Buffer3.prototype.writeDoubleBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE"), "writeDoubleBE");
    Buffer3.prototype.copy = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy"), "copy");
    Buffer3.prototype.fill = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code3 = val.charCodeAt(0);
          if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
            val = code3;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i22;
      if (typeof val === "number") {
        for (i22 = start; i22 < end; ++i22) {
          this[i22] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i22 = 0; i22 < end - start; ++i22) {
          this[i22 + start] = bytes[i22 % len];
        }
      }
      return this;
    }, "fill"), "fill");
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    __name2(base64clean, "base64clean");
    function utf8ToBytes2(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length2 = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i22 = 0; i22 < length2; ++i22) {
        codePoint = string2.charCodeAt(i22);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i22 + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes2, "utf8ToBytes2");
    __name2(utf8ToBytes2, "utf8ToBytes");
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i22 = 0; i22 < str.length; ++i22) {
        byteArray.push(str.charCodeAt(i22) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    __name2(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      var c2, hi, lo;
      var byteArray = [];
      for (var i22 = 0; i22 < str.length; ++i22) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i22);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    __name2(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes2(str) {
      return base642.toByteArray(base64clean(str));
    }
    __name(base64ToBytes2, "base64ToBytes2");
    __name2(base64ToBytes2, "base64ToBytes");
    function blitBuffer(src2, dst, offset, length2) {
      for (var i22 = 0; i22 < length2; ++i22) {
        if (i22 + offset >= dst.length || i22 >= src2.length)
          break;
        dst[i22 + offset] = src2[i22];
      }
      return i22;
    }
    __name(blitBuffer, "blitBuffer");
    __name2(blitBuffer, "blitBuffer");
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    __name(isInstance, "isInstance");
    __name2(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    __name2(numberIsNaN, "numberIsNaN");
    var hexSliceLookupTable = function() {
      var alphabet3 = "0123456789abcdef";
      var table = new Array(256);
      for (var i22 = 0; i22 < 16; ++i22) {
        var i16 = i22 * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet3[i22] + alphabet3[j];
        }
      }
      return table;
    }();
  }
});
var require_erc20_abi = __commonJS2({
  "src/wallet/plugins/EthereumPlugin/erc20.abi.json"(exports, module2) {
    module2.exports = [
      {
        constant: true,
        inputs: [],
        name: "name",
        outputs: [
          {
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_spender",
            type: "address"
          },
          {
            name: "_value",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_from",
            type: "address"
          },
          {
            name: "_to",
            type: "address"
          },
          {
            name: "_value",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "decimals",
        outputs: [
          {
            name: "",
            type: "uint8"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "_owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            name: "balance",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "symbol",
        outputs: [
          {
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_to",
            type: "address"
          },
          {
            name: "_value",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "_owner",
            type: "address"
          },
          {
            name: "_spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      }
    ];
  }
});
var require_uniswap_default_tokenlist = __commonJS2({
  "../../node_modules/.pnpm/@uniswap+default-token-list@4.1.0/node_modules/@uniswap/default-token-list/build/uniswap-default.tokenlist.json"(exports, module2) {
    module2.exports = {
      name: "Uniswap Labs Default",
      timestamp: "2022-06-29T15:57:01.868Z",
      version: {
        major: 4,
        minor: 1,
        patch: 0
      },
      tags: {},
      logoURI: "ipfs://QmNa8mQkrNKp1WEEeGjFezDmDeodkWRevGFN8JCV7b4Xir",
      keywords: [
        "uniswap",
        "default"
      ],
      tokens: [
        {
          chainId: 1,
          address: "0x111111111117dC0aa78b770fA6A738034120C302",
          name: "1inch",
          symbol: "1INCH",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13469/thumb/1inch-token.png?1608803028",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f"
              },
              "42161": {
                tokenAddress: "0x6314C31A7a1652cE482cffe247E9CB7c3f4BB9aF"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9",
          name: "Aave",
          symbol: "AAVE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12645/thumb/AAVE.png?1601374110",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xD6DF932A45C0f255f85145f286eA0b292B21C90B"
              },
              "42161": {
                tokenAddress: "0xba5DdD1f9d7F570dc94a51479a000E3BCE967196"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xEd04915c23f00A313a544955524EB7DBD823143d",
          name: "Alchemy Pay",
          symbol: "ACH",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/12390/thumb/ACH_%281%29.png?1599691266"
        },
        {
          chainId: 1,
          address: "0x91Af0fBB28ABA7E31403Cb457106Ce79397FD4E6",
          name: "Aergo",
          symbol: "AERGO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4490/thumb/aergo.png?1647696770"
        },
        {
          chainId: 1,
          address: "0x32353A6C91143bfd6C7d363B546e62a9A2489A20",
          name: "Adventure Gold",
          symbol: "AGLD",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/18125/thumb/lpgblc4h_400x400.jpg?1630570955",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x6a6bD53d677F8632631662C48bD47b1D4D6524ee"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x626E8036dEB333b408Be468F951bdB42433cBF18",
          name: "AIOZ Network",
          symbol: "AIOZ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14631/thumb/aioz_logo.png?1617413126",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xe2341718c6C0CbFa8e6686102DD8FbF4047a9e9B"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF",
          name: "Alchemix",
          symbol: "ALCX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14113/thumb/Alchemix.png?1614409874",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x95c300e7740D2A88a44124B424bFC1cB2F9c3b89"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xAC51066d7bEC65Dc4589368da368b212745d63E8",
          name: "My Neighbor Alice",
          symbol: "ALICE",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/14375/thumb/alice_logo.jpg?1615782968",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x50858d870FAF55da2fD90FB6DF7c34b5648305C6"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xfF20817765cB7f73d4bde2e66e067E58D11095C2",
          name: "Amp",
          symbol: "AMP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12409/thumb/amp-200x200.png?1599625397",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0621d647cecbFb64b79E44302c1933cB4f27054d"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x8290333ceF9e6D528dD5618Fb97a76f268f3EDD4",
          name: "Ankr",
          symbol: "ANKR",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4324/thumb/U85xTl2.png?1608111978",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x101A023270368c0D50BFfb62780F4aFd4ea79C35"
              }
            }
          }
        },
        {
          name: "Aragon Network Token",
          address: "0x960b236A07cf122663c4303350609A66A7B288C0",
          symbol: "ANT",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x960b236A07cf122663c4303350609A66A7B288C0/logo.png"
        },
        {
          chainId: 1,
          address: "0x4d224452801ACEd8B2F0aebE155379bb5D594381",
          name: "ApeCoin",
          symbol: "APE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/24383/small/apecoin.jpg?1647476455",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xB7b31a6BC18e48888545CE79e83E06003bE70930"
              },
              "42161": {
                tokenAddress: "0x74885b4D524d497261259B38900f54e6dbAd2210"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0b38210ea11411557c13457D4dA7dC6ea731B88a",
          name: "API3",
          symbol: "API3",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13256/thumb/api3.jpg?1606751424",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x45C27821E80F8789b60Fd8B600C73815d34DDa6C"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xBA50933C268F567BDC86E1aC131BE072C6B0b71a",
          name: "ARPA Chain",
          symbol: "ARPA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/8506/thumb/9u0a23XY_400x400.jpg?1559027357",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xEE800B277A96B0f490a1A732e1D6395FAD960A26"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x64D91f12Ece7362F91A6f8E7940Cd55F05060b92",
          name: "ASH",
          symbol: "ASH",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15714/thumb/omnPqaTY.png?1622820503"
        },
        {
          chainId: 1,
          address: "0x2565ae0385659badCada1031DB704442E1b69982",
          name: "Assemble Protocol",
          symbol: "ASM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11605/thumb/gpvrlkSq_400x400_%281%29.jpg?1591775789"
        },
        {
          chainId: 1,
          address: "0xA9B1Eb5908CfC3cdf91F9B8B3a74108598009096",
          name: "Bounce",
          symbol: "AUCTION",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13860/thumb/1_KtgpRIJzuwfHe0Rl0avP_g.jpeg?1612412025"
        },
        {
          chainId: 1,
          address: "0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998",
          name: "Audius",
          symbol: "AUDIO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12913/thumb/AudiusCoinLogo_2x.png?1603425727",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x5eB8D998371971D01954205c7AFE90A7AF6a95AC"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x845576c64f9754CF09d87e45B720E82F3EeF522C",
          name: "Artverse Token",
          symbol: "AVT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/19727/thumb/ewnektoB_400x400.png?1635767094"
        },
        {
          chainId: 1,
          address: "0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b",
          name: "Axie Infinity",
          symbol: "AXS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13029/thumb/axie_infinity_logo.png?1604471082",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x61BDD9C7d4dF4Bf47A4508c0c8245505F2Af5b7b"
              },
              "42161": {
                tokenAddress: "0xe88998Fb579266628aF6a03e3821d5983e5D0089"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x3472A5A71965499acd81997a54BBA8D852C6E53d",
          name: "Badger DAO",
          symbol: "BADGER",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13287/thumb/badger_dao_logo.jpg?1607054976",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x1FcbE5937B0cc2adf69772D228fA4205aCF4D9b2"
              },
              "42161": {
                tokenAddress: "0xBfa641051Ba0a0Ad1b0AcF549a89536A0D76472E"
              }
            }
          }
        },
        {
          name: "Balancer",
          address: "0xba100000625a3754423978a60c9317c58a424e3D",
          symbol: "BAL",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xba100000625a3754423978a60c9317c58a424e3D/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3"
              },
              "42161": {
                tokenAddress: "0x040d1EdC9569d4Bab2D15287Dc5A4F10F56a56B8"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xBA11D00c5f74255f56a5E366F4F77f5A186d7f55",
          name: "Band Protocol",
          symbol: "BAND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9545/thumb/band-protocol.png?1568730326",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xA8b1E0764f85f53dfe21760e8AfE5446D82606ac"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0D8775F648430679A709E98d2b0Cb6250d2887EF",
          name: "Basic Attention Token",
          symbol: "BAT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/677/thumb/basic-attention-token.png?1547034427",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x3Cef98bb43d732E2F285eE605a8158cDE967D219"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xF17e65822b568B3903685a7c9F496CF7656Cc6C2",
          name: "Biconomy",
          symbol: "BICO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/21061/thumb/biconomy_logo.jpg?1638269749",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x91c89A94567980f0e9723b487b0beD586eE96aa7"
              },
              "42161": {
                tokenAddress: "0xa68Ec98D7ca870cF1Dd0b00EBbb7c4bF60A8e74d"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x5732046A883704404F284Ce41FfADd5b007FD668",
          name: "Bluzelle",
          symbol: "BLZ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2848/thumb/ColorIcon_3x.png?1622516510",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x438B28C5AA5F00a817b7Def7cE2Fb3d5d1970974"
              }
            }
          }
        },
        {
          name: "Bancor Network Token",
          address: "0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C",
          symbol: "BNT",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xc26D47d5c33aC71AC5CF9F776D63Ba292a4F7842"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0391D2021f89DC339F60Fff84546EA23E337750f",
          name: "BarnBridge",
          symbol: "BOND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12811/thumb/barnbridge.jpg?1602728853",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x3e7eF8f50246f725885102E8238CBba33F276747"
              },
              "137": {
                tokenAddress: "0xA041544fe2BE56CCe31Ebb69102B965E06aacE80"
              },
              "42161": {
                tokenAddress: "0x0D81E50bC677fa67341c44D7eaA9228DEE64A4e1"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x799ebfABE77a6E34311eeEe9825190B9ECe32824",
          name: "Braintrust",
          symbol: "BTRST",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/18100/thumb/braintrust.PNG?1630475394"
        },
        {
          chainId: 1,
          address: "0x3506424F91fD33084466F402d5D97f05F8e3b4AF",
          name: "Chiliz",
          symbol: "CHZ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/8834/thumb/Chiliz.png?1561970540",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xf1938Ce12400f9a761084E7A80d37e732a4dA056"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x80C62FE4487E1351b47Ba49809EBD60ED085bf52",
          name: "Clover Finance",
          symbol: "CLV",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15278/thumb/clover.png?1645084454"
        },
        {
          name: "Compound",
          address: "0xc00e94Cb662C3520282E6f5717214004A7f26888",
          symbol: "COMP",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc00e94Cb662C3520282E6f5717214004A7f26888/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c"
              },
              "42161": {
                tokenAddress: "0x354A6dA3fcde098F8389cad84b0182725c6C91dE"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xDDB3422497E61e13543BeA06989C0789117555c5",
          name: "COTI",
          symbol: "COTI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2962/thumb/Coti.png?1559653863",
          extensions: {
            bridgeInfo: {
              "42161": {
                tokenAddress: "0x6FE14d3CC2f7bDdffBa5CdB3BBE7467dd81ea101"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x3D658390460295FB963f54dC0899cfb1c30776Df",
          name: "Circuits of Value",
          symbol: "COVAL",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/588/thumb/coval-logo.png?1599493950"
        },
        {
          chainId: 1,
          address: "0xA0b73E1Ff0B80914AB6fe0444E65848C4C34450b",
          name: "Cronos",
          symbol: "CRO",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/7310/thumb/oCw2s3GI_400x400.jpeg?1645172042",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xAdA58DF0F643D959C2A47c9D4d4c1a4deFe3F11C"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x08389495D7456E1951ddF7c3a1314A4bfb646d8B",
          name: "Crypterium",
          symbol: "CRPT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1901/thumb/crypt.png?1547036205"
        },
        {
          name: "Curve DAO Token",
          address: "0xD533a949740bb3306d119CC777fa900bA034cd52",
          symbol: "CRV",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xD533a949740bb3306d119CC777fa900bA034cd52/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x0994206dfE8De6Ec6920FF4D779B0d950605Fb53"
              },
              "137": {
                tokenAddress: "0x172370d5Cd63279eFa6d502DAB29171933a610AF"
              },
              "42161": {
                tokenAddress: "0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x491604c0FDF08347Dd1fa4Ee062a822A5DD06B5D",
          name: "Cartesi",
          symbol: "CTSI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11038/thumb/cartesi.png?1592288021",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x2727Ab1c2D22170ABc9b595177B2D5C6E1Ab7B7B"
              },
              "42161": {
                tokenAddress: "0x319f865b287fCC10b30d8cE6144e8b6D1b476999"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x321C2fE4446C7c963dc41Dd58879AF648838f98D",
          name: "Cryptex Finance",
          symbol: "CTX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14932/thumb/glossy_icon_-_C200px.png?1619073171",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x8c208BC2A808a088a78398fed8f2640cab0b6EDb"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xDf801468a808a32656D2eD2D2d80B72A129739f4",
          name: "Somnium Space CUBEs",
          symbol: "CUBE",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/10687/thumb/CUBE_icon.png?1617026861",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x276C9cbaa4BDf57d7109a41e67BD09699536FA3d"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x41e5560054824eA6B0732E656E3Ad64E20e94E45",
          name: "Civic",
          symbol: "CVC",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/788/thumb/civic.png?1547034556",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x66Dc5A08091d1968e08C16aA5b27BAC8398b02Be"
              },
              "42161": {
                tokenAddress: "0x9DfFB23CAd3322440bCcFF7aB1C58E781dDBF144"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B",
          name: "Convex Finance",
          symbol: "CVX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15585/thumb/convex.png?1621256328",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x4257EA7637c355F81616050CbB6a9b709fd72683"
              }
            }
          }
        },
        {
          name: "Dai Stablecoin",
          address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
          symbol: "DAI",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"
              },
              "137": {
                tokenAddress: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063"
              },
              "42161": {
                tokenAddress: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x3A880652F47bFaa771908C07Dd8673A787dAEd3A",
          name: "DerivaDAO",
          symbol: "DDX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13453/thumb/ddx_logo.png?1608741641",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x26f5FB1e6C8a65b3A873fF0a213FA16EFF5a7828"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x84cA8bc7997272c7CfB4D0Cd3D55cd942B3c9419",
          name: "DIA",
          symbol: "DIA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11955/thumb/image.png?1646041751",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x993f2CafE9dbE525243f4A78BeBC69DAc8D36000"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0AbdAce70D3790235af448C88547603b945604ea",
          name: "district0x",
          symbol: "DNT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/849/thumb/district0x.png?1547223762"
        },
        {
          chainId: 1,
          address: "0x92D6C1e31e14520e676a687F0a93788B716BEff5",
          name: "dYdX",
          symbol: "DYDX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17500/thumb/hjnIm9bV.jpg?1628009360",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x4C3bF0a3DE9524aF68327d1D2558a3B70d17D42a"
              },
              "42161": {
                tokenAddress: "0x51863cB90Ce5d6dA9663106F292fA27c8CC90c5a"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x761D38e5ddf6ccf6Cf7c55759d5210750B5D60F3",
          name: "Dogelon Mars",
          symbol: "ELON",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14962/thumb/6GxcPRo3_400x400.jpg?1619157413",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xE0339c80fFDE91F3e20494Df88d4206D86024cdF"
              },
              "42161": {
                tokenAddress: "0x3e4Cff6E50F37F731284A92d44AE943e17077fD4"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c",
          name: "Enjin Coin",
          symbol: "ENJ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1102/thumb/enjin-coin-logo.png?1547035078",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x7eC26842F195c852Fa843bB9f6D8B583a274a157"
              },
              "42161": {
                tokenAddress: "0x7fa9549791EFc9030e1Ed3F25D18014163806758"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72",
          name: "Ethereum Name Service",
          symbol: "ENS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/19785/thumb/acatxTm8_400x400.jpg?1635850140",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x65559aA14915a70190438eF90104769e5E890A00"
              },
              "137": {
                tokenAddress: "0xbD7A5Cf51d22930B8B3Df6d834F9BCEf90EE7c4f"
              },
              "42161": {
                tokenAddress: "0xfeA31d704DEb0975dA8e77Bf13E04239e70d7c28"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xBBc2AE13b23d715c30720F079fcd9B4a74093505",
          name: "Ethernity Chain",
          symbol: "ERN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14238/thumb/LOGO_HIGH_QUALITY.png?1647831402",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0E50BEA95Fe001A370A4F1C220C49AEdCB982DeC"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x1aBaEA1f7C830bD89Acc67eC4af516284b1bC33c",
          name: "Euro Coin",
          symbol: "EUROC",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/26045/thumb/euro-coin.png?1655394420",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x8a037dbcA8134FFc72C362e394e35E0Cad618F85"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xa0246c9032bC3A600820415aE600c6388619A14D",
          name: "Harvest Finance",
          symbol: "FARM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12304/thumb/Harvest.png?1613016180",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x176f5AB638cf4Ff3B6239Ba609C3fadAA46ef5B0"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xaea46A60368A7bD060eec7DF8CBa43b7EF41Ad85",
          name: "Fetch ai",
          symbol: "FET",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/5681/thumb/Fetch.jpg?1572098136",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x7583FEDDbceFA813dc18259940F76a02710A8905"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x77FbA179C79De5B7653F68b5039Af940AdA60ce0",
          name: "Ampleforth Governance Token",
          symbol: "FORTH",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14917/thumb/photo_2021-04-22_00.00.03.jpeg?1619020835",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x5eCbA59DAcc1ADc5bDEA35f38A732823fc3dE977"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xc770EEfAd204B5180dF6a14Ee197D99d808ee52d",
          name: "ShapeShift FOX Token",
          symbol: "FOX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9988/thumb/FOX.png?1574330622",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x65A05DB8322701724c197AF82C9CaE41195B0aA8"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x4E15361FD6b4BB609Fa63C81A2be19d873717870",
          name: "Fantom",
          symbol: "FTM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4001/thumb/Fantom.png?1558015016",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xC9c1c1c20B3658F8787CC2FD702267791f224Ce1"
              },
              "42161": {
                tokenAddress: "0xd42785D323e608B9E99fa542bd8b1000D4c2Df37"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x8c15Ef5b4B21951d50E53E4fbdA8298FFAD25057",
          name: "Function X",
          symbol: "FX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/8186/thumb/47271330_590071468072434_707260356350705664_n.jpg?1556096683"
        },
        {
          chainId: 1,
          address: "0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0",
          name: "Frax Share",
          symbol: "FXS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13423/thumb/frax_share.png?1608478989",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x3e121107F6F22DA4911079845a470757aF4e1A1b"
              },
              "42161": {
                tokenAddress: "0xd9f9d2Ee2d3EFE420699079f16D9e924affFdEA4"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x15D4c048F83bd7e37d49eA4C83a07267Ec4203dA",
          name: "Gala",
          symbol: "GALA",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/12493/thumb/GALA-COINGECKO.png?1600233435",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x09E1943Dd2A4e82032773594f50CF54453000b97"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xdab396cCF3d84Cf2D07C4454e10C8A6F5b008D2b",
          name: "Goldfinch",
          symbol: "GFI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/19081/thumb/GOLDFINCH.png?1634369662"
        },
        {
          chainId: 1,
          address: "0x7DD9c5Cba05E151C895FDe1CF355C9A1D5DA6429",
          name: "Golem",
          symbol: "GLM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/542/thumb/Golem_Submark_Positive_RGB.png?1606392013",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0B220b82F3eA3B7F6d9A1D8ab58930C064A2b5Bf"
              }
            }
          }
        },
        {
          name: "Gnosis Token",
          address: "0x6810e776880C02933D47DB1b9fc05908e5386b96",
          symbol: "GNO",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6810e776880C02933D47DB1b9fc05908e5386b96/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x5FFD62D3C3eE2E81C00A7b9079FB248e7dF024A8"
              },
              "42161": {
                tokenAddress: "0xa0b862F60edEf4452F25B4160F177db44DeB6Cf1"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xccC8cb5229B0ac8069C51fd58367Fd1e622aFD97",
          name: "Gods Unchained",
          symbol: "GODS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17139/thumb/10631.png?1635718182",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xF88fc6b493eda7650E4bcf7A290E8d108F677CfE"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xc944E90C64B2c07662A292be6244BDf05Cda44a7",
          name: "The Graph",
          symbol: "GRT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13397/thumb/Graph_Token.png?1608145566",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x5fe2B58c013d7601147DcdD68C143A77499f5531"
              },
              "42161": {
                tokenAddress: "0x23A941036Ae778Ac51Ab04CEa08Ed6e2FE103614"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xDe30da39c46104798bB5aA3fe8B9e0e1F348163F",
          name: "Gitcoin",
          symbol: "GTC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15810/thumb/gitcoin.png?1621992929",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xdb95f9188479575F3F718a245EcA1B3BF74567EC"
              },
              "42161": {
                tokenAddress: "0x7f9a7DB853Ca816B9A138AEe3380Ef34c437dEe0"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd",
          name: "Gemini Dollar",
          symbol: "GUSD",
          decimals: 2,
          logoURI: "https://assets.coingecko.com/coins/images/5992/thumb/gemini-dollar-gusd.png?1536745278",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xC8A94a3d3D2dabC3C1CaffFFDcA6A7543c3e3e65"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xC08512927D12348F6620a698105e1BAac6EcD911",
          name: "GYEN",
          symbol: "GYEN",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/14191/thumb/icon_gyen_200_200.png?1614843343",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x482bc619eE7662759CDc0685B4E78f464Da39C73"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x71Ab77b7dbB4fa7e017BC15090b2163221420282",
          name: "Highstreet",
          symbol: "HIGH",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/18973/thumb/logosq200200Coingecko.png?1634090470"
        },
        {
          chainId: 1,
          address: "0xB705268213D593B8FD88d3FDEFF93AFF5CbDcfAE",
          name: "IDEX",
          symbol: "IDEX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2565/thumb/logomark-purple-286x286.png?1638362736",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x9Cb74C8032b007466865f060ad2c46145d45553D"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xF57e7e7C23978C3cAEC3C3548E3D615c346e79fF",
          name: "Immutable X",
          symbol: "IMX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17233/thumb/imx.png?1636691817",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x183070C90B34A63292cC908Ce1b263Cb56D49A7F"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xe28b3B32B6c345A34Ff64674606124Dd5Aceca30",
          name: "Injective",
          symbol: "INJ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12882/thumb/Secondary_Symbol.png?1628233237",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x4E8dc2149EaC3f3dEf36b1c281EA466338249371"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x41D5D79431A913C4aE7d69a668ecdfE5fF9DFB68",
          name: "Inverse Finance",
          symbol: "INV",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14205/thumb/inverse_finance.jpg?1614921871",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xF18Ac368001b0DdC80aA6a8374deb49e868EFDb8"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x6fB3e0A217407EFFf7Ca062D46c26E5d60a14d69",
          name: "IoTeX",
          symbol: "IOTX",
          decimals: 18,
          logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/2777.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xf6372cDb9c1d3674E83842e3800F2A62aC9F3C66"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x7420B4b9a0110cdC71fB720908340C03F9Bc03EC",
          name: "JasmyCoin",
          symbol: "JASMY",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13876/thumb/JASMY200x200.jpg?1612473259",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xb87f5c1E81077FfcfE821dA240fd20C99c533aF1"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x85Eee30c52B0b379b046Fb0F85F4f3Dc3009aFEC",
          name: "Keep Network",
          symbol: "KEEP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3373/thumb/IuNzUb5b_400x400.jpg?1589526336",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x42f37A1296b2981F7C3cAcEd84c5096b2Eb0C72C"
              }
            }
          }
        },
        {
          name: "Kyber Network Crystal",
          address: "0xdd974D5C2e2928deA5F71b9825b8b646686BD200",
          symbol: "KNC",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdd974D5C2e2928deA5F71b9825b8b646686BD200/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x324b28d6565f784d596422B0F2E5aB6e9CFA1Dc7"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44",
          name: "Keep3rV1",
          symbol: "KP3R",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12966/thumb/kp3r_logo.jpg?1607057458",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x53AEc293212E3B792563Bc16f1be26956adb12e9"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x464eBE77c293E473B48cFe96dDCf88fcF7bFDAC0",
          name: "KRYLL",
          symbol: "KRL",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2807/thumb/krl.png?1547036979"
        },
        {
          chainId: 1,
          address: "0x037A54AaB062628C9Bbae1FDB1583c195585fe41",
          name: "LCX",
          symbol: "LCX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9985/thumb/zRPSu_0o_400x400.jpg?1574327008",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xE8A51D0dD1b4525189ddA2187F90ddF0932b5482"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32",
          name: "Lido DAO",
          symbol: "LDO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13573/thumb/Lido_DAO.png?1609873644",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xC3C7d422809852031b44ab29EEC9F1EfF2A58756"
              }
            }
          }
        },
        {
          name: "ChainLink Token",
          address: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
          symbol: "LINK",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x514910771AF9Ca656af840dff83E8264EcF986CA/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6"
              },
              "137": {
                tokenAddress: "0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39"
              },
              "42161": {
                tokenAddress: "0xf97f4df75117a78c1A5a0DBb814Af92458539FB4"
              }
            }
          }
        },
        {
          name: "Loom Network",
          address: "0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0",
          symbol: "LOOM",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x66EfB7cC647e0efab02eBA4316a2d2941193F6b3"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x58b6A8A3302369DAEc383334672404Ee733aB239",
          name: "Livepeer",
          symbol: "LPT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/7137/thumb/logo-circle-green.png?1619593365",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x3962F4A0A0051DccE0be73A7e09cEf5756736712"
              },
              "42161": {
                tokenAddress: "0x289ba1701C2F088cf0faf8B3705246331cB8A839"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x6DEA81C8171D0bA574754EF6F8b412F2Ed88c54D",
          name: "Liquity",
          symbol: "LQTY",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14665/thumb/200-lqty-icon.png?1617631180",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x8Ab2Fec94d17ae69FB90E7c773f2C85Ed1802c01"
              }
            }
          }
        },
        {
          name: "LoopringCoin V2",
          address: "0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD",
          symbol: "LRC",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0xFEaA9194F9F8c1B65429E31341a103071464907E"
              },
              "137": {
                tokenAddress: "0x84e1670F61347CDaeD56dcc736FB990fBB47ddC1"
              },
              "42161": {
                tokenAddress: "0x46d0cE7de6247b0A95f67b43B589b4041BaE7fbE"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0F5D2fB29fb7d3CFeE444a200298f468908cC942",
          name: "Decentraland",
          symbol: "MANA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/878/thumb/decentraland-mana.png?1550108745",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4"
              },
              "42161": {
                tokenAddress: "0x442d24578A564EF628A65e6a7E3e7be2a165E231"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074",
          name: "Mask Network",
          symbol: "MASK",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14051/thumb/Mask_Network.jpg?1614050316",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x3390108E913824B8eaD638444cc52B9aBdF63798"
              },
              "137": {
                tokenAddress: "0x2B9E7ccDF0F4e5B24757c1E1a80e311E34Cb10c7"
              },
              "42161": {
                tokenAddress: "0x533A7B414CD1236815a5e09F1E97FC7d5c313739"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0",
          name: "Polygon",
          symbol: "MATIC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4713/thumb/matic-token-icon.png?1624446912",
          extensions: {
            bridgeInfo: {
              "42161": {
                tokenAddress: "0x561877b6b3DD7651313794e5F2894B2F18bE0766"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x949D48EcA67b17269629c7194F4b727d4Ef9E5d6",
          name: "Merit Circle",
          symbol: "MC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/19304/thumb/Db4XqML.png?1634972154"
        },
        {
          chainId: 1,
          address: "0xfC98e825A2264D890F9a1e68ed50E1526abCcacD",
          name: "Moss Carbon Credit",
          symbol: "MCO2",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14414/thumb/ENtxnThA_400x400.jpg?1615948522",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xAa7DbD1598251f856C12f63557A4C4397c253Cea"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x814e0908b12A99FeCf5BC101bB5d0b8B5cDf7d26",
          name: "Measurable Data Token",
          symbol: "MDT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2441/thumb/mdt_logo.png?1569813574"
        },
        {
          chainId: 1,
          address: "0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3",
          name: "Magic Internet Money",
          symbol: "MIM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/16786/thumb/mimlogopng.png?1624979612",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x01288e04435bFcd4718FF203D6eD18146C17Cd4b"
              },
              "42161": {
                tokenAddress: "0xB20A02dfFb172C474BC4bDa3fD6f4eE70C04daf2"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x09a3EcAFa817268f77BE1283176B946C4ff2E608",
          name: "Mirror Protocol",
          symbol: "MIR",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13295/thumb/mirror_logo_transparent.png?1611554658",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x1C5cccA2CB59145A4B25F452660cbA6436DDce9b"
              }
            }
          }
        },
        {
          name: "Maker",
          address: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2",
          symbol: "MKR",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0xab7bAdEF82E9Fe11f6f33f87BC9bC2AA27F2fCB5"
              },
              "137": {
                tokenAddress: "0x6f7C932e7684666C9fd1d44527765433e01fF61d"
              },
              "42161": {
                tokenAddress: "0x2e9a6Df78E42a30712c10a9Dc4b1C8656f8F2879"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xec67005c4E498Ec7f55E092bd1d35cbC47C91892",
          name: "Melon",
          symbol: "MLN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/605/thumb/melon.png?1547034295",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xa9f37D84c856fDa3812ad0519Dad44FA0a3Fe207"
              },
              "42161": {
                tokenAddress: "0x8f5c1A99b1df736Ad685006Cb6ADCA7B7Ae4b514"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x33349B282065b0284d756F0577FB39c158F935e6",
          name: "Maple",
          symbol: "MPL",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14097/thumb/photo_2021-05-03_14.20.41.jpeg?1620022863"
        },
        {
          chainId: 1,
          address: "0x65Ef703f5594D2573eb71Aaf55BC0CB548492df4",
          name: "Multichain",
          symbol: "MULTI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/22087/thumb/1_Wyot-SDGZuxbjdkaOeT2-A.png?1640764238"
        },
        {
          chainId: 1,
          address: "0xe2f2a5C287993345a840Db3B0845fbC70f5935a5",
          name: "mStable USD",
          symbol: "MUSD",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11576/thumb/mStable_USD.png?1595591803"
        },
        {
          chainId: 1,
          address: "0x9E46A38F5DaaBe8683E10793b06749EEF7D733d1",
          name: "PolySwarm",
          symbol: "NCT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2843/thumb/ImcYCVfX_400x400.jpg?1628519767",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x4985E0B13554fB521840e893574D3848C10Fcc6f"
              },
              "42161": {
                tokenAddress: "0x53236015A675fcB937485F1AE58040e4Fb920d5b"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x5Cf04716BA20127F1E2297AdDCf4B5035000c9eb",
          name: "NKN",
          symbol: "NKN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3375/thumb/nkn.png?1548329212"
        },
        {
          name: "Numeraire",
          address: "0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671",
          symbol: "NMR",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0Bf519071b02F22C17E7Ed5F4002ee1911f46729"
              },
              "42161": {
                tokenAddress: "0x597701b32553b9fa473e21362D480b3a6B569711"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x4fE83213D56308330EC302a8BD641f1d0113A4Cc",
          name: "NuCypher",
          symbol: "NU",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3318/thumb/photo1198982838879365035.jpg?1547037916"
        },
        {
          chainId: 1,
          address: "0x967da4048cD07aB37855c090aAF366e4ce1b9F48",
          name: "Ocean Protocol",
          symbol: "OCEAN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3687/thumb/ocean-protocol-logo.jpg?1547038686",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x282d8efCe846A88B159800bd4130ad77443Fa1A1"
              },
              "42161": {
                tokenAddress: "0x933d31561e470478079FEB9A6Dd2691fAD8234DF"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x8207c1FfC5B6804F6024322CcF34F29c3541Ae26",
          name: "Origin Protocol",
          symbol: "OGN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3296/thumb/op.jpg?1547037878",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xa63Beffd33AB3a2EfD92a39A7D2361CEE14cEbA8"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xd26114cd6EE289AccF82350c8d8487fedB8A0C07",
          name: "OMG Network",
          symbol: "OMG",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/776/thumb/OMG_Network.jpg?1591167168",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x62414D03084EeB269E18C970a21f45D2967F0170"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x6F59e0461Ae5E2799F1fB3847f05a63B16d0DbF8",
          name: "ORCA Alliance",
          symbol: "ORCA",
          decimals: 18,
          logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/5183.png"
        },
        {
          chainId: 1,
          address: "0x0258F474786DdFd37ABCE6df6BBb1Dd5dfC4434a",
          name: "Orion Protocol",
          symbol: "ORN",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/11841/thumb/orion_logo.png?1594943318",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0EE392bA5ef1354c9bd75a98044667d307C0e773"
              }
            }
          }
        },
        {
          name: "Orchid",
          address: "0x4575f41308EC1483f3d399aa9a2826d74Da13Deb",
          symbol: "OXT",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4575f41308EC1483f3d399aa9a2826d74Da13Deb/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x9880e3dDA13c8e7D4804691A45160102d31F6060"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xc1D204d77861dEf49b6E769347a883B15EC397Ff",
          name: "PayperEx",
          symbol: "PAX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1601/thumb/pax.png?1547035800"
        },
        {
          chainId: 1,
          address: "0x45804880De22913dAFE09f4980848ECE6EcbAf78",
          name: "PAX Gold",
          symbol: "PAXG",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9519/thumb/paxg.PNG?1568542565",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x553d3D295e0f695B9228246232eDF400ed3560B5"
              },
              "42161": {
                tokenAddress: "0xfEb4DfC8C4Cf7Ed305bb08065D08eC6ee6728429"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xbC396689893D065F41bc2C6EcbeE5e0085233447",
          name: "Perpetual Protocol",
          symbol: "PERP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12381/thumb/60d18e06844a844ad75901a9_mark_only_03.png?1628674771",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x9e1028F5F1D5eDE59748FFceE5532509976840E0"
              },
              "137": {
                tokenAddress: "0x263534a4Fe3cb249dF46810718B7B612a30ebbff"
              },
              "42161": {
                tokenAddress: "0x753D224bCf9AAFaCD81558c32341416df61D3DAC"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x3a4f40631a4f906c2BaD353Ed06De7A5D3fCb430",
          name: "PlayDapp",
          symbol: "PLA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14316/thumb/54023228.png?1615366911",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x8765f05ADce126d70bcdF1b0a48Db573316662eB"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xD8912C10681D8B21Fd3742244f44658dBA12264E",
          name: "Pluton",
          symbol: "PLU",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1241/thumb/pluton.png?1548331624",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x7dc0cb65EC6019330a6841e9c274f2EE57A6CA6C"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x83e6f1E41cdd28eAcEB20Cb649155049Fac3D5Aa",
          name: "Polkastarter",
          symbol: "POLS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12648/thumb/polkastarter.png?1609813702",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x8dc302e2141DA59c934d900886DbF1518Fd92cd4"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x9992eC3cF6A55b00978cdDF2b27BC6882d88D1eC",
          name: "Polymath",
          symbol: "POLY",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2784/thumb/inKkF01.png?1605007034",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xcB059C5573646047D6d88dDdb87B745C18161d3b"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x595832F8FC6BF59c85C527fEC3740A1b7a361269",
          name: "Power Ledger",
          symbol: "POWR",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/1104/thumb/power-ledger.png?1547035082",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0AaB8DC887D34f00D50E19aee48371a941390d14"
              },
              "42161": {
                tokenAddress: "0x4e91F2AF1ee0F84B529478f19794F5AFD423e4A6"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x226bb599a12C826476e3A771454697EA52E9E220",
          name: "Propy",
          symbol: "PRO",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/869/thumb/propy.png?1548332100",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x82FFdFD1d8699E8886a4e77CeFA9dd9710a7FefD"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x4a220E6096B25EADb88358cb44068A3248254675",
          name: "Quant",
          symbol: "QNT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3370/thumb/5ZOu7brX_400x400.jpg?1612437252",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x36B77a184bE8ee56f5E81C56727B20647A42e28E"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x99ea4dB9EE77ACD40B119BD1dC4E33e1C070b80d",
          name: "Quantstamp",
          symbol: "QSP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1219/thumb/0_E0kZjb4dG4hUnoDD_.png?1604815917"
        },
        {
          chainId: 1,
          address: "0x6c28AeF8977c9B773996d0e8376d2EE379446F2f",
          name: "Quickswap",
          symbol: "QUICK",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13970/thumb/1_pOU6pBMEmiL-ZJVb0CYRjQ.png?1613386659",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x831753DD7087CaC61aB5644b308642cc1c33Dc13"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x31c8EAcBFFdD875c74b94b077895Bd78CF1E64A3",
          name: "Radicle",
          symbol: "RAD",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14013/thumb/radicle.png?1614402918",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x2f81e176471CC57fDC76f7d332FB4511bF2bebDD"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919",
          name: "Rai Reflex Index",
          symbol: "RAI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14004/thumb/RAI-logo-coin.png?1613592334",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x7FB688CCf682d58f86D7e38e03f9D22e7705448B"
              },
              "137": {
                tokenAddress: "0x00e5646f60AC6Fb446f621d146B6E1886f002905"
              },
              "42161": {
                tokenAddress: "0xaeF5bbcbFa438519a5ea80B4c7181B4E78d419f2"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xba5BDe662c17e2aDFF1075610382B9B691296350",
          name: "SuperRare",
          symbol: "RARE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17753/thumb/RARE.jpg?1629220534"
        },
        {
          chainId: 1,
          address: "0xFca59Cd816aB1eaD66534D82bc21E7515cE441CF",
          name: "Rarible",
          symbol: "RARI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11845/thumb/Rari.png?1594946953",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x780053837cE2CeEaD2A90D9151aA21FC89eD49c2"
              },
              "42161": {
                tokenAddress: "0xCF8600347Dc375C5f2FdD6Dab9BB66e0b6773cd7"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xA4EED63db85311E22dF4473f87CcfC3DaDCFA3E3",
          name: "Rubic",
          symbol: "RBC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12629/thumb/200x200.png?1607952509",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xc3cFFDAf8F3fdF07da6D5e3A89B8723D5E385ff8"
              },
              "42161": {
                tokenAddress: "0x2E9AE8f178d5Ea81970C7799A377B3985cbC335F"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x6123B0049F904d730dB3C36a31167D9d4121fA6B",
          name: "Ribbon Finance",
          symbol: "RBN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15823/thumb/RBN_64x64.png?1633529723"
        },
        {
          name: "Republic Token",
          address: "0x408e41876cCCDC0F92210600ef50372656052a38",
          symbol: "REN",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x408e41876cCCDC0F92210600ef50372656052a38/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x19782D3Dc4701cEeeDcD90f0993f0A9126ed89d0"
              },
              "42161": {
                tokenAddress: "0x9fA891e1dB0a6D1eEAC4B929b5AAE1011C79a204"
              }
            }
          }
        },
        {
          name: "Reputation Augur v1",
          address: "0x1985365e9f78359a9B6AD760e32412f4a445E862",
          symbol: "REP",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1985365e9f78359a9B6AD760e32412f4a445E862/logo.png"
        },
        {
          name: "Reputation Augur v2",
          address: "0x221657776846890989a759BA2973e427DfF5C9bB",
          symbol: "REPv2",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x221657776846890989a759BA2973e427DfF5C9bB/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x6563c1244820CfBd6Ca8820FBdf0f2847363F733"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x8f8221aFbB33998d8584A2B05749bA73c37a938a",
          name: "Request",
          symbol: "REQ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1031/thumb/Request_icon_green.png?1643250951",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xAdf2F2Ed91755eA3f4bcC9107a494879f633ae7C"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xD291E7a03283640FDc51b121aC401383A46cC623",
          name: "Rari Governance Token",
          symbol: "RGT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12900/thumb/Rari_Logo_Transparent.png?1613978014",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0xB548f63D4405466B36C0c0aC3318a22fDcec711a"
              },
              "137": {
                tokenAddress: "0x3b9dB434F08003A89554CDB43b3e0b1f8734BdE7"
              },
              "42161": {
                tokenAddress: "0xef888bcA6AB6B1d26dbeC977C455388ecd794794"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x607F4C5BB672230e8672085532f7e901544a7375",
          name: "iExec RLC",
          symbol: "RLC",
          decimals: 9,
          logoURI: "https://assets.coingecko.com/coins/images/646/thumb/pL1VuXm.png?1604543202",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xbe662058e00849C3Eef2AC9664f37fEfdF2cdbFE"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xf1f955016EcbCd7321c7266BccFB96c68ea5E49b",
          name: "Rally",
          symbol: "RLY",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12843/thumb/image.png?1611212077"
        },
        {
          chainId: 1,
          address: "0x6De037ef9aD2725EB40118Bb1702EBb27e4Aeb24",
          name: "Render Token",
          symbol: "RNDR",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11636/thumb/rndr.png?1638840934",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x61299774020dA444Af134c82fa83E3810b309991"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x3845badAde8e6dFF049820680d1F14bD3903a5d0",
          name: "The Sandbox",
          symbol: "SAND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12129/thumb/sandbox_logo.jpg?1597397942",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE",
          name: "Shiba Inu",
          symbol: "SHIB",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11939/thumb/shiba.png?1622619446",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x6f8a06447Ff6FcF75d803135a7de15CE88C1d4ec"
              },
              "42161": {
                tokenAddress: "0x5033833c9fe8B9d3E09EEd2f73d2aaF7E3872fd1"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x7C84e62859D0715eb77d1b1C4154Ecd6aBB21BEC",
          name: "Shping",
          symbol: "SHPING",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2588/thumb/r_yabKKi_400x400.jpg?1639470164"
        },
        {
          chainId: 1,
          address: "0x00c83aeCC790e8a4453e5dD3B0B4b3680501a7A7",
          name: "SKALE",
          symbol: "SKL",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13245/thumb/SKALE_token_300x300.png?1606789574"
        },
        {
          chainId: 1,
          address: "0xCC8Fa225D80b9c7D42F96e9570156c65D6cAAa25",
          name: "Smooth Love Potion",
          symbol: "SLP",
          decimals: 0,
          logoURI: "https://assets.coingecko.com/coins/images/10366/thumb/SLP.png?1578640057",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0C7304fBAf2A320a1c50c46FE03752722F729946"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x744d70FDBE2Ba4CF95131626614a1763DF805B9E",
          name: "Status",
          symbol: "SNT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/779/thumb/status.png?1548610778"
        },
        {
          name: "Synthetix Network Token",
          address: "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F",
          symbol: "SNX",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4"
              },
              "137": {
                tokenAddress: "0x50B728D8D964fd00C2d0AAD81718b71311feF68a"
              },
              "42161": {
                tokenAddress: "0xcBA56Cd8216FCBBF3fA6DF6137F3147cBcA37D60"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xD31a59c85aE9D8edEFeC411D448f90841571b89c",
          name: "SOL Wormhole ",
          symbol: "SOL",
          decimals: 9,
          logoURI: "https://assets.coingecko.com/coins/images/22876/thumb/SOL_wh_small.png?1644224316",
          extensions: {
            bridgeInfo: {
              "42161": {
                tokenAddress: "0xb74Da9FE2F96B9E0a5f4A3cf0b92dd2bEC617124"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x090185f2135308BaD17527004364eBcC2D37e5F6",
          name: "Spell Token",
          symbol: "SPELL",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15861/thumb/abracadabra-3.png?1622544862",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xcdB3C70CD25FD15307D84C4F9D37d5C043B33Fb2"
              },
              "42161": {
                tokenAddress: "0x3E6648C5a70A150A88bCE65F4aD4d506Fe15d2AF"
              }
            }
          }
        },
        {
          name: "Storj Token",
          address: "0xB64ef51C888972c908CFacf59B47C1AfBC0Ab8aC",
          symbol: "STORJ",
          decimals: 8,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xB64ef51C888972c908CFacf59B47C1AfBC0Ab8aC/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xd72357dAcA2cF11A5F155b9FF7880E595A3F5792"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x006BeA43Baa3f7A6f765F14f10A1a1b08334EF45",
          name: "Stox",
          symbol: "STX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1230/thumb/stox-token.png?1547035256",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xB36e3391B22a970d31A9b620Ae1A414C6c256d2a"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0763fdCCF1aE541A5961815C0872A8c5Bc6DE4d7",
          name: "SUKU",
          symbol: "SUKU",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11969/thumb/UmfW5S6f_400x400.jpg?1596602238"
        },
        {
          chainId: 1,
          address: "0xe53EC727dbDEB9E2d5456c3be40cFF031AB40A55",
          name: "SuperFarm",
          symbol: "SUPER",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14040/thumb/6YPdWn6.png?1613975899",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xa1428174F516F527fafdD146b883bB4428682737"
              }
            }
          }
        },
        {
          name: "Synth sUSD",
          address: "0x57Ab1ec28D129707052df4dF418D58a2D46d5f51",
          symbol: "sUSD",
          decimals: 18,
          chainId: 1,
          logoURI: "https://assets.coingecko.com/coins/images/5013/thumb/sUSD.png?1616150765",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xF81b4Bec6Ca8f9fe7bE01CA734F55B2b6e03A7a0"
              },
              "42161": {
                tokenAddress: "0xA970AF1a584579B618be4d69aD6F73459D112F95"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2",
          name: "Sushi",
          symbol: "SUSHI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12271/thumb/512x512_Logo_no_chop.png?1606986688",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a"
              },
              "42161": {
                tokenAddress: "0xd4d42F0b6DEF4CE0383636770eF773390d85c61A"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0f2D719407FdBeFF09D87557AbB7232601FD9F29",
          name: "Synapse",
          symbol: "SYN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/18024/thumb/syn.png?1635002049",
          extensions: {
            bridgeInfo: {
              "42161": {
                tokenAddress: "0x1bCfc0B4eE1471674cd6A9F6B363A034375eAD84"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa",
          name: "tBTC",
          symbol: "TBTC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11224/thumb/tBTC.png?1589620754",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x50a4a434247089848991DD8f09b889D4e2870aB6"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x2e9d63788249371f1DFC918a52f8d799F4a38C94",
          name: "Tokemak",
          symbol: "TOKE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17495/thumb/tokemak-avatar-200px-black.png?1628131614",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xe1708AbDE4847B4929b70547E5197F1Ba1db2250"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xaA7a9CA87d3694B5755f213B5D04094b8d0F0A6F",
          name: "OriginTrail",
          symbol: "TRAC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1877/thumb/TRAC.jpg?1635134367",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xA7b98d63a137bF402b4570799ac4caD0BB1c4B1c"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x88dF592F8eb5D7Bd38bFeF7dEb0fBc02cf3778a0",
          name: "Tellor",
          symbol: "TRB",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9644/thumb/Blk_icon_current.png?1584980686",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xE3322702BEdaaEd36CdDAb233360B939775ae5f1"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B",
          name: "Tribe",
          symbol: "TRIBE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14575/thumb/tribe.PNG?1617487954",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x8676815789211E799a6DC86d02748ADF9cF86836"
              },
              "42161": {
                tokenAddress: "0xBfAE6fecD8124ba33cbB2180aAb0Fe4c03914A5A"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784",
          name: "TrueFi",
          symbol: "TRU",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/13180/thumb/truefi_glyph_color.png?1617610941",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x5b77bCA482bd3E7958b1103d123888EfCCDaF803"
              }
            }
          }
        },
        {
          name: "UMA Voting Token v1",
          address: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828",
          symbol: "UMA",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0xE7798f023fC62146e8Aa1b36Da45fb70855a77Ea"
              },
              "137": {
                tokenAddress: "0x3066818837c5e6eD6601bd5a91B0762877A6B731"
              },
              "42161": {
                tokenAddress: "0xd693Ec944A85eeca4247eC1c3b130DCa9B0C3b22"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x441761326490cACF7aF299725B6292597EE822c2",
          name: "Unifi Protocol DAO",
          symbol: "UNFI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13152/thumb/logo-2.png?1605748967"
        },
        {
          name: "Uniswap",
          address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
          symbol: "UNI",
          decimals: 18,
          chainId: 1,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x6fd9d7AD17242c41f7131d257212c54A0e816691"
              },
              "137": {
                tokenAddress: "0xb33EaAd8d922B1083446DC23f610c2567fB5180f"
              },
              "42161": {
                tokenAddress: "0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x70D2b7C19352bB76e4409858FF5746e500f2B67c",
          name: "Pawtocol",
          symbol: "UPI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12186/thumb/pawtocol.jpg?1597962008"
        },
        {
          name: "USDCoin",
          address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          symbol: "USDC",
          decimals: 6,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
              },
              "137": {
                tokenAddress: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
              },
              "42161": {
                tokenAddress: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8"
              }
            }
          }
        },
        {
          name: "Tether USD",
          address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
          symbol: "USDT",
          decimals: 6,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdAC17F958D2ee523a2206206994597C13D831ec7/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58"
              },
              "137": {
                tokenAddress: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F"
              },
              "42161": {
                tokenAddress: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x3C4B6E6e1eA3D4863700D7F76b36B7f3D3f13E3d",
          name: "Voyager Token",
          symbol: "VGX",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/794/thumb/Voyager-vgx.png?1575693595"
        },
        {
          name: "Wrapped BTC",
          address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
          symbol: "WBTC",
          decimals: 8,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png",
          extensions: {
            bridgeInfo: {
              "10": {
                tokenAddress: "0x68f180fcCe6836688e9084f035309E29Bf0A2095"
              },
              "137": {
                tokenAddress: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6"
              },
              "42161": {
                tokenAddress: "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f"
              }
            }
          }
        },
        {
          name: "Wrapped Ether",
          address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
          symbol: "WETH",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png",
          extensions: {
            bridgeInfo: {
              "42161": {
                tokenAddress: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x55296f69f40Ea6d20E478533C15A6B08B654E758",
          name: "XYO Network",
          symbol: "XYO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4519/thumb/XYO_Network-logo.png?1547039819",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xd2507e7b5794179380673870d88B22F94da6abe0"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e",
          name: "yearn finance",
          symbol: "YFI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11849/thumb/yfi-192x192.png?1598325330",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xDA537104D6A5edd53c6fBba9A898708E465260b6"
              },
              "42161": {
                tokenAddress: "0x82e3A8F066a6989666b031d916c43672085b1582"
              }
            }
          }
        },
        {
          chainId: 1,
          address: "0xa1d0E215a23d7030842FC67cE582a6aFa3CCaB83",
          name: "DFI money",
          symbol: "YFII",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11902/thumb/YFII-logo.78631676.png?1598677348",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0xb8cb8a7F4C2885C03e57E973C74827909Fdc2032"
              }
            }
          }
        },
        {
          name: "0x Protocol Token",
          address: "0xE41d2489571d322189246DaFA5ebDe1F4699F498",
          symbol: "ZRX",
          decimals: 18,
          chainId: 1,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xE41d2489571d322189246DaFA5ebDe1F4699F498/logo.png",
          extensions: {
            bridgeInfo: {
              "137": {
                tokenAddress: "0x5559Edb74751A0edE9DeA4DC23aeE72cCA6bE3D5"
              },
              "42161": {
                tokenAddress: "0xBD591Bd4DdB64b77B5f76Eab8f03d02519235Ae2"
              }
            }
          }
        },
        {
          name: "Dai Stablecoin",
          address: "0xaD6D458402F60fD3Bd25163575031ACDce07538D",
          symbol: "DAI",
          decimals: 18,
          chainId: 3,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xaD6D458402F60fD3Bd25163575031ACDce07538D/logo.png"
        },
        {
          name: "Uniswap",
          address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
          symbol: "UNI",
          decimals: 18,
          chainId: 3,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
        },
        {
          name: "Wrapped Ether",
          address: "0xc778417E063141139Fce010982780140Aa0cD5Ab",
          symbol: "WETH",
          decimals: 18,
          chainId: 3,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc778417E063141139Fce010982780140Aa0cD5Ab/logo.png"
        },
        {
          name: "Dai Stablecoin",
          address: "0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735",
          symbol: "DAI",
          decimals: 18,
          chainId: 4,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735/logo.png"
        },
        {
          name: "Maker",
          address: "0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85",
          symbol: "MKR",
          decimals: 18,
          chainId: 4,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85/logo.png"
        },
        {
          name: "Uniswap",
          address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
          symbol: "UNI",
          decimals: 18,
          chainId: 4,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
        },
        {
          name: "Wrapped Ether",
          address: "0xc778417E063141139Fce010982780140Aa0cD5Ab",
          symbol: "WETH",
          decimals: 18,
          chainId: 4,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc778417E063141139Fce010982780140Aa0cD5Ab/logo.png"
        },
        {
          name: "Uniswap",
          address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
          symbol: "UNI",
          decimals: 18,
          chainId: 5,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
        },
        {
          name: "Wrapped Ether",
          address: "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6",
          symbol: "WETH",
          decimals: 18,
          chainId: 5,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6/logo.png"
        },
        {
          chainId: 10,
          address: "0x3e7eF8f50246f725885102E8238CBba33F276747",
          name: "BarnBridge",
          symbol: "BOND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12811/thumb/barnbridge.jpg?1602728853",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0391D2021f89DC339F60Fff84546EA23E337750f"
              }
            }
          }
        },
        {
          name: "Curve DAO Token",
          address: "0x0994206dfE8De6Ec6920FF4D779B0d950605Fb53",
          symbol: "CRV",
          decimals: 18,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xD533a949740bb3306d119CC777fa900bA034cd52/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD533a949740bb3306d119CC777fa900bA034cd52"
              }
            }
          }
        },
        {
          name: "Dai Stablecoin",
          address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
          symbol: "DAI",
          decimals: 18,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6B175474E89094C44Da98b954EedeAC495271d0F"
              }
            }
          }
        },
        {
          chainId: 10,
          address: "0x65559aA14915a70190438eF90104769e5E890A00",
          name: "Ethereum Name Service",
          symbol: "ENS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/19785/thumb/acatxTm8_400x400.jpg?1635850140",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72"
              }
            }
          }
        },
        {
          name: "ChainLink Token",
          address: "0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6",
          symbol: "LINK",
          decimals: 18,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x514910771AF9Ca656af840dff83E8264EcF986CA/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x514910771AF9Ca656af840dff83E8264EcF986CA"
              }
            }
          }
        },
        {
          name: "LoopringCoin V2",
          address: "0xFEaA9194F9F8c1B65429E31341a103071464907E",
          symbol: "LRC",
          decimals: 18,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD"
              }
            }
          }
        },
        {
          chainId: 10,
          address: "0x3390108E913824B8eaD638444cc52B9aBdF63798",
          name: "Mask Network",
          symbol: "MASK",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14051/thumb/Mask_Network.jpg?1614050316",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074"
              }
            }
          }
        },
        {
          name: "Maker",
          address: "0xab7bAdEF82E9Fe11f6f33f87BC9bC2AA27F2fCB5",
          symbol: "MKR",
          decimals: 18,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2"
              }
            }
          }
        },
        {
          chainId: 10,
          address: "0x9e1028F5F1D5eDE59748FFceE5532509976840E0",
          name: "Perpetual Protocol",
          symbol: "PERP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12381/thumb/60d18e06844a844ad75901a9_mark_only_03.png?1628674771",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xbC396689893D065F41bc2C6EcbeE5e0085233447"
              }
            }
          }
        },
        {
          chainId: 10,
          address: "0x7FB688CCf682d58f86D7e38e03f9D22e7705448B",
          name: "Rai Reflex Index",
          symbol: "RAI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14004/thumb/RAI-logo-coin.png?1613592334",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919"
              }
            }
          }
        },
        {
          chainId: 10,
          address: "0xB548f63D4405466B36C0c0aC3318a22fDcec711a",
          name: "Rari Governance Token",
          symbol: "RGT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12900/thumb/Rari_Logo_Transparent.png?1613978014",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD291E7a03283640FDc51b121aC401383A46cC623"
              }
            }
          }
        },
        {
          name: "Synthetix Network Token",
          address: "0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4",
          symbol: "SNX",
          decimals: 18,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F"
              }
            }
          }
        },
        {
          name: "UMA Voting Token v1",
          address: "0xE7798f023fC62146e8Aa1b36Da45fb70855a77Ea",
          symbol: "UMA",
          decimals: 18,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828"
              }
            }
          }
        },
        {
          name: "Uniswap",
          address: "0x6fd9d7AD17242c41f7131d257212c54A0e816691",
          symbol: "UNI",
          decimals: 18,
          chainId: 10,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984"
              }
            }
          }
        },
        {
          name: "USDCoin",
          address: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607",
          symbol: "USDC",
          decimals: 6,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
              }
            }
          }
        },
        {
          name: "Tether USD",
          address: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",
          symbol: "USDT",
          decimals: 6,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdAC17F958D2ee523a2206206994597C13D831ec7/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xdAC17F958D2ee523a2206206994597C13D831ec7"
              }
            }
          }
        },
        {
          name: "Wrapped BTC",
          address: "0x68f180fcCe6836688e9084f035309E29Bf0A2095",
          symbol: "WBTC",
          decimals: 8,
          chainId: 10,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599"
              }
            }
          }
        },
        {
          name: "Dai Stablecoin",
          address: "0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa",
          symbol: "DAI",
          decimals: 18,
          chainId: 42,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa/logo.png"
        },
        {
          name: "Maker",
          address: "0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD",
          symbol: "MKR",
          decimals: 18,
          chainId: 42,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD/logo.png"
        },
        {
          name: "Uniswap",
          address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
          symbol: "UNI",
          decimals: 18,
          chainId: 42,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
        },
        {
          name: "Wrapped Ether",
          address: "0xd0A1E359811322d97991E03f863a0C30C2cF029C",
          symbol: "WETH",
          decimals: 18,
          chainId: 42,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xd0A1E359811322d97991E03f863a0C30C2cF029C/logo.png"
        },
        {
          chainId: 137,
          address: "0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f",
          name: "1inch",
          symbol: "1INCH",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13469/thumb/1inch-token.png?1608803028",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x111111111117dC0aa78b770fA6A738034120C302"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xD6DF932A45C0f255f85145f286eA0b292B21C90B",
          name: "Aave",
          symbol: "AAVE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12645/thumb/AAVE.png?1601374110",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x6a6bD53d677F8632631662C48bD47b1D4D6524ee",
          name: "Adventure Gold",
          symbol: "AGLD",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/18125/thumb/lpgblc4h_400x400.jpg?1630570955",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x32353A6C91143bfd6C7d363B546e62a9A2489A20"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xe2341718c6C0CbFa8e6686102DD8FbF4047a9e9B",
          name: "AIOZ Network",
          symbol: "AIOZ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14631/thumb/aioz_logo.png?1617413126",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x626E8036dEB333b408Be468F951bdB42433cBF18"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x95c300e7740D2A88a44124B424bFC1cB2F9c3b89",
          name: "Alchemix",
          symbol: "ALCX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14113/thumb/Alchemix.png?1614409874",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x50858d870FAF55da2fD90FB6DF7c34b5648305C6",
          name: "My Neighbor Alice",
          symbol: "ALICE",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/14375/thumb/alice_logo.jpg?1615782968",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xAC51066d7bEC65Dc4589368da368b212745d63E8"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x0621d647cecbFb64b79E44302c1933cB4f27054d",
          name: "Amp",
          symbol: "AMP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12409/thumb/amp-200x200.png?1599625397",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xfF20817765cB7f73d4bde2e66e067E58D11095C2"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x101A023270368c0D50BFfb62780F4aFd4ea79C35",
          name: "Ankr",
          symbol: "ANKR",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4324/thumb/U85xTl2.png?1608111978",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x8290333ceF9e6D528dD5618Fb97a76f268f3EDD4"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xB7b31a6BC18e48888545CE79e83E06003bE70930",
          name: "ApeCoin",
          symbol: "APE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/24383/small/apecoin.jpg?1647476455",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4d224452801ACEd8B2F0aebE155379bb5D594381"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x45C27821E80F8789b60Fd8B600C73815d34DDa6C",
          name: "API3",
          symbol: "API3",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13256/thumb/api3.jpg?1606751424",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0b38210ea11411557c13457D4dA7dC6ea731B88a"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xEE800B277A96B0f490a1A732e1D6395FAD960A26",
          name: "ARPA Chain",
          symbol: "ARPA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/8506/thumb/9u0a23XY_400x400.jpg?1559027357",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBA50933C268F567BDC86E1aC131BE072C6B0b71a"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x5eB8D998371971D01954205c7AFE90A7AF6a95AC",
          name: "Audius",
          symbol: "AUDIO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12913/thumb/AudiusCoinLogo_2x.png?1603425727",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x61BDD9C7d4dF4Bf47A4508c0c8245505F2Af5b7b",
          name: "Axie Infinity",
          symbol: "AXS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13029/thumb/axie_infinity_logo.png?1604471082",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x1FcbE5937B0cc2adf69772D228fA4205aCF4D9b2",
          name: "Badger DAO",
          symbol: "BADGER",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13287/thumb/badger_dao_logo.jpg?1607054976",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3472A5A71965499acd81997a54BBA8D852C6E53d"
              }
            }
          }
        },
        {
          name: "Balancer",
          address: "0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3",
          symbol: "BAL",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xba100000625a3754423978a60c9317c58a424e3D/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xba100000625a3754423978a60c9317c58a424e3D"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xA8b1E0764f85f53dfe21760e8AfE5446D82606ac",
          name: "Band Protocol",
          symbol: "BAND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9545/thumb/band-protocol.png?1568730326",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBA11D00c5f74255f56a5E366F4F77f5A186d7f55"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x3Cef98bb43d732E2F285eE605a8158cDE967D219",
          name: "Basic Attention Token",
          symbol: "BAT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/677/thumb/basic-attention-token.png?1547034427",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0D8775F648430679A709E98d2b0Cb6250d2887EF"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x91c89A94567980f0e9723b487b0beD586eE96aa7",
          name: "Biconomy",
          symbol: "BICO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/21061/thumb/biconomy_logo.jpg?1638269749",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xF17e65822b568B3903685a7c9F496CF7656Cc6C2"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x438B28C5AA5F00a817b7Def7cE2Fb3d5d1970974",
          name: "Bluzelle",
          symbol: "BLZ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2848/thumb/ColorIcon_3x.png?1622516510",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x5732046A883704404F284Ce41FfADd5b007FD668"
              }
            }
          }
        },
        {
          name: "Bancor Network Token",
          address: "0xc26D47d5c33aC71AC5CF9F776D63Ba292a4F7842",
          symbol: "BNT",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xA041544fe2BE56CCe31Ebb69102B965E06aacE80",
          name: "BarnBridge",
          symbol: "BOND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12811/thumb/barnbridge.jpg?1602728853",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0391D2021f89DC339F60Fff84546EA23E337750f"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xf1938Ce12400f9a761084E7A80d37e732a4dA056",
          name: "Chiliz",
          symbol: "CHZ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/8834/thumb/Chiliz.png?1561970540",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3506424F91fD33084466F402d5D97f05F8e3b4AF"
              }
            }
          }
        },
        {
          name: "Compound",
          address: "0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c",
          symbol: "COMP",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc00e94Cb662C3520282E6f5717214004A7f26888/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xc00e94Cb662C3520282E6f5717214004A7f26888"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xAdA58DF0F643D959C2A47c9D4d4c1a4deFe3F11C",
          name: "Cronos",
          symbol: "CRO",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/7310/thumb/oCw2s3GI_400x400.jpeg?1645172042",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xA0b73E1Ff0B80914AB6fe0444E65848C4C34450b"
              }
            }
          }
        },
        {
          name: "Curve DAO Token",
          address: "0x172370d5Cd63279eFa6d502DAB29171933a610AF",
          symbol: "CRV",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xD533a949740bb3306d119CC777fa900bA034cd52/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD533a949740bb3306d119CC777fa900bA034cd52"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x2727Ab1c2D22170ABc9b595177B2D5C6E1Ab7B7B",
          name: "Cartesi",
          symbol: "CTSI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11038/thumb/cartesi.png?1592288021",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x491604c0FDF08347Dd1fa4Ee062a822A5DD06B5D"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x8c208BC2A808a088a78398fed8f2640cab0b6EDb",
          name: "Cryptex Finance",
          symbol: "CTX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14932/thumb/glossy_icon_-_C200px.png?1619073171",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x321C2fE4446C7c963dc41Dd58879AF648838f98D"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x276C9cbaa4BDf57d7109a41e67BD09699536FA3d",
          name: "Somnium Space CUBEs",
          symbol: "CUBE",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/10687/thumb/CUBE_icon.png?1617026861",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xDf801468a808a32656D2eD2D2d80B72A129739f4"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x66Dc5A08091d1968e08C16aA5b27BAC8398b02Be",
          name: "Civic",
          symbol: "CVC",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/788/thumb/civic.png?1547034556",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x41e5560054824eA6B0732E656E3Ad64E20e94E45"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x4257EA7637c355F81616050CbB6a9b709fd72683",
          name: "Convex Finance",
          symbol: "CVX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15585/thumb/convex.png?1621256328",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B"
              }
            }
          }
        },
        {
          name: "Dai Stablecoin",
          address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
          symbol: "DAI",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6B175474E89094C44Da98b954EedeAC495271d0F"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x26f5FB1e6C8a65b3A873fF0a213FA16EFF5a7828",
          name: "DerivaDAO",
          symbol: "DDX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13453/thumb/ddx_logo.png?1608741641",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3A880652F47bFaa771908C07Dd8673A787dAEd3A"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x993f2CafE9dbE525243f4A78BeBC69DAc8D36000",
          name: "DIA",
          symbol: "DIA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11955/thumb/image.png?1646041751",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x84cA8bc7997272c7CfB4D0Cd3D55cd942B3c9419"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x4C3bF0a3DE9524aF68327d1D2558a3B70d17D42a",
          name: "dYdX",
          symbol: "DYDX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17500/thumb/hjnIm9bV.jpg?1628009360",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x92D6C1e31e14520e676a687F0a93788B716BEff5"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xE0339c80fFDE91F3e20494Df88d4206D86024cdF",
          name: "Dogelon Mars",
          symbol: "ELON",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14962/thumb/6GxcPRo3_400x400.jpg?1619157413",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x761D38e5ddf6ccf6Cf7c55759d5210750B5D60F3"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x7eC26842F195c852Fa843bB9f6D8B583a274a157",
          name: "Enjin Coin",
          symbol: "ENJ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1102/thumb/enjin-coin-logo.png?1547035078",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xbD7A5Cf51d22930B8B3Df6d834F9BCEf90EE7c4f",
          name: "Ethereum Name Service",
          symbol: "ENS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/19785/thumb/acatxTm8_400x400.jpg?1635850140",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x0E50BEA95Fe001A370A4F1C220C49AEdCB982DeC",
          name: "Ethernity Chain",
          symbol: "ERN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14238/thumb/LOGO_HIGH_QUALITY.png?1647831402",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBBc2AE13b23d715c30720F079fcd9B4a74093505"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x8a037dbcA8134FFc72C362e394e35E0Cad618F85",
          name: "Euro Coin",
          symbol: "EUROC",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/26045/thumb/euro-coin.png?1655394420",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1aBaEA1f7C830bD89Acc67eC4af516284b1bC33c"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x176f5AB638cf4Ff3B6239Ba609C3fadAA46ef5B0",
          name: "Harvest Finance",
          symbol: "FARM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12304/thumb/Harvest.png?1613016180",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xa0246c9032bC3A600820415aE600c6388619A14D"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x7583FEDDbceFA813dc18259940F76a02710A8905",
          name: "Fetch ai",
          symbol: "FET",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/5681/thumb/Fetch.jpg?1572098136",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xaea46A60368A7bD060eec7DF8CBa43b7EF41Ad85"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x5eCbA59DAcc1ADc5bDEA35f38A732823fc3dE977",
          name: "Ampleforth Governance Token",
          symbol: "FORTH",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14917/thumb/photo_2021-04-22_00.00.03.jpeg?1619020835",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x77FbA179C79De5B7653F68b5039Af940AdA60ce0"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x65A05DB8322701724c197AF82C9CaE41195B0aA8",
          name: "ShapeShift FOX Token",
          symbol: "FOX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9988/thumb/FOX.png?1574330622",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xc770EEfAd204B5180dF6a14Ee197D99d808ee52d"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xC9c1c1c20B3658F8787CC2FD702267791f224Ce1",
          name: "Fantom",
          symbol: "FTM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4001/thumb/Fantom.png?1558015016",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4E15361FD6b4BB609Fa63C81A2be19d873717870"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x3e121107F6F22DA4911079845a470757aF4e1A1b",
          name: "Frax Share",
          symbol: "FXS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13423/thumb/frax_share.png?1608478989",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x09E1943Dd2A4e82032773594f50CF54453000b97",
          name: "Gala",
          symbol: "GALA",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/12493/thumb/GALA-COINGECKO.png?1600233435",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x15D4c048F83bd7e37d49eA4C83a07267Ec4203dA"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x0B220b82F3eA3B7F6d9A1D8ab58930C064A2b5Bf",
          name: "Golem",
          symbol: "GLM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/542/thumb/Golem_Submark_Positive_RGB.png?1606392013",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x7DD9c5Cba05E151C895FDe1CF355C9A1D5DA6429"
              }
            }
          }
        },
        {
          name: "Gnosis Token",
          address: "0x5FFD62D3C3eE2E81C00A7b9079FB248e7dF024A8",
          symbol: "GNO",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6810e776880C02933D47DB1b9fc05908e5386b96/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6810e776880C02933D47DB1b9fc05908e5386b96"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xF88fc6b493eda7650E4bcf7A290E8d108F677CfE",
          name: "Gods Unchained",
          symbol: "GODS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17139/thumb/10631.png?1635718182",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xccC8cb5229B0ac8069C51fd58367Fd1e622aFD97"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x5fe2B58c013d7601147DcdD68C143A77499f5531",
          name: "The Graph",
          symbol: "GRT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13397/thumb/Graph_Token.png?1608145566",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xc944E90C64B2c07662A292be6244BDf05Cda44a7"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xdb95f9188479575F3F718a245EcA1B3BF74567EC",
          name: "Gitcoin",
          symbol: "GTC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15810/thumb/gitcoin.png?1621992929",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xDe30da39c46104798bB5aA3fe8B9e0e1F348163F"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xC8A94a3d3D2dabC3C1CaffFFDcA6A7543c3e3e65",
          name: "Gemini Dollar",
          symbol: "GUSD",
          decimals: 2,
          logoURI: "https://assets.coingecko.com/coins/images/5992/thumb/gemini-dollar-gusd.png?1536745278",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x482bc619eE7662759CDc0685B4E78f464Da39C73",
          name: "GYEN",
          symbol: "GYEN",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/14191/thumb/icon_gyen_200_200.png?1614843343",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC08512927D12348F6620a698105e1BAac6EcD911"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x9Cb74C8032b007466865f060ad2c46145d45553D",
          name: "IDEX",
          symbol: "IDEX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2565/thumb/logomark-purple-286x286.png?1638362736",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xB705268213D593B8FD88d3FDEFF93AFF5CbDcfAE"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x183070C90B34A63292cC908Ce1b263Cb56D49A7F",
          name: "Immutable X",
          symbol: "IMX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17233/thumb/imx.png?1636691817",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xF57e7e7C23978C3cAEC3C3548E3D615c346e79fF"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x4E8dc2149EaC3f3dEf36b1c281EA466338249371",
          name: "Injective",
          symbol: "INJ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12882/thumb/Secondary_Symbol.png?1628233237",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xe28b3B32B6c345A34Ff64674606124Dd5Aceca30"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xF18Ac368001b0DdC80aA6a8374deb49e868EFDb8",
          name: "Inverse Finance",
          symbol: "INV",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14205/thumb/inverse_finance.jpg?1614921871",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x41D5D79431A913C4aE7d69a668ecdfE5fF9DFB68"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xf6372cDb9c1d3674E83842e3800F2A62aC9F3C66",
          name: "IoTeX",
          symbol: "IOTX",
          decimals: 18,
          logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/2777.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6fB3e0A217407EFFf7Ca062D46c26E5d60a14d69"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xb87f5c1E81077FfcfE821dA240fd20C99c533aF1",
          name: "JasmyCoin",
          symbol: "JASMY",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13876/thumb/JASMY200x200.jpg?1612473259",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x7420B4b9a0110cdC71fB720908340C03F9Bc03EC"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x42f37A1296b2981F7C3cAcEd84c5096b2Eb0C72C",
          name: "Keep Network",
          symbol: "KEEP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3373/thumb/IuNzUb5b_400x400.jpg?1589526336",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x85Eee30c52B0b379b046Fb0F85F4f3Dc3009aFEC"
              }
            }
          }
        },
        {
          name: "Kyber Network Crystal",
          address: "0x324b28d6565f784d596422B0F2E5aB6e9CFA1Dc7",
          symbol: "KNC",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdd974D5C2e2928deA5F71b9825b8b646686BD200/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xdd974D5C2e2928deA5F71b9825b8b646686BD200"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x53AEc293212E3B792563Bc16f1be26956adb12e9",
          name: "Keep3rV1",
          symbol: "KP3R",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12966/thumb/kp3r_logo.jpg?1607057458",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xE8A51D0dD1b4525189ddA2187F90ddF0932b5482",
          name: "LCX",
          symbol: "LCX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9985/thumb/zRPSu_0o_400x400.jpg?1574327008",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x037A54AaB062628C9Bbae1FDB1583c195585fe41"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xC3C7d422809852031b44ab29EEC9F1EfF2A58756",
          name: "Lido DAO",
          symbol: "LDO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13573/thumb/Lido_DAO.png?1609873644",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32"
              }
            }
          }
        },
        {
          name: "ChainLink Token",
          address: "0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39",
          symbol: "LINK",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x514910771AF9Ca656af840dff83E8264EcF986CA/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x514910771AF9Ca656af840dff83E8264EcF986CA"
              }
            }
          }
        },
        {
          name: "Loom Network",
          address: "0x66EfB7cC647e0efab02eBA4316a2d2941193F6b3",
          symbol: "LOOM",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x3962F4A0A0051DccE0be73A7e09cEf5756736712",
          name: "Livepeer",
          symbol: "LPT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/7137/thumb/logo-circle-green.png?1619593365",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x58b6A8A3302369DAEc383334672404Ee733aB239"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x8Ab2Fec94d17ae69FB90E7c773f2C85Ed1802c01",
          name: "Liquity",
          symbol: "LQTY",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14665/thumb/200-lqty-icon.png?1617631180",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6DEA81C8171D0bA574754EF6F8b412F2Ed88c54D"
              }
            }
          }
        },
        {
          name: "LoopringCoin V2",
          address: "0x84e1670F61347CDaeD56dcc736FB990fBB47ddC1",
          symbol: "LRC",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4",
          name: "Decentraland",
          symbol: "MANA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/878/thumb/decentraland-mana.png?1550108745",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0F5D2fB29fb7d3CFeE444a200298f468908cC942"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x2B9E7ccDF0F4e5B24757c1E1a80e311E34Cb10c7",
          name: "Mask Network",
          symbol: "MASK",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14051/thumb/Mask_Network.jpg?1614050316",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xAa7DbD1598251f856C12f63557A4C4397c253Cea",
          name: "Moss Carbon Credit",
          symbol: "MCO2",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14414/thumb/ENtxnThA_400x400.jpg?1615948522",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xfC98e825A2264D890F9a1e68ed50E1526abCcacD"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x01288e04435bFcd4718FF203D6eD18146C17Cd4b",
          name: "Magic Internet Money",
          symbol: "MIM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/16786/thumb/mimlogopng.png?1624979612",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x1C5cccA2CB59145A4B25F452660cbA6436DDce9b",
          name: "Mirror Protocol",
          symbol: "MIR",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13295/thumb/mirror_logo_transparent.png?1611554658",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x09a3EcAFa817268f77BE1283176B946C4ff2E608"
              }
            }
          }
        },
        {
          name: "Maker",
          address: "0x6f7C932e7684666C9fd1d44527765433e01fF61d",
          symbol: "MKR",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xa9f37D84c856fDa3812ad0519Dad44FA0a3Fe207",
          name: "Melon",
          symbol: "MLN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/605/thumb/melon.png?1547034295",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xec67005c4E498Ec7f55E092bd1d35cbC47C91892"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x4985E0B13554fB521840e893574D3848C10Fcc6f",
          name: "PolySwarm",
          symbol: "NCT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2843/thumb/ImcYCVfX_400x400.jpg?1628519767",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x9E46A38F5DaaBe8683E10793b06749EEF7D733d1"
              }
            }
          }
        },
        {
          name: "Numeraire",
          address: "0x0Bf519071b02F22C17E7Ed5F4002ee1911f46729",
          symbol: "NMR",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x282d8efCe846A88B159800bd4130ad77443Fa1A1",
          name: "Ocean Protocol",
          symbol: "OCEAN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3687/thumb/ocean-protocol-logo.jpg?1547038686",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x967da4048cD07aB37855c090aAF366e4ce1b9F48"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xa63Beffd33AB3a2EfD92a39A7D2361CEE14cEbA8",
          name: "Origin Protocol",
          symbol: "OGN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3296/thumb/op.jpg?1547037878",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x8207c1FfC5B6804F6024322CcF34F29c3541Ae26"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x62414D03084EeB269E18C970a21f45D2967F0170",
          name: "OMG Network",
          symbol: "OMG",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/776/thumb/OMG_Network.jpg?1591167168",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xd26114cd6EE289AccF82350c8d8487fedB8A0C07"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x0EE392bA5ef1354c9bd75a98044667d307C0e773",
          name: "Orion Protocol",
          symbol: "ORN",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/11841/thumb/orion_logo.png?1594943318",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0258F474786DdFd37ABCE6df6BBb1Dd5dfC4434a"
              }
            }
          }
        },
        {
          name: "Orchid",
          address: "0x9880e3dDA13c8e7D4804691A45160102d31F6060",
          symbol: "OXT",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4575f41308EC1483f3d399aa9a2826d74Da13Deb/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4575f41308EC1483f3d399aa9a2826d74Da13Deb"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x553d3D295e0f695B9228246232eDF400ed3560B5",
          name: "PAX Gold",
          symbol: "PAXG",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9519/thumb/paxg.PNG?1568542565",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x45804880De22913dAFE09f4980848ECE6EcbAf78"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x263534a4Fe3cb249dF46810718B7B612a30ebbff",
          name: "Perpetual Protocol",
          symbol: "PERP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12381/thumb/60d18e06844a844ad75901a9_mark_only_03.png?1628674771",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xbC396689893D065F41bc2C6EcbeE5e0085233447"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x8765f05ADce126d70bcdF1b0a48Db573316662eB",
          name: "PlayDapp",
          symbol: "PLA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14316/thumb/54023228.png?1615366911",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3a4f40631a4f906c2BaD353Ed06De7A5D3fCb430"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x7dc0cb65EC6019330a6841e9c274f2EE57A6CA6C",
          name: "Pluton",
          symbol: "PLU",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1241/thumb/pluton.png?1548331624",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD8912C10681D8B21Fd3742244f44658dBA12264E"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x8dc302e2141DA59c934d900886DbF1518Fd92cd4",
          name: "Polkastarter",
          symbol: "POLS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12648/thumb/polkastarter.png?1609813702",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x83e6f1E41cdd28eAcEB20Cb649155049Fac3D5Aa"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xcB059C5573646047D6d88dDdb87B745C18161d3b",
          name: "Polymath",
          symbol: "POLY",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2784/thumb/inKkF01.png?1605007034",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x9992eC3cF6A55b00978cdDF2b27BC6882d88D1eC"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x0AaB8DC887D34f00D50E19aee48371a941390d14",
          name: "Power Ledger",
          symbol: "POWR",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/1104/thumb/power-ledger.png?1547035082",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x595832F8FC6BF59c85C527fEC3740A1b7a361269"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x82FFdFD1d8699E8886a4e77CeFA9dd9710a7FefD",
          name: "Propy",
          symbol: "PRO",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/869/thumb/propy.png?1548332100",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x226bb599a12C826476e3A771454697EA52E9E220"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x36B77a184bE8ee56f5E81C56727B20647A42e28E",
          name: "Quant",
          symbol: "QNT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3370/thumb/5ZOu7brX_400x400.jpg?1612437252",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4a220E6096B25EADb88358cb44068A3248254675"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x831753DD7087CaC61aB5644b308642cc1c33Dc13",
          name: "Quickswap",
          symbol: "QUICK",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13970/thumb/1_pOU6pBMEmiL-ZJVb0CYRjQ.png?1613386659",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6c28AeF8977c9B773996d0e8376d2EE379446F2f"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x2f81e176471CC57fDC76f7d332FB4511bF2bebDD",
          name: "Radicle",
          symbol: "RAD",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14013/thumb/radicle.png?1614402918",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x31c8EAcBFFdD875c74b94b077895Bd78CF1E64A3"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x00e5646f60AC6Fb446f621d146B6E1886f002905",
          name: "Rai Reflex Index",
          symbol: "RAI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14004/thumb/RAI-logo-coin.png?1613592334",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x780053837cE2CeEaD2A90D9151aA21FC89eD49c2",
          name: "Rarible",
          symbol: "RARI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11845/thumb/Rari.png?1594946953",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xFca59Cd816aB1eaD66534D82bc21E7515cE441CF"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xc3cFFDAf8F3fdF07da6D5e3A89B8723D5E385ff8",
          name: "Rubic",
          symbol: "RBC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12629/thumb/200x200.png?1607952509",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xA4EED63db85311E22dF4473f87CcfC3DaDCFA3E3"
              }
            }
          }
        },
        {
          name: "Republic Token",
          address: "0x19782D3Dc4701cEeeDcD90f0993f0A9126ed89d0",
          symbol: "REN",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x408e41876cCCDC0F92210600ef50372656052a38/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x408e41876cCCDC0F92210600ef50372656052a38"
              }
            }
          }
        },
        {
          name: "Reputation Augur v2",
          address: "0x6563c1244820CfBd6Ca8820FBdf0f2847363F733",
          symbol: "REPv2",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x221657776846890989a759BA2973e427DfF5C9bB/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x221657776846890989a759BA2973e427DfF5C9bB"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xAdf2F2Ed91755eA3f4bcC9107a494879f633ae7C",
          name: "Request",
          symbol: "REQ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1031/thumb/Request_icon_green.png?1643250951",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x8f8221aFbB33998d8584A2B05749bA73c37a938a"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x3b9dB434F08003A89554CDB43b3e0b1f8734BdE7",
          name: "Rari Governance Token",
          symbol: "RGT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12900/thumb/Rari_Logo_Transparent.png?1613978014",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD291E7a03283640FDc51b121aC401383A46cC623"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xbe662058e00849C3Eef2AC9664f37fEfdF2cdbFE",
          name: "iExec RLC",
          symbol: "RLC",
          decimals: 9,
          logoURI: "https://assets.coingecko.com/coins/images/646/thumb/pL1VuXm.png?1604543202",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x607F4C5BB672230e8672085532f7e901544a7375"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x61299774020dA444Af134c82fa83E3810b309991",
          name: "Render Token",
          symbol: "RNDR",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11636/thumb/rndr.png?1638840934",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6De037ef9aD2725EB40118Bb1702EBb27e4Aeb24"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683",
          name: "The Sandbox",
          symbol: "SAND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12129/thumb/sandbox_logo.jpg?1597397942",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3845badAde8e6dFF049820680d1F14bD3903a5d0"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x6f8a06447Ff6FcF75d803135a7de15CE88C1d4ec",
          name: "Shiba Inu",
          symbol: "SHIB",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11939/thumb/shiba.png?1622619446",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x0C7304fBAf2A320a1c50c46FE03752722F729946",
          name: "Smooth Love Potion",
          symbol: "SLP",
          decimals: 0,
          logoURI: "https://assets.coingecko.com/coins/images/10366/thumb/SLP.png?1578640057",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xCC8Fa225D80b9c7D42F96e9570156c65D6cAAa25"
              }
            }
          }
        },
        {
          name: "Synthetix Network Token",
          address: "0x50B728D8D964fd00C2d0AAD81718b71311feF68a",
          symbol: "SNX",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xcdB3C70CD25FD15307D84C4F9D37d5C043B33Fb2",
          name: "Spell Token",
          symbol: "SPELL",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15861/thumb/abracadabra-3.png?1622544862",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x090185f2135308BaD17527004364eBcC2D37e5F6"
              }
            }
          }
        },
        {
          name: "Storj Token",
          address: "0xd72357dAcA2cF11A5F155b9FF7880E595A3F5792",
          symbol: "STORJ",
          decimals: 8,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xB64ef51C888972c908CFacf59B47C1AfBC0Ab8aC/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xB64ef51C888972c908CFacf59B47C1AfBC0Ab8aC"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xB36e3391B22a970d31A9b620Ae1A414C6c256d2a",
          name: "Stox",
          symbol: "STX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1230/thumb/stox-token.png?1547035256",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x006BeA43Baa3f7A6f765F14f10A1a1b08334EF45"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xa1428174F516F527fafdD146b883bB4428682737",
          name: "SuperFarm",
          symbol: "SUPER",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14040/thumb/6YPdWn6.png?1613975899",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xe53EC727dbDEB9E2d5456c3be40cFF031AB40A55"
              }
            }
          }
        },
        {
          name: "Synth sUSD",
          address: "0xF81b4Bec6Ca8f9fe7bE01CA734F55B2b6e03A7a0",
          symbol: "sUSD",
          decimals: 18,
          chainId: 137,
          logoURI: "https://assets.coingecko.com/coins/images/5013/thumb/sUSD.png?1616150765",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x57Ab1ec28D129707052df4dF418D58a2D46d5f51"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a",
          name: "Sushi",
          symbol: "SUSHI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12271/thumb/512x512_Logo_no_chop.png?1606986688",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x50a4a434247089848991DD8f09b889D4e2870aB6",
          name: "tBTC",
          symbol: "TBTC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11224/thumb/tBTC.png?1589620754",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xe1708AbDE4847B4929b70547E5197F1Ba1db2250",
          name: "Tokemak",
          symbol: "TOKE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17495/thumb/tokemak-avatar-200px-black.png?1628131614",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x2e9d63788249371f1DFC918a52f8d799F4a38C94"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xA7b98d63a137bF402b4570799ac4caD0BB1c4B1c",
          name: "OriginTrail",
          symbol: "TRAC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1877/thumb/TRAC.jpg?1635134367",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xaA7a9CA87d3694B5755f213B5D04094b8d0F0A6F"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xE3322702BEdaaEd36CdDAb233360B939775ae5f1",
          name: "Tellor",
          symbol: "TRB",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9644/thumb/Blk_icon_current.png?1584980686",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x88dF592F8eb5D7Bd38bFeF7dEb0fBc02cf3778a0"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x8676815789211E799a6DC86d02748ADF9cF86836",
          name: "Tribe",
          symbol: "TRIBE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14575/thumb/tribe.PNG?1617487954",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0x5b77bCA482bd3E7958b1103d123888EfCCDaF803",
          name: "TrueFi",
          symbol: "TRU",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/13180/thumb/truefi_glyph_color.png?1617610941",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784"
              }
            }
          }
        },
        {
          name: "UMA Voting Token v1",
          address: "0x3066818837c5e6eD6601bd5a91B0762877A6B731",
          symbol: "UMA",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828"
              }
            }
          }
        },
        {
          name: "Uniswap",
          address: "0xb33EaAd8d922B1083446DC23f610c2567fB5180f",
          symbol: "UNI",
          decimals: 18,
          chainId: 137,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984"
              }
            }
          }
        },
        {
          name: "USDCoin",
          address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          symbol: "USDC",
          decimals: 6,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
              }
            }
          }
        },
        {
          name: "Tether USD",
          address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
          symbol: "USDT",
          decimals: 6,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdAC17F958D2ee523a2206206994597C13D831ec7/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xdAC17F958D2ee523a2206206994597C13D831ec7"
              }
            }
          }
        },
        {
          name: "Wrapped BTC",
          address: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
          symbol: "WBTC",
          decimals: 8,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599"
              }
            }
          }
        },
        {
          name: "Wrapped Ether",
          address: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
          symbol: "WETH",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png"
        },
        {
          name: "Wrapped Matic",
          address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
          symbol: "WMATIC",
          decimals: 18,
          chainId: 137,
          logoURI: "https://assets.coingecko.com/coins/images/4713/thumb/matic-token-icon.png?1624446912"
        },
        {
          chainId: 137,
          address: "0xd2507e7b5794179380673870d88B22F94da6abe0",
          name: "XYO Network",
          symbol: "XYO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4519/thumb/XYO_Network-logo.png?1547039819",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x55296f69f40Ea6d20E478533C15A6B08B654E758"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xDA537104D6A5edd53c6fBba9A898708E465260b6",
          name: "yearn finance",
          symbol: "YFI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11849/thumb/yfi-192x192.png?1598325330",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e"
              }
            }
          }
        },
        {
          chainId: 137,
          address: "0xb8cb8a7F4C2885C03e57E973C74827909Fdc2032",
          name: "DFI money",
          symbol: "YFII",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11902/thumb/YFII-logo.78631676.png?1598677348",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xa1d0E215a23d7030842FC67cE582a6aFa3CCaB83"
              }
            }
          }
        },
        {
          name: "0x Protocol Token",
          address: "0x5559Edb74751A0edE9DeA4DC23aeE72cCA6bE3D5",
          symbol: "ZRX",
          decimals: 18,
          chainId: 137,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xE41d2489571d322189246DaFA5ebDe1F4699F498/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xE41d2489571d322189246DaFA5ebDe1F4699F498"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x6314C31A7a1652cE482cffe247E9CB7c3f4BB9aF",
          name: "1inch",
          symbol: "1INCH",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13469/thumb/1inch-token.png?1608803028",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x111111111117dC0aa78b770fA6A738034120C302"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xba5DdD1f9d7F570dc94a51479a000E3BCE967196",
          name: "Aave",
          symbol: "AAVE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12645/thumb/AAVE.png?1601374110",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x74885b4D524d497261259B38900f54e6dbAd2210",
          name: "ApeCoin",
          symbol: "APE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/24383/small/apecoin.jpg?1647476455",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4d224452801ACEd8B2F0aebE155379bb5D594381"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xe88998Fb579266628aF6a03e3821d5983e5D0089",
          name: "Axie Infinity",
          symbol: "AXS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13029/thumb/axie_infinity_logo.png?1604471082",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xBfa641051Ba0a0Ad1b0AcF549a89536A0D76472E",
          name: "Badger DAO",
          symbol: "BADGER",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13287/thumb/badger_dao_logo.jpg?1607054976",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3472A5A71965499acd81997a54BBA8D852C6E53d"
              }
            }
          }
        },
        {
          name: "Balancer",
          address: "0x040d1EdC9569d4Bab2D15287Dc5A4F10F56a56B8",
          symbol: "BAL",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xba100000625a3754423978a60c9317c58a424e3D/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xba100000625a3754423978a60c9317c58a424e3D"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xa68Ec98D7ca870cF1Dd0b00EBbb7c4bF60A8e74d",
          name: "Biconomy",
          symbol: "BICO",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/21061/thumb/biconomy_logo.jpg?1638269749",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xF17e65822b568B3903685a7c9F496CF7656Cc6C2"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x0D81E50bC677fa67341c44D7eaA9228DEE64A4e1",
          name: "BarnBridge",
          symbol: "BOND",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12811/thumb/barnbridge.jpg?1602728853",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0391D2021f89DC339F60Fff84546EA23E337750f"
              }
            }
          }
        },
        {
          name: "Compound",
          address: "0x354A6dA3fcde098F8389cad84b0182725c6C91dE",
          symbol: "COMP",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc00e94Cb662C3520282E6f5717214004A7f26888/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xc00e94Cb662C3520282E6f5717214004A7f26888"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x6FE14d3CC2f7bDdffBa5CdB3BBE7467dd81ea101",
          name: "COTI",
          symbol: "COTI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2962/thumb/Coti.png?1559653863",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xDDB3422497E61e13543BeA06989C0789117555c5"
              }
            }
          }
        },
        {
          name: "Curve DAO Token",
          address: "0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978",
          symbol: "CRV",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xD533a949740bb3306d119CC777fa900bA034cd52/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD533a949740bb3306d119CC777fa900bA034cd52"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x319f865b287fCC10b30d8cE6144e8b6D1b476999",
          name: "Cartesi",
          symbol: "CTSI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11038/thumb/cartesi.png?1592288021",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x491604c0FDF08347Dd1fa4Ee062a822A5DD06B5D"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x9DfFB23CAd3322440bCcFF7aB1C58E781dDBF144",
          name: "Civic",
          symbol: "CVC",
          decimals: 8,
          logoURI: "https://assets.coingecko.com/coins/images/788/thumb/civic.png?1547034556",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x41e5560054824eA6B0732E656E3Ad64E20e94E45"
              }
            }
          }
        },
        {
          name: "Dai Stablecoin",
          address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
          symbol: "DAI",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6B175474E89094C44Da98b954EedeAC495271d0F"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x51863cB90Ce5d6dA9663106F292fA27c8CC90c5a",
          name: "dYdX",
          symbol: "DYDX",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/17500/thumb/hjnIm9bV.jpg?1628009360",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x92D6C1e31e14520e676a687F0a93788B716BEff5"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x3e4Cff6E50F37F731284A92d44AE943e17077fD4",
          name: "Dogelon Mars",
          symbol: "ELON",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14962/thumb/6GxcPRo3_400x400.jpg?1619157413",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x761D38e5ddf6ccf6Cf7c55759d5210750B5D60F3"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x7fa9549791EFc9030e1Ed3F25D18014163806758",
          name: "Enjin Coin",
          symbol: "ENJ",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/1102/thumb/enjin-coin-logo.png?1547035078",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xfeA31d704DEb0975dA8e77Bf13E04239e70d7c28",
          name: "Ethereum Name Service",
          symbol: "ENS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/19785/thumb/acatxTm8_400x400.jpg?1635850140",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xd42785D323e608B9E99fa542bd8b1000D4c2Df37",
          name: "Fantom",
          symbol: "FTM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4001/thumb/Fantom.png?1558015016",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x4E15361FD6b4BB609Fa63C81A2be19d873717870"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xd9f9d2Ee2d3EFE420699079f16D9e924affFdEA4",
          name: "Frax Share",
          symbol: "FXS",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13423/thumb/frax_share.png?1608478989",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0"
              }
            }
          }
        },
        {
          name: "Gnosis Token",
          address: "0xa0b862F60edEf4452F25B4160F177db44DeB6Cf1",
          symbol: "GNO",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6810e776880C02933D47DB1b9fc05908e5386b96/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6810e776880C02933D47DB1b9fc05908e5386b96"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x23A941036Ae778Ac51Ab04CEa08Ed6e2FE103614",
          name: "The Graph",
          symbol: "GRT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/13397/thumb/Graph_Token.png?1608145566",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xc944E90C64B2c07662A292be6244BDf05Cda44a7"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x7f9a7DB853Ca816B9A138AEe3380Ef34c437dEe0",
          name: "Gitcoin",
          symbol: "GTC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15810/thumb/gitcoin.png?1621992929",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xDe30da39c46104798bB5aA3fe8B9e0e1F348163F"
              }
            }
          }
        },
        {
          name: "ChainLink Token",
          address: "0xf97f4df75117a78c1A5a0DBb814Af92458539FB4",
          symbol: "LINK",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x514910771AF9Ca656af840dff83E8264EcF986CA/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x514910771AF9Ca656af840dff83E8264EcF986CA"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x289ba1701C2F088cf0faf8B3705246331cB8A839",
          name: "Livepeer",
          symbol: "LPT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/7137/thumb/logo-circle-green.png?1619593365",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x58b6A8A3302369DAEc383334672404Ee733aB239"
              }
            }
          }
        },
        {
          name: "LoopringCoin V2",
          address: "0x46d0cE7de6247b0A95f67b43B589b4041BaE7fbE",
          symbol: "LRC",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x442d24578A564EF628A65e6a7E3e7be2a165E231",
          name: "Decentraland",
          symbol: "MANA",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/878/thumb/decentraland-mana.png?1550108745",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0F5D2fB29fb7d3CFeE444a200298f468908cC942"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x533A7B414CD1236815a5e09F1E97FC7d5c313739",
          name: "Mask Network",
          symbol: "MASK",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14051/thumb/Mask_Network.jpg?1614050316",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x561877b6b3DD7651313794e5F2894B2F18bE0766",
          name: "Polygon",
          symbol: "MATIC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/4713/thumb/matic-token-icon.png?1624446912",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xB20A02dfFb172C474BC4bDa3fD6f4eE70C04daf2",
          name: "Magic Internet Money",
          symbol: "MIM",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/16786/thumb/mimlogopng.png?1624979612",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3"
              }
            }
          }
        },
        {
          name: "Maker",
          address: "0x2e9a6Df78E42a30712c10a9Dc4b1C8656f8F2879",
          symbol: "MKR",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x8f5c1A99b1df736Ad685006Cb6ADCA7B7Ae4b514",
          name: "Melon",
          symbol: "MLN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/605/thumb/melon.png?1547034295",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xec67005c4E498Ec7f55E092bd1d35cbC47C91892"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x53236015A675fcB937485F1AE58040e4Fb920d5b",
          name: "PolySwarm",
          symbol: "NCT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/2843/thumb/ImcYCVfX_400x400.jpg?1628519767",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x9E46A38F5DaaBe8683E10793b06749EEF7D733d1"
              }
            }
          }
        },
        {
          name: "Numeraire",
          address: "0x597701b32553b9fa473e21362D480b3a6B569711",
          symbol: "NMR",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x933d31561e470478079FEB9A6Dd2691fAD8234DF",
          name: "Ocean Protocol",
          symbol: "OCEAN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/3687/thumb/ocean-protocol-logo.jpg?1547038686",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x967da4048cD07aB37855c090aAF366e4ce1b9F48"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xfEb4DfC8C4Cf7Ed305bb08065D08eC6ee6728429",
          name: "PAX Gold",
          symbol: "PAXG",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/9519/thumb/paxg.PNG?1568542565",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x45804880De22913dAFE09f4980848ECE6EcbAf78"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x753D224bCf9AAFaCD81558c32341416df61D3DAC",
          name: "Perpetual Protocol",
          symbol: "PERP",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12381/thumb/60d18e06844a844ad75901a9_mark_only_03.png?1628674771",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xbC396689893D065F41bc2C6EcbeE5e0085233447"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x4e91F2AF1ee0F84B529478f19794F5AFD423e4A6",
          name: "Power Ledger",
          symbol: "POWR",
          decimals: 6,
          logoURI: "https://assets.coingecko.com/coins/images/1104/thumb/power-ledger.png?1547035082",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x595832F8FC6BF59c85C527fEC3740A1b7a361269"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xaeF5bbcbFa438519a5ea80B4c7181B4E78d419f2",
          name: "Rai Reflex Index",
          symbol: "RAI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14004/thumb/RAI-logo-coin.png?1613592334",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xCF8600347Dc375C5f2FdD6Dab9BB66e0b6773cd7",
          name: "Rarible",
          symbol: "RARI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11845/thumb/Rari.png?1594946953",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xFca59Cd816aB1eaD66534D82bc21E7515cE441CF"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x2E9AE8f178d5Ea81970C7799A377B3985cbC335F",
          name: "Rubic",
          symbol: "RBC",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12629/thumb/200x200.png?1607952509",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xA4EED63db85311E22dF4473f87CcfC3DaDCFA3E3"
              }
            }
          }
        },
        {
          name: "Republic Token",
          address: "0x9fA891e1dB0a6D1eEAC4B929b5AAE1011C79a204",
          symbol: "REN",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x408e41876cCCDC0F92210600ef50372656052a38/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x408e41876cCCDC0F92210600ef50372656052a38"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xef888bcA6AB6B1d26dbeC977C455388ecd794794",
          name: "Rari Governance Token",
          symbol: "RGT",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12900/thumb/Rari_Logo_Transparent.png?1613978014",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD291E7a03283640FDc51b121aC401383A46cC623"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x5033833c9fe8B9d3E09EEd2f73d2aaF7E3872fd1",
          name: "Shiba Inu",
          symbol: "SHIB",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11939/thumb/shiba.png?1622619446",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE"
              }
            }
          }
        },
        {
          name: "Synthetix Network Token",
          address: "0xcBA56Cd8216FCBBF3fA6DF6137F3147cBcA37D60",
          symbol: "SNX",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xb74Da9FE2F96B9E0a5f4A3cf0b92dd2bEC617124",
          name: "SOL Wormhole ",
          symbol: "SOL",
          decimals: 9,
          logoURI: "https://assets.coingecko.com/coins/images/22876/thumb/SOL_wh_small.png?1644224316",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xD31a59c85aE9D8edEFeC411D448f90841571b89c"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x3E6648C5a70A150A88bCE65F4aD4d506Fe15d2AF",
          name: "Spell Token",
          symbol: "SPELL",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/15861/thumb/abracadabra-3.png?1622544862",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x090185f2135308BaD17527004364eBcC2D37e5F6"
              }
            }
          }
        },
        {
          name: "Synth sUSD",
          address: "0xA970AF1a584579B618be4d69aD6F73459D112F95",
          symbol: "sUSD",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://assets.coingecko.com/coins/images/5013/thumb/sUSD.png?1616150765",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x57Ab1ec28D129707052df4dF418D58a2D46d5f51"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xd4d42F0b6DEF4CE0383636770eF773390d85c61A",
          name: "Sushi",
          symbol: "SUSHI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/12271/thumb/512x512_Logo_no_chop.png?1606986688",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x1bCfc0B4eE1471674cd6A9F6B363A034375eAD84",
          name: "Synapse",
          symbol: "SYN",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/18024/thumb/syn.png?1635002049",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0f2D719407FdBeFF09D87557AbB7232601FD9F29"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0xBfAE6fecD8124ba33cbB2180aAb0Fe4c03914A5A",
          name: "Tribe",
          symbol: "TRIBE",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/14575/thumb/tribe.PNG?1617487954",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B"
              }
            }
          }
        },
        {
          name: "UMA Voting Token v1",
          address: "0xd693Ec944A85eeca4247eC1c3b130DCa9B0C3b22",
          symbol: "UMA",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828"
              }
            }
          }
        },
        {
          name: "Uniswap",
          address: "0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0",
          symbol: "UNI",
          decimals: 18,
          chainId: 42161,
          logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984"
              }
            }
          }
        },
        {
          name: "USDCoin",
          address: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
          symbol: "USDC",
          decimals: 6,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
              }
            }
          }
        },
        {
          name: "Tether USD",
          address: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
          symbol: "USDT",
          decimals: 6,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdAC17F958D2ee523a2206206994597C13D831ec7/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xdAC17F958D2ee523a2206206994597C13D831ec7"
              }
            }
          }
        },
        {
          name: "Wrapped BTC",
          address: "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f",
          symbol: "WBTC",
          decimals: 8,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599"
              }
            }
          }
        },
        {
          name: "Wrapped Ether",
          address: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
          symbol: "WETH",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
              }
            }
          }
        },
        {
          chainId: 42161,
          address: "0x82e3A8F066a6989666b031d916c43672085b1582",
          name: "yearn finance",
          symbol: "YFI",
          decimals: 18,
          logoURI: "https://assets.coingecko.com/coins/images/11849/thumb/yfi-192x192.png?1598325330",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e"
              }
            }
          }
        },
        {
          name: "0x Protocol Token",
          address: "0xBD591Bd4DdB64b77B5f76Eab8f03d02519235Ae2",
          symbol: "ZRX",
          decimals: 18,
          chainId: 42161,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xE41d2489571d322189246DaFA5ebDe1F4699F498/logo.png",
          extensions: {
            bridgeInfo: {
              "1": {
                tokenAddress: "0xE41d2489571d322189246DaFA5ebDe1F4699F498"
              }
            }
          }
        },
        {
          name: "Wrapped Ether",
          address: "0xA6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa",
          symbol: "WETH",
          decimals: 18,
          chainId: 80001,
          logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png"
        },
        {
          name: "Wrapped Matic",
          address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
          symbol: "WMATIC",
          decimals: 18,
          chainId: 80001,
          logoURI: "https://assets.coingecko.com/coins/images/4713/thumb/matic-token-icon.png?1624446912"
        }
      ]
    };
  }
});
var require_base32_decode = __commonJS2({
  "../../node_modules/.pnpm/base32-decode@1.0.0/node_modules/base32-decode/index.js"(exports, module2) {
    var RFC46482 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    var RFC4648_HEX2 = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
    var CROCKFORD2 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
    function readChar(alphabet3, char) {
      var idx = alphabet3.indexOf(char);
      if (idx === -1) {
        throw new Error("Invalid character found: " + char);
      }
      return idx;
    }
    __name(readChar, "readChar");
    __name2(readChar, "readChar");
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function base32Decode2(input, variant) {
      var alphabet3;
      switch (variant) {
        case "RFC3548":
        case "RFC4648":
          alphabet3 = RFC46482;
          input = input.replace(/=+$/, "");
          break;
        case "RFC4648-HEX":
          alphabet3 = RFC4648_HEX2;
          input = input.replace(/=+$/, "");
          break;
        case "Crockford":
          alphabet3 = CROCKFORD2;
          input = input.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1");
          break;
        default:
          throw new Error("Unknown base32 variant: " + variant);
      }
      var length2 = input.length;
      var bits = 0;
      var value = 0;
      var index = 0;
      var output = new Uint8Array(length2 * 5 / 8 | 0);
      for (var i22 = 0; i22 < length2; i22++) {
        value = value << 5 | readChar(alphabet3, input[i22]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output.buffer;
    }, "base32Decode2"), "base32Decode");
  }
});
var import_promise = __toESM2(require_promise3());
var g = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : void 0;
if (g) {
  if (typeof g.AbortController === "undefined") {
    g.AbortController = ac.AbortController;
  }
  if (typeof g.AbortSignal === "undefined") {
    g.AbortSignal = ac.AbortSignal;
  }
}
var findFirstResult = /* @__PURE__ */ __name2((array, callback) => {
  return array.reduce((result, item) => {
    if (result !== void 0)
      return result;
    return callback(item);
  }, void 0);
}, "findFirstResult");
var pluginImplementsPlane = /* @__PURE__ */ __name2((plugin, plane) => {
  if (plane === "read")
    return "get" in (plugin.read ?? {});
  if (plane === "store")
    return "upload" in (plugin.store ?? {});
  if (plane === "index")
    return "get" in (plugin.index ?? {});
  if (plane === "cache")
    return "getIndex" in (plugin.cache ?? {});
  if (plane === "id")
    return "did" in (plugin.id ?? {});
  return false;
}, "pluginImplementsPlane");
var learnCardImplementsPlane = /* @__PURE__ */ __name2((learnCard, plane) => {
  if (plane === "read")
    return "read" in learnCard;
  if (plane === "store")
    return "store" in learnCard;
  if (plane === "index")
    return "index" in learnCard;
  if (plane === "cache")
    return "cache" in learnCard;
  if (plane === "id")
    return "id" in learnCard;
  return false;
}, "learnCardImplementsPlane");
var mapObject = /* @__PURE__ */ __name2((obj, callback) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key22, value], index) => [key22, callback(value, index)])
  );
}, "mapObject");
var isFulfilledAndNotEmpty = /* @__PURE__ */ __name2((input) => input.status === "fulfilled" && !!input.value, "isFulfilledAndNotEmpty");
var uniqBy = /* @__PURE__ */ __name2((array, key22) => {
  return [
    ...new Map(array.map((obj) => [key22 instanceof Function ? key22(obj) : obj[key22], obj])).values()
  ];
}, "uniqBy");
var getPlaneProviders = /* @__PURE__ */ __name2((plugins, plane) => {
  return plugins.reduce((providers, plugin) => {
    if (plane in plugin) {
      providers[plugin.name] = {
        name: plugin.name,
        displayName: plugin.displayName,
        description: plugin.description
      };
    }
    return providers;
  }, {});
}, "getPlaneProviders");
var bindLearnCardToFunctionsObject = /* @__PURE__ */ __name2((learnCard, obj) => mapObject(obj, (method) => method.bind(learnCard, learnCard)), "bindLearnCardToFunctionsObject");
var addPluginToLearnCard = /* @__PURE__ */ __name2(async (learnCard, plugin) => {
  learnCard.debug?.("Adding plugin", plugin.name);
  return generateLearnCard({
    plugins: [...learnCard.plugins, plugin],
    debug: learnCard.debug
  });
}, "addPluginToLearnCard");
var generateReadPlane = /* @__PURE__ */ __name2((learnCard) => {
  return {
    get: async (uri, { cache = "cache-first" } = {}) => {
      learnCard.debug?.("learnCard.read.get", uri);
      if (!uri)
        return void 0;
      if (cache === "cache-only" && !learnCardImplementsPlane(learnCard, "cache")) {
        throw new Error("Cannot read from cache. Cache Plane is not implemented!");
      }
      if (learnCardImplementsPlane(learnCard, "cache") && cache !== "skip-cache") {
        const cachedResponse = await learnCard.cache.getVc(uri);
        if (cachedResponse) {
          if (cache === "cache-first" && learnCardImplementsPlane(learnCard, "read")) {
            learnCard.read.get(uri, { cache: "skip-cache" }).then((res) => learnCard.cache.setVc(uri, res));
          }
          return cachedResponse;
        }
      }
      const results = await Promise.allSettled(
        learnCard.plugins.map(async (plugin) => {
          if (!pluginImplementsPlane(plugin, "read")) {
            throw new Error("Plugin is not a Read Plugin");
          }
          return plugin.read.get(learnCard, uri);
        })
      );
      const vc = results.find(isFulfilledAndNotEmpty)?.value;
      if (vc && learnCardImplementsPlane(learnCard, "cache") && cache !== "skip-cache") {
        await learnCard.cache.setVc(uri, vc);
      }
      return vc;
    },
    providers: getPlaneProviders(learnCard.plugins, "read")
  };
}, "generateReadPlane");
var addCachingToStorePlane = /* @__PURE__ */ __name2((plane) => ({
  upload: async (_learnCard, vc, { cache = "cache-first" } = {}) => {
    const uri = await plane.upload(_learnCard, vc);
    if (cache !== "skip-cache" && learnCardImplementsPlane(_learnCard, "cache")) {
      await _learnCard.cache.setVc(uri, vc);
    }
    return uri;
  },
  ..."uploadMany" in plane ? { uploadMany: plane.uploadMany } : {},
  ..."uploadEncrypted" in plane ? {
    uploadEncrypted: async (_learnCard, vc, params, { cache = "cache-first" } = {}) => {
      const uri = await plane.uploadEncrypted?.(_learnCard, vc, params);
      if (cache !== "skip-cache" && learnCardImplementsPlane(_learnCard, "cache")) {
        await _learnCard.cache.setVc(uri, vc);
      }
      return uri;
    }
  } : {}
}), "addCachingToStorePlane");
var generateStorePlane = /* @__PURE__ */ __name2((learnCard) => {
  const pluginPlanes = learnCard.plugins.reduce((planes, plugin) => {
    if (pluginImplementsPlane(plugin, "store")) {
      planes[plugin.name] = bindLearnCardToFunctionsObject(
        learnCard,
        addCachingToStorePlane(plugin.store)
      );
    }
    return planes;
  }, {});
  return { ...pluginPlanes, providers: getPlaneProviders(learnCard.plugins, "store") };
}, "generateStorePlane");
var addCachingToIndexPlane = /* @__PURE__ */ __name2((plane, name3) => ({
  get: async (_learnCard, query, { cache = "cache-first" } = {}) => {
    if (cache === "cache-only" && !learnCardImplementsPlane(_learnCard, "cache")) {
      throw new Error("Cannot read from cache. Cache Plane is not implemented!");
    }
    if (learnCardImplementsPlane(_learnCard, "cache") && cache !== "skip-cache") {
      const cachedResponse = await _learnCard.cache.getIndex(name3, query ?? {});
      if (cachedResponse) {
        if (cache === "cache-first") {
          plane.get(_learnCard, query, { cache: "skip-cache" }).then((res) => _learnCard.cache.setIndex(name3, query ?? {}, res));
        }
        return cachedResponse;
      }
    }
    const list = await plane.get(_learnCard, query);
    if (list && learnCardImplementsPlane(_learnCard, "cache") && cache !== "skip-cache") {
      await _learnCard.cache.setIndex(name3, query ?? {}, list);
    }
    return list;
  },
  add: async (_learnCard, record, { cache = "cache-first" } = {}) => {
    if (cache !== "skip-cache" && learnCardImplementsPlane(_learnCard, "cache")) {
      await _learnCard.cache.flushIndex();
    }
    return plane.add(_learnCard, record);
  },
  ...plane.addMany ? {
    addMany: async (_learnCard, records, { cache = "cache-first" } = {}) => {
      if (cache !== "skip-cache" && learnCardImplementsPlane(_learnCard, "cache")) {
        await _learnCard.cache.flushIndex();
      }
      return plane.addMany?.(_learnCard, records);
    }
  } : {},
  update: async (_learnCard, id2, update22, { cache = "cache-first" } = {}) => {
    if (cache !== "skip-cache" && learnCardImplementsPlane(_learnCard, "cache")) {
      await _learnCard.cache.flushIndex();
    }
    return plane.update(_learnCard, id2, update22);
  },
  remove: async (_learnCard, id2, { cache = "cache-first" } = {}) => {
    if (cache !== "skip-cache" && learnCardImplementsPlane(_learnCard, "cache")) {
      await _learnCard.cache.flushIndex();
    }
    return plane.remove(_learnCard, id2);
  },
  ...plane.removeAll ? {
    removeAll: async (_learnCard, { cache = "cache-first" } = {}) => {
      if (cache !== "skip-cache" && learnCardImplementsPlane(_learnCard, "cache")) {
        await _learnCard.cache.flushIndex();
      }
      return plane.removeAll?.(_learnCard);
    }
  } : {}
}), "addCachingToIndexPlane");
var generateIndexPlane = /* @__PURE__ */ __name2((learnCard) => {
  const individualPlanes = learnCard.plugins.reduce(
    (planes, plugin) => {
      if (pluginImplementsPlane(plugin, "index")) {
        planes[plugin.name] = bindLearnCardToFunctionsObject(
          learnCard,
          addCachingToIndexPlane(plugin.index, plugin.name)
        );
      }
      return planes;
    },
    {}
  );
  const all = {
    get: async (query, { cache = "cache-first" } = {}) => {
      learnCard.debug?.("learnCard.index.all.get");
      if (cache === "cache-only" && !learnCardImplementsPlane(learnCard, "cache")) {
        throw new Error("Cannot read from cache. Cache Plane is not implemented!");
      }
      if (learnCardImplementsPlane(learnCard, "cache") && cache !== "skip-cache") {
        const cachedResponse = await learnCard.cache.getIndex("all", query ?? {});
        if (cachedResponse) {
          if (cache === "cache-first" && learnCardImplementsPlane(learnCard, "index")) {
            learnCard.index.all.get(query, { cache: "skip-cache" }).then((res) => learnCard.cache.setIndex("all", query ?? {}, res));
          }
          return cachedResponse;
        }
      }
      const resultsWithDuplicates = (await Promise.all(
        learnCard.plugins.map(async (plugin) => {
          if (!pluginImplementsPlane(plugin, "index"))
            return [];
          return plugin.index.get(learnCard, query);
        })
      )).flat();
      const results = uniqBy(resultsWithDuplicates, "id");
      if (results && learnCardImplementsPlane(learnCard, "cache") && cache !== "skip-cache") {
        await learnCard.cache.setIndex("all", query ?? {}, results);
      }
      return results;
    }
  };
  return { ...individualPlanes, all, providers: getPlaneProviders(learnCard.plugins, "index") };
}, "generateIndexPlane");
var generateCachePlane = /* @__PURE__ */ __name2((learnCard) => {
  return {
    getIndex: async (name3, query) => {
      learnCard.debug?.("learnCard.cache.getIndex");
      try {
        const results = await Promise.allSettled(
          learnCard.plugins.map(async (plugin) => {
            if (!pluginImplementsPlane(plugin, "cache")) {
              throw new Error("Plugin is not a Cache Plugin");
            }
            return plugin.cache.getIndex(learnCard, name3, query);
          })
        );
        const index = results.find(isFulfilledAndNotEmpty)?.value;
        return index;
      } catch (error) {
        return void 0;
      }
    },
    setIndex: async (name3, query, value) => {
      learnCard.debug?.("learnCard.cache.setIndex");
      const result = await Promise.allSettled(
        learnCard.plugins.map(async (plugin) => {
          if (!pluginImplementsPlane(plugin, "cache")) {
            throw new Error("Plugin is not a Cache Plugin");
          }
          return plugin.cache.setIndex(learnCard, name3, query, value);
        })
      );
      return result.some((promiseResult) => promiseResult.status === "fulfilled");
    },
    flushIndex: async () => {
      learnCard.debug?.("learnCard.cache.flushIndex");
      const result = await Promise.allSettled(
        learnCard.plugins.map(async (plugin) => {
          if (!pluginImplementsPlane(plugin, "cache")) {
            throw new Error("Plugin is not a Cache Plugin");
          }
          return plugin.cache.flushIndex(learnCard);
        })
      );
      return result.some((promiseResult) => promiseResult.status === "fulfilled");
    },
    getVc: async (uri) => {
      learnCard.debug?.("learnCard.cache.getVc");
      try {
        const results = await Promise.allSettled(
          learnCard.plugins.map(async (plugin) => {
            if (!pluginImplementsPlane(plugin, "cache")) {
              throw new Error("Plugin is not a Cache Plugin");
            }
            return plugin.cache.getVc(learnCard, uri);
          })
        );
        const vc = results.find(isFulfilledAndNotEmpty)?.value;
        return vc;
      } catch (error) {
        return void 0;
      }
    },
    setVc: async (uri, value) => {
      learnCard.debug?.("learnCard.cache.setVc");
      const result = await Promise.allSettled(
        learnCard.plugins.map(async (plugin) => {
          if (!pluginImplementsPlane(plugin, "cache")) {
            throw new Error("Plugin is not a Cache Plugin");
          }
          return plugin.cache.setVc(learnCard, uri, value);
        })
      );
      return result.some((promiseResult) => promiseResult.status === "fulfilled");
    },
    flushVc: async () => {
      learnCard.debug?.("learnCard.cache.flushVc");
      const result = await Promise.allSettled(
        learnCard.plugins.map(async (plugin) => {
          if (!pluginImplementsPlane(plugin, "cache")) {
            throw new Error("Plugin is not a Cache Plugin");
          }
          return plugin.cache.flushVc(learnCard);
        })
      );
      return result.some((promiseResult) => promiseResult.status === "fulfilled");
    },
    providers: getPlaneProviders(learnCard.plugins, "cache")
  };
}, "generateCachePlane");
var generateIdPlane = /* @__PURE__ */ __name2((learnCard) => {
  return {
    did: (method) => {
      learnCard.debug?.("learnCard.id.did", method);
      const result = findFirstResult([...learnCard.plugins].reverse(), (plugin) => {
        try {
          if (!pluginImplementsPlane(plugin, "id"))
            return void 0;
          return plugin.id.did(learnCard, method);
        } catch (error) {
          return void 0;
        }
      });
      if (!result)
        throw new Error(`No plugin supports did method ${method}`);
      return result;
    },
    keypair: (algorithm) => {
      learnCard.debug?.("learnCard.id.keypair", algorithm);
      const result = findFirstResult(learnCard.plugins, (plugin) => {
        try {
          if (!pluginImplementsPlane(plugin, "id"))
            return void 0;
          return plugin.id.keypair(learnCard, algorithm);
        } catch (error) {
          return void 0;
        }
      });
      if (!result)
        throw new Error(`No plugin supports keypair type ${algorithm}`);
      return result;
    },
    providers: getPlaneProviders(learnCard.plugins, "id")
  };
}, "generateIdPlane");
var bindMethods = /* @__PURE__ */ __name2((learnCard, pluginMethods) => bindLearnCardToFunctionsObject(learnCard, pluginMethods), "bindMethods");
var generateLearnCard = /* @__PURE__ */ __name2(async (_learnCard = {}) => {
  const { plugins = [] } = _learnCard;
  const pluginMethods = plugins.reduce((cumulativePluginMethods, plugin) => {
    const newPluginMethods = { ...cumulativePluginMethods, ...plugin.methods };
    return newPluginMethods;
  }, {});
  const learnCard = {
    read: {},
    store: {},
    index: {},
    cache: {},
    id: {},
    plugins,
    invoke: pluginMethods,
    addPlugin: function(plugin) {
      return addPluginToLearnCard(this, plugin);
    },
    debug: _learnCard.debug
  };
  learnCard.read = generateReadPlane(learnCard);
  learnCard.store = generateStorePlane(learnCard);
  learnCard.index = generateIndexPlane(learnCard);
  learnCard.cache = generateCachePlane(learnCard);
  learnCard.id = generateIdPlane(learnCard);
  if (pluginMethods)
    learnCard.invoke = bindMethods(learnCard, pluginMethods);
  return learnCard;
}, "generateLearnCard");
if (typeof window === "undefined" && !globalThis.crypto)
  globalThis.crypto = import_isomorphic_webcrypto.default;
var customLearnCard = /* @__PURE__ */ __name2(async ({ debug } = {}) => generateLearnCard({ debug }), "customLearnCard");
var wasm;
var heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
__name(getObject, "getObject");
__name2(getObject, "getObject");
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
__name(dropObject, "dropObject");
__name2(dropObject, "dropObject");
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
__name(takeObject, "takeObject");
__name2(takeObject, "takeObject");
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var cachedUint8Memory0 = new Uint8Array();
function getUint8Memory0() {
  if (cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
__name(getUint8Memory0, "getUint8Memory0");
__name2(getUint8Memory0, "getUint8Memory0");
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
__name(getStringFromWasm0, "getStringFromWasm0");
__name2(getStringFromWasm0, "getStringFromWasm0");
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
__name(addHeapObject, "addHeapObject");
__name2(addHeapObject, "addHeapObject");
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf2 = cachedTextEncoder.encode(arg);
  view.set(buf2);
  return {
    read: arg.length,
    written: buf2.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf2 = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf2.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf2.length).set(buf2);
    WASM_VECTOR_LEN = buf2.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code3 = arg.charCodeAt(offset);
    if (code3 > 127)
      break;
    mem[ptr + offset] = code3;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
__name(passStringToWasm0, "passStringToWasm0");
__name2(passStringToWasm0, "passStringToWasm0");
function isLikeNone(x2) {
  return x2 === void 0 || x2 === null;
}
__name(isLikeNone, "isLikeNone");
__name2(isLikeNone, "isLikeNone");
var cachedInt32Memory0 = new Int32Array();
function getInt32Memory0() {
  if (cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
__name(getInt32Memory0, "getInt32Memory0");
__name2(getInt32Memory0, "getInt32Memory0");
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name3 = val.name;
    if (typeof name3 == "string" && name3.length > 0) {
      return `Function(${name3})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length2 = val.length;
    let debug = "[";
    if (length2 > 0) {
      debug += debugString(val[0]);
    }
    for (let i22 = 1; i22 < length2; i22++) {
      debug += ", " + debugString(val[i22]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_2) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
__name(debugString, "debugString");
__name2(debugString, "debugString");
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name2((...args) => {
    state.cnt++;
    const a3 = state.a;
    state.a = 0;
    try {
      return f(a3, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(a3, state.b);
      } else {
        state.a = a3;
      }
    }
  }, "real");
  real.original = state;
  return real;
}
__name(makeMutClosure, "makeMutClosure");
__name2(makeMutClosure, "makeMutClosure");
function __wbg_adapter_26(arg0, arg1, arg2) {
  wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hf6251ee6687a20b8(arg0, arg1, addHeapObject(arg2));
}
__name(__wbg_adapter_26, "__wbg_adapter_26");
__name2(__wbg_adapter_26, "__wbg_adapter_26");
function didResolver(did, input_metadata) {
  const ptr0 = passStringToWasm0(did, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(input_metadata, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.didResolver(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(didResolver, "didResolver");
__name2(didResolver, "didResolver");
function resolveDID(did, input_metadata) {
  const ptr0 = passStringToWasm0(did, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(input_metadata, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.resolveDID(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(resolveDID, "resolveDID");
__name2(resolveDID, "resolveDID");
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
__name(passArray8ToWasm0, "passArray8ToWasm0");
__name2(passArray8ToWasm0, "passArray8ToWasm0");
function generateEd25519KeyFromBytes(bytes) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.generateEd25519KeyFromBytes(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(ptr1, len1);
  }
}
__name(generateEd25519KeyFromBytes, "generateEd25519KeyFromBytes");
__name2(generateEd25519KeyFromBytes, "generateEd25519KeyFromBytes");
function generateSecp256k1KeyFromBytes(bytes) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.generateSecp256k1KeyFromBytes(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(ptr1, len1);
  }
}
__name(generateSecp256k1KeyFromBytes, "generateSecp256k1KeyFromBytes");
__name2(generateSecp256k1KeyFromBytes, "generateSecp256k1KeyFromBytes");
function keyToDID(method_pattern, jwk) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(method_pattern, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(jwk, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    wasm.keyToDID(retptr, ptr0, len0, ptr1, len1);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr2 = r0;
    var len2 = r1;
    if (r3) {
      ptr2 = 0;
      len2 = 0;
      throw takeObject(r2);
    }
    return getStringFromWasm0(ptr2, len2);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(ptr2, len2);
  }
}
__name(keyToDID, "keyToDID");
__name2(keyToDID, "keyToDID");
function keyToVerificationMethod(method_pattern, jwk) {
  const ptr0 = passStringToWasm0(method_pattern, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(jwk, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.keyToVerificationMethod(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(keyToVerificationMethod, "keyToVerificationMethod");
__name2(keyToVerificationMethod, "keyToVerificationMethod");
function didToVerificationMethod(did) {
  const ptr0 = passStringToWasm0(did, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.didToVerificationMethod(ptr0, len0);
  return takeObject(ret);
}
__name(didToVerificationMethod, "didToVerificationMethod");
__name2(didToVerificationMethod, "didToVerificationMethod");
function issueCredential(credential, proof_options, key22) {
  const ptr0 = passStringToWasm0(credential, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passStringToWasm0(key22, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len2 = WASM_VECTOR_LEN;
  const ret = wasm.issueCredential(ptr0, len0, ptr1, len1, ptr2, len2);
  return takeObject(ret);
}
__name(issueCredential, "issueCredential");
__name2(issueCredential, "issueCredential");
function verifyCredential(vc, proof_options) {
  const ptr0 = passStringToWasm0(vc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.verifyCredential(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(verifyCredential, "verifyCredential");
__name2(verifyCredential, "verifyCredential");
function issuePresentation(presentation, proof_options, key22) {
  const ptr0 = passStringToWasm0(presentation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passStringToWasm0(key22, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len2 = WASM_VECTOR_LEN;
  const ret = wasm.issuePresentation(ptr0, len0, ptr1, len1, ptr2, len2);
  return takeObject(ret);
}
__name(issuePresentation, "issuePresentation");
__name2(issuePresentation, "issuePresentation");
function verifyPresentation(vp, proof_options) {
  const ptr0 = passStringToWasm0(vp, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.verifyPresentation(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(verifyPresentation, "verifyPresentation");
__name2(verifyPresentation, "verifyPresentation");
function contextLoader(url) {
  const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.contextLoader(ptr0, len0);
  return takeObject(ret);
}
__name(contextLoader, "contextLoader");
__name2(contextLoader, "contextLoader");
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e2) {
    wasm.__wbindgen_exn_store(addHeapObject(e2));
  }
}
__name(handleError, "handleError");
__name2(handleError, "handleError");
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
__name(getArrayU8FromWasm0, "getArrayU8FromWasm0");
__name2(getArrayU8FromWasm0, "getArrayU8FromWasm0");
function __wbg_adapter_133(arg0, arg1, arg2, arg3) {
  wasm.wasm_bindgen__convert__closures__invoke2_mut__h63ffd509f6690aab(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
__name(__wbg_adapter_133, "__wbg_adapter_133");
__name2(__wbg_adapter_133, "__wbg_adapter_133");
async function load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e2);
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
__name(load, "load");
__name2(load, "load");
function getImports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fetch_b1379d93c1e2b015 = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fetch_17b968b9c79d3c56 = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_4cba26249c1686cd = function() {
    return handleError(function() {
      const ret = new Headers();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_append_9c6d4d7f71076e48 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_instanceof_Response_240e67e5796c3c6b = function(arg0) {
    const ret = getObject(arg0) instanceof Response;
    return ret;
  };
  imports.wbg.__wbg_url_0f503b904b694ff5 = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_status_9067c6a4fdd064c9 = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
  };
  imports.wbg.__wbg_headers_aa309e800cf75016 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_arrayBuffer_ccd485f4d2929b08 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).arrayBuffer();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithstrandinit_de7c409ec8538105 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_randomFillSync_91e2b39becca6147 = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_getRandomValues_b14734aa289bc356 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_process_e56fd54cf6319b6c = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbg_versions_77e21455908dad33 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_node_0dd25d832e4785d5 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg_crypto_b95d7173266618a9 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_msCrypto_5a86d77a66230f81 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_NODE_MODULE_26b231378c1be7dd = function() {
    const ret = module;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_require_0db1598d9ccecb30 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_randomFillSync_d2ba53160aec6aba = function(arg0, arg1, arg2) {
    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
  };
  imports.wbg.__wbg_getRandomValues_e57c9b75ddead065 = function(arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
  };
  imports.wbg.__wbg_self_86b4b13392c7af56 = function() {
    return handleError(function() {
      const ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_crypto_b8c92eaac23d0d80 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_msCrypto_9ad6677321a08dd8 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg_static_accessor_MODULE_452b4680e8614c81 = function() {
    const ret = module;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_require_f5521a5b85ad2542 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getRandomValues_dd27e6b0652b3236 = function(arg0) {
    const ret = getObject(arg0).getRandomValues;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg_newnoargs_971e9a5abe185139 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_726d1c2255989269 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_3d0c4cc33e7418c9 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_done_e5655b169bb04f60 = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_value_8f901bca1014f843 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_iterator_22ed2b976832ff0c = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_72332cd2bc57924c = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_33d7bcddbbfa394a = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_e6a9fecc2bf26696 = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_self_fd00a1ef86d1b2ed = function() {
    return handleError(function() {
      const ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_6f6e346d8bbd61d7 = function() {
    return handleError(function() {
      const ret = window.window;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_3348936ac49df00a = function() {
    return handleError(function() {
      const ret = globalThis.globalThis;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_67175caf56f55ca9 = function() {
    return handleError(function() {
      const ret = global.global;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_65af9f665ab6ade5 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getTime_58b0bdbebd4ef11d = function(arg0) {
    const ret = getObject(arg0).getTime();
    return ret;
  };
  imports.wbg.__wbg_new0_adda2d4bcb124f0a = function() {
    const ret = new Date();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_52205195aa880fc2 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = /* @__PURE__ */ __name2((arg02, arg12) => {
        const a3 = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_133(a3, state0.b, arg02, arg12);
        } finally {
          state0.a = a3;
        }
      }, "cb0");
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_resolve_0107b3a501450ba0 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_18da6e5453572fc8 = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_e5489f796341454b = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_buffer_34f5ec9f8a838ba0 = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_88fdad741db1b182 = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_cda198d9dbc6d7ea = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_1a930cfcda1a8067 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_length_51f19f73d6d9eff3 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_newwithlength_66e5530e7079ea1b = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_subarray_270ff8dd5582c1ac = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_has_3be27932089d278e = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.has(getObject(arg0), getObject(arg1));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_set_2762e698c2f5b7e0 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_stringify_d8d1ee75d5b55ce4 = function() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper9508 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 2773, __wbg_adapter_26);
    return addHeapObject(ret);
  };
  return imports;
}
__name(getImports, "getImports");
__name2(getImports, "getImports");
function initMemory(imports, maybe_memory) {
}
__name(initMemory, "initMemory");
__name2(initMemory, "initMemory");
function finalizeInit(instance, module2) {
  wasm = instance.exports;
  init2.__wbindgen_wasm_module = module2;
  cachedInt32Memory0 = new Int32Array();
  cachedUint8Memory0 = new Uint8Array();
  return wasm;
}
__name(finalizeInit, "finalizeInit");
__name2(finalizeInit, "finalizeInit");
async function init2(input) {
  if (typeof input === "undefined") {
    input = new URL("didkit_wasm_bg.wasm", import_meta.url);
  }
  const imports = getImports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  initMemory(imports);
  const { instance, module: module2 } = await load(await input, imports);
  return finalizeInit(instance, module2);
}
__name(init2, "init");
__name2(init2, "init");
var didkit_wasm_default = init2;
var initialized = false;
var init22 = /* @__PURE__ */ __name2(async (arg = "https://cdn.filestackcontent.com/mg9PANmSiRzqPDfNluAa") => {
  if (initialized)
    return;
  initialized = true;
  return didkit_wasm_default(arg);
}, "init");
var didkit_default = init22;
var getDidKitPlugin = /* @__PURE__ */ __name2(async (input) => {
  await didkit_default(input);
  const memoizedDids = {};
  return {
    name: "DIDKit",
    displayName: "DIDKit",
    description: "Provides an interface to DIDKit, which allows for the generation of key material, as well as signing and verifying credentials and presentations",
    methods: {
      generateEd25519KeyFromBytes: (_learnCard, bytes) => JSON.parse(generateEd25519KeyFromBytes(bytes)),
      generateSecp256k1KeyFromBytes: (_learnCard, bytes) => JSON.parse(generateSecp256k1KeyFromBytes(bytes)),
      keyToDid: (_learnCard, type, keypair) => {
        const memoizedDid = memoizedDids[type];
        if (!memoizedDid) {
          const did = keyToDID(type, JSON.stringify(keypair));
          memoizedDids[type] = did;
          return did;
        }
        return memoizedDid;
      },
      keyToVerificationMethod: async (_learnCard, type, keypair) => keyToVerificationMethod(type, JSON.stringify(keypair)),
      didToVerificationMethod: async (_learnCard, did) => didToVerificationMethod(did),
      issueCredential: async (_learnCard, credential, options, keypair) => JSON.parse(
        await issueCredential(
          JSON.stringify(credential),
          JSON.stringify(options),
          JSON.stringify(keypair)
        )
      ),
      verifyCredential: async (_learnCard, credential, options = {}) => JSON.parse(
        await verifyCredential(JSON.stringify(credential), JSON.stringify(options))
      ),
      issuePresentation: async (_learnCard, presentation, options, keypair) => {
        const isJwt = options.proofFormat === "jwt";
        const result = await issuePresentation(
          JSON.stringify(presentation),
          JSON.stringify(options),
          JSON.stringify(keypair)
        );
        return isJwt ? result : JSON.parse(result);
      },
      verifyPresentation: async (_learnCard, presentation, options = {}) => {
        const isJwt = typeof presentation === "string";
        return JSON.parse(
          await verifyPresentation(
            isJwt ? presentation : JSON.stringify(presentation),
            JSON.stringify(options)
          )
        );
      },
      contextLoader: async (_learnCard, url) => JSON.parse(await contextLoader(url)),
      resolveDid: async (_learnCard, did, inputMetadata = {}) => JSON.parse(await resolveDID(did, JSON.stringify(inputMetadata))),
      didResolver: async (_learnCard, did, inputMetadata = {}) => JSON.parse(await didResolver(did, JSON.stringify(inputMetadata)))
    }
  };
}, "getDidKitPlugin");
var expirationPlugin = /* @__PURE__ */ __name2((learnCard) => ({
  name: "Expiration",
  displayName: "Expiration Extension",
  description: "Adds a check to make sure credentials aren't expired when verifying them",
  methods: {
    verifyCredential: async (_learnCard, credential) => {
      const verificationCheck = await learnCard.invoke.verifyCredential(credential);
      if (credential.expirationDate && new Date() > new Date(credential.expirationDate)) {
        verificationCheck.errors.push("expiration error: Credential is expired");
      } else {
        verificationCheck.checks.push("expiration");
      }
      return verificationCheck;
    }
  }
}), "expirationPlugin");
var VC_TEMPLATES = {
  basic: ({
    did = "did:example:d23dd687a7dc6787646f2eb98d0",
    subject = "did:example:d23dd687a7dc6787646f2eb98d0",
    issuanceDate = "2020-08-19T21:41:50Z"
  } = {}) => ({
    "@context": ["https://www.w3.org/2018/credentials/v1"],
    id: "http://example.org/credentials/3731",
    type: ["VerifiableCredential"],
    issuer: did,
    issuanceDate,
    credentialSubject: { id: subject }
  }),
  achievement: ({
    did = "did:example:d23dd687a7dc6787646f2eb98d0",
    subject = "did:example:d23dd687a7dc6787646f2eb98d0",
    name: name3 = "Teamwork Badge",
    achievementName = "Teamwork",
    description = "This badge recognizes the development of the capacity to collaborate within a group environment.",
    criteriaNarrative = "Team members are nominated for this badge by their peers and recognized upon review by Example Corp management.",
    issuanceDate = "2020-08-19T21:41:50Z"
  } = {}) => ({
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://purl.imsglobal.org/spec/ob/v3p0/context.json"
    ],
    id: "http://example.com/credentials/3527",
    type: ["VerifiableCredential", "OpenBadgeCredential"],
    issuer: did,
    issuanceDate,
    name: name3,
    credentialSubject: {
      id: subject,
      type: ["AchievementSubject"],
      achievement: {
        id: "https://example.com/achievements/21st-century-skills/teamwork",
        type: ["Achievement"],
        criteria: { narrative: criteriaNarrative },
        description,
        name: achievementName
      }
    }
  }),
  jff2: ({
    did = "did:example:d23dd687a7dc6787646f2eb98d0",
    subject = "did:example:d23dd687a7dc6787646f2eb98d0",
    issuanceDate = "2020-08-19T21:41:50Z"
  } = {}) => ({
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://purl.imsglobal.org/spec/ob/v3p0/context.json",
      "https://w3id.org/security/suites/ed25519-2020/v1"
    ],
    id: "urn:uuid:a63a60be-f4af-491c-87fc-2c8fd3007a58",
    type: ["VerifiableCredential", "OpenBadgeCredential"],
    name: "JFF x vc-edu PlugFest 2 Interoperability",
    issuer: {
      type: ["Profile"],
      id: did,
      name: "Jobs for the Future (JFF)",
      image: {
        id: "https://w3c-ccg.github.io/vc-ed/plugfest-1-2022/images/JFF_LogoLockup.png",
        type: "Image"
      }
    },
    issuanceDate,
    credentialSubject: {
      type: ["AchievementSubject"],
      id: subject,
      achievement: {
        id: "urn:uuid:bd6d9316-f7ae-4073-a1e5-2f7f5bd22922",
        type: ["Achievement"],
        name: "JFF x vc-edu PlugFest 2 Interoperability",
        description: "This credential solution supports the use of OBv3 and w3c Verifiable Credentials and is interoperable with at least two other solutions.  This was demonstrated successfully during JFF x vc-edu PlugFest 2.",
        criteria: {
          narrative: "Solutions providers earned this badge by demonstrating interoperability between multiple providers based on the OBv3 candidate final standard, with some additional required fields. Credential issuers earning this badge successfully issued a credential into at least two wallets.  Wallet implementers earning this badge successfully displayed credentials issued by at least two different credential issuers."
        },
        image: {
          id: "https://w3c-ccg.github.io/vc-ed/plugfest-2-2022/images/JFF-VC-EDU-PLUGFEST2-badge-image.png",
          type: "Image"
        }
      }
    }
  }),
  boost: ({
    did = "did:example:d23dd687a7dc6787646f2eb98d0",
    subject = "did:example:d23dd687a7dc6787646f2eb98d0",
    issuanceDate = "2020-08-19T21:41:50Z",
    expirationDate,
    boostName = "Example Boost",
    boostId = "urn:uuid:boost:example:555",
    boostImage,
    achievementId = "urn:uuid:123",
    achievementType = "Influencer",
    achievementName = "Awesome Badge",
    achievementDescription = "Awesome People Earn Awesome Badge",
    achievementNarrative = "Earned by being awesome.",
    achievementImage = "",
    attachments,
    display
  } = {}) => ({
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://purl.imsglobal.org/spec/ob/v3p0/context.json",
      {
        type: "@type",
        xsd: "https://www.w3.org/2001/XMLSchema#",
        lcn: "https://docs.learncard.com/definitions#",
        BoostCredential: {
          "@id": "lcn:boostCredential",
          "@context": {
            boostId: {
              "@id": "lcn:boostId",
              "@type": "xsd:string"
            },
            display: {
              "@id": "lcn:boostDisplay",
              "@context": {
                backgroundImage: {
                  "@id": "lcn:boostBackgroundImage",
                  "@type": "xsd:string"
                },
                backgroundColor: {
                  "@id": "lcn:boostBackgroundColor",
                  "@type": "xsd:string"
                }
              }
            },
            image: {
              "@id": "lcn:boostImage",
              "@type": "xsd:string"
            },
            attachments: {
              "@id": "lcn:boostAttachments",
              "@container": "@set",
              "@context": {
                type: {
                  "@id": "lcn:boostAttachmentType",
                  "@type": "xsd:string"
                },
                title: {
                  "@id": "lcn:boostAttachmentTitle",
                  "@type": "xsd:string"
                },
                url: {
                  "@id": "lcn:boostAttachmentUrl",
                  "@type": "xsd:string"
                }
              }
            }
          }
        }
      }
    ],
    type: ["VerifiableCredential", "OpenBadgeCredential", "BoostCredential"],
    issuer: did,
    issuanceDate,
    name: boostName,
    expirationDate,
    credentialSubject: {
      id: subject,
      type: ["AchievementSubject"],
      achievement: {
        id: achievementId,
        type: ["Achievement"],
        achievementType,
        name: achievementName,
        description: achievementDescription,
        image: achievementImage,
        criteria: {
          narrative: achievementNarrative
        }
      }
    },
    display,
    image: boostImage,
    attachments
  })
};
var getVCTemplatesPlugin = /* @__PURE__ */ __name2(() => {
  return {
    name: "VC Templates",
    displayName: "VC Templates",
    description: "Allows for the easy creation of VCs and VPs based on predefined templates",
    methods: {
      newCredential: (_learnCard, args = { type: "basic" }) => {
        const did = args.did || _learnCard.id.did();
        if (!did)
          throw new Error("Could not get issuer did!");
        const defaults = {
          did,
          subject: "did:example:d23dd687a7dc6787646f2eb98d0",
          issuanceDate: "2020-08-19T21:41:50Z"
        };
        const { type = "basic", ...functionArgs } = args;
        if (!(type in VC_TEMPLATES))
          throw new Error("Invalid Test VC Type!");
        return VC_TEMPLATES[type]({ ...defaults, ...functionArgs });
      },
      newPresentation: async (_learnCard, credential, args = {}) => {
        const did = args?.did || _learnCard.id.did();
        if (!did)
          throw new Error("Could not get issuer did!");
        return {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          type: ["VerifiablePresentation"],
          holder: did,
          verifiableCredential: credential
        };
      }
    }
  };
}, "getVCTemplatesPlugin");
var RPC_ERRORS = {
  ParseError: {
    message: "Parse error",
    code: -32700
  },
  InvalidRequest: {
    message: "Invalid Request",
    code: -32600
  },
  MethodNotFound: {
    message: "Method not found",
    code: -32601
  },
  InvalidParams: {
    message: "Invalid params",
    code: -32602
  },
  InternalError: {
    message: "Internal Error",
    code: -32603
  },
  ServerError: {
    message: "Server error",
    code: -32e3
  }
};
function parseUrl(url, base4) {
  if (base4 === void 0) {
    base4 = window.location.href;
  }
  if (typeof URL === "function") {
    return new URL(url, base4);
  }
  if (typeof url !== "string") {
    throw new TypeError('"url" must be a string.');
  }
  if (!url.includes(":")) {
    if (base4.startsWith("http") && !url.startsWith("/")) {
      url = base4 + "/" + url;
    } else {
      url = base4 + url;
    }
  }
  const parser = document.createElement("a");
  parser.href = url;
  let origin = (parser.protocol || window.location.protocol) + "//";
  if (parser.host) {
    if (parser.protocol === "http:" && parser.port === "80" || parser.protocol === "https:" && parser.port === "443") {
      origin += parser.hostname;
    } else {
      origin += parser.host;
    }
  } else {
    origin += window.location.host;
  }
  let pathname = parser.pathname;
  if (!pathname.startsWith("/")) {
    pathname = "/" + pathname;
  }
  return {
    host: parser.host || window.location.host,
    hostname: parser.hostname,
    origin,
    protocol: parser.protocol,
    pathname
  };
}
__name(parseUrl, "parseUrl");
__name2(parseUrl, "parseUrl");
function uuidv4(a3, b2) {
  for (b2 = a3 = ""; a3++ < 36; b2 += a3 * 51 & 52 ? (a3 ^ 15 ? 8 ^ Math.random() * (a3 ^ 20 ? 16 : 4) : 4).toString(16) : "-")
    ;
  return b2;
}
__name(uuidv4, "uuidv4");
__name2(uuidv4, "uuidv4");
function isValidMessage(message) {
  return message && typeof message === "object" && message.jsonrpc === "2.0" && message.id && typeof message.id === "string";
}
__name(isValidMessage, "isValidMessage");
__name2(isValidMessage, "isValidMessage");
function isValidRequest(message) {
  return isValidMessage(message) && Array.isArray(message.params);
}
__name(isValidRequest, "isValidRequest");
__name2(isValidRequest, "isValidRequest");
function isValidResponse(message) {
  return isValidMessage(message) && !!("result" in message ^ "error" in message) && (!("error" in message) || isValidError(message.error));
}
__name(isValidResponse, "isValidResponse");
__name2(isValidResponse, "isValidResponse");
function isValidError(error) {
  return error && typeof error === "object" && typeof error.code === "number" && typeof error.message === "string";
}
__name(isValidError, "isValidError");
__name2(isValidError, "isValidError");
function serializeError(error) {
  const err = {
    message: error.message
  };
  if (error.constructor.name !== "Error") {
    err.constructor = error.constructor.name;
  }
  if ("name" in error) {
    err.name = error.name;
  }
  if ("code" in error) {
    err.code = error.code;
  } else {
    err.code = RPC_ERRORS.ServerError.code;
  }
  if ("details" in error) {
    err.details = error.details;
  }
  return err;
}
__name(serializeError, "serializeError");
__name2(serializeError, "serializeError");
function deserializeError(error) {
  let err;
  if (error.constructor === "DOMException") {
    err = new DOMException(error.message, error.name);
  } else {
    err = new Error(error.message);
    if ("code" in error) {
      err.code = error.code;
    }
  }
  if (error.details) {
    err.details = error.details;
  }
  return err;
}
__name(deserializeError, "deserializeError");
__name2(deserializeError, "deserializeError");
function createMessageListener({ listener: listener2, origin, handle, expectRequest }) {
  if (isHandlePromise(handle)) {
    const promise = handle;
    handle = false;
    promise.then((h3) => handle = h3);
  }
  return (e2) => {
    if (!(e2.source === handle && e2.origin === origin && (expectRequest && isValidRequest(e2.data) || !expectRequest && isValidResponse(e2.data)))) {
      return;
    }
    listener2(e2.data, e2);
  };
}
__name(createMessageListener, "createMessageListener");
__name2(createMessageListener, "createMessageListener");
function destructureMethodName(fqMethodName) {
  let [name3, ...rest] = fqMethodName.split(".");
  const method = rest.pop();
  name3 = [name3, ...rest].join(".");
  return { name: name3, method };
}
__name(destructureMethodName, "destructureMethodName");
__name2(destructureMethodName, "destructureMethodName");
function isHandlePromise(handle) {
  try {
    return typeof handle.then === "function";
  } catch (e2) {
  }
  return false;
}
__name(isHandlePromise, "isHandlePromise");
__name2(isHandlePromise, "isHandlePromise");
var RPC_CLIENT_CALL_TIMEOUT = 3e4;
var Client = /* @__PURE__ */ __name(class {
  constructor() {
    this.origin = null;
    this._handle = null;
    this._listener = null;
    this._pending = /* @__PURE__ */ new Map();
  }
  async connect(origin, options) {
    if (this._listener) {
      throw new Error("Already connected.");
    }
    options = options || {};
    const self2 = this;
    self2.origin = parseUrl(origin).origin;
    self2._handle = options.handle || window.opener || window.parent;
    const pending = self2._pending;
    self2._listener = createMessageListener({
      origin: self2.origin,
      handle: self2._handle,
      expectRequest: false,
      listener: (message) => {
        if (!pending.has(message.id)) {
          return;
        }
        const { resolve, reject, cancelTimeout } = pending.get(message.id);
        cancelTimeout();
        if ("result" in message) {
          return resolve(message.result);
        }
        reject(deserializeError(message.error));
      }
    });
    window.addEventListener("message", self2._listener);
    return new Injector(self2);
  }
  async send(qualifiedMethodName, parameters, {
    timeout = RPC_CLIENT_CALL_TIMEOUT
  }) {
    if (!this._listener) {
      throw new Error("RPC client not connected.");
    }
    const self2 = this;
    const message = {
      jsonrpc: "2.0",
      id: uuidv4(),
      method: qualifiedMethodName,
      params: parameters
    };
    if (isHandlePromise(self2._handle)) {
      const handle = await self2._handle;
      handle.postMessage(message, self2.origin);
    } else {
      self2._handle.postMessage(message, self2.origin);
    }
    return new Promise((resolve, reject) => {
      const pending = self2._pending;
      let cancelTimeout;
      if (timeout > 0) {
        const timeoutId = setTimeout(() => {
          pending.delete(message.id);
          reject(new Error("RPC call timed out."));
        }, timeout);
        cancelTimeout = /* @__PURE__ */ __name2(() => {
          pending.delete(message.id);
          clearTimeout(timeoutId);
        }, "cancelTimeout");
      } else {
        cancelTimeout = /* @__PURE__ */ __name2(() => {
          pending.delete(message.id);
        }, "cancelTimeout");
      }
      pending.set(message.id, { resolve, reject, cancelTimeout });
    });
  }
  close() {
    if (this._listener) {
      window.removeEventListener("message", this._listener);
      this._handle = this.origin = this._listener = null;
      for (const value of this._pending.values()) {
        value.reject(new Error("RPC client closed."));
      }
      this._pending = /* @__PURE__ */ new Map();
    }
  }
}, "Client");
__name2(Client, "Client");
var Injector = /* @__PURE__ */ __name(class {
  constructor(client) {
    this.client = client;
    this._apis = /* @__PURE__ */ new Map();
  }
  define(name3, definition) {
    if (!(name3 && typeof name3 === "string")) {
      throw new TypeError("`name` must be a non-empty string.");
    }
    if (!(definition && typeof definition === "object" && Array.isArray(definition.functions))) {
      throw new TypeError(
        "`definition.function` must be an array of function names or function definition objects to be defined."
      );
    }
    const self2 = this;
    const api = {};
    definition.functions.forEach((fn) => {
      if (typeof fn === "string") {
        fn = { name: fn, options: {} };
      }
      api[fn.name] = async function() {
        return self2.client.send(
          name3 + "." + fn.name,
          [...arguments],
          fn.options
        );
      };
    });
    self2._apis[name3] = api;
    return api;
  }
  get(name3, definition) {
    const api = this._apis[name3];
    if (!api) {
      if (definition) {
        return this.define(name3, definition);
      }
      throw new Error(`API "${name3}" has not been defined.`);
    }
    return this._apis[name3];
  }
}, "Injector");
__name2(Injector, "Injector");
var EventEmitter = /* @__PURE__ */ __name(class {
  constructor({ deserialize = /* @__PURE__ */ __name2((e2) => e2, "deserialize"), waitUntil = /* @__PURE__ */ __name2(async () => {
  }, "waitUntil") } = {}) {
    this._listeners = [];
    this._deserialize = deserialize;
    this._waitUntil = waitUntil;
  }
  async emit(event) {
    event = this._deserialize(event);
    (this._listeners[event.type] || []).forEach((l) => l(event));
    return this._waitUntil(event);
  }
  addEventListener(eventType, fn) {
    if (!this._listeners[eventType]) {
      this._listeners[eventType] = [fn];
    } else {
      this._listeners[eventType].push(fn);
    }
  }
  removeEventListener(eventType, fn) {
    const listeners = this._listeners[eventType];
    if (!listeners) {
      return;
    }
    const idx = listeners.indexOf(fn);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  }
}, "EventEmitter");
__name2(EventEmitter, "EventEmitter");
var Server = /* @__PURE__ */ __name(class {
  constructor() {
    this.origin = null;
    this._handle = null;
    this._apis = /* @__PURE__ */ new Map();
  }
  define(name3, api) {
    if (!(name3 && typeof name3 === "string")) {
      throw new TypeError("`name` must be a non-empty string.");
    }
    if (!(api && api !== "object")) {
      throw new TypeError("`api` must be an object.");
    }
    if (name3 in this._apis) {
      throw new Error(`The "${name3}" API is already defined.`);
    }
    this._apis[name3] = api;
  }
  async listen(origin, options) {
    if (this._listener) {
      throw new Error("Already listening.");
    }
    options = options || {};
    const self2 = this;
    self2.origin = parseUrl(origin).origin;
    self2._handle = options.handle || window.opener || window.parent;
    const ignoreUnknownApi = options.ignoreUnknownApi === "true" || false;
    self2._listener = createMessageListener({
      origin: self2.origin,
      handle: self2._handle,
      expectRequest: true,
      listener: (message) => {
        const { name: name3, method } = destructureMethodName(message.method);
        const api = self2._apis[name3];
        if (method && method.startsWith("_")) {
          return sendMethodNotFound(self2._handle, self2.origin, message);
        }
        if (!api && ignoreUnknownApi) {
          return;
        }
        if (!api || typeof api[method] !== "function") {
          return sendMethodNotFound(self2._handle, self2.origin, message);
        }
        const fn = api[method];
        (async () => {
          const response = {
            jsonrpc: "2.0",
            id: message.id
          };
          try {
            response.result = await fn.apply(api, message.params);
          } catch (e2) {
            response.error = serializeError(e2);
          }
          if (self2._handle) {
            if (isHandlePromise(self2._handle)) {
              self2._handle.then((h3) => h3.postMessage(response, self2.origin));
            } else {
              self2._handle.postMessage(response, self2.origin);
            }
          }
        })();
      }
    });
    window.addEventListener("message", self2._listener);
  }
  close() {
    if (this._listener) {
      window.removeEventListener("message", this._listener);
      this._handle = this.origin = this._listener = null;
    }
  }
}, "Server");
__name2(Server, "Server");
function sendMethodNotFound(handle, origin, message) {
  const response = {
    jsonrpc: "2.0",
    id: message.id,
    error: Object.assign({}, RPC_ERRORS.MethodNotFound)
  };
  if (isHandlePromise(handle)) {
    return handle.then((h3) => h3.postMessage(response, origin));
  } else {
    return handle.postMessage(response, origin);
  }
}
__name(sendMethodNotFound, "sendMethodNotFound");
__name2(sendMethodNotFound, "sendMethodNotFound");
var WebApp = /* @__PURE__ */ __name(class {
  constructor(relyingOrigin) {
    this.relyingOrigin = parseUrl(relyingOrigin).origin;
    this.client = null;
    this.injector = null;
    this.client = new Client();
    this.server = new Server();
    this._control = null;
    this._connected = false;
  }
  async connect() {
    this.injector = await this.client.connect(this.relyingOrigin);
    this._connected = true;
    this._control = this.injector.define("core.control", {
      functions: ["ready", "show", "hide"]
    });
    this.server.listen(this.relyingOrigin);
    return this.injector;
  }
  async ready() {
    if (!this._connected) {
      throw new Error('WebApp not connected. Did you call ".connect()"?');
    }
    await this._control.ready();
    return this;
  }
  close() {
    if (this._connected) {
      this.server.close();
      this.client.close();
      this._connected = false;
    }
  }
  async show() {
    if (!this._connected) {
      throw new Error(
        'Cannot "show" yet; not connected. Did you call ".connect()"?'
      );
    }
    return this._control.show();
  }
  async hide() {
    if (!this._connected) {
      throw new Error(
        'Cannot "hide" yet; not connected. Did you call ".connect()?"'
      );
    }
    return this._control.hide();
  }
}, "WebApp");
__name2(WebApp, "WebApp");
var WebAppWindowDialog = /* @__PURE__ */ __name(class {
  constructor() {
    this._closeEventListeners = /* @__PURE__ */ new Set();
  }
  addEventListener(name3, listener2) {
    if (name3 !== "close") {
      throw new Error(`Unknown event "${name3}".`);
    }
    if (typeof listener2 !== "function") {
      throw new TypeError('"listener" must be a function.');
    }
    this._closeEventListeners.add(listener2);
  }
  removeEventListener(name3, listener2) {
    if (name3 !== "close") {
      throw new Error(`Unknown event "${name3}".`);
    }
    if (typeof listener2 !== "function") {
      throw new TypeError('"listener" must be a function.');
    }
    this._closeEventListeners.delete(listener2);
  }
  show() {
  }
  close() {
    for (const listener2 of this._closeEventListeners) {
      listener2({});
    }
  }
  destroy() {
    this._closeEventListeners.clear();
  }
}, "WebAppWindowDialog");
__name2(WebAppWindowDialog, "WebAppWindowDialog");
var WebAppWindowInlineDialog = /* @__PURE__ */ __name(class extends WebAppWindowDialog {
  constructor({ url, handle, className }) {
    super();
    this.url = url;
    this.handle = handle;
    this.dialog = document.createElement("dialog");
    applyStyle(this.dialog, {
      position: "fixed",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      "max-width": "100%",
      "max-height": "100%",
      display: "none",
      margin: 0,
      padding: 0,
      border: "none",
      background: "transparent",
      color: "black",
      "box-sizing": "border-box",
      overflow: "hidden",
      "user-select": "none",
      "z-index": 1e6
    });
    this.dialog.className = "web-app-window";
    if (typeof className === "string") {
      this.dialog.className = this.dialog.className + " " + className;
    }
    const style = document.createElement("style");
    style.appendChild(
      document.createTextNode(`dialog.web-app-window::backdrop {
        background-color: transparent;
      }`)
    );
    this.container = document.createElement("div");
    applyStyle(this.container, {
      position: "relative",
      width: "100%",
      height: "100%",
      margin: 0,
      padding: 0,
      display: "flex",
      "flex-direction": "column"
    });
    this.container.className = "web-app-window-backdrop";
    this.iframe = document.createElement("iframe");
    this.iframe.src = url;
    this.iframe.scrolling = "auto";
    applyStyle(this.iframe, {
      position: "fixed",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      border: "none",
      background: "transparent",
      overflow: "hidden",
      margin: 0,
      padding: 0,
      "flex-grow": 1,
      "user-select": "none"
    });
    this.dialog.appendChild(style);
    this.container.appendChild(this.iframe);
    this.dialog.appendChild(this.container);
    this.dialog.addEventListener("cancel", (e2) => {
      e2.preventDefault();
      this.hide();
    });
    document.body.appendChild(this.dialog);
    this.handle = this.iframe.contentWindow;
  }
  show() {
    this.dialog.style.display = "block";
    if (this.dialog.showModal) {
      this.dialog.showModal();
    }
    try {
      this.dialog.style.pointerEvents = "none";
    } catch (e2) {
    }
    setTimeout(() => {
      try {
        this.dialog.style.pointerEvents = "";
      } catch (e2) {
      }
    }, 32);
  }
  close() {
    this.dialog.style.display = "none";
    if (this.dialog.close) {
      try {
        this.dialog.close();
      } catch (e2) {
        console.error(e2);
      }
    }
    super.close();
  }
  destroy() {
    this.dialog.parentNode.removeChild(this.dialog);
    super.destroy();
  }
}, "WebAppWindowInlineDialog");
__name2(WebAppWindowInlineDialog, "WebAppWindowInlineDialog");
function applyStyle(element, style) {
  for (const name3 in style) {
    element.style[name3] = style[name3];
  }
}
__name(applyStyle, "applyStyle");
__name2(applyStyle, "applyStyle");
var WebAppWindowPopupDialog = /* @__PURE__ */ __name(class extends WebAppWindowDialog {
  constructor({ url, handle, bounds = { width: 500, height: 400 } }) {
    super();
    this.url = url;
    this.handle = handle;
    this._locationChanging = false;
    if (!handle) {
      this._openWindow({ url, name: "web-app-window", bounds });
    }
    this.destroyed = false;
    this._removeListeners = () => {
    };
  }
  show() {
  }
  close() {
    this.destroy();
  }
  destroy() {
    if (this.handle && !this.destroyed) {
      this.handle.close();
      super.close();
      this.handle = null;
      this.destroyed = true;
      this._removeListeners();
      super.destroy();
    }
  }
  isClosed() {
    return !this.handle || this.handle.closed;
  }
  _openWindow({ url, name: name3, bounds }) {
    const { x: x2, y: y3 } = bounds;
    let { width = 500, height = 400 } = bounds;
    width = Math.min(width, window.innerWidth);
    height = Math.min(height, window.innerHeight);
    const left = Math.floor(x2 !== void 0 ? x2 : window.screenX + (window.innerWidth - width) / 2);
    const top = Math.floor(y3 !== void 0 ? y3 : window.screenY + (window.innerHeight - height) / 2);
    const features = `popup=yes,menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=${width},height=${height},left=${left},top=${top}`;
    this._locationChanging = true;
    this.handle = window.open(url, name3, features);
    this._addListeners();
  }
  setLocation(url) {
    this.url = url;
    this._locationChanging = true;
    this.handle.location.replace(url);
  }
  _addListeners() {
    const destroyDialog = /* @__PURE__ */ __name2(() => this.destroy(), "destroyDialog");
    const loadDialog = /* @__PURE__ */ __name2(() => {
      this._locationChanging = false;
    }, "loadDialog");
    const unloadDialog = /* @__PURE__ */ __name2(() => {
      if (this._locationChanging) {
        return;
      }
      this.destroy();
    }, "unloadDialog");
    this.handle.addEventListener("unload", unloadDialog);
    this.handle.addEventListener("load", loadDialog);
    window.addEventListener("beforeUnload", destroyDialog, { once: true });
    const intervalId = setInterval(() => {
      if (this.isClosed()) {
        this.destroy();
        clearInterval(intervalId);
      }
    }, 250);
    this._removeListeners = () => {
      clearInterval(intervalId);
      this.handle.removeListener("unload", unloadDialog);
      this.handle.removeListener("load", loadDialog);
      window.removeEventListener("beforeUnload", destroyDialog);
    };
  }
}, "WebAppWindowPopupDialog");
__name2(WebAppWindowPopupDialog, "WebAppWindowPopupDialog");
var LOAD_WINDOW_TIMEOUT = 6e4;
var WebAppWindow = /* @__PURE__ */ __name(class {
  constructor(url, {
    timeout = LOAD_WINDOW_TIMEOUT,
    dialog = null,
    handle,
    popup = false,
    className = null,
    customize = null,
    bounds
  } = {}) {
    this.visible = false;
    this.dialog = dialog;
    this.handle = null;
    this.popup = popup;
    this.windowControl = null;
    this._destroyed = false;
    this._ready = false;
    this._private = {};
    this._timeoutId = null;
    if (handle && handle._dialog) {
      this.dialog = dialog = handle._dialog;
    }
    this._private._readyPromise = new Promise((resolve, reject) => {
      this._timeoutId = setTimeout(
        () => reject(new DOMException(
          "Loading Web application window timed out.",
          "TimeoutError"
        )),
        timeout
      );
      this._private._resolveReady = (value) => {
        clearTimeout(this.timeoutId);
        this._timeoutId = null;
        resolve(value);
      };
      this._private._rejectReady = (err) => {
        clearTimeout(this.timeoutId);
        this._timeoutId = null;
        reject(err);
      };
    });
    this._private.isReady = async () => {
      return this._private._readyPromise;
    };
    this._private.destroy = () => {
      if (this._timeoutId) {
        this._private._rejectReady(new DOMException(
          "Web application window closed before ready.",
          "AbortError"
        ));
      }
      if (!this._destroyed) {
        this.dialog.destroy();
        this.dialog = null;
        this._destroyed = true;
      }
    };
    if (customize) {
      if (!typeof customize === "function") {
        throw new TypeError("`options.customize` must be a function.");
      }
    }
    if (!this.dialog) {
      if (this.popup) {
        this.dialog = new WebAppWindowPopupDialog({ url, handle, bounds });
      } else {
        this.dialog = new WebAppWindowInlineDialog({ url, handle, className });
      }
    }
    if (this.popup && bounds) {
      let { x: x2, y: y3, width = 500, height = 400 } = bounds;
      width = Math.min(width, window.innerWidth);
      height = Math.min(height + 30, window.innerHeight);
      x2 = Math.floor(x2 !== void 0 ? x2 : window.screenX + (window.innerWidth - width) / 2);
      y3 = Math.floor(y3 !== void 0 ? y3 : window.screenY + (window.innerHeight - height) / 2 + 15);
      this.dialog.handle.resizeTo(width, height);
      this.dialog.handle.moveTo(x2, y3);
    }
    this.handle = this.dialog.handle;
    if (customize) {
      try {
        customize({
          dialog: this.dialog.dialog,
          container: this.dialog.container,
          iframe: this.dialog.iframe,
          webAppWindow: this
        });
      } catch (e2) {
        console.error(e2);
      }
    }
  }
  ready() {
    this._ready = true;
    this._private._resolveReady(true);
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      const body = document.querySelector("body");
      this._bodyOverflowStyle = body.style.overflow;
      body.style.overflow = "hidden";
      if (!this._destroyed) {
        this.dialog.show();
      } else if (this.windowControl.show) {
        this.windowControl.show();
      }
    }
  }
  hide() {
    if (this.visible) {
      this.visible = false;
      const body = document.querySelector("body");
      if (this._bodyOverflowStyle) {
        body.style.overflow = this._bodyOverflowStyle;
      } else {
        body.style.overflow = "";
      }
      if (!this._destroyed) {
        this.dialog.close();
      } else if (this.windowControl.hide) {
        this.windowControl.hide();
      }
    }
  }
}, "WebAppWindow");
__name2(WebAppWindow, "WebAppWindow");
var WEB_APP_CONTEXT_LOAD_TIMEOUT = 1e4;
var WebAppContext = /* @__PURE__ */ __name(class {
  constructor() {
    this.client = new Client();
    this.server = new Server();
    this.injector = null;
    this.control = null;
    this.loaded = false;
    this.closed = false;
  }
  async createWindow(url, {
    timeout = WEB_APP_CONTEXT_LOAD_TIMEOUT,
    iframe,
    dialog = null,
    popup = false,
    handle,
    windowControl,
    className,
    customize,
    bounds
  } = {}) {
    if (this.loaded) {
      throw new Error("AppContext already loaded.");
    }
    this.loaded = true;
    this.control = new WebAppWindow(url, {
      timeout,
      dialog,
      iframe,
      popup,
      handle,
      windowControl,
      className,
      customize,
      bounds
    });
    window.addEventListener("pagehide", () => this.close(), { once: true });
    this.server.define("core.control", this.control);
    const origin = parseUrl(url).origin;
    this.server.listen(origin, {
      handle: this.control.handle,
      ignoreUnknownApi: true
    });
    await this.control._private.isReady();
    this.injector = await this.client.connect(origin, {
      handle: this.control.handle
    });
    return this.injector;
  }
  close() {
    if (!this.closed) {
      this.closed = true;
      this.control._private.destroy();
      this.server.close();
      this.client.close();
    }
  }
}, "WebAppContext");
__name2(WebAppContext, "WebAppContext");
var CredentialRequestEvent = /* @__PURE__ */ __name(class {
  constructor({
    credentialHandler,
    credentialRequestOrigin,
    credentialRequestOptions,
    hintKey
  }) {
    this.type = "credentialrequest";
    this._credentialHandler = credentialHandler;
    this.credentialRequestOrigin = credentialRequestOrigin;
    this.credentialRequestOptions = credentialRequestOptions;
    this.hintKey = hintKey;
  }
  async openWindow(url) {
    await this._credentialHandler.show();
    const appWindow = new WebAppWindow(url, {
      className: "credential-handler"
    });
    appWindow.ready();
    appWindow.show();
    appWindow.handle._dialog = appWindow.dialog;
    return appWindow.handle;
  }
  respondWith(handlerResponse) {
    this._promise = handlerResponse;
  }
}, "CredentialRequestEvent");
__name2(CredentialRequestEvent, "CredentialRequestEvent");
var CredentialStoreEvent = /* @__PURE__ */ __name(class {
  constructor({
    credentialHandler,
    credentialRequestOrigin,
    credential,
    hintKey
  }) {
    this.type = "credentialstore";
    this._credentialHandler = credentialHandler;
    this.credentialRequestOrigin = credentialRequestOrigin;
    this.credential = credential;
    this.hintKey = hintKey;
  }
  async openWindow(url) {
    await this._credentialHandler.show();
    const appWindow = new WebAppWindow(url);
    appWindow.ready();
    appWindow.show();
    appWindow.handle._dialog = appWindow.dialog;
    return appWindow.handle;
  }
  respondWith(handlerResponse) {
    this._promise = handlerResponse;
  }
}, "CredentialStoreEvent");
__name2(CredentialStoreEvent, "CredentialStoreEvent");
var CredentialHandlerService = /* @__PURE__ */ __name(class {
  constructor(credentialHandler) {
    this._credentialHandler = credentialHandler;
  }
  async request(credentialRequestEvent) {
    return await this._credentialHandler._emitter.emit(
      new CredentialRequestEvent(Object.assign(
        { credentialHandler: this._credentialHandler },
        credentialRequestEvent
      ))
    );
  }
  async store(credentialStoreEvent) {
    return await this._credentialHandler._emitter.emit(
      new CredentialStoreEvent(Object.assign(
        { credentialHandler: this._credentialHandler },
        credentialStoreEvent
      ))
    );
  }
}, "CredentialHandlerService");
__name2(CredentialHandlerService, "CredentialHandlerService");
var EVENT_TYPES = ["credentialrequest", "credentialstore"];
var CredentialHandler = /* @__PURE__ */ __name(class extends WebApp {
  constructor(mediatorOrigin, inline = false) {
    if (typeof mediatorOrigin !== "string") {
      throw new TypeError('"mediatorOrigin" must be a string.');
    }
    super(mediatorOrigin, inline);
    this._emitter = new EventEmitter({
      async waitUntil(event) {
        return event._promise || Promise.reject(
          new DOMException(
            'No "credentialrequest" event handler found.',
            "NotFoundError"
          )
        );
      }
    });
  }
  async connect() {
    const injector = await super.connect();
    this.server.define("credentialHandler", new CredentialHandlerService(this));
    await this.ready();
    return injector;
  }
  addEventListener(eventType, fn) {
    if (!EVENT_TYPES.includes(eventType)) {
      throw new DOMException(
        `Unsupported event type "${eventType}"`,
        "NotSupportedError"
      );
    }
    return this._emitter.addEventListener(eventType, fn);
  }
  removeEventListener(eventType, fn) {
    if (!EVENT_TYPES.includes(eventType)) {
      throw new DOMException(
        `Unsupported event type "${eventType}"`,
        "NotSupportedError"
      );
    }
    return this._emitter.removeEventListener(eventType, fn);
  }
}, "CredentialHandler");
__name2(CredentialHandler, "CredentialHandler");
var CredentialHints = /* @__PURE__ */ __name(class {
  constructor(url, injector) {
    const remote = injector.get("credentialHints", {
      functions: ["delete", "get", "keys", "has", "set", "clear"]
    });
    for (let methodName in remote) {
      if (methodName !== "set") {
        const method = remote[methodName].bind(this, url);
        this[methodName] = function(...args) {
          this._deprecateNotice();
          return method(...args);
        };
      }
    }
    this._remoteSet = remote.set.bind(this, url);
  }
  async set(hintKey, credentialHint) {
    this._deprecateNotice();
    credentialHint.icons = credentialHint.icons || [];
    const promises = credentialHint.icons.map((icon) => imageToDataUrl(icon.src).then((fetchedImage) => {
      icon.fetchedImage = fetchedImage;
    }));
    await Promise.all(promises);
    return this._remoteSet(hintKey, credentialHint);
  }
  _deprecateNotice() {
    console.warn("Credential hints are deprecated and no longer used.");
  }
}, "CredentialHints");
__name2(CredentialHints, "CredentialHints");
function imageToDataUrl(url) {
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = () => {
      let canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.height = img.height;
      canvas.width = img.width;
      ctx.drawImage(img, 0, 0);
      const dataUrl = canvas.toDataURL();
      resolve(dataUrl);
      canvas = null;
    };
    img.onerror = () => resolve(null);
    img.src = url;
  });
}
__name(imageToDataUrl, "imageToDataUrl");
__name2(imageToDataUrl, "imageToDataUrl");
var CredentialManager = /* @__PURE__ */ __name(class {
  constructor(url, injector) {
    if (!(url && typeof url === "string")) {
      throw new TypeError('"url" must be a non-empty string.');
    }
    this.hints = new CredentialHints(url, injector);
  }
  static async requestPermission() {
    const status = await navigator.credentialsPolyfill.permissions.request(
      { name: "credentialhandler" }
    );
    return status.state;
  }
}, "CredentialManager");
__name2(CredentialManager, "CredentialManager");
var CredentialHandlerRegistration = /* @__PURE__ */ __name(class {
  constructor(url, injector) {
    if (!(url && typeof url === "string")) {
      throw new TypeError('"url" must be a non-empty string.');
    }
    this.credentialManager = new CredentialManager(url, injector);
  }
}, "CredentialHandlerRegistration");
__name2(CredentialHandlerRegistration, "CredentialHandlerRegistration");
var CredentialHandlers = /* @__PURE__ */ __name(class {
  constructor(injector) {
    this._init = (async () => {
      this._injector = await injector;
      this._remote = this._injector.get("credentialHandlers", {
        functions: [
          "register",
          "unregister",
          "getRegistration",
          "hasRegistration"
        ]
      });
    })();
  }
  async register(url) {
    this._deprecateNotice();
    await this._init;
    url = await this._remote.register("credential", url);
    return new CredentialHandlerRegistration(url, this._injector);
  }
  async unregister(url) {
    this._deprecateNotice();
    await this._init;
    return this._remote.unregister("credential", url);
  }
  async getRegistration(url) {
    this._deprecateNotice();
    await this._init;
    url = await this._remote.getRegistration("credential", url);
    if (!url) {
      return null;
    }
    return new CredentialHandlerRegistration(url, this._injector);
  }
  async hasRegistration(url) {
    this._deprecateNotice();
    await this._init;
    return await this._remote.hasRegistration("credential", url);
  }
  _deprecateNotice() {
    console.warn(
      'Credential handler registration APIs are deprecated. The credential handler specified in "manifest.json" is now automatically registered when a user grants permission to install a credential handler via "CredentialManager.requestPermission()".'
    );
  }
}, "CredentialHandlers");
__name2(CredentialHandlers, "CredentialHandlers");
var WebCredential2 = /* @__PURE__ */ __name(class {
  constructor(dataType, data, { recommendedHandlerOrigins = [] } = {}) {
    if (typeof dataType !== "string") {
      throw new TypeError('"dataType" must be a string.');
    }
    this.type = "web";
    this.dataType = dataType;
    this.data = data;
    this.options = { recommendedHandlerOrigins };
  }
}, "WebCredential2");
__name2(WebCredential2, "WebCredential");
var CREDENTIAL_GET_TIMEOUT = 0;
var CREDENTIAL_STORE_TIMEOUT = 0;
var CredentialsContainer = /* @__PURE__ */ __name(class {
  constructor(injector) {
    this._nativeCredentialsContainer = {
      get: navigator.credentials && navigator.credentials.get && navigator.credentials.get.bind(navigator.credentials),
      store: navigator.credentials && navigator.credentials.store && navigator.credentials.store.bind(navigator.credentials)
    };
    this._init = (async () => {
      this._remote = (await injector).get("credentialsContainer", {
        functions: [
          { name: "get", options: { timeout: CREDENTIAL_GET_TIMEOUT } },
          { name: "store", options: { timeout: CREDENTIAL_STORE_TIMEOUT } }
        ]
      });
    })();
  }
  async get(options = {}) {
    if (options.web) {
      await this._init;
      const credential = await this._remote.get(options);
      if (!credential) {
        return null;
      }
      return new WebCredential2(credential.dataType, credential.data);
    }
    if (this._nativeCredentialsContainer.get) {
      return this._nativeCredentialsContainer.get(options);
    }
    throw new DOMException("Not implemented.", "NotSupportedError");
  }
  async store(credential) {
    if (credential instanceof WebCredential2) {
      await this._init;
      const result = await this._remote.store(credential);
      if (!result) {
        return null;
      }
      return new WebCredential2(result.dataType, result.data);
    }
    if (this._nativeCredentialsContainer.store) {
      return this._nativeCredentialsContainer.store(credential);
    }
    throw new DOMException("Not implemented.", "NotSupportedError");
  }
}, "CredentialsContainer");
__name2(CredentialsContainer, "CredentialsContainer");
var PERMISSION_REQUEST_TIMEOUT = 0;
var PermissionManager = /* @__PURE__ */ __name(class {
  constructor(injector) {
    this._init = (async () => {
      this._remote = (await injector).get("permissionManager", {
        functions: [
          "query",
          { name: "request", options: { timeout: PERMISSION_REQUEST_TIMEOUT } },
          "revoke"
        ]
      });
    })();
  }
  async query(permissionDesc) {
    await this._init;
    return await this._remote.query(permissionDesc);
  }
  async request(permissionDesc) {
    await this._init;
    return await this._remote.request(permissionDesc);
  }
  async revoke(permissionDesc) {
    await this._init;
    return await this._remote.revoke(permissionDesc);
  }
}, "PermissionManager");
__name2(PermissionManager, "PermissionManager");
var DEFAULT_MEDIATOR_ORIGIN = "https://authn.io";
var loaded;
async function loadOnce(options) {
  if (loaded) {
    return loaded;
  }
  loaded = true;
  return load2(options);
}
__name(loadOnce, "loadOnce");
__name2(loadOnce, "loadOnce");
async function load2(options = {
  mediatorOrigin: DEFAULT_MEDIATOR_ORIGIN
}) {
  _assertSecureContext();
  let mediatorUrl;
  if (typeof options === "string") {
    mediatorUrl = options;
  } else if (options && typeof options === "object" && typeof options.mediatorOrigin === "string") {
    mediatorUrl = `${options.mediatorOrigin}/mediator`;
  } else {
    throw new Error(
      '"options.mediatorOrigin" must be a string expressing the origin of the mediator.'
    );
  }
  const appContext = new WebAppContext();
  const injector = appContext.createWindow(mediatorUrl, {
    className: "credential-mediator",
    timeout: 3e4
  });
  const style = document.createElement("style");
  style.appendChild(document.createTextNode(
    `dialog.web-app-window.credential-mediator > .web-app-window-backdrop {
      background-color: rgba(0, 0, 0, 0.25);
    }`
  ));
  document.body.appendChild(style);
  const polyfill = {};
  polyfill.permissions = new PermissionManager(injector);
  polyfill.CredentialHandlers = new CredentialHandlers(injector);
  polyfill.CredentialHandler = CredentialHandler;
  polyfill.CredentialManager = CredentialManager;
  polyfill.credentials = new CredentialsContainer(injector);
  polyfill.WebCredential = WebCredential2;
  navigator.credentialsPolyfill = polyfill;
  if ("credentials" in navigator) {
    navigator.credentials.get = polyfill.credentials.get.bind(
      polyfill.credentials
    );
    navigator.credentials.store = polyfill.credentials.store.bind(
      polyfill.credentials
    );
  } else {
    navigator.credentials = polyfill.credentials;
  }
  window.CredentialManager = CredentialManager;
  window.WebCredential = WebCredential2;
  return polyfill;
}
__name(load2, "load2");
__name2(load2, "load");
function _assertSecureContext() {
  if (!window.isSecureContext) {
    throw new DOMException("SecurityError", "The operation is insecure.");
  }
}
__name(_assertSecureContext, "_assertSecureContext");
__name2(_assertSecureContext, "_assertSecureContext");
var PROXY_EVENT_TIMEOUT = 6e4;
var CredentialEventProxy = /* @__PURE__ */ __name(class extends WebApp {
  constructor() {
    super(window.location.origin);
  }
  async receive() {
    const self2 = this;
    await self2.connect();
    return new Promise((resolveReceive, rejectReceive) => {
      const timeoutId = setTimeout(() => {
        rejectReceive(new Error("Timed out waiting to receive event."));
      }, PROXY_EVENT_TIMEOUT);
      self2.server.define("credentialEventProxy", {
        async send(event) {
          resolveReceive(event);
          clearTimeout(timeoutId);
          return new Promise((resolveSend, rejectSend) => {
            event.respondWith = (promise) => {
              try {
                resolveSend(promise);
              } catch (e2) {
                rejectSend(e2);
              }
            };
          });
        }
      });
      self2.ready();
    });
  }
}, "CredentialEventProxy");
__name2(CredentialEventProxy, "CredentialEventProxy");
var DEFAULT_MEDIATOR = "https://authn.io";
async function installHandler() {
  const CredentialManager2 = navigator.credentialsPolyfill.CredentialManager;
  const result = await CredentialManager2.requestPermission();
  if (result !== "granted") {
    throw new Error("Permission denied.");
  }
}
__name(installHandler, "installHandler");
__name2(installHandler, "installHandler");
async function activateHandler({
  mediatorOrigin = DEFAULT_MEDIATOR,
  get: get2,
  store
}) {
  if (!(get2 || store)) {
    throw new Error('"get" or "store" function(s) must be specified.');
  }
  const CredentialHandler2 = navigator.credentialsPolyfill.CredentialHandler;
  const self2 = new CredentialHandler2(mediatorOrigin);
  if (get2) {
    if (typeof get2 !== "function") {
      throw new TypeError('"get" must be a function.');
    }
    self2.addEventListener("credentialrequest", (event) => listener({ event, get: get2 }));
  }
  if (store) {
    if (typeof store !== "function") {
      throw new TypeError('"store" must be a function.');
    }
    self2.addEventListener("credentialstore", (event) => listener({ event, store }));
  }
  await self2.connect();
}
__name(activateHandler, "activateHandler");
__name2(activateHandler, "activateHandler");
async function receiveCredentialEvent() {
  const proxy = new CredentialEventProxy();
  return proxy.receive();
}
__name(receiveCredentialEvent, "receiveCredentialEvent");
__name2(receiveCredentialEvent, "receiveCredentialEvent");
function listener({ event, get: get2, store }) {
  event.respondWith(createResponse({ event, get: get2, store }));
}
__name(listener, "listener");
__name2(listener, "listener");
async function createResponse({ event, get: get2, store }) {
  const result = await (get2 || store)({ event });
  if (!(result && typeof result === "object")) {
    throw new TypeError(
      'Return value of "get" or "store" hook must be an object.'
    );
  }
  if (result.type === "response") {
    return { dataType: result.dataType, data: result.data };
  }
  if (result.type === "redirect") {
    const appContext = new WebAppContext();
    const handle = await event.openWindow(result.url);
    const windowReady = appContext.createWindow(result.url, {
      handle,
      popup: false,
      timeout: 6e5
    });
    const injector = await windowReady;
    const proxy = injector.get("credentialEventProxy", {
      functions: [{ name: "send", options: { timeout: 0 } }]
    });
    return proxy.send({
      type: event.type,
      credentialRequestOptions: event.credentialRequestOptions,
      credentialRequestOrigin: event.credentialRequestOrigin,
      credential: event.credential,
      hintKey: event.hintKey
    });
  }
  throw new Error(
    'Return value of "get" or "store" must have a type of "response" or "redirect".'
  );
}
__name(createResponse, "createResponse");
__name2(createResponse, "createResponse");
var getCHAPIPlugin = /* @__PURE__ */ __name2(async () => {
  if (typeof window === "undefined") {
    return {
      name: "CHAPI",
      methods: {
        installChapiHandler: async () => {
          throw new Error("CHAPI is only available inside of a browser!");
        },
        activateChapiHandler: async () => {
          throw new Error("CHAPI is only available inside of a browser!");
        },
        receiveChapiEvent: async () => {
          throw new Error("CHAPI is only available inside of a browser!");
        },
        storeCredentialViaChapiDidAuth: async () => {
          throw new Error("CHAPI is only available inside of a browser!");
        },
        storePresentationViaChapi: async () => {
          throw new Error("CHAPI is only available inside of a browser!");
        }
      }
    };
  }
  await loadOnce();
  return {
    name: "CHAPI",
    displayName: "CHAPI",
    description: "Credential Handler API. Allows sending/retrieving credentials across wallets and issuers",
    methods: {
      installChapiHandler: async () => installHandler(),
      activateChapiHandler: async (_learnCard, {
        mediatorOrigin = `https://authn.io/mediator?${encodeURIComponent(
          window.location.origin
        )}`,
        get: get2,
        store
      }) => {
        return activateHandler({ mediatorOrigin, get: get2, store });
      },
      receiveChapiEvent: async () => receiveCredentialEvent(),
      storeCredentialViaChapiDidAuth: async (_learnCard, credential) => {
        const challenge = crypto.randomUUID();
        const domain = window.location.origin;
        const vpr = {
          web: {
            VerifiablePresentation: {
              query: { type: "DIDAuthentication" },
              challenge,
              domain
            }
          }
        };
        const res = await navigator.credentials.get(vpr);
        if (!res)
          return { success: false, reason: "did not auth" };
        const verification = await _learnCard.invoke.verifyPresentation(res.data, {
          challenge,
          domain,
          proofPurpose: "authentication"
        });
        if (verification.warnings.length > 0 || verification.errors.length > 0) {
          return { success: false, reason: "auth failed verification" };
        }
        const subject = res.data?.proof?.verificationMethod?.split("#")[0];
        if (!Array.isArray(credential.credentialSubject)) {
          credential.credentialSubject.id = subject;
        }
        const vp = await _learnCard.invoke.getTestVp(
          await _learnCard.invoke.issueCredential(credential)
        );
        const success = await _learnCard.invoke.storePresentationViaChapi(vp);
        if (success)
          return { success: true };
        return { success: false, reason: "did not store" };
      },
      storePresentationViaChapi: async (_learnCard, presentation) => {
        const wc = new WebCredential("VerifiablePresentation", presentation);
        return window.navigator.credentials.store(wc);
      }
    }
  };
}, "getCHAPIPlugin");
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  __name2(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  __name2(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key22 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key22)) {
        keys.push(key22);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  __name2(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name2((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name2((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = /* @__PURE__ */ __name(class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name2((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i22 = 0;
          while (i22 < issue.path.length) {
            const el = issue.path[i22];
            const terminal = i22 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i22++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}, "ZodError");
__name2(ZodError, "ZodError");
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = /* @__PURE__ */ __name2((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(issue.minimum)}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(issue.maximum)}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
__name2(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");
__name2(getErrorMap, "getErrorMap");
var makeIssue = /* @__PURE__ */ __name2((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
__name2(addIssueToContext, "addIssueToContext");
var ParseStatus = /* @__PURE__ */ __name(class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key22, value } = pair;
      if (key22.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key22.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key22.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}, "ParseStatus");
__name2(ParseStatus, "ParseStatus");
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name2((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name2((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name2((x2) => x2.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name2((x2) => x2.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name2((x2) => x2.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name2((x2) => typeof Promise !== "undefined" && x2 instanceof Promise, "isAsync");
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = /* @__PURE__ */ __name(class {
  constructor(parent, value, path, key22) {
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key22;
  }
  get path() {
    return this._path.concat(this._key);
  }
}, "ParseInputLazyPath");
__name2(ParseInputLazyPath, "ParseInputLazyPath");
var handleResult = /* @__PURE__ */ __name2((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    const error = new ZodError(ctx.common.issues);
    return { success: false, error };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name2((iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
__name2(processCreateParams, "processCreateParams");
var ZodType = /* @__PURE__ */ __name(class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name2((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name2(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, "ZodType");
__name2(ZodType, "ZodType");
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|([^-]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}))$/;
var datetimeRegex = /* @__PURE__ */ __name2((args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
}, "datetimeRegex");
var ZodString = /* @__PURE__ */ __name(class extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}, "ZodString");
__name2(ZodString, "ZodString");
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
__name2(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = /* @__PURE__ */ __name(class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}, "ZodNumber");
__name2(ZodNumber, "ZodNumber");
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}, "ZodBigInt");
__name2(ZodBigInt, "ZodBigInt");
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}, "ZodBoolean");
__name2(ZodBoolean, "ZodBoolean");
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}, "ZodDate");
__name2(ZodDate, "ZodDate");
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}, "ZodSymbol");
__name2(ZodSymbol, "ZodSymbol");
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}, "ZodUndefined");
__name2(ZodUndefined, "ZodUndefined");
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}, "ZodNull");
__name2(ZodNull, "ZodNull");
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = /* @__PURE__ */ __name(class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}, "ZodAny");
__name2(ZodAny, "ZodAny");
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = /* @__PURE__ */ __name(class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}, "ZodUnknown");
__name2(ZodUnknown, "ZodUnknown");
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}, "ZodNever");
__name2(ZodNever, "ZodNever");
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}, "ZodVoid");
__name2(ZodVoid, "ZodVoid");
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i22) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i22));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i22) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i22));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}, "ZodArray");
__name2(ZodArray, "ZodArray");
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key22 in schema.shape) {
      const fieldSchema = schema.shape[key22];
      newShape[key22] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema.element));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
__name2(deepPartialify, "deepPartialify");
var ZodObject = /* @__PURE__ */ __name(class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key22 in ctx.data) {
        if (!shapeKeys.includes(key22)) {
          extraKeys.push(key22);
        }
      }
    }
    const pairs = [];
    for (const key22 of shapeKeys) {
      const keyValidator = shape[key22];
      const value = ctx.data[key22];
      pairs.push({
        key: { status: "valid", value: key22 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key22)),
        alwaysSet: key22 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key22 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key22 },
            value: { status: "valid", value: ctx.data[key22] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key22 of extraKeys) {
        const value = ctx.data[key22];
        pairs.push({
          key: { status: "valid", value: key22 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key22)
          ),
          alwaysSet: key22 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key22 = await pair.key;
          syncPairs.push({
            key: key22,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key22, schema) {
    return this.augment({ [key22]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key22) => {
      if (mask[key22] && this.shape[key22]) {
        shape[key22] = this.shape[key22];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key22) => {
      if (!mask[key22]) {
        shape[key22] = this.shape[key22];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key22) => {
      const fieldSchema = this.shape[key22];
      if (mask && !mask[key22]) {
        newShape[key22] = fieldSchema;
      } else {
        newShape[key22] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key22) => {
      if (mask && !mask[key22]) {
        newShape[key22] = this.shape[key22];
      } else {
        const fieldSchema = this.shape[key22];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key22] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}, "ZodObject");
__name2(ZodObject, "ZodObject");
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    __name2(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}, "ZodUnion");
__name2(ZodUnion, "ZodUnion");
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name2((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}, "ZodDiscriminatedUnion");
__name2(ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
function mergeValues(a3, b2) {
  const aType = getParsedType(a3);
  const bType = getParsedType(b2);
  if (a3 === b2) {
    return { valid: true, data: a3 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a3).filter((key22) => bKeys.indexOf(key22) !== -1);
    const newObj = { ...a3, ...b2 };
    for (const key22 of sharedKeys) {
      const sharedValue = mergeValues(a3[key22], b2[key22]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key22] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a3.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a3.length; index++) {
      const itemA = a3[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b2) {
    return { valid: true, data: a3 };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
__name2(mergeValues, "mergeValues");
var ZodIntersection = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name2((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}, "ZodIntersection");
__name2(ZodIntersection, "ZodIntersection");
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}, "ZodTuple");
__name2(ZodTuple, "ZodTuple");
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = /* @__PURE__ */ __name(class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key22 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key22, ctx.path, key22)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key22], ctx.path, key22))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}, "ZodRecord");
__name2(ZodRecord, "ZodRecord");
var ZodMap = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key22, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key22, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key22 = await pair.key;
          const value = await pair.value;
          if (key22.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key22.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key22.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key22 = pair.key;
        const value = pair.value;
        if (key22.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key22.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key22.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}, "ZodMap");
__name2(ZodMap, "ZodMap");
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    __name2(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i22) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i22)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}, "ZodSet");
__name2(ZodSet, "ZodSet");
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = /* @__PURE__ */ __name(class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    __name2(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    __name2(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}, "ZodFunction");
__name2(ZodFunction, "ZodFunction");
var ZodLazy = /* @__PURE__ */ __name(class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}, "ZodLazy");
__name2(ZodLazy, "ZodLazy");
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}, "ZodLiteral");
__name2(ZodLiteral, "ZodLiteral");
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
__name2(createZodEnum, "createZodEnum");
var ZodEnum = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}, "ZodEnum");
__name2(ZodEnum, "ZodEnum");
ZodEnum.create = createZodEnum;
var ZodNativeEnum = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}, "ZodNativeEnum");
__name2(ZodNativeEnum, "ZodNativeEnum");
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = /* @__PURE__ */ __name(class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}, "ZodPromise");
__name2(ZodPromise, "ZodPromise");
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = /* @__PURE__ */ __name(class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name2((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base4 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base4))
          return base4;
        const result = effect.transform(base4.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base4) => {
          if (!isValid(base4))
            return base4;
          return Promise.resolve(effect.transform(base4.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}, "ZodEffects");
__name2(ZodEffects, "ZodEffects");
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}, "ZodOptional");
__name2(ZodOptional, "ZodOptional");
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}, "ZodNullable");
__name2(ZodNullable, "ZodNullable");
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}, "ZodDefault");
__name2(ZodDefault, "ZodDefault");
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const result = this._def.innerType._parse({
      data: ctx.data,
      path: ctx.path,
      parent: {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue()
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue()
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}, "ZodCatch");
__name2(ZodCatch, "ZodCatch");
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}, "ZodNaN");
__name2(ZodNaN, "ZodNaN");
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}, "ZodBranded");
__name2(ZodBranded, "ZodBranded");
var ZodPipeline = /* @__PURE__ */ __name(class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name2(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a3, b2) {
    return new ZodPipeline({
      in: a3,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}, "ZodPipeline");
__name2(ZodPipeline, "ZodPipeline");
var custom = /* @__PURE__ */ __name2((check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : params;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal });
      }
    });
  return ZodAny.create();
}, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name2((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params, true), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name2(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name2(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name2(() => booleanType().optional(), "oboolean");
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var mod = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  get objectUtil() {
    return objectUtil;
  },
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
var ContextValidator = mod.array(mod.string().or(mod.record(mod.any())));
var AchievementCriteriaValidator = mod.object({
  type: mod.string().optional(),
  narrative: mod.string().optional()
});
var ImageValidator = mod.string().or(
  mod.object({
    id: mod.string(),
    type: mod.string(),
    caption: mod.string().optional()
  })
);
var GeoCoordinatesValidator = mod.object({
  type: mod.string().min(1).or(mod.string().array().nonempty()),
  latitude: mod.number(),
  longitude: mod.number()
});
var AddressValidator = mod.object({
  type: mod.string().min(1).or(mod.string().array().nonempty()),
  addressCountry: mod.string().optional(),
  addressCountryCode: mod.string().optional(),
  addressRegion: mod.string().optional(),
  addressLocality: mod.string().optional(),
  streetAddress: mod.string().optional(),
  postOfficeBoxNumber: mod.string().optional(),
  postalCode: mod.string().optional(),
  geo: GeoCoordinatesValidator.optional()
});
var IdentifierTypeValidator = mod.enum([
  "sourcedId",
  "systemId",
  "productId",
  "userName",
  "accountId",
  "emailAddress",
  "nationalIdentityNumber",
  "isbn",
  "issn",
  "lisSourcedId",
  "oneRosterSourcedId",
  "sisSourcedId",
  "ltiContextId",
  "ltiDeploymentId",
  "ltiToolId",
  "ltiPlatformId",
  "ltiUserId",
  "identifier"
]).or(mod.string());
var IdentifierEntryValidator = mod.object({
  type: mod.string().min(1).or(mod.string().array().nonempty()),
  identifier: mod.string(),
  identifierType: IdentifierTypeValidator
});
var ProfileValidator = mod.string().or(
  mod.object({
    id: mod.string().optional(),
    type: mod.string().or(mod.string().array().nonempty().optional()),
    name: mod.string().optional(),
    url: mod.string().optional(),
    phone: mod.string().optional(),
    description: mod.string().optional(),
    endorsement: mod.any().array().optional(),
    image: ImageValidator.optional(),
    email: mod.string().email().optional(),
    address: AddressValidator.optional(),
    otherIdentifier: IdentifierEntryValidator.array().optional(),
    official: mod.string().optional(),
    parentOrg: mod.any().optional(),
    familyName: mod.string().optional(),
    givenName: mod.string().optional(),
    additionalName: mod.string().optional(),
    patronymicName: mod.string().optional(),
    honorificPrefix: mod.string().optional(),
    honorificSuffix: mod.string().optional(),
    familyNamePrefix: mod.string().optional(),
    dateOfBirth: mod.string().optional()
  }).catchall(mod.any())
);
var CredentialSubjectValidator = mod.object({ id: mod.string().optional() }).catchall(mod.any());
var CredentialStatusValidator = mod.object({ type: mod.string(), id: mod.string() });
var CredentialSchemaValidator = mod.object({ id: mod.string(), type: mod.string() });
var RefreshServiceValidator = mod.object({ id: mod.string(), type: mod.string() }).catchall(mod.any());
var UnsignedVCValidator = mod.object({
  "@context": ContextValidator,
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  issuer: ProfileValidator,
  issuanceDate: mod.string(),
  expirationDate: mod.string().optional(),
  credentialSubject: CredentialSubjectValidator.or(CredentialSubjectValidator.array()),
  credentialStatus: CredentialStatusValidator.optional(),
  credentialSchema: CredentialSchemaValidator.array().optional(),
  refreshService: RefreshServiceValidator.optional()
}).catchall(mod.any());
var ProofValidator = mod.object({
  type: mod.string(),
  created: mod.string(),
  challenge: mod.string().optional(),
  domain: mod.string().optional(),
  nonce: mod.string().optional(),
  proofPurpose: mod.string(),
  verificationMethod: mod.string(),
  jws: mod.string().optional()
}).catchall(mod.any());
var VCValidator = UnsignedVCValidator.extend({
  proof: ProofValidator.or(ProofValidator.array())
});
var UnsignedVPValidator = mod.object({
  "@context": ContextValidator,
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  verifiableCredential: VCValidator.or(VCValidator.array()).optional(),
  holder: mod.string().optional()
}).catchall(mod.any());
var VPValidator = UnsignedVPValidator.extend({
  proof: ProofValidator.or(ProofValidator.array())
});
var AlignmentTargetTypeValidator = mod.enum([
  "ceasn:Competency",
  "ceterms:Credential",
  "CFItem",
  "CFRubric",
  "CFRubricCriterion",
  "CFRubricCriterionLevel",
  "CTDL"
]).or(mod.string());
var AlignmentValidator = mod.object({
  type: mod.string().array().nonempty(),
  targetCode: mod.string().optional(),
  targetDescription: mod.string().optional(),
  targetName: mod.string(),
  targetFramework: mod.string().optional(),
  targetType: AlignmentTargetTypeValidator.optional(),
  targetUrl: mod.string()
});
var KnownAchievementTypeValidator = mod.enum([
  "Achievement",
  "ApprenticeshipCertificate",
  "Assessment",
  "Assignment",
  "AssociateDegree",
  "Award",
  "Badge",
  "BachelorDegree",
  "Certificate",
  "CertificateOfCompletion",
  "Certification",
  "CommunityService",
  "Competency",
  "Course",
  "CoCurricular",
  "Degree",
  "Diploma",
  "DoctoralDegree",
  "Fieldwork",
  "GeneralEducationDevelopment",
  "JourneymanCertificate",
  "LearningProgram",
  "License",
  "Membership",
  "ProfessionalDoctorate",
  "QualityAssuranceCredential",
  "MasterCertificate",
  "MasterDegree",
  "MicroCredential",
  "ResearchDoctorate",
  "SecondarySchoolDiploma"
]);
var AchievementTypeValidator = KnownAchievementTypeValidator.or(mod.string());
var CriteriaValidator = mod.object({ id: mod.string().optional(), narrative: mod.string().optional() }).catchall(mod.any());
var EndorsementSubjectValidator = mod.object({
  id: mod.string(),
  type: mod.string().array().nonempty(),
  endorsementComment: mod.string().optional()
});
var EndorsementCredentialValidator = UnsignedVCValidator.extend({
  credentialSubject: EndorsementSubjectValidator,
  proof: ProofValidator.or(ProofValidator.array()).optional()
});
var RelatedValidator = mod.object({
  id: mod.string(),
  "@language": mod.string().optional(),
  version: mod.string().optional()
});
var ResultTypeValidator = mod.enum([
  "GradePointAverage",
  "LetterGrade",
  "Percent",
  "PerformanceLevel",
  "PredictedScore",
  "RawScore",
  "Result",
  "RubricCriterion",
  "RubricCriterionLevel",
  "RubricScore",
  "ScaledScore",
  "Status"
]).or(mod.string());
var RubricCriterionValidator = mod.object({
  id: mod.string(),
  type: mod.string().array().nonempty(),
  alignment: AlignmentValidator.array().optional(),
  description: mod.string().optional(),
  level: mod.string().optional(),
  name: mod.string(),
  points: mod.string().optional()
}).catchall(mod.any());
var ResultDescriptionValidator = mod.object({
  id: mod.string(),
  type: mod.string().array().nonempty(),
  alignment: AlignmentValidator.array().optional(),
  allowedValue: mod.string().array().optional(),
  name: mod.string(),
  requiredLevel: mod.string().optional(),
  requiredValue: mod.string().optional(),
  resultType: ResultTypeValidator,
  rubricCriterionLevel: RubricCriterionValidator.array().optional(),
  valueMax: mod.string().optional(),
  valueMin: mod.string().optional()
}).catchall(mod.any());
var AchievementValidator = mod.object({
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  alignment: AlignmentValidator.array().optional(),
  achievementType: AchievementTypeValidator.optional(),
  creator: ProfileValidator.optional(),
  creditsAvailable: mod.number().optional(),
  criteria: CriteriaValidator,
  description: mod.string(),
  endorsement: EndorsementCredentialValidator.array().optional(),
  fieldOfStudy: mod.string().optional(),
  humanCode: mod.string().optional(),
  image: ImageValidator.optional(),
  "@language": mod.string().optional(),
  name: mod.string(),
  otherIdentifier: IdentifierEntryValidator.array().optional(),
  related: RelatedValidator.array().optional(),
  resultDescription: ResultDescriptionValidator.array().optional(),
  specialization: mod.string().optional(),
  tag: mod.string().array().optional(),
  version: mod.string().optional()
}).catchall(mod.any());
var IdentityObjectValidator = mod.object({
  type: mod.string(),
  hashed: mod.boolean(),
  identityHash: mod.string(),
  identityType: mod.string(),
  salt: mod.string().optional()
});
var ResultStatusTypeValidator = mod.enum([
  "Completed",
  "Enrolled",
  "Failed",
  "InProgress",
  "OnHold",
  "Withdrew"
]);
var ResultValidator = mod.object({
  type: mod.string().array().nonempty(),
  achievedLevel: mod.string().optional(),
  alignment: AlignmentValidator.array().optional(),
  resultDescription: mod.string().optional(),
  status: ResultStatusTypeValidator.optional(),
  value: mod.string().optional()
}).catchall(mod.any());
var AchievementSubjectValidator = mod.object({
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  activityEndDate: mod.string().optional(),
  activityStartDate: mod.string().optional(),
  creditsEarned: mod.number().optional(),
  achievement: AchievementValidator.optional(),
  identifier: IdentityObjectValidator.array().optional(),
  image: ImageValidator.optional(),
  licenseNumber: mod.string().optional(),
  narrative: mod.string().optional(),
  result: ResultValidator.array().optional(),
  role: mod.string().optional(),
  source: ProfileValidator.optional(),
  term: mod.string().optional()
}).catchall(mod.any());
var EvidenceValidator = mod.object({
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  narrative: mod.string().optional(),
  name: mod.string().optional(),
  description: mod.string().optional(),
  genre: mod.string().optional(),
  audience: mod.string().optional()
}).catchall(mod.any());
var UnsignedAchievementCredentialValidator = UnsignedVCValidator.extend({
  name: mod.string().optional(),
  description: mod.string().optional(),
  image: ImageValidator.optional(),
  credentialSubject: AchievementSubjectValidator.or(AchievementSubjectValidator.array()),
  endorsement: UnsignedVCValidator.array().optional(),
  evidence: EvidenceValidator.array().optional()
});
var AchievementCredentialValidator = UnsignedAchievementCredentialValidator.extend({
  proof: ProofValidator.or(ProofValidator.array())
});
var VerificationCheckValidator = mod.object({
  checks: mod.string().array(),
  warnings: mod.string().array(),
  errors: mod.string().array()
});
var VerificationStatusValidator = mod.enum(["Success", "Failed", "Error"]);
var VerificationStatusEnum = VerificationStatusValidator.enum;
var VerificationItemValidator = mod.object({
  check: mod.string(),
  status: VerificationStatusValidator,
  message: mod.string().optional(),
  details: mod.string().optional()
});
var CredentialInfoValidator = mod.object({
  title: mod.string().optional(),
  createdAt: mod.string().optional(),
  issuer: ProfileValidator.optional(),
  issuee: ProfileValidator.optional(),
  credentialSubject: CredentialSubjectValidator.optional()
});
var CredentialRecordValidator = mod.object({ id: mod.string(), uri: mod.string() }).catchall(mod.any());
var LCNProfileValidator = mod.object({
  profileId: mod.string().min(3).max(40),
  displayName: mod.string().default(""),
  did: mod.string(),
  email: mod.string().optional(),
  image: mod.string().optional(),
  isServiceProfile: mod.boolean().default(false).optional()
});
var LCNProfileConnectionStatusEnum = mod.enum([
  "CONNECTED",
  "PENDING_REQUEST_SENT",
  "PENDING_REQUEST_RECEIVED",
  "NOT_CONNECTED"
]);
var SentCredentialInfoValidator = mod.object({
  uri: mod.string(),
  to: mod.string(),
  from: mod.string(),
  sent: mod.string().datetime(),
  received: mod.string().datetime().optional()
});
var BoostValidator = mod.object({
  uri: mod.string(),
  name: mod.string().optional(),
  type: mod.string().optional(),
  category: mod.string().optional()
});
var BoostRecipientValidator = mod.object({
  to: LCNProfileValidator,
  from: mod.string(),
  received: mod.string()
});
var LCNNotificationTypeEnumValidator = mod.enum([
  "CONNECTION_REQUEST",
  "CONNECTION_ACCEPTED",
  "CREDENTIAL_RECEIVED",
  "CREDENTIAL_ACCEPTED",
  "BOOST_RECEIVED",
  "BOOST_ACCEPTED",
  "PRESENTATION_REQUEST",
  "PRESENTATION_RECEIVED"
]);
var LCNNotificationMessageValidator = mod.object({
  title: mod.string().optional(),
  body: mod.string().optional()
});
var LCNNotificationDataValidator = mod.object({
  vcUris: mod.array(mod.string()).optional(),
  vpUris: mod.array(mod.string()).optional()
});
var LCNNotificationValidator = mod.object({
  type: LCNNotificationTypeEnumValidator,
  to: mod.string().or(LCNProfileValidator),
  from: mod.string().or(LCNProfileValidator),
  message: LCNNotificationMessageValidator.optional(),
  data: LCNNotificationDataValidator.optional(),
  sent: mod.string().datetime().optional()
});
var JWKValidator = mod.object({
  kty: mod.string(),
  crv: mod.string(),
  x: mod.string(),
  y: mod.string().optional(),
  n: mod.string().optional(),
  d: mod.string()
});
var JWERecipientHeaderValidator = mod.object({
  alg: mod.string(),
  iv: mod.string(),
  tag: mod.string(),
  epk: JWKValidator.partial().optional(),
  kid: mod.string().optional(),
  apv: mod.string().optional(),
  apu: mod.string().optional()
});
var JWERecipientValidator = mod.object({
  header: JWERecipientHeaderValidator,
  encrypted_key: mod.string()
});
var JWEValidator = mod.object({
  protected: mod.string(),
  iv: mod.string(),
  ciphertext: mod.string(),
  tag: mod.string(),
  aad: mod.string().optional(),
  recipients: JWERecipientValidator.array().optional()
});
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
__name(toInteger, "toInteger");
__name2(toInteger, "toInteger");
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
__name(requiredArgs, "requiredArgs");
__name2(requiredArgs, "requiredArgs");
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _typeof3(obj2) {
      return typeof obj2;
    }, "_typeof3"), "_typeof");
  } else {
    _typeof = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, "_typeof3"), "_typeof");
  }
  return _typeof(obj);
}
__name(_typeof, "_typeof");
__name2(_typeof, "_typeof");
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
__name(toDate, "toDate");
__name2(toDate, "toDate");
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
__name(addMilliseconds, "addMilliseconds");
__name2(addMilliseconds, "addMilliseconds");
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
__name(getDefaultOptions, "getDefaultOptions");
__name2(getDefaultOptions, "getDefaultOptions");
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
__name(getTimezoneOffsetInMilliseconds, "getTimezoneOffsetInMilliseconds");
__name2(getTimezoneOffsetInMilliseconds, "getTimezoneOffsetInMilliseconds");
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _typeof3(obj2) {
      return typeof obj2;
    }, "_typeof3"), "_typeof");
  } else {
    _typeof2 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, "_typeof3"), "_typeof");
  }
  return _typeof2(obj);
}
__name(_typeof2, "_typeof2");
__name2(_typeof2, "_typeof");
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof2(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
__name(isDate, "isDate");
__name2(isDate, "isDate");
function isValid2(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
__name(isValid2, "isValid2");
__name2(isValid2, "isValid");
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
__name(subMilliseconds, "subMilliseconds");
__name2(subMilliseconds, "subMilliseconds");
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
__name(getUTCDayOfYear, "getUTCDayOfYear");
__name2(getUTCDayOfYear, "getUTCDayOfYear");
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
__name(startOfUTCISOWeek, "startOfUTCISOWeek");
__name2(startOfUTCISOWeek, "startOfUTCISOWeek");
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
__name(getUTCISOWeekYear, "getUTCISOWeekYear");
__name2(getUTCISOWeekYear, "getUTCISOWeekYear");
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
__name(startOfUTCISOWeekYear, "startOfUTCISOWeekYear");
__name2(startOfUTCISOWeekYear, "startOfUTCISOWeekYear");
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
__name(getUTCISOWeek, "getUTCISOWeek");
__name2(getUTCISOWeek, "getUTCISOWeek");
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
__name(startOfUTCWeek, "startOfUTCWeek");
__name2(startOfUTCWeek, "startOfUTCWeek");
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
__name(getUTCWeekYear, "getUTCWeekYear");
__name2(getUTCWeekYear, "getUTCWeekYear");
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
__name(startOfUTCWeekYear, "startOfUTCWeekYear");
__name2(startOfUTCWeekYear, "startOfUTCWeekYear");
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}
__name(getUTCWeek, "getUTCWeek");
__name2(getUTCWeek, "getUTCWeek");
function addLeadingZeros(number, targetLength) {
  var sign5 = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign5 + output;
}
__name(addLeadingZeros, "addLeadingZeros");
__name2(addLeadingZeros, "addLeadingZeros");
var formatters = {
  y: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  }, "y"), "y"),
  M: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  }, "M"), "M"),
  d: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  }, "d"), "d"),
  a: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  }, "a"), "a"),
  h: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  }, "h"), "h"),
  H: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  }, "H"), "H"),
  m: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  }, "m"), "m"),
  s: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  }, "s"), "s"),
  S: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }, "S"), "S")
};
var lightFormatters_default = formatters;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  G: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function G(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  }, "G"), "G"),
  y: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function y2(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token);
  }, "y2"), "y"),
  Y: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function Y(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  }, "Y"), "Y"),
  R: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  }, "R"), "R"),
  u: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  }, "u"), "u"),
  Q: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function Q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "Q"), "Q"),
  q: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  }, "q"), "q"),
  M: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function M2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "M2"), "M"),
  L: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function L(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  }, "L"), "L"),
  w: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function w(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  }, "w"), "w"),
  I: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function I(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  }, "I"), "I"),
  d: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function d2(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token);
  }, "d2"), "d"),
  D: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function D(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  }, "D"), "D"),
  E: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function E(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "E"), "E"),
  e: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function e(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "e"), "e"),
  c: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function c(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  }, "c"), "c"),
  i: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "i"), "i"),
  a: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function a2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "a2"), "a"),
  b: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "b"), "b"),
  B: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function B(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  }, "B"), "B"),
  h: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function h2(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token);
  }, "h2"), "h"),
  H: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function H2(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token);
  }, "H2"), "H"),
  K: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function K(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  }, "K"), "K"),
  k: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function k(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  }, "k"), "k"),
  m: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function m2(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token);
  }, "m2"), "m"),
  s: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token);
  }, "s2"), "s"),
  S: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function S2(date, token) {
    return lightFormatters_default.S(date, token);
  }, "S2"), "S"),
  X: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  }, "X"), "X"),
  x: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  }, "x"), "x"),
  O: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  }, "O"), "O"),
  z: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  }, "z"), "z"),
  t: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  }, "t"), "t"),
  T: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }, "T"), "T")
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign5 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign5 + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign5 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
__name(formatTimezoneShort, "formatTimezoneShort");
__name2(formatTimezoneShort, "formatTimezoneShort");
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign5 = offset > 0 ? "-" : "+";
    return sign5 + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
__name(formatTimezoneWithOptionalMinutes, "formatTimezoneWithOptionalMinutes");
__name2(formatTimezoneWithOptionalMinutes, "formatTimezoneWithOptionalMinutes");
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign5 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign5 + hours + delimiter + minutes;
}
__name(formatTimezone, "formatTimezone");
__name2(formatTimezone, "formatTimezone");
var formatters_default = formatters2;
var dateLongFormatter = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}, "dateLongFormatter2"), "dateLongFormatter");
var timeLongFormatter = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}, "timeLongFormatter2"), "timeLongFormatter");
var dateTimeLongFormatter = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}, "dateTimeLongFormatter2"), "dateTimeLongFormatter");
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
__name(isProtectedDayOfYearToken, "isProtectedDayOfYearToken");
__name2(isProtectedDayOfYearToken, "isProtectedDayOfYearToken");
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
__name(isProtectedWeekYearToken, "isProtectedWeekYearToken");
__name2(isProtectedWeekYearToken, "isProtectedWeekYearToken");
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
__name(throwProtectedError, "throwProtectedError");
__name2(throwProtectedError, "throwProtectedError");
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
}, "formatDistance2"), "formatDistance");
var formatDistance_default = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
__name(buildFormatLongFn, "buildFormatLongFn");
__name2(buildFormatLongFn, "buildFormatLongFn");
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}, "formatRelative2"), "formatRelative");
var formatRelative_default = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context2 = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context2 === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
__name(buildLocalizeFn, "buildLocalizeFn");
__name2(buildLocalizeFn, "buildLocalizeFn");
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
}, "ordinalNumber2"), "ordinalNumber");
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function argumentCallback(quarter) {
      return quarter - 1;
    }, "argumentCallback"), "argumentCallback")
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;
function buildMatchFn(args) {
  return function(string2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string2.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key22 = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key22) : key22;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string2.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
__name(buildMatchFn, "buildMatchFn");
__name2(buildMatchFn, "buildMatchFn");
function findKey(object, predicate) {
  for (var key22 in object) {
    if (object.hasOwnProperty(key22) && predicate(object[key22])) {
      return key22;
    }
  }
  return void 0;
}
__name(findKey, "findKey");
__name2(findKey, "findKey");
function findIndex(array, predicate) {
  for (var key22 = 0; key22 < array.length; key22++) {
    if (predicate(array[key22])) {
      return key22;
    }
  }
  return void 0;
}
__name(findIndex, "findIndex");
__name2(findIndex, "findIndex");
function buildMatchPatternFn(args) {
  return function(string2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string2.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string2.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string2.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
__name(buildMatchPatternFn, "buildMatchPatternFn");
__name2(buildMatchPatternFn, "buildMatchPatternFn");
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function valueCallback(value) {
      return parseInt(value, 10);
    }, "valueCallback"), "valueCallback")
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function valueCallback2(index) {
      return index + 1;
    }, "valueCallback2"), "valueCallback")
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale;
var defaultLocale_default = en_US_default;
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid2(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
__name(format, "format");
__name2(format, "format");
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
__name(cleanEscapedString, "cleanEscapedString");
__name2(cleanEscapedString, "cleanEscapedString");
var transformErrorCheck = /* @__PURE__ */ __name2((error, _credential) => {
  const prefix = error.split(" error")[0];
  return prefix || error;
}, "transformErrorCheck");
var transformErrorMessage = /* @__PURE__ */ __name2((error, credential) => {
  if (error.startsWith("expiration")) {
    return credential.expirationDate ? `Invalid \u2022 Expired ${format(
      new Date(credential.expirationDate),
      "dd MMM yyyy"
    ).toUpperCase()}` : "Invalid \u2022 Expired";
  }
  return error;
}, "transformErrorMessage");
var transformCheckMessage = /* @__PURE__ */ __name2((check, credential) => {
  return {
    proof: "Valid",
    expiration: credential.expirationDate ? `Valid \u2022 Expires ${format(
      new Date(credential.expirationDate),
      "dd MMM yyyy"
    ).toUpperCase()}` : "Valid \u2022 Does Not Expire"
  }[check] || check;
}, "transformCheckMessage");
var verifyCredential2 = /* @__PURE__ */ __name2((learnCard) => {
  return async (_learnCard, credential, options, prettify = false) => {
    const rawVerificationCheck = await learnCard.invoke.verifyCredential(credential, options);
    if (!prettify)
      return rawVerificationCheck;
    const verificationItems = [];
    rawVerificationCheck.errors.forEach((error) => {
      verificationItems.push({
        status: VerificationStatusEnum.Failed,
        check: transformErrorCheck(error, credential),
        details: transformErrorMessage(error, credential)
      });
    });
    rawVerificationCheck.warnings.forEach((warning) => {
      verificationItems.push({
        status: VerificationStatusEnum.Error,
        check: "hmm",
        message: warning
      });
    });
    rawVerificationCheck.checks.forEach((check) => {
      verificationItems.push({
        status: VerificationStatusEnum.Success,
        check,
        message: transformCheckMessage(check, credential)
      });
    });
    return verificationItems;
  };
}, "verifyCredential");
var getLearnCardPlugin = /* @__PURE__ */ __name2((learnCard) => ({
  name: "LearnCard",
  displayName: "LearnCard",
  description: "Adds opinionated logic to a LearnCard",
  methods: {
    verifyCredential: verifyCredential2(learnCard)
  }
}), "getLearnCardPlugin");
var emptyLearnCard = /* @__PURE__ */ __name2(async ({ didkit, debug } = {}) => {
  const didkitLc = await (await generateLearnCard({ debug })).addPlugin(await getDidKitPlugin(didkit));
  const expirationLc = await didkitLc.addPlugin(expirationPlugin(didkitLc));
  const templatesLc = await expirationLc.addPlugin(getVCTemplatesPlugin());
  const chapiLc = await templatesLc.addPlugin(await getCHAPIPlugin());
  return chapiLc.addPlugin(getLearnCardPlugin(chapiLc));
}, "emptyLearnCard");
function toUint8Array(str) {
  var s3 = 0, sl = str.length, bytes = [];
  if (sl % 2) {
    throw new Error("invalid hex:" + str);
  }
  for (; s3 < sl; s3 += 2) {
    bytes.push(parseInt(str.substr(s3, 2), 16));
  }
  return new Uint8Array(bytes);
}
__name(toUint8Array, "toUint8Array");
__name2(toUint8Array, "toUint8Array");
var __defProp22 = Object.defineProperty;
var __name22 = /* @__PURE__ */ __name2((target, value) => __defProp22(target, "name", { value, configurable: true }), "__name");
var isHex = /* @__PURE__ */ __name22((str) => /^[0-9a-f]+$/i.test(str), "isHex");
var ED25519_METHODS = ["key", "tz", "pkh:tz", "pkh:tezos", "pkh:sol", "pkh:solana"];
var SECP256K1_METHODS = [
  "key",
  "tz",
  "ethr",
  "pkh:tz",
  "pkh:tezos",
  "pkh:eth",
  "pkh:celo",
  "pkh:poly",
  "pkh:btc",
  "pkh:doge",
  "pkh:eip155",
  "pkh:bip122"
];
var getAlgorithmForDidMethod = /* @__PURE__ */ __name2((didMethod) => {
  if (ED25519_METHODS.includes(didMethod))
    return "ed25519";
  if (SECP256K1_METHODS.includes(didMethod) || didMethod.startsWith("pkh:eip155:") || didMethod.startsWith("pkh:bip122:")) {
    return "secp256k1";
  }
  throw new Error("Unspported Did Method");
}, "getAlgorithmForDidMethod");
var getDidKeyPlugin = /* @__PURE__ */ __name2(async (learnCard, key22, defaultDidMethod) => {
  if (key22.length === 0)
    throw new Error("Please don't use an empty string for a key!");
  if (!isHex(key22))
    throw new Error("Key must be a hexadecimal string!");
  if (key22.length > 64)
    throw new Error("Key must be less than 64 characters");
  if (key22.length < 64) {
    console.warn(
      "Warning: A LearnCard has been initialized with a seed that is less than 32 bytes, and will be padded with zeroes"
    );
    console.warn(
      "Please instantiate LearnCards using 32 bytes that have been randomly generated in a cryptographically secure fashion!"
    );
    console.warn(
      "See https://app.gitbook.com/o/6uDv1QDlxaaZC7i8EaGb/s/FXvEJ9j3Vf3FW5Nc557n/learn-card-packages/learncard-core/instantiation#key-generation for details"
    );
  }
  const seed = key22.padStart(64, "0");
  const seedBytes = toUint8Array(seed);
  const memoizedDids = {};
  const keyPairs = {
    ed25519: learnCard.invoke.generateEd25519KeyFromBytes(seedBytes),
    secp256k1: learnCard.invoke.generateSecp256k1KeyFromBytes(seedBytes)
  };
  const did = /* @__PURE__ */ __name2((method = defaultDidMethod) => {
    if (!memoizedDids[method]) {
      const algorithm = getAlgorithmForDidMethod(method);
      memoizedDids[method] = learnCard.invoke.keyToDid(method, keyPairs[algorithm]);
    }
    return memoizedDids[method];
  }, "did");
  const keypair = /* @__PURE__ */ __name2((algorithm = "ed25519") => {
    if (!keyPairs[algorithm])
      throw new Error("Unsupported algorithm");
    return keyPairs[algorithm];
  }, "keypair");
  return {
    name: "DID Key",
    displayName: "DID Key",
    description: "Generates dids and JWKs using 32 Secure Random Bytes of Entropy",
    id: {
      did: (_learnCard, method) => did(method),
      keypair: (_learnCard, algorithm) => keypair(algorithm)
    },
    methods: {
      getSubjectDid: (_learnCard, method = defaultDidMethod) => did(method),
      getSubjectKeypair: (_learnCard, algorithm = "ed25519") => keypair(algorithm),
      getKey: () => seed
    }
  };
}, "getDidKeyPlugin");
var issueCredential2 = /* @__PURE__ */ __name2((initLearnCard2) => {
  return async (learnCard, credential, signingOptions = {}) => {
    const kp = learnCard.id.keypair();
    if (!kp)
      throw new Error("Cannot issue credential: Could not get subject keypair");
    const verificationMethod = await learnCard.invoke.didToVerificationMethod(
      typeof credential.issuer === "string" ? credential.issuer : credential.issuer.id
    );
    const options = {
      verificationMethod,
      proofPurpose: "assertionMethod",
      type: "Ed25519Signature2020",
      ...signingOptions
    };
    return initLearnCard2.invoke.issueCredential(credential, options, kp);
  };
}, "issueCredential");
var verifyCredential3 = /* @__PURE__ */ __name2((initLearnCard2) => {
  return async (_learnCard, credential, options = {}) => {
    return initLearnCard2.invoke.verifyCredential(credential, options);
  };
}, "verifyCredential");
var issuePresentation2 = /* @__PURE__ */ __name2((initLearnCard2) => {
  return async (learnCard, presentation, signingOptions = {}) => {
    const kp = learnCard.id.keypair();
    if (!kp)
      throw new Error("Cannot issue credential: Could not get subject keypair");
    const verificationMethod = await learnCard.invoke.didToVerificationMethod(
      learnCard.id.did()
    );
    const options = {
      verificationMethod,
      ...signingOptions.proofFormat === "jwt" ? {} : { proofPurpose: "assertionMethod" },
      ...signingOptions.proofFormat === "jwt" ? {} : { type: "Ed25519Signature2020" },
      ...signingOptions
    };
    return initLearnCard2.invoke.issuePresentation(presentation, options, kp);
  };
}, "issuePresentation");
var verifyPresentation2 = /* @__PURE__ */ __name2((initLearnCard2) => {
  return async (_learnCard, presentation, options = {}) => {
    return initLearnCard2.invoke.verifyPresentation(presentation, options);
  };
}, "verifyPresentation");
var getVCPlugin = /* @__PURE__ */ __name2((learnCard) => {
  return {
    name: "VC",
    displayName: "VC",
    description: "Handles the infrastructure needed to issue and verify credentials and presentations",
    methods: {
      issueCredential: issueCredential2(learnCard),
      verifyCredential: verifyCredential3(learnCard),
      issuePresentation: issuePresentation2(learnCard),
      verifyPresentation: verifyPresentation2(learnCard),
      getTestVc: (_learnCard, subject = "did:example:d23dd687a7dc6787646f2eb98d0") => {
        const did = _learnCard.id.did();
        return {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          id: "http://example.org/credentials/3731",
          type: ["VerifiableCredential"],
          issuer: did,
          issuanceDate: "2020-08-19T21:41:50Z",
          credentialSubject: { id: subject }
        };
      },
      getTestVp: async (_learnCard, _credential) => {
        const credential = _credential || await _learnCard.invoke.issueCredential(_learnCard.invoke.getTestVc());
        const did = _learnCard.id.did();
        return {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          type: ["VerifiablePresentation"],
          holder: did,
          verifiableCredential: credential
        };
      },
      getDidAuthVp: async (_learnCard, options = {}) => {
        const did = _learnCard.id.did();
        const unsignedVP = {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          type: ["VerifiablePresentation"],
          holder: did
        };
        return _learnCard.invoke.issuePresentation(unsignedVP, {
          proofPurpose: "authentication",
          ...options
        });
      }
    }
  };
}, "getVCPlugin");
var VCResolutionPlugin = {
  name: "VC Resolution",
  displayName: "VC Resolution",
  description: "[Deprecated] Allows for a fallback mechanism of resolving credentials",
  methods: {
    resolveCredential: async (_learnCard, uri) => {
      throw new Error(`No Credential Resolution Plugins found that can resolve ${uri}`);
    }
  }
};
var import_lodash6 = __toESM2(require_lodash());
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e2) {
    return recover(e2);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
__name(_catch, "_catch");
__name2(_catch, "_catch");
function inMemoryCache() {
  const cache = /* @__PURE__ */ new Map();
  return function(parsed, resolve) {
    try {
      let _temp2 = /* @__PURE__ */ __name(function(_result) {
        if (_exit)
          return _result;
        const cached = cache.get(parsed.didUrl);
        return cached !== void 0 ? cached : Promise.resolve(resolve()).then(function(result) {
          var _result$didResolution;
          if (((_result$didResolution = result.didResolutionMetadata) == null ? void 0 : _result$didResolution.error) !== "notFound") {
            cache.set(parsed.didUrl, result);
          }
          return result;
        });
      }, "_temp2");
      __name2(_temp2, "_temp2");
      let _exit;
      const _temp = function() {
        if (parsed.params && parsed.params["no-cache"] === "true") {
          return Promise.resolve(resolve()).then(function(_await$resolve) {
            _exit = 1;
            return _await$resolve;
          });
        }
      }();
      return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
__name(inMemoryCache, "inMemoryCache");
__name2(inMemoryCache, "inMemoryCache");
function noCache(parsed, resolve) {
  return resolve();
}
__name(noCache, "noCache");
__name2(noCache, "noCache");
var PCT_ENCODED = "(?:%[0-9a-fA-F]{2})";
var ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`;
var METHOD = "([a-z0-9]+)";
var METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`;
var PARAM_CHAR = "[a-zA-Z0-9_.:%-]";
var PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`;
var PARAMS = `((${PARAM})*)`;
var PATH = `(/[^#?]*)?`;
var QUERY = `([?][^#]*)?`;
var FRAGMENT = `(#.*)?`;
var DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
function parse2(didUrl) {
  if (didUrl === "" || !didUrl)
    return null;
  const sections = didUrl.match(DID_MATCHER);
  if (sections) {
    const parts = {
      did: `did:${sections[1]}:${sections[2]}`,
      method: sections[1],
      id: sections[2],
      didUrl
    };
    if (sections[4]) {
      const params = sections[4].slice(1).split(";");
      parts.params = {};
      for (const p of params) {
        const kv = p.split("=");
        parts.params[kv[0]] = kv[1];
      }
    }
    if (sections[6])
      parts.path = sections[6];
    if (sections[7])
      parts.query = sections[7].slice(1);
    if (sections[8])
      parts.fragment = sections[8].slice(1);
    return parts;
  }
  return null;
}
__name(parse2, "parse");
__name2(parse2, "parse");
var EMPTY_RESULT = {
  didResolutionMetadata: {},
  didDocument: null,
  didDocumentMetadata: {}
};
function wrapLegacyResolver(resolve) {
  return function(did, parsed, resolver) {
    try {
      return Promise.resolve(_catch(function() {
        return Promise.resolve(resolve(did, parsed, resolver)).then(function(doc) {
          return {
            ...EMPTY_RESULT,
            didResolutionMetadata: {
              contentType: "application/did+ld+json"
            },
            didDocument: doc
          };
        });
      }, function(e2) {
        return {
          ...EMPTY_RESULT,
          didResolutionMetadata: {
            error: "notFound",
            message: e2.toString()
          }
        };
      }));
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
__name(wrapLegacyResolver, "wrapLegacyResolver");
__name2(wrapLegacyResolver, "wrapLegacyResolver");
var Resolver2 = /* @__PURE__ */ __name(class {
  constructor(registry2 = {}, options = {}) {
    this.registry = void 0;
    this.cache = void 0;
    this.registry = registry2;
    this.cache = options.cache === true ? inMemoryCache() : options.cache || noCache;
    if (options.legacyResolvers) {
      Object.keys(options.legacyResolvers).map((methodName) => {
        if (!this.registry[methodName]) {
          this.registry[methodName] = wrapLegacyResolver(
            options.legacyResolvers[methodName]
          );
        }
      });
    }
  }
  resolve(didUrl, options = {}) {
    try {
      const _this = this;
      const parsed = parse2(didUrl);
      if (parsed === null) {
        return Promise.resolve({
          ...EMPTY_RESULT,
          didResolutionMetadata: {
            error: "invalidDid"
          }
        });
      }
      const resolver = _this.registry[parsed.method];
      if (!resolver) {
        return Promise.resolve({
          ...EMPTY_RESULT,
          didResolutionMetadata: {
            error: "unsupportedDidMethod"
          }
        });
      }
      return Promise.resolve(_this.cache(parsed, () => resolver(parsed.did, parsed, _this, options)));
    } catch (e2) {
      return Promise.reject(e2);
    }
  }
}, "Resolver");
__name2(Resolver2, "Resolver");
init_concat();
init_from_string();
init_to_string();
init_alloc();
init_as_uint8array();
init_basics();
var import_sha256 = __toESM2(require_sha256());
var import_js_sha32 = __toESM2(require_sha32());
var import_elliptic2 = __toESM2(require_elliptic());
var import_ed25519 = __toESM2(require_ed25519());
var import_canonicalize = __toESM2(require_canonicalize());
var import_x25519 = __toESM2(require_x25519());
var import_xchacha20poly1305 = __toESM2(require_xchacha20poly1305());
var import_random6 = __toESM2(require_random());
function bytesToBase64url(b2) {
  return toString3(b2, "base64url");
}
__name(bytesToBase64url, "bytesToBase64url");
__name2(bytesToBase64url, "bytesToBase64url");
function base64ToBytes(s3) {
  const inputBase64Url = s3.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return fromString2(inputBase64Url, "base64url");
}
__name(base64ToBytes, "base64ToBytes");
__name2(base64ToBytes, "base64ToBytes");
function base58ToBytes(s3) {
  return fromString2(s3, "base58btc");
}
__name(base58ToBytes, "base58ToBytes");
__name2(base58ToBytes, "base58ToBytes");
function hexToBytes(s3) {
  const input = s3.startsWith("0x") ? s3.substring(2) : s3;
  return fromString2(input.toLowerCase(), "base16");
}
__name(hexToBytes, "hexToBytes");
__name2(hexToBytes, "hexToBytes");
function encodeBase64url(s3) {
  return bytesToBase64url(fromString2(s3));
}
__name(encodeBase64url, "encodeBase64url");
__name2(encodeBase64url, "encodeBase64url");
function decodeBase64url(s3) {
  return toString3(base64ToBytes(s3));
}
__name(decodeBase64url, "decodeBase64url");
__name2(decodeBase64url, "decodeBase64url");
function bytesToHex(b2) {
  return toString3(b2, "base16");
}
__name(bytesToHex, "bytesToHex");
__name2(bytesToHex, "bytesToHex");
function stringToBytes(s3) {
  return fromString2(s3);
}
__name(stringToBytes, "stringToBytes");
__name2(stringToBytes, "stringToBytes");
function toJose({
  r: r2,
  s: s3,
  recoveryParam
}, recoverable) {
  const jose = new Uint8Array(recoverable ? 65 : 64);
  jose.set(fromString2(r2, "base16"), 0);
  jose.set(fromString2(s3, "base16"), 32);
  if (recoverable) {
    if (typeof recoveryParam === "undefined") {
      throw new Error("Signer did not return a recoveryParam");
    }
    jose[64] = recoveryParam;
  }
  return bytesToBase64url(jose);
}
__name(toJose, "toJose");
__name2(toJose, "toJose");
function fromJose(signature22) {
  const signatureBytes = base64ToBytes(signature22);
  if (signatureBytes.length < 64 || signatureBytes.length > 65) {
    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`);
  }
  const r2 = bytesToHex(signatureBytes.slice(0, 32));
  const s3 = bytesToHex(signatureBytes.slice(32, 64));
  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : void 0;
  return {
    r: r2,
    s: s3,
    recoveryParam
  };
}
__name(fromJose, "fromJose");
__name2(fromJose, "fromJose");
function toSealed(ciphertext, tag) {
  return concat2([base64ToBytes(ciphertext), base64ToBytes(tag)]);
}
__name(toSealed, "toSealed");
__name2(toSealed, "toSealed");
var hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/;
var base58Matcher = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/;
var base64Matcher = /^([0-9a-zA-Z=\-_+/]{43}|[0-9a-zA-Z=\-_+/]{86})(={0,2})$/;
function parseKey(input) {
  if (typeof input === "string") {
    if (hexMatcher.test(input)) {
      return hexToBytes(input);
    } else if (base58Matcher.test(input)) {
      return base58ToBytes(input);
    } else if (base64Matcher.test(input)) {
      return base64ToBytes(input);
    } else {
      throw TypeError("bad_key: Invalid private key format");
    }
  } else if (input instanceof Uint8Array) {
    return input;
  } else {
    throw TypeError("bad_key: Invalid private key format");
  }
}
__name(parseKey, "parseKey");
__name2(parseKey, "parseKey");
function sha25622(payload) {
  const data = typeof payload === "string" ? fromString2(payload) : payload;
  return (0, import_sha256.hash)(data);
}
__name(sha25622, "sha2562");
__name2(sha25622, "sha256");
function keccak(data) {
  return new Uint8Array(import_js_sha32.keccak_256.arrayBuffer(data));
}
__name(keccak, "keccak");
__name2(keccak, "keccak");
function toEthereumAddress(hexPublicKey) {
  const hashInput = fromString2(hexPublicKey.slice(2), "base16");
  return `0x${toString3(keccak(hashInput).slice(-20), "base16")}`;
}
__name(toEthereumAddress, "toEthereumAddress");
__name2(toEthereumAddress, "toEthereumAddress");
function writeUint32BE(value, array = new Uint8Array(4)) {
  const encoded = fromString2(value.toString(), "base10");
  array.set(encoded, 4 - encoded.length);
  return array;
}
__name(writeUint32BE, "writeUint32BE");
__name2(writeUint32BE, "writeUint32BE");
var lengthAndInput = /* @__PURE__ */ __name2((input) => concat2([writeUint32BE(input.length), input]), "lengthAndInput");
function concatKDF(secret, keyLen, alg, producerInfo, consumerInfo) {
  if (keyLen !== 256)
    throw new Error(`Unsupported key length: ${keyLen}`);
  const value = concat2([lengthAndInput(fromString2(alg)), lengthAndInput(typeof producerInfo === "undefined" ? new Uint8Array(0) : producerInfo), lengthAndInput(typeof consumerInfo === "undefined" ? new Uint8Array(0) : consumerInfo), writeUint32BE(keyLen)]);
  const roundNumber = 1;
  return (0, import_sha256.hash)(concat2([writeUint32BE(roundNumber), secret, value]));
}
__name(concatKDF, "concatKDF");
__name2(concatKDF, "concatKDF");
var secp256k1$1 = new import_elliptic2.ec("secp256k1");
function EdDSASigner(secretKey) {
  const privateKeyBytes = parseKey(secretKey);
  if (privateKeyBytes.length !== 64) {
    throw new Error(`bad_key: Invalid private key format. Expecting 64 bytes, but got ${privateKeyBytes.length}`);
  }
  return function(data) {
    try {
      const dataBytes = typeof data === "string" ? stringToBytes(data) : data;
      const sig = (0, import_ed25519.sign)(privateKeyBytes, dataBytes);
      return Promise.resolve(bytesToBase64url(sig));
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
__name(EdDSASigner, "EdDSASigner");
__name2(EdDSASigner, "EdDSASigner");
function instanceOfEcdsaSignature(object) {
  return typeof object === "object" && "r" in object && "s" in object;
}
__name(instanceOfEcdsaSignature, "instanceOfEcdsaSignature");
__name2(instanceOfEcdsaSignature, "instanceOfEcdsaSignature");
function ES256KSignerAlg(recoverable) {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign5(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature22) {
        if (instanceOfEcdsaSignature(signature22)) {
          return toJose(signature22, recoverable);
        } else {
          if (recoverable && typeof fromJose(signature22).recoveryParam === "undefined") {
            throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`);
          }
          return signature22;
        }
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, "sign5"), "sign");
}
__name(ES256KSignerAlg, "ES256KSignerAlg");
__name2(ES256KSignerAlg, "ES256KSignerAlg");
function Ed25519SignerAlg() {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign5(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature22) {
        if (!instanceOfEcdsaSignature(signature22)) {
          return signature22;
        } else {
          throw new Error("invalid_config: expected a signer function that returns a string instead of signature object");
        }
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, "sign5"), "sign");
}
__name(Ed25519SignerAlg, "Ed25519SignerAlg");
__name2(Ed25519SignerAlg, "Ed25519SignerAlg");
var algorithms$1 = {
  ES256K: ES256KSignerAlg(),
  "ES256K-R": ES256KSignerAlg(true),
  Ed25519: Ed25519SignerAlg(),
  EdDSA: Ed25519SignerAlg()
};
function SignerAlg(alg) {
  const impl = algorithms$1[alg];
  if (!impl)
    throw new Error(`not_supported: Unsupported algorithm ${alg}`);
  return impl;
}
__name(SignerAlg, "SignerAlg");
__name2(SignerAlg, "SignerAlg");
var secp256k1 = new import_elliptic2.ec("secp256k1");
function toSignatureObject(signature22, recoverable = false) {
  const rawSig = base64ToBytes(signature22);
  if (rawSig.length !== (recoverable ? 65 : 64)) {
    throw new Error("wrong signature length");
  }
  const r2 = bytesToHex(rawSig.slice(0, 32));
  const s3 = bytesToHex(rawSig.slice(32, 64));
  const sigObj = {
    r: r2,
    s: s3
  };
  if (recoverable) {
    sigObj.recoveryParam = rawSig[64];
  }
  return sigObj;
}
__name(toSignatureObject, "toSignatureObject");
__name2(toSignatureObject, "toSignatureObject");
function extractPublicKeyBytes(pk) {
  if (pk.publicKeyBase58) {
    return base58ToBytes(pk.publicKeyBase58);
  } else if (pk.publicKeyBase64) {
    return base64ToBytes(pk.publicKeyBase64);
  } else if (pk.publicKeyHex) {
    return hexToBytes(pk.publicKeyHex);
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "secp256k1" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
    return hexToBytes(secp256k1.keyFromPublic({
      x: bytesToHex(base64ToBytes(pk.publicKeyJwk.x)),
      y: bytesToHex(base64ToBytes(pk.publicKeyJwk.y))
    }).getPublic("hex"));
  } else if (pk.publicKeyMultibase) {
    const {
      base16: base162,
      base58btc: base58btc2,
      base64: base642,
      base64url: base64url2
    } = bases;
    const baseDecoder = base162.decoder.or(base58btc2.decoder.or(base642.decoder.or(base64url2.decoder)));
    return baseDecoder.decode(pk.publicKeyMultibase);
  }
  return new Uint8Array();
}
__name(extractPublicKeyBytes, "extractPublicKeyBytes");
__name2(extractPublicKeyBytes, "extractPublicKeyBytes");
function verifyES256K(data, signature22, authenticators) {
  const hash3 = sha25622(data);
  const sigObj = toSignatureObject(signature22);
  const fullPublicKeys = authenticators.filter(({
    ethereumAddress,
    blockchainAccountId
  }) => {
    return typeof ethereumAddress === "undefined" && typeof blockchainAccountId === "undefined";
  });
  const ethAddressKeys = authenticators.filter(({
    ethereumAddress,
    blockchainAccountId
  }) => {
    return typeof ethereumAddress !== "undefined" || typeof blockchainAccountId !== void 0;
  });
  let signer = fullPublicKeys.find((pk) => {
    try {
      const pubBytes = extractPublicKeyBytes(pk);
      return secp256k1.keyFromPublic(pubBytes).verify(hash3, sigObj);
    } catch (err) {
      return false;
    }
  });
  if (!signer && ethAddressKeys.length > 0) {
    signer = verifyRecoverableES256K(data, signature22, ethAddressKeys);
  }
  if (!signer)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
__name(verifyES256K, "verifyES256K");
__name2(verifyES256K, "verifyES256K");
function verifyRecoverableES256K(data, signature22, authenticators) {
  let signatures;
  if (signature22.length > 86) {
    signatures = [toSignatureObject(signature22, true)];
  } else {
    const so = toSignatureObject(signature22, false);
    signatures = [{
      ...so,
      recoveryParam: 0
    }, {
      ...so,
      recoveryParam: 1
    }];
  }
  const checkSignatureAgainstSigner = /* @__PURE__ */ __name2((sigObj) => {
    const hash3 = sha25622(data);
    const recoveredKey = secp256k1.recoverPubKey(hash3, sigObj, sigObj.recoveryParam);
    const recoveredPublicKeyHex = recoveredKey.encode("hex");
    const recoveredCompressedPublicKeyHex = recoveredKey.encode("hex", true);
    const recoveredAddress = toEthereumAddress(recoveredPublicKeyHex);
    const signer2 = authenticators.find((pk) => {
      var _pk$ethereumAddress, _pk$blockchainAccount, _pk$blockchainAccount2;
      const keyHex = bytesToHex(extractPublicKeyBytes(pk));
      return keyHex === recoveredPublicKeyHex || keyHex === recoveredCompressedPublicKeyHex || ((_pk$ethereumAddress = pk.ethereumAddress) == null ? void 0 : _pk$ethereumAddress.toLowerCase()) === recoveredAddress || ((_pk$blockchainAccount = pk.blockchainAccountId) == null ? void 0 : (_pk$blockchainAccount2 = _pk$blockchainAccount.split("@eip155")) == null ? void 0 : _pk$blockchainAccount2[0].toLowerCase()) === recoveredAddress;
    });
    return signer2;
  }, "checkSignatureAgainstSigner");
  const signer = signatures.map(checkSignatureAgainstSigner).filter((key22) => typeof key22 !== "undefined");
  if (signer.length === 0)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer[0];
}
__name(verifyRecoverableES256K, "verifyRecoverableES256K");
__name2(verifyRecoverableES256K, "verifyRecoverableES256K");
function verifyEd25519(data, signature22, authenticators) {
  const clear = stringToBytes(data);
  const sig = base64ToBytes(signature22);
  const signer = authenticators.find((pk) => {
    return (0, import_ed25519.verify)(extractPublicKeyBytes(pk), clear, sig);
  });
  if (!signer)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
__name(verifyEd25519, "verifyEd25519");
__name2(verifyEd25519, "verifyEd25519");
var algorithms = {
  ES256K: verifyES256K,
  "ES256K-R": verifyRecoverableES256K,
  Ed25519: verifyEd25519,
  EdDSA: verifyEd25519
};
function VerifierAlgorithm(alg) {
  const impl = algorithms[alg];
  if (!impl)
    throw new Error(`not_supported: Unsupported algorithm ${alg}`);
  return impl;
}
__name(VerifierAlgorithm, "VerifierAlgorithm");
__name2(VerifierAlgorithm, "VerifierAlgorithm");
VerifierAlgorithm.toSignatureObject = toSignatureObject;
var createJWS = /* @__PURE__ */ __name2(function(payload, signer, header = {}, options = {}) {
  try {
    if (!header.alg)
      header.alg = defaultAlg;
    const encodedPayload = typeof payload === "string" ? payload : encodeSection(payload, options.canonicalize);
    const signingInput = [encodeSection(header, options.canonicalize), encodedPayload].join(".");
    const jwtSigner = SignerAlg(header.alg);
    return Promise.resolve(jwtSigner(signingInput, signer)).then(function(signature22) {
      return [signingInput, signature22].join(".");
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
}, "createJWS");
var defaultAlg = "ES256K";
function encodeSection(data, shouldCanonicalize = false) {
  if (shouldCanonicalize) {
    return encodeBase64url((0, import_canonicalize.default)(data));
  } else {
    return encodeBase64url(JSON.stringify(data));
  }
}
__name(encodeSection, "encodeSection");
__name2(encodeSection, "encodeSection");
function decodeJWS(jws) {
  const parts = jws.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
  if (parts) {
    return {
      header: JSON.parse(decodeBase64url(parts[1])),
      payload: parts[2],
      signature: parts[3],
      data: `${parts[1]}.${parts[2]}`
    };
  }
  throw new Error("invalid_argument: Incorrect format JWS");
}
__name(decodeJWS, "decodeJWS");
__name2(decodeJWS, "decodeJWS");
function verifyJWSDecoded({
  header,
  data,
  signature: signature22
}, pubKeys) {
  if (!Array.isArray(pubKeys))
    pubKeys = [pubKeys];
  const signer = VerifierAlgorithm(header.alg)(data, signature22, pubKeys);
  return signer;
}
__name(verifyJWSDecoded, "verifyJWSDecoded");
__name2(verifyJWSDecoded, "verifyJWSDecoded");
function verifyJWS(jws, pubKeys) {
  const jwsDecoded = decodeJWS(jws);
  return verifyJWSDecoded(jwsDecoded, pubKeys);
}
__name(verifyJWS, "verifyJWS");
__name2(verifyJWS, "verifyJWS");
function _for(test, update22, body) {
  var stage;
  for (; ; ) {
    var shouldContinue = test();
    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }
    if (!shouldContinue) {
      return result;
    }
    if (shouldContinue.then) {
      stage = 0;
      break;
    }
    var result = body();
    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }
    if (update22) {
      var updateValue = update22();
      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }
  var pact = new _Pact();
  var reject = _settle.bind(null, pact, 2);
  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;
  function _resumeAfterBody(value) {
    result = value;
    do {
      if (update22) {
        updateValue = update22();
        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }
      shouldContinue = test();
      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);
        return;
      }
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }
      result = body();
      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);
    result.then(_resumeAfterBody).then(void 0, reject);
  }
  __name(_resumeAfterBody, "_resumeAfterBody");
  __name2(_resumeAfterBody, "_resumeAfterBody");
  function _resumeAfterTest(shouldContinue2) {
    if (shouldContinue2) {
      result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
  __name(_resumeAfterTest, "_resumeAfterTest");
  __name2(_resumeAfterTest, "_resumeAfterTest");
  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
  __name(_resumeAfterUpdate, "_resumeAfterUpdate");
  __name2(_resumeAfterUpdate, "_resumeAfterUpdate");
}
__name(_for, "_for");
__name2(_for, "_for");
var decryptJWE = /* @__PURE__ */ __name2(function(jwe, decrypter) {
  try {
    let _temp5 = /* @__PURE__ */ __name(function(_result) {
      if (_exit)
        ;
      if (cleartext === null)
        throw new Error("failure: Failed to decrypt");
      return cleartext;
    }, "_temp5");
    __name2(_temp5, "_temp5");
    let _exit;
    validateJWE(jwe);
    const protHeader = JSON.parse(decodeBase64url(jwe.protected));
    if (protHeader.enc !== decrypter.enc)
      throw new Error(`not_supported: Decrypter does not supported: '${protHeader.enc}'`);
    const sealed = toSealed(jwe.ciphertext, jwe.tag);
    const aad = new Uint8Array(Buffer.from(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected));
    let cleartext = null;
    const _temp4 = function() {
      if (protHeader.alg === "dir" && decrypter.alg === "dir") {
        return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)).then(function(_decrypter$decrypt) {
          cleartext = _decrypter$decrypt;
        });
      } else
        return function() {
          if (!jwe.recipients || jwe.recipients.length === 0) {
            throw new Error("bad_jwe: missing recipients");
          } else {
            let i22 = 0;
            return _for(function() {
              return !cleartext && i22 < jwe.recipients.length;
            }, function() {
              return i22++;
            }, function() {
              const recipient = jwe.recipients[i22];
              Object.assign(recipient.header, protHeader);
              const _temp3 = function() {
                if (recipient.header.alg === decrypter.alg) {
                  return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)).then(function(_decrypter$decrypt2) {
                    cleartext = _decrypter$decrypt2;
                  });
                }
              }();
              if (_temp3 && _temp3.then)
                return _temp3.then(function() {
                });
            });
          }
        }();
    }();
    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4));
  } catch (e2) {
    return Promise.reject(e2);
  }
}, "decryptJWE");
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    const observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
__name(_settle, "_settle");
__name2(_settle, "_settle");
var _Pact = /* @__PURE__ */ function() {
  function _Pact2() {
  }
  __name(_Pact2, "_Pact2");
  __name2(_Pact2, "_Pact");
  _Pact2.prototype.then = function(onFulfilled, onRejected) {
    const result = new _Pact2();
    const state = this.s;
    if (state) {
      const callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e2) {
          _settle(result, 2, e2);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function(_this) {
      try {
        const value = _this.v;
        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e2) {
        _settle(result, 2, e2);
      }
    };
    return result;
  };
  return _Pact2;
}();
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}
__name(_isSettledPact, "_isSettledPact");
__name2(_isSettledPact, "_isSettledPact");
function _forTo(array, body, check) {
  var i22 = -1, pact, reject;
  function _cycle(result) {
    try {
      while (++i22 < array.length && (!check || !check())) {
        result = body(i22);
        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }
      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e2) {
      _settle(pact || (pact = new _Pact()), 2, e2);
    }
  }
  __name(_cycle, "_cycle");
  __name2(_cycle, "_cycle");
  _cycle();
  return pact;
}
__name(_forTo, "_forTo");
__name2(_forTo, "_forTo");
function _forOf(target, body, check) {
  if (typeof target[_iteratorSymbol] === "function") {
    let _cycle = /* @__PURE__ */ __name(function(result) {
      try {
        while (!(step = iterator2.next()).done && (!check || !check())) {
          result = body(step.value);
          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }
        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e2) {
        _settle(pact || (pact = new _Pact()), 2, e2);
      }
    }, "_cycle");
    __name2(_cycle, "_cycle");
    var iterator2 = target[_iteratorSymbol](), step, pact, reject;
    _cycle();
    if (iterator2.return) {
      var _fixup = /* @__PURE__ */ __name2(function(value) {
        try {
          if (!step.done) {
            iterator2.return();
          }
        } catch (e2) {
        }
        return value;
      }, "_fixup");
      if (pact && pact.then) {
        return pact.then(_fixup, function(e2) {
          throw _fixup(e2);
        });
      }
      _fixup();
    }
    return pact;
  }
  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  }
  var values = [];
  for (var i22 = 0; i22 < target.length; i22++) {
    values.push(target[i22]);
  }
  return _forTo(values, function(i3) {
    return body(values[i3]);
  }, check);
}
__name(_forOf, "_forOf");
__name2(_forOf, "_forOf");
function validateJWE(jwe) {
  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {
    throw new Error("bad_jwe: missing properties");
  }
  if (jwe.recipients) {
    jwe.recipients.map((rec) => {
      if (!(rec.header && rec.encrypted_key)) {
        throw new Error("bad_jwe: malformed recipients");
      }
    });
  }
}
__name(validateJWE, "validateJWE");
__name2(validateJWE, "validateJWE");
function encodeJWE({
  ciphertext,
  tag,
  iv,
  protectedHeader,
  recipient
}, aad) {
  const jwe = {
    protected: protectedHeader,
    iv: bytesToBase64url(iv),
    ciphertext: bytesToBase64url(ciphertext),
    tag: bytesToBase64url(tag)
  };
  if (aad)
    jwe.aad = bytesToBase64url(aad);
  if (recipient)
    jwe.recipients = [recipient];
  return jwe;
}
__name(encodeJWE, "encodeJWE");
__name2(encodeJWE, "encodeJWE");
var createJWE = /* @__PURE__ */ __name2(function(cleartext, encrypters, protectedHeader = {}, aad) {
  try {
    if (encrypters[0].alg === "dir") {
      if (encrypters.length > 1)
        throw new Error('not_supported: Can only do "dir" encryption to one key.');
      return Promise.resolve(encrypters[0].encrypt(cleartext, protectedHeader, aad)).then(function(encryptionResult) {
        return encodeJWE(encryptionResult, aad);
      });
    } else {
      const tmpEnc = encrypters[0].enc;
      if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {
        throw new Error("invalid_argument: Incompatible encrypters passed");
      }
      let cek;
      let jwe;
      const _temp2 = _forOf(encrypters, function(encrypter) {
        const _temp = function() {
          if (!cek) {
            return Promise.resolve(encrypter.encrypt(cleartext, protectedHeader, aad)).then(function(encryptionResult) {
              cek = encryptionResult.cek;
              jwe = encodeJWE(encryptionResult, aad);
            });
          } else {
            return Promise.resolve(encrypter.encryptCek == null ? void 0 : encrypter.encryptCek(cek)).then(function(recipient) {
              if (recipient) {
                var _jwe, _jwe$recipients;
                (_jwe = jwe) == null ? void 0 : (_jwe$recipients = _jwe.recipients) == null ? void 0 : _jwe$recipients.push(recipient);
              }
            });
          }
        }();
        if (_temp && _temp.then)
          return _temp.then(function() {
          });
      });
      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function() {
        return jwe;
      }) : jwe);
    }
  } catch (e2) {
    return Promise.reject(e2);
  }
}, "createJWE");
var resolveX25519Encrypters = /* @__PURE__ */ __name2(function(dids, resolver) {
  try {
    const encryptersForDID = /* @__PURE__ */ __name2(function(did) {
      try {
        return Promise.resolve(resolver.resolve(did)).then(function({
          didResolutionMetadata,
          didDocument
        }) {
          var _didDocument$keyAgree;
          if (didResolutionMetadata != null && didResolutionMetadata.error || didDocument == null) {
            throw new Error(`resolver_error: Could not resolve ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`);
          }
          if (!didDocument.keyAgreement)
            throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`);
          const agreementKeys = (_didDocument$keyAgree = didDocument.keyAgreement) == null ? void 0 : _didDocument$keyAgree.map((key22) => {
            if (typeof key22 === "string") {
              return [...didDocument.publicKey || [], ...didDocument.verificationMethod || []].find((pk) => pk.id === key22);
            }
            return key22;
          }).filter((key22) => typeof key22 !== "undefined");
          const pks = agreementKeys.filter((key22) => {
            return key22.type === "X25519KeyAgreementKey2019" && Boolean(key22.publicKeyBase58);
          });
          if (!pks.length)
            throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`);
          return pks.map((pk) => x25519Encrypter(base58ToBytes(pk.publicKeyBase58), pk.id));
        });
      } catch (e2) {
        return Promise.reject(e2);
      }
    }, "encryptersForDID");
    const encrypterPromises = dids.map((did) => encryptersForDID(did));
    return Promise.resolve(Promise.all(encrypterPromises)).then(function(encrypterArrays) {
      const flattenedArray = [].concat(...encrypterArrays);
      return flattenedArray;
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
}, "resolveX25519Encrypters");
function xc20pEncrypter(key22) {
  const cipher = new import_xchacha20poly1305.XChaCha20Poly1305(key22);
  return (cleartext, aad) => {
    const iv = (0, import_random6.randomBytes)(cipher.nonceLength);
    const sealed = cipher.seal(iv, cleartext, aad);
    return {
      ciphertext: sealed.subarray(0, sealed.length - cipher.tagLength),
      tag: sealed.subarray(sealed.length - cipher.tagLength),
      iv
    };
  };
}
__name(xc20pEncrypter, "xc20pEncrypter");
__name2(xc20pEncrypter, "xc20pEncrypter");
function xc20pDirEncrypter(key22) {
  const encrypt2 = /* @__PURE__ */ __name2(function(cleartext, protectedHeader = {}, aad) {
    try {
      const protHeader = encodeBase64url(JSON.stringify(Object.assign({
        alg
      }, protectedHeader, {
        enc
      })));
      const encodedAad = new Uint8Array(Buffer.from(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader));
      return Promise.resolve({
        ...xc20pEncrypt(cleartext, encodedAad),
        protectedHeader: protHeader
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, "encrypt");
  const xc20pEncrypt = xc20pEncrypter(key22);
  const enc = "XC20P";
  const alg = "dir";
  return {
    alg,
    enc,
    encrypt: encrypt2
  };
}
__name(xc20pDirEncrypter, "xc20pDirEncrypter");
__name2(xc20pDirEncrypter, "xc20pDirEncrypter");
function xc20pDirDecrypter(key22) {
  const decrypt3 = /* @__PURE__ */ __name2(function(sealed, iv, aad) {
    try {
      return Promise.resolve(cipher.open(iv, sealed, aad));
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, "decrypt");
  const cipher = new import_xchacha20poly1305.XChaCha20Poly1305(key22);
  return {
    alg: "dir",
    enc: "XC20P",
    decrypt: decrypt3
  };
}
__name(xc20pDirDecrypter, "xc20pDirDecrypter");
__name2(xc20pDirDecrypter, "xc20pDirDecrypter");
function x25519Encrypter(publicKey, kid) {
  const encrypt2 = /* @__PURE__ */ __name2(function(cleartext, protectedHeader = {}, aad) {
    try {
      Object.assign(protectedHeader, {
        alg: void 0
      });
      const cek = (0, import_random6.randomBytes)(32);
      return Promise.resolve(xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)).then(function(_xc20pDirEncrypter$en) {
        return Promise.resolve(encryptCek(cek)).then(function(_encryptCek) {
          return {
            ..._xc20pDirEncrypter$en,
            recipient: _encryptCek,
            cek
          };
        });
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, "encrypt");
  const encryptCek = /* @__PURE__ */ __name2(function(cek) {
    try {
      const epk = (0, import_x25519.generateKeyPair)();
      const sharedSecret = (0, import_x25519.sharedKey)(epk.secretKey, publicKey);
      const kek = concatKDF(sharedSecret, keyLen, alg);
      const res = xc20pEncrypter(kek)(cek);
      const recipient = {
        encrypted_key: bytesToBase64url(res.ciphertext),
        header: {
          alg,
          iv: bytesToBase64url(res.iv),
          tag: bytesToBase64url(res.tag),
          epk: {
            kty: "OKP",
            crv,
            x: bytesToBase64url(epk.publicKey)
          }
        }
      };
      if (kid)
        recipient.header.kid = kid;
      return Promise.resolve(recipient);
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, "encryptCek");
  const alg = "ECDH-ES+XC20PKW";
  const keyLen = 256;
  const crv = "X25519";
  return {
    alg,
    enc: "XC20P",
    encrypt: encrypt2,
    encryptCek
  };
}
__name(x25519Encrypter, "x25519Encrypter");
__name2(x25519Encrypter, "x25519Encrypter");
function validateHeader(header) {
  if (!(header && header.epk && header.iv && header.tag)) {
    throw new Error("bad_jwe: malformed header");
  }
}
__name(validateHeader, "validateHeader");
__name2(validateHeader, "validateHeader");
function x25519Decrypter(receiverSecret) {
  const decrypt3 = /* @__PURE__ */ __name2(function(sealed, iv, aad, recipient) {
    try {
      let _temp4 = /* @__PURE__ */ __name(function() {
        const kek = concatKDF(sharedSecret, keyLen, alg);
        const sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag);
        return Promise.resolve(xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))).then(function(cek) {
          return cek === null ? null : xc20pDirDecrypter(cek).decrypt(sealed, iv, aad);
        });
      }, "_temp4");
      __name2(_temp4, "_temp4");
      var _recipient, _recipient$header$epk;
      validateHeader((_recipient = recipient) == null ? void 0 : _recipient.header);
      recipient = recipient;
      if (((_recipient$header$epk = recipient.header.epk) == null ? void 0 : _recipient$header$epk.crv) !== crv || typeof recipient.header.epk.x == "undefined")
        return Promise.resolve(null);
      const publicKey = base64ToBytes(recipient.header.epk.x);
      let sharedSecret;
      const _temp3 = function() {
        if (receiverSecret instanceof Uint8Array) {
          sharedSecret = (0, import_x25519.sharedKey)(receiverSecret, publicKey);
        } else {
          return Promise.resolve(receiverSecret(publicKey)).then(function(_receiverSecret) {
            sharedSecret = _receiverSecret;
          });
        }
      }();
      return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3));
    } catch (e2) {
      return Promise.reject(e2);
    }
  }, "decrypt");
  const alg = "ECDH-ES+XC20PKW";
  const keyLen = 256;
  const crv = "X25519";
  return {
    alg,
    enc: "XC20P",
    decrypt: decrypt3
  };
}
__name(x25519Decrypter, "x25519Decrypter");
__name2(x25519Decrypter, "x25519Decrypter");
init_src();
var readonly2 = /* @__PURE__ */ __name2(({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
}), "readonly");
var links = /* @__PURE__ */ __name2(function* (source, base4) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key22, value] of Object.entries(source)) {
    const path = [
      ...base4,
      key22
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
}, "links");
var tree = /* @__PURE__ */ __name2(function* (source, base4) {
  if (source == null)
    return;
  for (const [key22, value] of Object.entries(source)) {
    const path = [
      ...base4,
      key22
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
  }
}, "tree");
var get = /* @__PURE__ */ __name2((source, path) => {
  let node = source;
  for (const [index, key22] of path.entries()) {
    node = node[key22];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
}, "get");
var Block = /* @__PURE__ */ __name(class {
  constructor({ cid, bytes, value }) {
    if (!cid || !bytes || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
}, "Block");
__name2(Block, "Block");
var encode5 = /* @__PURE__ */ __name2(async ({ value, codec, hasher }) => {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes = codec.encode(value);
  const hash3 = await hasher.digest(bytes);
  const cid = CID.create(1, codec.code, hash3);
  return new Block({
    value,
    bytes,
    cid
  });
}, "encode");
var decode6 = /* @__PURE__ */ __name2(async ({ bytes, codec, hasher }) => {
  if (!bytes)
    throw new Error('Missing required argument "bytes"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const value = codec.decode(bytes);
  const hash3 = await hasher.digest(bytes);
  const cid = CID.create(1, codec.code, hash3);
  return new Block({
    value,
    bytes,
    cid
  });
}, "decode");
init_cid();
init_sha2_browser();
init_identity2();
init_base64();
var esm_exports = {};
__export2(esm_exports, {
  code: () => code2,
  decode: () => decode8,
  encode: () => encode7,
  name: () => name2
});
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType2 = getObjectType(value);
  if (objectType2) {
    return objectType2;
  }
  return "Object";
}
__name(is, "is");
__name2(is, "is");
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
__name(isBuffer, "isBuffer");
__name2(isBuffer, "isBuffer");
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
__name(getObjectType, "getObjectType");
__name2(getObjectType, "getObjectType");
var Type = /* @__PURE__ */ __name(class {
  constructor(major, name3, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name3;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
}, "Type");
__name2(Type, "Type");
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = /* @__PURE__ */ __name(class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
}, "Token");
__name2(Token, "Token");
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder2 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
__name(isBuffer2, "isBuffer2");
__name2(isBuffer2, "isBuffer");
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
__name(asU8A, "asU8A");
__name2(asU8A, "asU8A");
var toString4 = useBuffer ? (bytes, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice(bytes, start, end);
} : (bytes, start, end) => {
  return end - start > 64 ? textDecoder2.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
};
var fromString3 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder2.encode(string2) : utf8ToBytes(string2);
};
var fromArray = /* @__PURE__ */ __name2((arr) => {
  return Uint8Array.from(arr);
}, "fromArray");
var slice = useBuffer ? (bytes, start, end) => {
  if (isBuffer2(bytes)) {
    return new Uint8Array(bytes.subarray(start, end));
  }
  return bytes.slice(start, end);
} : (bytes, start, end) => {
  return bytes.slice(start, end);
};
var concat22 = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c2) => c2 instanceof Uint8Array ? c2 : globalThis.Buffer.from(c2));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off = 0;
  for (let b2 of chunks) {
    if (off + b2.length > out.length) {
      b2 = b2.subarray(0, out.length - off);
    }
    out.set(b2, off);
    off += b2.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare2(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i22 = 0; i22 < b1.length; i22++) {
    if (b1[i22] === b2[i22]) {
      continue;
    }
    return b1[i22] < b2[i22] ? -1 : 1;
  }
  return 0;
}
__name(compare2, "compare2");
__name2(compare2, "compare");
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i22 = 0; i22 < length2; ++i22) {
    codePoint = string2.charCodeAt(i22);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i22 + 1 === length2) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
__name(utf8ToBytes, "utf8ToBytes");
__name2(utf8ToBytes, "utf8ToBytes");
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
__name(utf8Slice, "utf8Slice");
__name2(utf8Slice, "utf8Slice");
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i22 = 0;
  while (i22 < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i22, i22 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
__name(decodeCodePointsArray, "decodeCodePointsArray");
__name2(decodeCodePointsArray, "decodeCodePointsArray");
var defaultChunkSize = 256;
var Bl = /* @__PURE__ */ __name(class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat22(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
}, "Bl");
__name2(Bl, "Bl");
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
__name(assertEnoughData, "assertEnoughData");
__name2(assertEnoughData, "assertEnoughData");
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint8, "readUint8");
__name2(readUint8, "readUint8");
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint16, "readUint16");
__name2(readUint16, "readUint16");
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint32, "readUint32");
__name2(readUint32, "readUint32");
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
__name(readUint64, "readUint64");
__name2(readUint64, "readUint64");
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
__name(decodeUint8, "decodeUint8");
__name2(decodeUint8, "decodeUint8");
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
__name(decodeUint16, "decodeUint16");
__name2(decodeUint16, "decodeUint16");
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
__name(decodeUint32, "decodeUint32");
__name2(decodeUint32, "decodeUint32");
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
__name(decodeUint64, "decodeUint64");
__name2(decodeUint64, "decodeUint64");
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
__name(encodeUint, "encodeUint");
__name2(encodeUint, "encodeUint");
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
__name(encodeUintValue, "encodeUintValue");
__name2(encodeUintValue, "encodeUintValue");
encodeUint.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize"), "encodedSize");
encodeUintValue.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
}, "encodedSize2"), "encodedSize");
encodeUint.compareTokens = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
}, "compareTokens"), "compareTokens");
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
__name(decodeNegint8, "decodeNegint8");
__name2(decodeNegint8, "decodeNegint8");
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
__name(decodeNegint16, "decodeNegint16");
__name2(decodeNegint16, "decodeNegint16");
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
__name(decodeNegint32, "decodeNegint32");
__name2(decodeNegint32, "decodeNegint32");
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
__name(decodeNegint64, "decodeNegint64");
__name2(decodeNegint64, "decodeNegint64");
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
__name(encodeNegint, "encodeNegint");
__name2(encodeNegint, "encodeNegint");
encodeNegint.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
}, "encodedSize3"), "encodedSize");
encodeNegint.compareTokens = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
}, "compareTokens2"), "compareTokens");
function toToken(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf2, prefix + length2);
}
__name(toToken, "toToken");
__name2(toToken, "toToken");
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
__name(decodeBytesCompact, "decodeBytesCompact");
__name2(decodeBytesCompact, "decodeBytesCompact");
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeBytes8, "decodeBytes8");
__name2(decodeBytes8, "decodeBytes8");
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeBytes16, "decodeBytes16");
__name2(decodeBytes16, "decodeBytes16");
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeBytes32, "decodeBytes32");
__name2(decodeBytes32, "decodeBytes32");
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
__name(decodeBytes64, "decodeBytes64");
__name2(decodeBytes64, "decodeBytes64");
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString3(token.value) : token.value;
  }
  return token.encodedBytes;
}
__name(tokenBytes, "tokenBytes");
__name2(tokenBytes, "tokenBytes");
function encodeBytes2(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
__name(encodeBytes2, "encodeBytes");
__name2(encodeBytes2, "encodeBytes");
encodeBytes2.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
}, "encodedSize4"), "encodedSize");
encodeBytes2.compareTokens = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
}, "compareTokens3"), "compareTokens");
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}
__name(compareBytes, "compareBytes");
__name2(compareBytes, "compareBytes");
function toToken2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString4(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
__name(toToken2, "toToken2");
__name2(toToken2, "toToken");
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
__name(decodeStringCompact, "decodeStringCompact");
__name2(decodeStringCompact, "decodeStringCompact");
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
__name(decodeString8, "decodeString8");
__name2(decodeString8, "decodeString8");
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
__name(decodeString16, "decodeString16");
__name2(decodeString16, "decodeString16");
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
__name(decodeString32, "decodeString32");
__name2(decodeString32, "decodeString32");
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
__name(decodeString64, "decodeString64");
__name2(decodeString64, "decodeString64");
var encodeString2 = encodeBytes2;
function toToken3(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
__name(toToken3, "toToken3");
__name2(toToken3, "toToken");
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
__name(decodeArrayCompact, "decodeArrayCompact");
__name2(decodeArrayCompact, "decodeArrayCompact");
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeArray8, "decodeArray8");
__name2(decodeArray8, "decodeArray8");
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeArray16, "decodeArray16");
__name2(decodeArray16, "decodeArray16");
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeArray32, "decodeArray32");
__name2(decodeArray32, "decodeArray32");
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
__name(decodeArray64, "decodeArray64");
__name2(decodeArray64, "decodeArray64");
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
__name(decodeArrayIndefinite, "decodeArrayIndefinite");
__name2(decodeArrayIndefinite, "decodeArrayIndefinite");
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
__name(encodeArray, "encodeArray");
__name2(encodeArray, "encodeArray");
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize5"), "encodedSize");
function toToken4(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
__name(toToken4, "toToken4");
__name2(toToken4, "toToken");
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
__name(decodeMapCompact, "decodeMapCompact");
__name2(decodeMapCompact, "decodeMapCompact");
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeMap8, "decodeMap8");
__name2(decodeMap8, "decodeMap8");
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeMap16, "decodeMap16");
__name2(decodeMap16, "decodeMap16");
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeMap32, "decodeMap32");
__name2(decodeMap32, "decodeMap32");
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
__name(decodeMap64, "decodeMap64");
__name2(decodeMap64, "decodeMap64");
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
__name(decodeMapIndefinite, "decodeMapIndefinite");
__name2(decodeMapIndefinite, "decodeMapIndefinite");
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
__name(encodeMap, "encodeMap");
__name2(encodeMap, "encodeMap");
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize6"), "encodedSize");
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
__name(decodeTagCompact, "decodeTagCompact");
__name2(decodeTagCompact, "decodeTagCompact");
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
__name(decodeTag8, "decodeTag8");
__name2(decodeTag8, "decodeTag8");
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
__name(decodeTag16, "decodeTag16");
__name2(decodeTag16, "decodeTag16");
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
__name(decodeTag32, "decodeTag32");
__name2(decodeTag32, "decodeTag32");
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
__name(decodeTag64, "decodeTag64");
__name2(decodeTag64, "decodeTag64");
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
__name(encodeTag, "encodeTag");
__name2(encodeTag, "encodeTag");
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize7"), "encodedSize");
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
__name(decodeUndefined, "decodeUndefined");
__name2(decodeUndefined, "decodeUndefined");
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
__name(decodeBreak, "decodeBreak");
__name2(decodeBreak, "decodeBreak");
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
__name(createToken, "createToken");
__name2(createToken, "createToken");
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
__name(decodeFloat16, "decodeFloat16");
__name2(decodeFloat16, "decodeFloat16");
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
__name(decodeFloat32, "decodeFloat32");
__name2(decodeFloat32, "decodeFloat32");
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
__name(decodeFloat64, "decodeFloat64");
__name2(decodeFloat64, "decodeFloat64");
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
__name(encodeFloat, "encodeFloat");
__name2(encodeFloat, "encodeFloat");
encodeFloat.encodedSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
}, "encodedSize8"), "encodedSize");
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
__name(encodeFloat16, "encodeFloat16");
__name2(encodeFloat16, "encodeFloat16");
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
__name(readFloat16, "readFloat16");
__name2(readFloat16, "readFloat16");
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
__name(encodeFloat32, "encodeFloat32");
__name2(encodeFloat32, "encodeFloat32");
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
__name(readFloat32, "readFloat32");
__name2(readFloat32, "readFloat32");
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
__name(encodeFloat64, "encodeFloat64");
__name2(encodeFloat64, "encodeFloat64");
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
__name(readFloat64, "readFloat64");
__name2(readFloat64, "readFloat64");
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
__name(invalidMinor, "invalidMinor");
__name2(invalidMinor, "invalidMinor");
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
__name(errorer, "errorer");
__name2(errorer, "errorer");
var jump = [];
for (let i22 = 0; i22 <= 23; i22++) {
  jump[i22] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i22 = 32; i22 <= 55; i22++) {
  jump[i22] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i22 = 64; i22 <= 87; i22++) {
  jump[i22] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i22 = 96; i22 <= 119; i22++) {
  jump[i22] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i22 = 128; i22 <= 151; i22++) {
  jump[i22] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i22 = 160; i22 <= 183; i22++) {
  jump[i22] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i22 = 192; i22 <= 215; i22++) {
  jump[i22] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i22 = 224; i22 <= 243; i22++) {
  jump[i22] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i22 = 0; i22 < 24; i22++) {
  quick[i22] = new Token(Type.uint, i22, 1);
}
for (let i22 = -1; i22 >= -24; i22--) {
  quick[31 - i22] = new Token(Type.negint, i22, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
__name(quickEncodeToken, "quickEncodeToken");
__name2(quickEncodeToken, "quickEncodeToken");
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes2;
  encoders[Type.string.major] = encodeString2;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
__name(makeCborEncoders, "makeCborEncoders");
__name2(makeCborEncoders, "makeCborEncoders");
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = /* @__PURE__ */ __name(class {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
}, "Ref");
__name2(Ref, "Ref");
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i22 = 0;
    for (const e2 of obj) {
      entries[i22++] = objectToTokens(e2, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i22 = 0;
    for (const key22 of keys) {
      entries[i22++] = [
        objectToTokens(key22, options, refStack),
        objectToTokens(isMap ? obj.get(key22) : obj[key22], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length2),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
__name(objectToTokens, "objectToTokens");
__name2(objectToTokens, "objectToTokens");
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
__name(sortMapEntries, "sortMapEntries");
__name2(sortMapEntries, "sortMapEntries");
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
__name(mapSorter, "mapSorter");
__name2(mapSorter, "mapSorter");
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
__name(tokensToEncoded, "tokensToEncoded");
__name2(tokensToEncoded, "tokensToEncoded");
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
__name(encodeCustom, "encodeCustom");
__name2(encodeCustom, "encodeCustom");
function encode6(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
__name(encode6, "encode6");
__name2(encode6, "encode");
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = /* @__PURE__ */ __name(class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
}, "Tokeniser");
__name2(Tokeniser, "Tokeniser");
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i22 = 0; i22 < token.value; i22++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i22}, expected ${token.value})`);
    }
    arr[i22] = value;
  }
  return arr;
}
__name(tokenToArray, "tokenToArray");
__name2(tokenToArray, "tokenToArray");
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m3 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i22 = 0; i22 < token.value; i22++) {
    const key22 = tokensToObject(tokeniser, options);
    if (key22 === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key22 === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i22} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key22 !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key22})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m3.has(key22) || !useMaps && key22 in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key22}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i22} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m3.set(key22, value);
    } else {
      obj[key22] = value;
    }
  }
  return useMaps ? m3 : obj;
}
__name(tokenToMap, "tokenToMap");
__name2(tokenToMap, "tokenToMap");
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
__name(tokensToObject, "tokensToObject");
__name2(tokensToObject, "tokensToObject");
function decode7(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
__name(decode7, "decode7");
__name2(decode7, "decode");
init_cid();
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
__name(cidEncoder, "cidEncoder");
__name2(cidEncoder, "cidEncoder");
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
__name(undefinedEncoder, "undefinedEncoder");
__name2(undefinedEncoder, "undefinedEncoder");
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
__name(numberEncoder, "numberEncoder");
__name2(numberEncoder, "numberEncoder");
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
__name(cidDecoder, "cidDecoder");
__name2(cidDecoder, "cidDecoder");
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name2 = "dag-cbor";
var code2 = 113;
var encode7 = /* @__PURE__ */ __name2((node) => encode6(node, encodeOptions), "encode");
var decode8 = /* @__PURE__ */ __name2((data) => decode7(data, decodeOptions), "decode");
var ENC_BLOCK_SIZE = 24;
async function encodePayload(payload) {
  const block = await encode5({ value: payload, codec: esm_exports, hasher: sha2563 });
  return {
    cid: block.cid,
    linkedBlock: block.bytes
  };
}
__name(encodePayload, "encodePayload");
__name2(encodePayload, "encodePayload");
function pad(b2, blockSize = ENC_BLOCK_SIZE) {
  const padLen = (blockSize - b2.length % blockSize) % blockSize;
  const bytes = new Uint8Array(b2.length + padLen);
  bytes.set(b2, 0);
  return bytes;
}
__name(pad, "pad");
__name2(pad, "pad");
async function encodeIdentityCID(obj) {
  const block = await encode5({ value: obj, codec: esm_exports, hasher: identity2 });
  return block.cid;
}
__name(encodeIdentityCID, "encodeIdentityCID");
__name2(encodeIdentityCID, "encodeIdentityCID");
function decodeIdentityCID(cid) {
  cid = CID.asCID(cid);
  if (cid.code !== code2)
    throw new Error("CID codec must be dag-cbor");
  if (cid.multihash.code !== identity2.code)
    throw new Error("CID must use identity multihash");
  return decode8(cid.multihash.digest);
}
__name(decodeIdentityCID, "decodeIdentityCID");
__name2(decodeIdentityCID, "decodeIdentityCID");
async function prepareCleartext(cleartext, blockSize) {
  return pad((await encodeIdentityCID(cleartext)).bytes, blockSize);
}
__name(prepareCleartext, "prepareCleartext");
__name2(prepareCleartext, "prepareCleartext");
function decodeCleartext(b2) {
  return decodeIdentityCID(CID.decodeFirst(b2)[0]);
}
__name(decodeCleartext, "decodeCleartext");
__name2(decodeCleartext, "decodeCleartext");
var abortableHandlerSymbol = Symbol("abortable");
var abortedReasonSymbol = Symbol("aborted");
function abortable(source, signal) {
  if (signal.aborted) {
    return Promise.reject(abortedReasonSymbol);
  }
  let rejectAborted;
  const abortion = new Promise((_resolve, reject) => {
    rejectAborted = reject;
  });
  signal.addEventListener("abort", () => {
    rejectAborted(abortedReasonSymbol);
  });
  return Promise.race([
    source,
    abortion
  ]);
}
__name(abortable, "abortable");
__name2(abortable, "abortable");
var nanoid = /* @__PURE__ */ __name2((size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id2, byte) => {
  byte &= 63;
  if (byte < 36) {
    id2 += byte.toString(36);
  } else if (byte < 62) {
    id2 += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id2 += "-";
  } else {
    id2 += "_";
  }
  return id2;
}, ""), "nanoid");
var ABORT_REQUEST_METHOD = "utils_abort_request";
var ERROR_CODE;
(function(ERROR_CODE2) {
  ERROR_CODE2[ERROR_CODE2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  ERROR_CODE2[ERROR_CODE2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  ERROR_CODE2[ERROR_CODE2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  ERROR_CODE2[ERROR_CODE2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  ERROR_CODE2[ERROR_CODE2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
})(ERROR_CODE || (ERROR_CODE = {}));
var ERROR_MESSAGE = {
  [ERROR_CODE.PARSE_ERROR]: "Parse error",
  [ERROR_CODE.INVALID_REQUEST]: "Invalid request",
  [ERROR_CODE.METHOD_NOT_FOUND]: "Method not found",
  [ERROR_CODE.INVALID_PARAMS]: "Invalid params",
  [ERROR_CODE.INTERNAL_ERROR]: "Internal error"
};
function isServerError(code3) {
  return -32e3 >= code3 && code3 >= -32099;
}
__name(isServerError, "isServerError");
__name2(isServerError, "isServerError");
function getErrorMessage(code3) {
  return ERROR_MESSAGE[code3.toString()] ?? (isServerError(code3) ? "Server error" : "Application error");
}
__name(getErrorMessage, "getErrorMessage");
__name2(getErrorMessage, "getErrorMessage");
var RPCError = /* @__PURE__ */ __name(class extends Error {
  static fromObject(err) {
    return new RPCError(err.code, err.message, err.data);
  }
  toObject() {
    return {
      code: this.code,
      data: this.data,
      message: this.message
    };
  }
  constructor(code3, message, data) {
    super();
    Object.setPrototypeOf(this, RPCError.prototype);
    this.code = code3;
    this.data = data;
    this.message = message ?? getErrorMessage(code3);
  }
}, "RPCError");
__name2(RPCError, "RPCError");
function createErrorFactory(code3) {
  const message = ERROR_MESSAGE[code3];
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function createError(data) {
    return new RPCError(code3, message, data);
  }, "createError"), "createError");
}
__name(createErrorFactory, "createErrorFactory");
__name2(createErrorFactory, "createErrorFactory");
var createParseError = createErrorFactory(ERROR_CODE.PARSE_ERROR);
var createInvalidRequest = createErrorFactory(ERROR_CODE.INVALID_REQUEST);
var createMethodNotFound = createErrorFactory(ERROR_CODE.METHOD_NOT_FOUND);
var createInvalidParams = createErrorFactory(ERROR_CODE.INVALID_PARAMS);
var createInternalError = createErrorFactory(ERROR_CODE.INTERNAL_ERROR);
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration, "_checkPrivateRedeclaration");
__name2(_checkPrivateRedeclaration, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet, "_classApplyDescriptorGet");
__name2(_classApplyDescriptorGet, "_classApplyDescriptorGet");
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet, "_classApplyDescriptorSet");
__name2(_classApplyDescriptorSet, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor, "_classExtractFieldDescriptor");
__name2(_classExtractFieldDescriptor, "_classExtractFieldDescriptor");
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
__name(_classPrivateFieldGet, "_classPrivateFieldGet");
__name2(_classPrivateFieldGet, "_classPrivateFieldGet");
function _classPrivateFieldInit(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit, "_classPrivateFieldInit");
__name2(_classPrivateFieldInit, "_classPrivateFieldInit");
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet, "_classPrivateFieldSet");
__name2(_classPrivateFieldSet, "_classPrivateFieldSet");
var _connection = /* @__PURE__ */ new WeakMap();
var RPCClient = /* @__PURE__ */ __name(class {
  get connection() {
    return _classPrivateFieldGet(this, _connection);
  }
  createID() {
    return nanoid();
  }
  request(method, params = void 0, options = {}) {
    const { signal } = options;
    if (signal?.aborted) {
      return Promise.reject(abortedReasonSymbol);
    }
    const id2 = this.createID();
    const responsePromise = _classPrivateFieldGet(this, _connection).send({
      jsonrpc: "2.0",
      id: id2,
      method,
      params
    }).then((res) => {
      if (res == null) {
        throw new Error("Missing response");
      }
      if (res.error != null) {
        throw RPCError.fromObject(res.error);
      }
      return res.result;
    });
    if (signal == null) {
      return responsePromise;
    }
    signal.addEventListener("abort", () => {
      void this.notify(ABORT_REQUEST_METHOD, {
        id: id2
      });
    });
    return abortable(responsePromise, signal);
  }
  async notify(method, params = void 0) {
    await _classPrivateFieldGet(this, _connection).send({
      jsonrpc: "2.0",
      method,
      params
    });
  }
  constructor(connection) {
    _classPrivateFieldInit(this, _connection, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _connection, connection);
  }
}, "RPCClient");
__name2(RPCClient, "RPCClient");
function createErrorResponse(id2, code3) {
  return {
    jsonrpc: "2.0",
    id: id2,
    error: {
      code: code3,
      message: getErrorMessage(code3)
    }
  };
}
__name(createErrorResponse, "createErrorResponse");
__name2(createErrorResponse, "createErrorResponse");
function fallbackOnHandlerError(_ctx, msg, error) {
  console.warn("Unhandled handler error", msg, error);
}
__name(fallbackOnHandlerError, "fallbackOnHandlerError");
__name2(fallbackOnHandlerError, "fallbackOnHandlerError");
function fallbackOnInvalidMessage(_ctx, msg) {
  console.warn("Unhandled invalid message", msg);
}
__name(fallbackOnInvalidMessage, "fallbackOnInvalidMessage");
__name2(fallbackOnInvalidMessage, "fallbackOnInvalidMessage");
function fallbackOnNotification(_ctx, msg) {
  console.warn("Unhandled notification", msg);
}
__name(fallbackOnNotification, "fallbackOnNotification");
__name2(fallbackOnNotification, "fallbackOnNotification");
function createHandler(methods, options = {}) {
  const onHandlerError = options.onHandlerError ?? fallbackOnHandlerError;
  const onInvalidMessage = options.onInvalidMessage ?? fallbackOnInvalidMessage;
  const onNotification = options.onNotification ?? fallbackOnNotification;
  const inflight = {};
  function handleNotification(ctx, msg) {
    if (msg.method === ABORT_REQUEST_METHOD) {
      const requestID = msg.params?.id;
      if (requestID != null) {
        inflight[requestID]?.abort();
      }
    } else {
      onNotification(ctx, msg);
    }
  }
  __name(handleNotification, "handleNotification");
  __name2(handleNotification, "handleNotification");
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(async function handleRequest(ctx, msg) {
    const id2 = msg.id;
    if (msg.jsonrpc !== "2.0" || msg.method == null) {
      if (id2 == null) {
        onInvalidMessage(ctx, msg);
        return null;
      }
      return createErrorResponse(id2, ERROR_CODE.INVALID_REQUEST);
    }
    const handler = methods[msg.method];
    if (handler == null) {
      if (id2 == null) {
        handleNotification(ctx, msg);
        return null;
      }
      return createErrorResponse(id2, ERROR_CODE.METHOD_NOT_FOUND);
    }
    try {
      let handled;
      if (id2 != null && handler[abortableHandlerSymbol]) {
        const controller = new AbortController();
        inflight[id2] = controller;
        handled = handler(ctx, msg.params, {
          signal: controller.signal
        });
      } else {
        handled = handler(ctx, msg.params, {});
      }
      const result = handled == null ? handled : typeof handled.then === "function" ? await handled : handled;
      return id2 == null || inflight[id2]?.signal.aborted ? null : {
        jsonrpc: "2.0",
        id: id2,
        result
      };
    } catch (err) {
      if (id2 == null || inflight[id2]?.signal.aborted) {
        onHandlerError(ctx, msg, err);
        return null;
      }
      let error;
      if (err instanceof RPCError) {
        error = err.toObject();
      } else {
        onHandlerError(ctx, msg, err);
        const code3 = err.code ?? -32e3;
        error = {
          code: code3,
          message: err.message || getErrorMessage(code3)
        };
      }
      return {
        jsonrpc: "2.0",
        id: id2,
        error
      };
    } finally {
      if (id2 != null) {
        delete inflight[id2];
      }
    }
  }, "handleRequest"), "handleRequest");
}
__name(createHandler, "createHandler");
__name2(createHandler, "createHandler");
init_cid();
var import_api = __toESM2(require_api(), 1);
var import_node_exports = __toESM2(require_node_exports(), 1);
var GRAMMAR = `
sign-in-with-ethereum =
    domain %s" wants you to sign in with your Ethereum account:" LF
    address LF
    LF
    [ statement LF ]
    LF
    %s"URI: " URI LF
    %s"Version: " version LF
    %s"Chain ID: " chain-id LF
    %s"Nonce: " nonce LF
    %s"Issued At: " issued-at
    [ LF %s"Expiration Time: " expiration-time ]
    [ LF %s"Not Before: " not-before ]
    [ LF %s"Request ID: " request-id ]
    [ LF %s"Resources:"
    resources ]

domain = dnsauthority

address = "0x" 40*40HEXDIG
    ; Must also conform to captilization
    ; checksum encoding specified in EIP-55
    ; where applicable (EOAs).

statement = *( reserved / unreserved / " " )
    ; The purpose is to exclude LF (line breaks).

version = "1"

nonce = 8*( ALPHA / DIGIT )

issued-at = date-time
expiration-time = date-time
not-before = date-time

request-id = *pchar

chain-id = 1*DIGIT
    ; See EIP-155 for valid CHAIN_IDs.

resources = *( LF resource )

resource = "- " URI

; ------------------------------------------------------------------------------
; RFC 3986

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

hier-part     = "//" authority path-abempty
              / path-absolute
              / path-rootless
              / path-empty

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

authority     = [ userinfo "@" ] host [ ":" port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

IPv6address   =                            6( h16 ":" ) ls32
              /                       "::" 5( h16 ":" ) ls32
              / [               h16 ] "::" 4( h16 ":" ) ls32
              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              / [ *4( h16 ":" ) h16 ] "::"              ls32
              / [ *5( h16 ":" ) h16 ] "::"              h16
              / [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims )

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-rootless = segment-nz *( "/" segment )
path-empty    = 0pchar

segment       = *pchar
segment-nz    = 1*pchar

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

query         = *( pchar / "/" / "?" )

fragment      = *( pchar / "/" / "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="

; ------------------------------------------------------------------------------
; RFC 4501

dnsauthority    = host [ ":" port ]
                             ; See RFC 3986 for the
                             ; definition of "host" and "port".

; ------------------------------------------------------------------------------
; RFC 3339

date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset

date-time       = full-date "T" full-time

; ------------------------------------------------------------------------------
; RFC 5234

ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
LF             =  %x0A
                  ; linefeed
DIGIT          =  %x30-39
                  ; 0-9
HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`;
var ParsedMessage = /* @__PURE__ */ __name(class {
  constructor(msg) {
    const api = new import_api.default(GRAMMAR);
    api.generate();
    if (api.errors.length) {
      console.error(api.errorsToAscii());
      console.error(api.linesToAscii());
      console.log(api.displayAttributeErrors());
      throw new Error(`ABNF grammar has errors`);
    }
    const grammarObj = api.toObject();
    const parser = new import_node_exports.default.parser();
    parser.ast = new import_node_exports.default.ast();
    const id2 = import_node_exports.default.ids;
    const domain = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.domain = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "domain");
    parser.ast.callbacks.domain = domain;
    const address = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.address = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "address");
    parser.ast.callbacks.address = address;
    const statement = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.statement = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "statement");
    parser.ast.callbacks.statement = statement;
    const uri = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        if (!data.uri) {
          data.uri = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
        }
      }
      return ret;
    }, "uri");
    parser.ast.callbacks.uri = uri;
    const version122 = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.version = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "version");
    parser.ast.callbacks.version = version122;
    const chainId = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.chainId = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "chainId");
    parser.ast.callbacks["chain-id"] = chainId;
    const nonce = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.nonce = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "nonce");
    parser.ast.callbacks.nonce = nonce;
    const issuedAt = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.issuedAt = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "issuedAt");
    parser.ast.callbacks["issued-at"] = issuedAt;
    const expirationTime = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.expirationTime = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "expirationTime");
    parser.ast.callbacks["expiration-time"] = expirationTime;
    const notBefore = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.notBefore = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "notBefore");
    parser.ast.callbacks["not-before"] = notBefore;
    const requestId = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.requestId = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "requestId");
    parser.ast.callbacks["request-id"] = requestId;
    const resources = /* @__PURE__ */ __name2(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id2.SEM_OK;
      if (state === id2.SEM_PRE) {
        data.resources = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength).slice(3).split("\n- ");
      }
      return ret;
    }, "resources");
    parser.ast.callbacks.resources = resources;
    const result = parser.parse(grammarObj, "sign-in-with-ethereum", msg);
    if (!result.success) {
      throw new Error(`Invalid message: ${JSON.stringify(result)}`);
    }
    const elements = {};
    parser.ast.translate(elements);
    for (const [key22, value] of Object.entries(elements)) {
      this[key22] = value;
    }
  }
}, "ParsedMessage");
__name2(ParsedMessage, "ParsedMessage");
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i22 = 1; i22 < arguments.length; i22++) {
      var source = arguments[i22];
      for (var key22 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key22)) {
          target[key22] = source[key22];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");
__name2(_extends, "_extends");
var CAIP2 = {
  name: "chainId",
  regex: "[-:a-zA-Z0-9]{5,41}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,32}"
      }
    }
  }
};
var CAIP10 = {
  name: "accountId",
  regex: "[-:a-zA-Z0-9]{7,106}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,32}"
      },
      2: {
        name: "address",
        regex: "[a-zA-Z0-9]{1,64}"
      }
    }
  }
};
var AssetName$1 = {
  name: "assetName",
  regex: "[-:a-zA-Z0-9]{5,73}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,64}"
      }
    }
  }
};
var CAIP19AssetType = {
  name: "assetType",
  regex: "[-:a-zA-Z0-9]{11,115}",
  parameters: {
    delimiter: "/",
    values: {
      0: CAIP2,
      1: AssetName$1
    }
  }
};
var CAIP19AssetId = {
  name: "assetId",
  regex: "[-:a-zA-Z0-9]{13,148}",
  parameters: {
    delimiter: "/",
    values: {
      0: CAIP2,
      1: AssetName$1,
      2: {
        name: "tokenId",
        regex: "[-a-zA-Z0-9]{1,32}"
      }
    }
  }
};
var CAIP = {
  "2": CAIP2,
  "10": CAIP10,
  "19": {
    assetName: AssetName$1,
    assetType: CAIP19AssetType,
    assetId: CAIP19AssetId
  }
};
function splitParams(id2, spec) {
  return id2.split(spec.parameters.delimiter);
}
__name(splitParams, "splitParams");
__name2(splitParams, "splitParams");
function getParams(id2, spec) {
  var arr = splitParams(id2, spec);
  var params = {};
  arr.forEach(function(value, index) {
    params[spec.parameters.values[index].name] = value;
  });
  return params;
}
__name(getParams, "getParams");
__name2(getParams, "getParams");
function joinParams(params, spec) {
  return Object.values(spec.parameters.values).map(function(parameter) {
    var param = params[parameter.name];
    return typeof param === "string" ? param : joinParams(param, parameter);
  }).join(spec.parameters.delimiter);
}
__name(joinParams, "joinParams");
__name2(joinParams, "joinParams");
function isValidId(id2, spec) {
  if (!new RegExp(spec.regex).test(id2))
    return false;
  var params = splitParams(id2, spec);
  if (params.length !== Object.keys(spec.parameters.values).length)
    return false;
  var matches = params.map(function(param, index) {
    return new RegExp(spec.parameters.values[index].regex).test(param);
  }).filter(function(x2) {
    return !!x2;
  });
  if (matches.length !== params.length)
    return false;
  return true;
}
__name(isValidId, "isValidId");
__name2(isValidId, "isValidId");
var ChainId = /* @__PURE__ */ function() {
  function ChainId2(params) {
    if (typeof params === "string") {
      params = ChainId2.parse(params);
    }
    this.namespace = params.namespace;
    this.reference = params.reference;
  }
  __name(ChainId2, "ChainId2");
  __name2(ChainId2, "ChainId");
  ChainId2.parse = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parse3(id2) {
    if (!isValidId(id2, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id2);
    }
    return new ChainId2(getParams(id2, this.spec)).toJSON();
  }, "parse3"), "parse");
  ChainId2.format = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function format2(params) {
    return joinParams(params, this.spec);
  }, "format2"), "format");
  var _proto = ChainId2.prototype;
  _proto.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
    return ChainId2.format(this.toJSON());
  }, "toString6"), "toString");
  _proto.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
    return {
      namespace: this.namespace,
      reference: this.reference
    };
  }, "toJSON2"), "toJSON");
  return ChainId2;
}();
ChainId.spec = CAIP["2"];
var AccountId = /* @__PURE__ */ function() {
  function AccountId2(params) {
    if (typeof params === "string") {
      params = AccountId2.parse(params);
    }
    this.chainId = new ChainId(params.chainId);
    this.address = params.address;
  }
  __name(AccountId2, "AccountId2");
  __name2(AccountId2, "AccountId");
  AccountId2.parse = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parse3(id2) {
    if (!isValidId(id2, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id2);
    }
    var _getParams = getParams(id2, this.spec), namespace = _getParams.namespace, reference = _getParams.reference, address = _getParams.address;
    var chainId = new ChainId({
      namespace,
      reference
    });
    return new AccountId2({
      chainId,
      address
    }).toJSON();
  }, "parse3"), "parse");
  AccountId2.format = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function format2(params) {
    var chainId = new ChainId(params.chainId);
    var splitParams2 = _extends({}, chainId.toJSON(), {
      address: params.address
    });
    return joinParams(splitParams2, this.spec);
  }, "format2"), "format");
  var _proto = AccountId2.prototype;
  _proto.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
    return AccountId2.format(this.toJSON());
  }, "toString6"), "toString");
  _proto.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
    return {
      chainId: this.chainId.toJSON(),
      address: this.address
    };
  }, "toJSON2"), "toJSON");
  return AccountId2;
}();
AccountId.spec = CAIP["10"];
var AssetName = /* @__PURE__ */ function() {
  function AssetName2(params) {
    if (typeof params === "string") {
      params = AssetName2.parse(params);
    }
    this.namespace = params.namespace;
    this.reference = params.reference;
  }
  __name(AssetName2, "AssetName2");
  __name2(AssetName2, "AssetName");
  AssetName2.parse = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parse3(id2) {
    if (!isValidId(id2, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id2);
    }
    return new AssetName2(getParams(id2, this.spec)).toJSON();
  }, "parse3"), "parse");
  AssetName2.format = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function format2(params) {
    return joinParams(params, this.spec);
  }, "format2"), "format");
  var _proto = AssetName2.prototype;
  _proto.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
    return AssetName2.format(this.toJSON());
  }, "toString6"), "toString");
  _proto.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
    return {
      namespace: this.namespace,
      reference: this.reference
    };
  }, "toJSON2"), "toJSON");
  return AssetName2;
}();
AssetName.spec = CAIP["19"].assetName;
var AssetType = /* @__PURE__ */ function() {
  function AssetType2(params) {
    if (typeof params === "string") {
      params = AssetType2.parse(params);
    }
    this.chainId = new ChainId(params.chainId);
    this.assetName = new AssetName(params.assetName);
  }
  __name(AssetType2, "AssetType2");
  __name2(AssetType2, "AssetType");
  AssetType2.parse = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parse3(id2) {
    if (!isValidId(id2, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id2);
    }
    return new AssetType2(getParams(id2, this.spec)).toJSON();
  }, "parse3"), "parse");
  AssetType2.format = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function format2(params) {
    return joinParams(params, this.spec);
  }, "format2"), "format");
  var _proto = AssetType2.prototype;
  _proto.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
    return AssetType2.format(this.toJSON());
  }, "toString6"), "toString");
  _proto.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
    return {
      chainId: this.chainId.toJSON(),
      assetName: this.assetName
    };
  }, "toJSON2"), "toJSON");
  return AssetType2;
}();
AssetType.spec = CAIP["19"].assetType;
var AssetId = /* @__PURE__ */ function() {
  function AssetId2(params) {
    if (typeof params === "string") {
      params = AssetId2.parse(params);
    }
    this.chainId = new ChainId(params.chainId);
    this.assetName = new AssetName(params.assetName);
    this.tokenId = params.tokenId;
  }
  __name(AssetId2, "AssetId2");
  __name2(AssetId2, "AssetId");
  AssetId2.parse = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function parse3(id2) {
    if (!isValidId(id2, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id2);
    }
    return new AssetId2(getParams(id2, this.spec)).toJSON();
  }, "parse3"), "parse");
  AssetId2.format = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function format2(params) {
    return joinParams(params, this.spec);
  }, "format2"), "format");
  var _proto = AssetId2.prototype;
  _proto.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString6() {
    return AssetId2.format(this.toJSON());
  }, "toString6"), "toString");
  _proto.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON22() {
    return {
      chainId: this.chainId.toJSON(),
      assetName: this.assetName.toJSON(),
      tokenId: this.tokenId
    };
  }, "toJSON2"), "toJSON");
  return AssetId2;
}();
AssetId.spec = CAIP["19"].assetId;
var ErrorTypes;
(function(ErrorTypes2) {
  ErrorTypes2["INVALID_SIGNATURE"] = "Invalid signature.";
  ErrorTypes2["EXPIRED_MESSAGE"] = "Expired message.";
  ErrorTypes2["MALFORMED_SESSION"] = "Malformed session.";
})(ErrorTypes || (ErrorTypes = {}));
var SignatureType;
(function(SignatureType2) {
  SignatureType2["PERSONAL_SIGNATURE"] = "Personal signature";
})(SignatureType || (SignatureType = {}));
var SiwxMessage = /* @__PURE__ */ __name(class {
  static fromCacao(cacao) {
    const account = AccountId.parse(cacao.p.iss.replace("did:pkh:", ""));
    const siwx = new this({
      domain: cacao.p.domain,
      address: account.address,
      uri: cacao.p.aud,
      version: cacao.p.version,
      chainId: new ChainId(account.chainId).reference
    });
    if (cacao.p.statement)
      siwx.statement = cacao.p.statement;
    if (cacao.p.nonce)
      siwx.nonce = cacao.p.nonce;
    if (cacao.p.iat)
      siwx.issuedAt = cacao.p.iat;
    if (cacao.p.exp)
      siwx.expirationTime = cacao.p.exp;
    if (cacao.p.nbf)
      siwx.notBefore = cacao.p.nbf;
    if (cacao.p.requestId)
      siwx.requestId = cacao.p.requestId;
    if (cacao.p.resources)
      siwx.resources = cacao.p.resources;
    if (cacao.s) {
      if (cacao.s.s)
        siwx.signature = cacao.s.s;
      if (cacao.s.t === "eip191")
        siwx.type = SignatureType.PERSONAL_SIGNATURE;
    }
    return siwx;
  }
  toMessage(chain) {
    return asString(this, chain);
  }
  constructor(param) {
    this.statement = void 0;
    this.nonce = void 0;
    this.issuedAt = void 0;
    this.expirationTime = void 0;
    this.notBefore = void 0;
    this.requestId = void 0;
    this.resources = void 0;
    this.signature = void 0;
    if (typeof param === "string") {
      const parsedMessage = new ParsedMessage(param);
      this.domain = parsedMessage.domain;
      this.address = parsedMessage.address;
      this.statement = parsedMessage.statement;
      this.uri = parsedMessage.uri;
      this.version = parsedMessage.version;
      this.nonce = parsedMessage.nonce;
      this.issuedAt = parsedMessage.issuedAt;
      this.expirationTime = parsedMessage.expirationTime;
      this.notBefore = parsedMessage.notBefore;
      this.requestId = parsedMessage.requestId;
      this.chainId = parsedMessage.chainId;
      this.resources = parsedMessage.resources;
    } else {
      Object.assign(this, param);
    }
  }
}, "SiwxMessage");
__name2(SiwxMessage, "SiwxMessage");
function asLegacyChainIdString(message, chainName) {
  const header = `${message.domain} wants you to sign in with your ${chainName} account:`;
  const uriField = `URI: ${message.uri}`;
  let prefix = [
    header,
    message.address
  ].join("\n");
  const versionField = `Version: ${message.version}`;
  if (!message.nonce) {
    message.nonce = (Math.random() + 1).toString(36).substring(4);
  }
  const nonceField = `Nonce: ${message.nonce}`;
  const suffixArray = [
    uriField,
    versionField,
    nonceField
  ];
  if (message.issuedAt) {
    Date.parse(message.issuedAt);
  }
  message.issuedAt = message.issuedAt ? message.issuedAt : new Date().toISOString();
  suffixArray.push(`Issued At: ${message.issuedAt}`);
  if (message.expirationTime) {
    const expiryField = `Expiration Time: ${message.expirationTime}`;
    suffixArray.push(expiryField);
  }
  if (message.notBefore) {
    suffixArray.push(`Not Before: ${message.notBefore}`);
  }
  if (message.requestId) {
    suffixArray.push(`Request ID: ${message.requestId}`);
  }
  if (message.chainId) {
    suffixArray.push(`Chain ID: ${message.chainId}`);
  }
  if (message.resources) {
    suffixArray.push([
      `Resources:`,
      ...message.resources.map((x2) => `- ${x2}`)
    ].join("\n"));
  }
  const suffix = suffixArray.join("\n");
  if (message.statement) {
    prefix = [
      prefix,
      message.statement
    ].join("\n\n");
  }
  return [
    prefix,
    suffix
  ].join("\n\n");
}
__name(asLegacyChainIdString, "asLegacyChainIdString");
__name2(asLegacyChainIdString, "asLegacyChainIdString");
function asString(message, chainName) {
  const header = `${message.domain} wants you to sign in with your ${chainName} account:`;
  const uriField = `URI: ${message.uri}`;
  let prefix = [
    header,
    message.address
  ].join("\n");
  const versionField = `Version: ${message.version}`;
  if (!message.nonce) {
    message.nonce = (Math.random() + 1).toString(36).substring(4);
  }
  const nonceField = `Nonce: ${message.nonce}`;
  const chainIdField = `Chain ID: ${message.chainId}`;
  const suffixArray = [
    uriField,
    versionField,
    chainIdField,
    nonceField
  ];
  if (message.issuedAt) {
    Date.parse(message.issuedAt);
  }
  message.issuedAt = message.issuedAt ? message.issuedAt : new Date().toISOString();
  suffixArray.push(`Issued At: ${message.issuedAt}`);
  if (message.expirationTime) {
    const expiryField = `Expiration Time: ${message.expirationTime}`;
    suffixArray.push(expiryField);
  }
  if (message.notBefore) {
    suffixArray.push(`Not Before: ${message.notBefore}`);
  }
  if (message.requestId) {
    suffixArray.push(`Request ID: ${message.requestId}`);
  }
  if (message.resources && message.resources.length >= 1) {
    suffixArray.push([
      `Resources:`,
      ...message.resources.map((x2) => `- ${x2}`)
    ].join("\n"));
  }
  const suffix = suffixArray.join("\n");
  if (message.statement) {
    prefix = [
      prefix,
      message.statement
    ].join("\n\n");
  }
  return [
    prefix,
    suffix
  ].join("\n\n");
}
__name(asString, "asString");
__name2(asString, "asString");
var SiweMessage = /* @__PURE__ */ __name(class extends SiwxMessage {
  toMessage() {
    return super.toMessage("Ethereum");
  }
  signMessage() {
    let message;
    switch (this.type) {
      case SignatureType.PERSONAL_SIGNATURE: {
        message = this.toMessage();
        break;
      }
      default: {
        message = this.toMessage();
        break;
      }
    }
    return message;
  }
}, "SiweMessage");
__name2(SiweMessage, "SiweMessage");
init_sha2_browser();
var CLOCK_SKEW_DEFAULT_SEC = 5 * 60;
var LEGACY_CHAIN_ID_REORG_DATE = new Date("2022-09-20").valueOf();
var Cacao;
(function(Cacao2) {
  function fromSiweMessage(siweMessage) {
    const cacao = {
      h: {
        t: "eip4361"
      },
      p: {
        domain: siweMessage.domain,
        iat: siweMessage.issuedAt,
        iss: `did:pkh:eip155:${siweMessage.chainId}:${siweMessage.address}`,
        aud: siweMessage.uri,
        version: siweMessage.version,
        nonce: siweMessage.nonce
      }
    };
    if (siweMessage.signature) {
      cacao.s = {
        t: "eip191",
        s: siweMessage.signature
      };
    }
    if (siweMessage.notBefore) {
      cacao.p.nbf = siweMessage.notBefore;
    }
    if (siweMessage.expirationTime) {
      cacao.p.exp = siweMessage.expirationTime;
    }
    if (siweMessage.statement) {
      cacao.p.statement = siweMessage.statement;
    }
    if (siweMessage.requestId) {
      cacao.p.requestId = siweMessage.requestId;
    }
    if (siweMessage.resources) {
      cacao.p.resources = siweMessage.resources;
    }
    return cacao;
  }
  __name(fromSiweMessage, "fromSiweMessage");
  __name2(fromSiweMessage, "fromSiweMessage");
  Cacao2.fromSiweMessage = fromSiweMessage;
  function fromSiwsMessage(siwsMessage) {
    const cacao = {
      h: {
        t: "caip122"
      },
      p: {
        domain: siwsMessage.domain,
        iat: siwsMessage.issuedAt,
        iss: `did:pkh:solana:${siwsMessage.chainId}:${siwsMessage.address}`,
        aud: siwsMessage.uri,
        version: siwsMessage.version,
        nonce: siwsMessage.nonce
      }
    };
    if (siwsMessage.signature) {
      cacao.s = {
        t: "solana:ed25519",
        s: siwsMessage.signature
      };
    }
    if (siwsMessage.notBefore) {
      cacao.p.nbf = siwsMessage.notBefore;
    }
    if (siwsMessage.expirationTime) {
      cacao.p.exp = siwsMessage.expirationTime;
    }
    if (siwsMessage.statement) {
      cacao.p.statement = siwsMessage.statement;
    }
    if (siwsMessage.requestId) {
      cacao.p.requestId = siwsMessage.requestId;
    }
    if (siwsMessage.resources) {
      cacao.p.resources = siwsMessage.resources;
    }
    return cacao;
  }
  __name(fromSiwsMessage, "fromSiwsMessage");
  __name2(fromSiwsMessage, "fromSiwsMessage");
  Cacao2.fromSiwsMessage = fromSiwsMessage;
  function fromSiwTezosMessage(siwTezosMessage) {
    const cacao = {
      h: {
        t: "caip122"
      },
      p: {
        domain: siwTezosMessage.domain,
        iat: siwTezosMessage.issuedAt,
        iss: `did:pkh:tezos:${siwTezosMessage.chainId}:${siwTezosMessage.address}`,
        aud: siwTezosMessage.uri,
        version: siwTezosMessage.version,
        nonce: siwTezosMessage.nonce
      }
    };
    if (siwTezosMessage.signature) {
      cacao.s = {
        t: "tezos:ed25519",
        s: siwTezosMessage.signature
      };
    }
    if (siwTezosMessage.notBefore) {
      cacao.p.nbf = siwTezosMessage.notBefore;
    }
    if (siwTezosMessage.expirationTime) {
      cacao.p.exp = siwTezosMessage.expirationTime;
    }
    if (siwTezosMessage.statement) {
      cacao.p.statement = siwTezosMessage.statement;
    }
    if (siwTezosMessage.requestId) {
      cacao.p.requestId = siwTezosMessage.requestId;
    }
    if (siwTezosMessage.resources) {
      cacao.p.resources = siwTezosMessage.resources;
    }
    return cacao;
  }
  __name(fromSiwTezosMessage, "fromSiwTezosMessage");
  __name2(fromSiwTezosMessage, "fromSiwTezosMessage");
  Cacao2.fromSiwTezosMessage = fromSiwTezosMessage;
  function fromSiwStacksMessage(siwStacksMessage) {
    const cacao = {
      h: {
        t: "caip122"
      },
      p: {
        domain: siwStacksMessage.domain,
        iat: siwStacksMessage.issuedAt,
        iss: `did:pkh:stacks:${siwStacksMessage.chainId}:${siwStacksMessage.address}`,
        aud: siwStacksMessage.uri,
        version: siwStacksMessage.version,
        nonce: siwStacksMessage.nonce
      }
    };
    if (siwStacksMessage.signature) {
      cacao.s = {
        t: "stacks:secp256k1",
        s: siwStacksMessage.signature
      };
    }
    if (siwStacksMessage.notBefore) {
      cacao.p.nbf = siwStacksMessage.notBefore;
    }
    if (siwStacksMessage.expirationTime) {
      cacao.p.exp = siwStacksMessage.expirationTime;
    }
    if (siwStacksMessage.statement) {
      cacao.p.statement = siwStacksMessage.statement;
    }
    if (siwStacksMessage.requestId) {
      cacao.p.requestId = siwStacksMessage.requestId;
    }
    if (siwStacksMessage.resources) {
      cacao.p.resources = siwStacksMessage.resources;
    }
    return cacao;
  }
  __name(fromSiwStacksMessage, "fromSiwStacksMessage");
  __name2(fromSiwStacksMessage, "fromSiwStacksMessage");
  Cacao2.fromSiwStacksMessage = fromSiwStacksMessage;
  async function fromBlockBytes(bytes) {
    const block = await decode6({
      bytes,
      codec: esm_exports,
      hasher: sha2563
    });
    return block.value;
  }
  __name(fromBlockBytes, "fromBlockBytes");
  __name2(fromBlockBytes, "fromBlockBytes");
  Cacao2.fromBlockBytes = fromBlockBytes;
  async function verify4(cacao, opts = {}) {
    assertSigned(cacao);
    const verify5 = opts.verifiers[cacao.s.t];
    if (!verify5)
      throw new Error("Unsupported CACAO signature type, register the needed verifier");
    return verify5(cacao, opts);
  }
  __name(verify4, "verify4");
  __name2(verify4, "verify");
  Cacao2.verify = verify4;
})(Cacao || (Cacao = {}));
var CacaoBlock;
(function(CacaoBlock2) {
  function fromCacao(cacao) {
    return encode5({
      value: cacao,
      codec: esm_exports,
      hasher: sha2563
    });
  }
  __name(fromCacao, "fromCacao");
  __name2(fromCacao, "fromCacao");
  CacaoBlock2.fromCacao = fromCacao;
})(CacaoBlock || (CacaoBlock = {}));
function assertSigned(cacao) {
  if (cacao.s === null || cacao.s === void 0) {
    throw new Error(`CACAO does not have a signature`);
  }
}
__name(assertSigned, "assertSigned");
__name2(assertSigned, "assertSigned");
function verifyTimeChecks(cacao, options) {
  const atTime = options.atTime ? options.atTime.getTime() : Date.now();
  const clockSkew = (options.clockSkewSecs ?? CLOCK_SKEW_DEFAULT_SEC) * 1e3;
  if (Date.parse(cacao.p.iat) > atTime + clockSkew || Date.parse(cacao.p.nbf) > atTime + clockSkew) {
    throw new Error(`CACAO is not valid yet`);
  }
  const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1e3 : 0;
  if (!options.disableExpirationCheck && Date.parse(cacao.p.exp) + phaseOutMS + clockSkew < atTime) {
    throw new Error(`CACAO has expired`);
  }
}
__name(verifyTimeChecks, "verifyTimeChecks");
__name2(verifyTimeChecks, "verifyTimeChecks");
var version28 = "logger/5.7.0";
var _permanentCensorErrors2 = false;
var _censorErrors2 = false;
var LogLevels2 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel2 = LogLevels2["default"];
var _globalLogger2 = null;
function _checkNormalize2() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
__name(_checkNormalize2, "_checkNormalize");
__name2(_checkNormalize2, "_checkNormalize");
var _normalizeError2 = _checkNormalize2();
var LogLevel2;
(function(LogLevel22) {
  LogLevel22["DEBUG"] = "DEBUG";
  LogLevel22["INFO"] = "INFO";
  LogLevel22["WARNING"] = "WARNING";
  LogLevel22["ERROR"] = "ERROR";
  LogLevel22["OFF"] = "OFF";
})(LogLevel2 || (LogLevel2 = {}));
var ErrorCode2;
(function(ErrorCode22) {
  ErrorCode22["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode22["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode22["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode22["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode22["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode22["TIMEOUT"] = "TIMEOUT";
  ErrorCode22["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode22["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode22["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode22["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode22["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode22["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode22["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode22["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode22["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode22["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode22["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode22["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode22["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode2 || (ErrorCode2 = {}));
var HEX2 = "0123456789abcdef";
var Logger2 = /* @__PURE__ */ __name(class {
  constructor(version122) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version122,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels2[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel2 > LogLevels2[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger2.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger2.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger2.levels.WARNING, args);
  }
  makeError(message, code3, params) {
    if (_censorErrors2) {
      return this.makeError("censored error", code3, {});
    }
    if (!code3) {
      code3 = Logger2.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key22) => {
      const value = params[key22];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i22 = 0; i22 < value.length; i22++) {
            hex += HEX2[value[i22] >> 4];
            hex += HEX2[value[i22] & 15];
          }
          messageDetails.push(key22 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key22 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key22 + "=" + JSON.stringify(params[key22].toString()));
      }
    });
    messageDetails.push(`code=${code3}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code3) {
      case ErrorCode2.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode2.CALL_EXCEPTION:
      case ErrorCode2.INSUFFICIENT_FUNDS:
      case ErrorCode2.MISSING_NEW:
      case ErrorCode2.NONCE_EXPIRED:
      case ErrorCode2.REPLACEMENT_UNDERPRICED:
      case ErrorCode2.TRANSACTION_REPLACED:
      case ErrorCode2.UNPREDICTABLE_GAS_LIMIT:
        url = code3;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code3;
    Object.keys(params).forEach(function(key22) {
      error[key22] = params[key22];
    });
    return error;
  }
  throwError(message, code3, params) {
    throw this.makeError(message, code3, params);
  }
  throwArgumentError(message, name3, value) {
    return this.throwError(message, Logger2.errors.INVALID_ARGUMENT, {
      argument: name3,
      value
    });
  }
  assert(condition, message, code3, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code3, params);
  }
  assertArgument(condition, message, name3, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name3, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError2) {
      this.throwError("platform missing String.prototype.normalize", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError2
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger2.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger2.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger2.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger2) {
      _globalLogger2 = new Logger2(version28);
    }
    return _globalLogger2;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors2) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors2 = !!censorship;
    _permanentCensorErrors2 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels2[logLevel.toLowerCase()];
    if (level == null) {
      Logger2.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel2 = level;
  }
  static from(version122) {
    return new Logger2(version122);
  }
}, "Logger");
__name2(Logger2, "Logger");
Logger2.errors = ErrorCode2;
Logger2.levels = LogLevel2;
var version32 = "bytes/5.7.0";
var logger47 = new Logger2(version32);
function isHexable2(value) {
  return !!value.toHexString;
}
__name(isHexable2, "isHexable");
__name2(isHexable2, "isHexable");
function addSlice2(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice2(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
__name(addSlice2, "addSlice");
__name2(addSlice2, "addSlice");
function isBytesLike2(value) {
  return isHexString2(value) && !(value.length % 2) || isBytes2(value);
}
__name(isBytesLike2, "isBytesLike");
__name2(isBytesLike2, "isBytesLike");
function isInteger2(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
__name(isInteger2, "isInteger");
__name2(isInteger2, "isInteger");
function isBytes2(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger2(value.length) || value.length < 0) {
    return false;
  }
  for (let i22 = 0; i22 < value.length; i22++) {
    const v = value[i22];
    if (!isInteger2(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
__name(isBytes2, "isBytes");
__name2(isBytes2, "isBytes");
function arrayify2(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger47.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice2(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    value = value.toHexString();
  }
  if (isHexString2(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger47.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i22 = 0; i22 < hex.length; i22 += 2) {
      result.push(parseInt(hex.substring(i22, i22 + 2), 16));
    }
    return addSlice2(new Uint8Array(result));
  }
  if (isBytes2(value)) {
    return addSlice2(new Uint8Array(value));
  }
  return logger47.throwArgumentError("invalid arrayify value", "value", value);
}
__name(arrayify2, "arrayify");
__name2(arrayify2, "arrayify");
function concat3(items) {
  const objects = items.map((item) => arrayify2(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice2(result);
}
__name(concat3, "concat3");
__name2(concat3, "concat");
function zeroPad2(value, length2) {
  value = arrayify2(value);
  if (value.length > length2) {
    logger47.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice2(result);
}
__name(zeroPad2, "zeroPad");
__name2(zeroPad2, "zeroPad");
function isHexString2(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
__name(isHexString2, "isHexString");
__name2(isHexString2, "isHexString");
var HexCharacters2 = "0123456789abcdef";
function hexlify2(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger47.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters2[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    return value.toHexString();
  }
  if (isHexString2(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger47.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes2(value)) {
    let result = "0x";
    for (let i22 = 0; i22 < value.length; i22++) {
      let v = value[i22];
      result += HexCharacters2[(v & 240) >> 4] + HexCharacters2[v & 15];
    }
    return result;
  }
  return logger47.throwArgumentError("invalid hexlify value", "value", value);
}
__name(hexlify2, "hexlify");
__name2(hexlify2, "hexlify");
function hexDataLength2(data) {
  if (typeof data !== "string") {
    data = hexlify2(data);
  } else if (!isHexString2(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
__name(hexDataLength2, "hexDataLength");
__name2(hexDataLength2, "hexDataLength");
function hexDataSlice2(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify2(data);
  } else if (!isHexString2(data) || data.length % 2) {
    logger47.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
__name(hexDataSlice2, "hexDataSlice");
__name2(hexDataSlice2, "hexDataSlice");
function hexZeroPad2(value, length2) {
  if (typeof value !== "string") {
    value = hexlify2(value);
  } else if (!isHexString2(value)) {
    logger47.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger47.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
__name(hexZeroPad2, "hexZeroPad");
__name2(hexZeroPad2, "hexZeroPad");
function splitSignature2(signature22) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike2(signature22)) {
    let bytes = arrayify2(signature22);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify2(bytes.slice(0, 32));
      result.s = hexlify2(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify2(bytes.slice(0, 32));
      result.s = hexlify2(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger47.throwArgumentError("invalid signature string", "signature", signature22);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger47.throwArgumentError("signature invalid v byte", "signature", signature22);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify2(bytes.slice(32, 64));
  } else {
    result.r = signature22.r;
    result.s = signature22.s;
    result.v = signature22.v;
    result.recoveryParam = signature22.recoveryParam;
    result._vs = signature22._vs;
    if (result._vs != null) {
      const vs2 = zeroPad2(arrayify2(result._vs), 32);
      result._vs = hexlify2(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger47.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature22);
      }
      vs2[0] &= 127;
      const s3 = hexlify2(vs2);
      if (result.s == null) {
        result.s = s3;
      } else if (result.s !== s3) {
        logger47.throwArgumentError("signature v mismatch _vs", "signature", signature22);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger47.throwArgumentError("signature missing v and recoveryParam", "signature", signature22);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger47.throwArgumentError("signature recoveryParam mismatch v", "signature", signature22);
        }
      }
    }
    if (result.r == null || !isHexString2(result.r)) {
      logger47.throwArgumentError("signature missing or invalid r", "signature", signature22);
    } else {
      result.r = hexZeroPad2(result.r, 32);
    }
    if (result.s == null || !isHexString2(result.s)) {
      logger47.throwArgumentError("signature missing or invalid s", "signature", signature22);
    } else {
      result.s = hexZeroPad2(result.s, 32);
    }
    const vs = arrayify2(result.s);
    if (vs[0] >= 128) {
      logger47.throwArgumentError("signature s out of range", "signature", signature22);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify2(vs);
    if (result._vs) {
      if (!isHexString2(result._vs)) {
        logger47.throwArgumentError("signature invalid _vs", "signature", signature22);
      }
      result._vs = hexZeroPad2(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger47.throwArgumentError("signature _vs mismatch v and s", "signature", signature22);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
__name(splitSignature2, "splitSignature");
__name2(splitSignature2, "splitSignature");
var import_bn3 = __toESM2(require_bn22());
var version42 = "bignumber/5.7.0";
var BN3 = import_bn3.default.BN;
var logger210 = new Logger2(version42);
function _base36To162(value) {
  return new BN3(value, 36).toString(16);
}
__name(_base36To162, "_base36To16");
__name2(_base36To162, "_base36To16");
var import_js_sha322 = __toESM2(require_sha32());
function keccak2563(data) {
  return "0x" + import_js_sha322.default.keccak_256(arrayify2(data));
}
__name(keccak2563, "keccak256");
__name2(keccak2563, "keccak256");
var version52 = "address/5.7.0";
var logger310 = new Logger2(version52);
function getChecksumAddress2(address) {
  if (!isHexString2(address, 20)) {
    logger310.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i22 = 0; i22 < 40; i22++) {
    expanded[i22] = chars[i22].charCodeAt(0);
  }
  const hashed = arrayify2(keccak2563(expanded));
  for (let i22 = 0; i22 < 40; i22 += 2) {
    if (hashed[i22 >> 1] >> 4 >= 8) {
      chars[i22] = chars[i22].toUpperCase();
    }
    if ((hashed[i22 >> 1] & 15) >= 8) {
      chars[i22 + 1] = chars[i22 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
__name(getChecksumAddress2, "getChecksumAddress");
__name2(getChecksumAddress2, "getChecksumAddress");
var MAX_SAFE_INTEGER2 = 9007199254740991;
function log102(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
__name(log102, "log10");
__name2(log102, "log10");
var ibanLookup2 = {};
for (let i22 = 0; i22 < 10; i22++) {
  ibanLookup2[String(i22)] = String(i22);
}
for (let i22 = 0; i22 < 26; i22++) {
  ibanLookup2[String.fromCharCode(65 + i22)] = String(10 + i22);
}
var safeDigits2 = Math.floor(log102(MAX_SAFE_INTEGER2));
function ibanChecksum2(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup2[c2];
  }).join("");
  while (expanded.length >= safeDigits2) {
    let block = expanded.substring(0, safeDigits2);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
__name(ibanChecksum2, "ibanChecksum");
__name2(ibanChecksum2, "ibanChecksum");
function getAddress2(address) {
  let result = null;
  if (typeof address !== "string") {
    logger310.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress2(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger310.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum2(address)) {
      logger310.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To162(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress2("0x" + result);
  } else {
    logger310.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
__name(getAddress2, "getAddress");
__name2(getAddress2, "getAddress");
var version62 = "properties/5.7.0";
var logger48 = new Logger2(version62);
function defineReadOnly2(object, name3, value) {
  Object.defineProperty(object, name3, {
    enumerable: true,
    value,
    writable: false
  });
}
__name(defineReadOnly2, "defineReadOnly");
__name2(defineReadOnly2, "defineReadOnly");
var version72 = "strings/5.7.0";
var logger52 = new Logger2(version72);
var UnicodeNormalizationForm2;
(function(UnicodeNormalizationForm22) {
  UnicodeNormalizationForm22["current"] = "";
  UnicodeNormalizationForm22["NFC"] = "NFC";
  UnicodeNormalizationForm22["NFD"] = "NFD";
  UnicodeNormalizationForm22["NFKC"] = "NFKC";
  UnicodeNormalizationForm22["NFKD"] = "NFKD";
})(UnicodeNormalizationForm2 || (UnicodeNormalizationForm2 = {}));
var Utf8ErrorReason2;
(function(Utf8ErrorReason22) {
  Utf8ErrorReason22["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason22["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason22["OVERRUN"] = "string overrun";
  Utf8ErrorReason22["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason22["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason22["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason22["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason2 || (Utf8ErrorReason2 = {}));
function errorFunc2(reason, offset, bytes, output, badCodepoint) {
  return logger52.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
__name(errorFunc2, "errorFunc");
__name2(errorFunc2, "errorFunc");
function ignoreFunc2(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason2.BAD_PREFIX || reason === Utf8ErrorReason2.UNEXPECTED_CONTINUE) {
    let i22 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i22++;
    }
    return i22;
  }
  if (reason === Utf8ErrorReason2.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
__name(ignoreFunc2, "ignoreFunc");
__name2(ignoreFunc2, "ignoreFunc");
function replaceFunc2(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason2.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc2(reason, offset, bytes, output, badCodepoint);
}
__name(replaceFunc2, "replaceFunc");
__name2(replaceFunc2, "replaceFunc");
var Utf8ErrorFuncs2 = Object.freeze({
  error: errorFunc2,
  ignore: ignoreFunc2,
  replace: replaceFunc2
});
function toUtf8Bytes2(str, form = UnicodeNormalizationForm2.current) {
  if (form != UnicodeNormalizationForm2.current) {
    logger52.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i22 = 0; i22 < str.length; i22++) {
    const c2 = str.charCodeAt(i22);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i22++;
      const c22 = str.charCodeAt(i22);
      if (i22 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify2(result);
}
__name(toUtf8Bytes2, "toUtf8Bytes");
__name2(toUtf8Bytes2, "toUtf8Bytes");
var messagePrefix2 = "Ethereum Signed Message:\n";
function hashMessage2(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes2(message);
  }
  return keccak2563(concat3([
    toUtf8Bytes2(messagePrefix2),
    toUtf8Bytes2(String(message.length)),
    message
  ]));
}
__name(hashMessage2, "hashMessage");
__name2(hashMessage2, "hashMessage");
var import_bn22 = __toESM2(require_bn22());
var import_hash9 = __toESM2(require_hash2());
function createCommonjsModule2(fn, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base4) {
      return commonjsRequire2(path, base4 === void 0 || base4 === null ? module2.path : base4);
    }
  }, fn(module2, module2.exports), module2.exports;
}
__name(createCommonjsModule2, "createCommonjsModule");
__name2(createCommonjsModule2, "createCommonjsModule");
function commonjsRequire2() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
__name(commonjsRequire2, "commonjsRequire");
__name2(commonjsRequire2, "commonjsRequire");
var minimalisticAssert2 = assert2;
function assert2(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
__name(assert2, "assert");
__name2(assert2, "assert");
assert2.equal = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function assertEqual2(l, r2, msg) {
  if (l != r2)
    throw new Error(msg || "Assertion failed: " + l + " != " + r2);
}, "assertEqual"), "assertEqual");
var utils_12 = createCommonjsModule2(function(module2, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i22 = 0; i22 < msg.length; i22++)
        res[i22] = msg[i22] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i22 = 0; i22 < msg.length; i22 += 2)
        res.push(parseInt(msg[i22] + msg[i22 + 1], 16));
    } else {
      for (var i22 = 0; i22 < msg.length; i22++) {
        var c2 = msg.charCodeAt(i22);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  __name(toArray, "toArray");
  __name2(toArray, "toArray");
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  __name(zero2, "zero2");
  __name2(zero2, "zero2");
  utils.zero2 = zero2;
  function toHex2(msg) {
    var res = "";
    for (var i22 = 0; i22 < msg.length; i22++)
      res += zero2(msg[i22].toString(16));
    return res;
  }
  __name(toHex2, "toHex");
  __name2(toHex2, "toHex");
  utils.toHex = toHex2;
  utils.encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encode16(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  }, "encode16"), "encode");
});
var utils_1$12 = createCommonjsModule2(function(module2, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert2;
  utils.toArray = utils_12.toArray;
  utils.zero2 = utils_12.zero2;
  utils.toHex = utils_12.toHex;
  utils.encode = utils_12.encode;
  function getNAF22(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i22 = 0; i22 < naf.length; i22++) {
      var z2;
      var mod2 = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod2 > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod2;
        else
          z2 = mod2;
        k2.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i22] = z2;
      k2.iushrn(1);
    }
    return naf;
  }
  __name(getNAF22, "getNAF2");
  __name2(getNAF22, "getNAF");
  utils.getNAF = getNAF22;
  function getJSF22(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d22 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d22) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d22 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d22 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d22 === u2 + 1)
        d22 = 1 - d22;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  __name(getJSF22, "getJSF2");
  __name2(getJSF22, "getJSF");
  utils.getJSF = getJSF22;
  function cachedProperty(obj, name3, computer) {
    var key22 = "_" + name3;
    obj.prototype[name3] = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function cachedProperty2() {
      return this[key22] !== void 0 ? this[key22] : this[key22] = computer.call(this);
    }, "cachedProperty2"), "cachedProperty");
  }
  __name(cachedProperty, "cachedProperty");
  __name2(cachedProperty, "cachedProperty");
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  __name(parseBytes, "parseBytes");
  __name2(parseBytes, "parseBytes");
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn22.default(bytes, "hex", "le");
  }
  __name(intFromLE, "intFromLE");
  __name2(intFromLE, "intFromLE");
  utils.intFromLE = intFromLE;
});
var getNAF2 = utils_1$12.getNAF;
var getJSF2 = utils_1$12.getJSF;
var assert$12 = utils_1$12.assert;
function BaseCurve2(type, conf) {
  this.type = type;
  this.p = new import_bn22.default(conf.p, 16);
  this.red = conf.prime ? import_bn22.default.red(conf.prime) : import_bn22.default.mont(this.p);
  this.zero = new import_bn22.default(0).toRed(this.red);
  this.one = new import_bn22.default(1).toRed(this.red);
  this.two = new import_bn22.default(2).toRed(this.red);
  this.n = conf.n && new import_bn22.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
__name(BaseCurve2, "BaseCurve");
__name2(BaseCurve2, "BaseCurve");
var base3 = BaseCurve2;
BaseCurve2.prototype.point = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function point3() {
  throw new Error("Not implemented");
}, "point"), "point");
BaseCurve2.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate5() {
  throw new Error("Not implemented");
}, "validate"), "validate");
BaseCurve2.prototype._fixedNafMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _fixedNafMul2(p, k2) {
  assert$12(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF2(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a3 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i22 = I2; i22 > 0; i22--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i22)
        b2 = b2.mixedAdd(doubles.points[j]);
      else if (nafW === -i22)
        b2 = b2.mixedAdd(doubles.points[j].neg());
    }
    a3 = a3.add(b2);
  }
  return a3.toP();
}, "_fixedNafMul"), "_fixedNafMul");
BaseCurve2.prototype._wnafMul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _wnafMul2(p, k2) {
  var w2 = 4;
  var nafPoints = p._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF2(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i22 = naf.length - 1; i22 >= 0; i22--) {
    for (var l = 0; i22 >= 0 && naf[i22] === 0; i22--)
      l++;
    if (i22 >= 0)
      l++;
    acc = acc.dblp(l);
    if (i22 < 0)
      break;
    var z2 = naf[i22];
    assert$12(z2 !== 0);
    if (p.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
}, "_wnafMul"), "_wnafMul");
BaseCurve2.prototype._wnafMulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _wnafMulAdd2(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i22;
  var j;
  var p;
  for (i22 = 0; i22 < len; i22++) {
    p = points[i22];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i22] = nafPoints.wnd;
    wnd[i22] = nafPoints.points;
  }
  for (i22 = len - 1; i22 >= 1; i22 -= 2) {
    var a3 = i22 - 1;
    var b2 = i22;
    if (wndWidth[a3] !== 1 || wndWidth[b2] !== 1) {
      naf[a3] = getNAF2(coeffs[a3], wndWidth[a3], this._bitLength);
      naf[b2] = getNAF2(coeffs[b2], wndWidth[b2], this._bitLength);
      max = Math.max(naf[a3].length, max);
      max = Math.max(naf[b2].length, max);
      continue;
    }
    var comb = [
      points[a3],
      null,
      null,
      points[b2]
    ];
    if (points[a3].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a3].add(points[b2]);
      comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
    } else if (points[a3].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a3].toJ().mixedAdd(points[b2]);
      comb[2] = points[a3].add(points[b2].neg());
    } else {
      comb[1] = points[a3].toJ().mixedAdd(points[b2]);
      comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF2(coeffs[a3], coeffs[b2]);
    max = Math.max(jsf[0].length, max);
    naf[a3] = new Array(max);
    naf[b2] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a3][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j] = 0;
      wnd[a3] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i22 = max; i22 >= 0; i22--) {
    var k2 = 0;
    while (i22 >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i22] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i22--;
    }
    if (i22 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i22 < 0)
      break;
    for (j = 0; j < len; j++) {
      var z2 = tmp[j];
      p;
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p = wnd[j][z2 - 1 >> 1];
      else if (z2 < 0)
        p = wnd[j][-z2 - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i22 = 0; i22 < len; i22++)
    wnd[i22] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
}, "_wnafMulAdd"), "_wnafMulAdd");
function BasePoint2(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
__name(BasePoint2, "BasePoint");
__name2(BasePoint2, "BasePoint");
BaseCurve2.BasePoint = BasePoint2;
BasePoint2.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq4() {
  throw new Error("Not implemented");
}, "eq"), "eq");
BasePoint2.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate22() {
  return this.curve.validate(this);
}, "validate2"), "validate");
BaseCurve2.prototype.decodePoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function decodePoint2(bytes, enc) {
  bytes = utils_1$12.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$12(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$12(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
}, "decodePoint"), "decodePoint");
BasePoint2.prototype.encodeCompressed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encodeCompressed2(enc) {
  return this.encode(enc, true);
}, "encodeCompressed"), "encodeCompressed");
BasePoint2.prototype._encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _encode3(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
}, "_encode"), "_encode");
BasePoint2.prototype.encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encode8(enc, compact) {
  return utils_1$12.encode(this._encode(compact), enc);
}, "encode8"), "encode");
BasePoint2.prototype.precompute = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function precompute2(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
}, "precompute"), "precompute");
BasePoint2.prototype._hasDoubles = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _hasDoubles2(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
}, "_hasDoubles"), "_hasDoubles");
BasePoint2.prototype._getDoubles = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getDoubles2(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i22 = 0; i22 < power; i22 += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
}, "_getDoubles"), "_getDoubles");
BasePoint2.prototype._getNAFPoints = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getNAFPoints2(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl32 = max === 1 ? null : this.dbl();
  for (var i22 = 1; i22 < max; i22++)
    res[i22] = res[i22 - 1].add(dbl32);
  return {
    wnd,
    points: res
  };
}, "_getNAFPoints"), "_getNAFPoints");
BasePoint2.prototype._getBeta = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getBeta3() {
  return null;
}, "_getBeta"), "_getBeta");
BasePoint2.prototype.dblp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dblp3(k2) {
  var r2 = this;
  for (var i22 = 0; i22 < k2; i22++)
    r2 = r2.dbl();
  return r2;
}, "dblp"), "dblp");
var inherits_browser2 = createCommonjsModule2(function(module2) {
  if (typeof Object.create === "function") {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    }, "inherits"), "inherits");
  } else {
    module2.exports = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = /* @__PURE__ */ __name2(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    }, "inherits"), "inherits");
  }
});
var assert$22 = utils_1$12.assert;
function ShortCurve2(conf) {
  base3.call(this, "short", conf);
  this.a = new import_bn22.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn22.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
__name(ShortCurve2, "ShortCurve");
__name2(ShortCurve2, "ShortCurve");
inherits_browser2(ShortCurve2, base3);
var short_12 = ShortCurve2;
ShortCurve2.prototype._getEndomorphism = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getEndomorphism2(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn22.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn22.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$22(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn22.default(vec.a, 16),
        b: new import_bn22.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
}, "_getEndomorphism"), "_getEndomorphism");
ShortCurve2.prototype._getEndoRoots = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getEndoRoots2(num) {
  var red = num === this.p ? this.red : import_bn22.default.mont(num);
  var tinv = new import_bn22.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s3 = new import_bn22.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s3).fromRed();
  var l2 = ntinv.redSub(s3).fromRed();
  return [l1, l2];
}, "_getEndoRoots"), "_getEndoRoots");
ShortCurve2.prototype._getEndoBasis = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getEndoBasis2(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v = this.n.clone();
  var x1 = new import_bn22.default(1);
  var y1 = new import_bn22.default(0);
  var x2 = new import_bn22.default(0);
  var y22 = new import_bn22.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a22;
  var b2;
  var prevR;
  var i22 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v.div(u2);
    r2 = v.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y22.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i22 === 2) {
      break;
    }
    prevR = r2;
    v = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y22 = y1;
    y1 = y3;
  }
  a22 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a22.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a22 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a22.negative) {
    a22 = a22.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a22, b: b2 }
  ];
}, "_getEndoBasis"), "_getEndoBasis");
ShortCurve2.prototype._endoSplit = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _endoSplit2(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
}, "_endoSplit"), "_endoSplit");
ShortCurve2.prototype.pointFromX = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromX2(x2, odd) {
  x2 = new import_bn22.default(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y22.redSqrt();
  if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
}, "pointFromX"), "pointFromX");
ShortCurve2.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate32(point32) {
  if (point32.inf)
    return true;
  var x2 = point32.x;
  var y3 = point32.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y3.redSqr().redISub(rhs).cmpn(0) === 0;
}, "validate3"), "validate");
ShortCurve2.prototype._endoWnafMulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i22 = 0; i22 < points.length; i22++) {
    var split = this._endoSplit(coeffs[i22]);
    var p = points[i22];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i22 * 2] = p;
    npoints[i22 * 2 + 1] = beta;
    ncoeffs[i22 * 2] = split.k1;
    ncoeffs[i22 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i22 * 2, jacobianResult);
  for (var j = 0; j < i22 * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
}, "_endoWnafMulAdd"), "_endoWnafMulAdd");
function Point2(curve, x2, y3, isRed) {
  base3.BasePoint.call(this, curve, "affine");
  if (x2 === null && y3 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn22.default(x2, 16);
    this.y = new import_bn22.default(y3, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
__name(Point2, "Point");
__name2(Point2, "Point");
inherits_browser2(Point2, base3.BasePoint);
ShortCurve2.prototype.point = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function point22(x2, y3, isRed) {
  return new Point2(this, x2, y3, isRed);
}, "point2"), "point");
ShortCurve2.prototype.pointFromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function pointFromJSON2(obj, red) {
  return Point2.fromJSON(this, obj, red);
}, "pointFromJSON"), "pointFromJSON");
Point2.prototype._getBeta = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _getBeta22() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = /* @__PURE__ */ __name2(function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    }, "endoMul");
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
}, "_getBeta2"), "_getBeta");
Point2.prototype.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON2() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
}, "toJSON"), "toJSON");
Point2.fromJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromJSON2(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  __name(obj2point, "obj2point");
  __name2(obj2point, "obj2point");
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
}, "fromJSON"), "fromJSON");
Point2.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, "inspect"), "inspect");
Point2.prototype.isInfinity = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isInfinity3() {
  return this.inf;
}, "isInfinity"), "isInfinity");
Point2.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add3(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
}, "add"), "add");
Point2.prototype.dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dbl3() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a3 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a3).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
}, "dbl"), "dbl");
Point2.prototype.getX = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getX2() {
  return this.x.fromRed();
}, "getX"), "getX");
Point2.prototype.getY = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getY2() {
  return this.y.fromRed();
}, "getY"), "getY");
Point2.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul3(k2) {
  k2 = new import_bn22.default(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
}, "mul"), "mul");
Point2.prototype.mulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
}, "mulAdd"), "mulAdd");
Point2.prototype.jmulAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function jmulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
}, "jmulAdd"), "jmulAdd");
Point2.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq22(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
}, "eq2"), "eq");
Point2.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg3(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = /* @__PURE__ */ __name2(function(p) {
      return p.neg();
    }, "negate");
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
}, "neg"), "neg");
Point2.prototype.toJ = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJ2() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
}, "toJ"), "toJ");
function JPoint2(curve, x2, y3, z2) {
  base3.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y3 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn22.default(0);
  } else {
    this.x = new import_bn22.default(x2, 16);
    this.y = new import_bn22.default(y3, 16);
    this.z = new import_bn22.default(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
__name(JPoint2, "JPoint");
__name2(JPoint2, "JPoint");
inherits_browser2(JPoint2, base3.BasePoint);
ShortCurve2.prototype.jpoint = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function jpoint2(x2, y3, z2) {
  return new JPoint2(this, x2, y3, z2);
}, "jpoint"), "jpoint");
JPoint2.prototype.toP = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toP2() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
}, "toP"), "toP");
JPoint2.prototype.neg = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function neg22() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, "neg2"), "neg");
JPoint2.prototype.add = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function add22(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s22 = p.y.redMul(z2.redMul(this.z));
  var h3 = u1.redSub(u2);
  var r2 = s1.redSub(s22);
  if (h3.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h3.redSqr();
  var h32 = h22.redMul(h3);
  var v = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p.z).redMul(h3);
  return this.curve.jpoint(nx, ny, nz);
}, "add2"), "add");
JPoint2.prototype.mixedAdd = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mixedAdd2(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s22 = p.y.redMul(z2).redMul(this.z);
  var h3 = u1.redSub(u2);
  var r2 = s1.redSub(s22);
  if (h3.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h3.redSqr();
  var h32 = h22.redMul(h3);
  var v = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h3);
  return this.curve.jpoint(nx, ny, nz);
}, "mixedAdd"), "mixedAdd");
JPoint2.prototype.dblp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dblp22(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i22;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i22 = 0; i22 < pow; i22++)
      r2 = r2.dbl();
    return r2;
  }
  var a3 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i22 = 0; i22 < pow; i22++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i22 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
}, "dblp2"), "dblp");
JPoint2.prototype.dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function dbl22() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
}, "dbl2"), "dbl");
JPoint2.prototype._zeroDbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _zeroDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m3 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m3.redSqr().redISub(s3).redISub(s3);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m3.redMul(s3.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a3 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d3 = this.x.redAdd(b2).redSqr().redISub(a3).redISub(c2);
    d3 = d3.redIAdd(d3);
    var e2 = a3.redAdd(a3).redIAdd(a3);
    var f = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d3).redISub(d3);
    ny = e2.redMul(d3.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
}, "_zeroDbl"), "_zeroDbl");
JPoint2.prototype._threeDbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _threeDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m3 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m3.redSqr().redISub(s3).redISub(s3);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m3.redMul(s3.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
}, "_threeDbl"), "_threeDbl");
JPoint2.prototype._dbl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _dbl2() {
  var a3 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
}, "_dbl"), "_dbl");
JPoint2.prototype.trpl = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function trpl2() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m3 = xx.redAdd(xx).redIAdd(xx);
  var mm = m3.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m3.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
}, "trpl"), "trpl");
JPoint2.prototype.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul22(k2, kbase) {
  k2 = new import_bn22.default(k2, kbase);
  return this.curve._wnafMul(this, k2);
}, "mul2"), "mul");
JPoint2.prototype.eq = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eq32(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
}, "eq3"), "eq");
JPoint2.prototype.eqXToP = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eqXToP2(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
}, "eqXToP"), "eqXToP");
JPoint2.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect22() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, "inspect2"), "inspect");
JPoint2.prototype.isInfinity = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isInfinity22() {
  return this.z.cmpn(0) === 0;
}, "isInfinity2"), "isInfinity");
var curve_12 = createCommonjsModule2(function(module2, exports) {
  "use strict";
  var curve = exports;
  curve.base = base3;
  curve.short = short_12;
  curve.mont = null;
  curve.edwards = null;
});
var curves_12 = createCommonjsModule2(function(module2, exports) {
  "use strict";
  var curves = exports;
  var assert22 = utils_1$12.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_12.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_12.edwards(options);
    else
      this.curve = new curve_12.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert22(this.g.validate(), "Invalid curve");
    assert22(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  __name(PresetCurve, "PresetCurve");
  __name2(PresetCurve, "PresetCurve");
  curves.PresetCurve = PresetCurve;
  function defineCurve(name3, options) {
    Object.defineProperty(curves, name3, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name3, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  __name(defineCurve, "defineCurve");
  __name2(defineCurve, "defineCurve");
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash9.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash9.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash9.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG2(options) {
  if (!(this instanceof HmacDRBG2))
    return new HmacDRBG2(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_12.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_12.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_12.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert2(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
__name(HmacDRBG2, "HmacDRBG");
__name2(HmacDRBG2, "HmacDRBG");
var hmacDrbg2 = HmacDRBG2;
HmacDRBG2.prototype._init = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function init3(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i22 = 0; i22 < this.V.length; i22++) {
    this.K[i22] = 0;
    this.V[i22] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
}, "init3"), "init");
HmacDRBG2.prototype._hmac = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function hmac2() {
  return new import_hash9.default.hmac(this.hash, this.K);
}, "hmac"), "hmac");
HmacDRBG2.prototype._update = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function update2(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
}, "update"), "update");
HmacDRBG2.prototype.reseed = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function reseed2(entropy, entropyEnc, add32, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add32;
    add32 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_12.toArray(entropy, entropyEnc);
  add32 = utils_12.toArray(add32, addEnc);
  minimalisticAssert2(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add32 || []));
  this._reseed = 1;
}, "reseed"), "reseed");
HmacDRBG2.prototype.generate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function generate2(len, enc, add32, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add32;
    add32 = enc;
    enc = null;
  }
  if (add32) {
    add32 = utils_12.toArray(add32, addEnc || "hex");
    this._update(add32);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add32);
  this._reseed++;
  return utils_12.encode(res, enc);
}, "generate"), "generate");
var assert$32 = utils_1$12.assert;
function KeyPair2(ec3, options) {
  this.ec = ec3;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
__name(KeyPair2, "KeyPair");
__name2(KeyPair2, "KeyPair");
var key2 = KeyPair2;
KeyPair2.fromPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromPublic2(ec3, pub, enc) {
  if (pub instanceof KeyPair2)
    return pub;
  return new KeyPair2(ec3, {
    pub,
    pubEnc: enc
  });
}, "fromPublic"), "fromPublic");
KeyPair2.fromPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromPrivate2(ec3, priv, enc) {
  if (priv instanceof KeyPair2)
    return priv;
  return new KeyPair2(ec3, {
    priv,
    privEnc: enc
  });
}, "fromPrivate"), "fromPrivate");
KeyPair2.prototype.validate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function validate42() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
}, "validate4"), "validate");
KeyPair2.prototype.getPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPublic2(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
}, "getPublic"), "getPublic");
KeyPair2.prototype.getPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPrivate2(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
}, "getPrivate"), "getPrivate");
KeyPair2.prototype._importPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _importPrivate2(key22, enc) {
  this.priv = new import_bn22.default(key22, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
}, "_importPrivate"), "_importPrivate");
KeyPair2.prototype._importPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _importPublic2(key22, enc) {
  if (key22.x || key22.y) {
    if (this.ec.curve.type === "mont") {
      assert$32(key22.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$32(key22.x && key22.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key22.x, key22.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key22, enc);
}, "_importPublic"), "_importPublic");
KeyPair2.prototype.derive = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function derive2(pub) {
  if (!pub.validate()) {
    assert$32(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
}, "derive"), "derive");
KeyPair2.prototype.sign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign22(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
}, "sign2"), "sign");
KeyPair2.prototype.verify = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function verify22(msg, signature22) {
  return this.ec.verify(msg, signature22, this);
}, "verify2"), "verify");
KeyPair2.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect32() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
}, "inspect3"), "inspect");
var assert$42 = utils_1$12.assert;
function Signature2(options, enc) {
  if (options instanceof Signature2)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$42(options.r && options.s, "Signature without r or s");
  this.r = new import_bn22.default(options.r, 16);
  this.s = new import_bn22.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
__name(Signature2, "Signature");
__name2(Signature2, "Signature");
var signature2 = Signature2;
function Position2() {
  this.place = 0;
}
__name(Position2, "Position");
__name2(Position2, "Position");
function getLength2(buf2, p) {
  var initial = buf2[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i22 = 0, off = p.place; i22 < octetLen; i22++, off++) {
    val <<= 8;
    val |= buf2[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
__name(getLength2, "getLength");
__name2(getLength2, "getLength");
function rmPadding2(buf2) {
  var i22 = 0;
  var len = buf2.length - 1;
  while (!buf2[i22] && !(buf2[i22 + 1] & 128) && i22 < len) {
    i22++;
  }
  if (i22 === 0) {
    return buf2;
  }
  return buf2.slice(i22);
}
__name(rmPadding2, "rmPadding");
__name2(rmPadding2, "rmPadding");
Signature2.prototype._importDER = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _importDER2(data, enc) {
  data = utils_1$12.toArray(data, enc);
  var p = new Position2();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength2(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength2(data, p);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength2(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s3 = data.slice(p.place, slen + p.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s3[0] === 0) {
    if (s3[1] & 128) {
      s3 = s3.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn22.default(r2);
  this.s = new import_bn22.default(s3);
  this.recoveryParam = null;
  return true;
}, "_importDER"), "_importDER");
function constructLength2(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
__name(constructLength2, "constructLength");
__name2(constructLength2, "constructLength");
Signature2.prototype.toDER = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toDER2(enc) {
  var r2 = this.r.toArray();
  var s3 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s3[0] & 128)
    s3 = [0].concat(s3);
  r2 = rmPadding2(r2);
  s3 = rmPadding2(s3);
  while (!s3[0] && !(s3[1] & 128)) {
    s3 = s3.slice(1);
  }
  var arr = [2];
  constructLength2(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength2(arr, s3.length);
  var backHalf = arr.concat(s3);
  var res = [48];
  constructLength2(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$12.encode(res, enc);
}, "toDER"), "toDER");
var rand2 = /* @__PURE__ */ __name2(function() {
  throw new Error("unsupported");
}, "rand");
var assert$52 = utils_1$12.assert;
function EC2(options) {
  if (!(this instanceof EC2))
    return new EC2(options);
  if (typeof options === "string") {
    assert$52(
      Object.prototype.hasOwnProperty.call(curves_12, options),
      "Unknown curve " + options
    );
    options = curves_12[options];
  }
  if (options instanceof curves_12.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
__name(EC2, "EC");
__name2(EC2, "EC");
var ec2 = EC2;
EC2.prototype.keyPair = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyPair2(options) {
  return new key2(this, options);
}, "keyPair"), "keyPair");
EC2.prototype.keyFromPrivate = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyFromPrivate2(priv, enc) {
  return key2.fromPrivate(this, priv, enc);
}, "keyFromPrivate"), "keyFromPrivate");
EC2.prototype.keyFromPublic = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function keyFromPublic2(pub, enc) {
  return key2.fromPublic(this, pub, enc);
}, "keyFromPublic"), "keyFromPublic");
EC2.prototype.genKeyPair = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function genKeyPair2(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg2({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand2(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn22.default(2));
  for (; ; ) {
    var priv = new import_bn22.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
}, "genKeyPair"), "genKeyPair");
EC2.prototype._truncateToN = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function _truncateToN2(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
}, "_truncateToN"), "_truncateToN");
EC2.prototype.sign = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sign3(msg, key22, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key22 = this.keyFromPrivate(key22, enc);
  msg = this._truncateToN(new import_bn22.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key22.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg2({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn22.default(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new import_bn22.default(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s3 = k2.invm(this.n).mul(r2.mul(key22.getPrivate()).iadd(msg));
    s3 = s3.umod(this.n);
    if (s3.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s3.cmp(this.nh) > 0) {
      s3 = this.n.sub(s3);
      recoveryParam ^= 1;
    }
    return new signature2({ r: r2, s: s3, recoveryParam });
  }
}, "sign3"), "sign");
EC2.prototype.verify = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function verify3(msg, signature$1, key22, enc) {
  msg = this._truncateToN(new import_bn22.default(msg, 16));
  key22 = this.keyFromPublic(key22, enc);
  signature$1 = new signature2(signature$1, "hex");
  var r2 = signature$1.r;
  var s3 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s3.cmpn(1) < 0 || s3.cmp(this.n) >= 0)
    return false;
  var sinv = s3.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key22.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r2) === 0;
  }
  p = this.g.jmulAdd(u1, key22.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r2);
}, "verify3"), "verify");
EC2.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$52((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature2(signature$1, enc);
  var n = this.n;
  var e2 = new import_bn22.default(msg);
  var r2 = signature$1.r;
  var s3 = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e2).mul(rInv).umod(n);
  var s22 = s3.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC2.prototype.getKeyRecoveryParam = function(e2, signature$1, Q2, enc) {
  signature$1 = new signature2(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i22 = 0; i22 < 4; i22++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i22);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i22;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_12 = createCommonjsModule2(function(module2, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$12;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_12;
  elliptic.curves = curves_12;
  elliptic.ec = ec2;
  elliptic.eddsa = null;
});
var EC$12 = elliptic_12.ec;
var version82 = "signing-key/5.7.0";
var logger62 = new Logger2(version82);
var _curve2 = null;
function getCurve2() {
  if (!_curve2) {
    _curve2 = new EC$12("secp256k1");
  }
  return _curve2;
}
__name(getCurve2, "getCurve");
__name2(getCurve2, "getCurve");
var SigningKey2 = /* @__PURE__ */ __name(class {
  constructor(privateKey) {
    defineReadOnly2(this, "curve", "secp256k1");
    defineReadOnly2(this, "privateKey", hexlify2(privateKey));
    if (hexDataLength2(this.privateKey) !== 32) {
      logger62.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair22 = getCurve2().keyFromPrivate(arrayify2(this.privateKey));
    defineReadOnly2(this, "publicKey", "0x" + keyPair22.getPublic(false, "hex"));
    defineReadOnly2(this, "compressedPublicKey", "0x" + keyPair22.getPublic(true, "hex"));
    defineReadOnly2(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve2().keyFromPublic(arrayify2(this.publicKey));
    const p1 = getCurve2().keyFromPublic(arrayify2(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest2) {
    const keyPair22 = getCurve2().keyFromPrivate(arrayify2(this.privateKey));
    const digestBytes = arrayify2(digest2);
    if (digestBytes.length !== 32) {
      logger62.throwArgumentError("bad digest length", "digest", digest2);
    }
    const signature22 = keyPair22.sign(digestBytes, { canonical: true });
    return splitSignature2({
      recoveryParam: signature22.recoveryParam,
      r: hexZeroPad2("0x" + signature22.r.toString(16), 32),
      s: hexZeroPad2("0x" + signature22.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair22 = getCurve2().keyFromPrivate(arrayify2(this.privateKey));
    const otherKeyPair = getCurve2().keyFromPublic(arrayify2(computePublicKey2(otherKey)));
    return hexZeroPad2("0x" + keyPair22.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}, "SigningKey");
__name2(SigningKey2, "SigningKey");
function recoverPublicKey2(digest2, signature22) {
  const sig = splitSignature2(signature22);
  const rs = { r: arrayify2(sig.r), s: arrayify2(sig.s) };
  return "0x" + getCurve2().recoverPubKey(arrayify2(digest2), rs, sig.recoveryParam).encode("hex", false);
}
__name(recoverPublicKey2, "recoverPublicKey");
__name2(recoverPublicKey2, "recoverPublicKey");
function computePublicKey2(key22, compressed) {
  const bytes = arrayify2(key22);
  if (bytes.length === 32) {
    const signingKey = new SigningKey2(bytes);
    if (compressed) {
      return "0x" + getCurve2().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify2(bytes);
    }
    return "0x" + getCurve2().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify2(bytes);
    }
    return "0x" + getCurve2().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger62.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
__name(computePublicKey2, "computePublicKey");
__name2(computePublicKey2, "computePublicKey");
var version92 = "transactions/5.7.0";
var logger72 = new Logger2(version92);
var TransactionTypes2;
(function(TransactionTypes22) {
  TransactionTypes22[TransactionTypes22["legacy"] = 0] = "legacy";
  TransactionTypes22[TransactionTypes22["eip2930"] = 1] = "eip2930";
  TransactionTypes22[TransactionTypes22["eip1559"] = 2] = "eip1559";
})(TransactionTypes2 || (TransactionTypes2 = {}));
function computeAddress2(key22) {
  const publicKey = computePublicKey2(key22);
  return getAddress2(hexDataSlice2(keccak2563(hexDataSlice2(publicKey, 1)), 12));
}
__name(computeAddress2, "computeAddress");
__name2(computeAddress2, "computeAddress");
function recoverAddress2(digest2, signature22) {
  return computeAddress2(recoverPublicKey2(arrayify2(digest2), signature22));
}
__name(recoverAddress2, "recoverAddress");
__name2(recoverAddress2, "recoverAddress");
var version102 = "wallet/5.7.0";
var logger82 = new Logger2(version102);
function verifyMessage2(message, signature22) {
  return recoverAddress2(hashMessage2(message), signature22);
}
__name(verifyMessage2, "verifyMessage");
__name2(verifyMessage2, "verifyMessage");
function getEIP191Verifier() {
  return {
    eip191: async (cacao, opts) => {
      verifyEIP191Signature(cacao, opts);
    }
  };
}
__name(getEIP191Verifier, "getEIP191Verifier");
__name2(getEIP191Verifier, "getEIP191Verifier");
var LEGACY_CHAIN_ID_REORG_DATE2 = new Date("2022-09-20").valueOf();
function verifyEIP191Signature(cacao, options) {
  assertSigned(cacao);
  verifyTimeChecks(cacao, options);
  const recoveredAddress = verifyMessage2(SiweMessage.fromCacao(cacao).toMessage(), cacao.s.s).toLowerCase();
  const recoveredAddresses = [
    recoveredAddress
  ];
  if (Date.parse(cacao.p.iat) <= LEGACY_CHAIN_ID_REORG_DATE2) {
    const legacyChainIdRecoveredAddress = verifyMessage2(asLegacyChainIdString(SiweMessage.fromCacao(cacao), "Ethereum"), cacao.s.s).toLowerCase();
    recoveredAddresses.push(legacyChainIdRecoveredAddress);
  }
  const issuerAddress = AccountId.parse(cacao.p.iss.replace("did:pkh:", "")).address.toLowerCase();
  if (!recoveredAddresses.includes(issuerAddress)) {
    throw new Error(`Signature does not belong to issuer`);
  }
}
__name(verifyEIP191Signature, "verifyEIP191Signature");
__name2(verifyEIP191Signature, "verifyEIP191Signature");
init_to_string();
init_from_string();
var import_random22 = __toESM2(require_random(), 1);
init_to_string();
function randomString() {
  return toString3((0, import_random22.randomBytes)(16), "base64");
}
__name(randomString, "randomString");
__name2(randomString, "randomString");
var B64 = "base64pad";
var B64_URL = "base64url";
function encodeBase64(bytes) {
  return toString3(bytes, B64);
}
__name(encodeBase64, "encodeBase64");
__name2(encodeBase64, "encodeBase64");
function encodeBase64Url(bytes) {
  return toString3(bytes, B64_URL);
}
__name(encodeBase64Url, "encodeBase64Url");
__name2(encodeBase64Url, "encodeBase64Url");
function decodeBase64(s3) {
  return fromString2(s3, B64);
}
__name(decodeBase64, "decodeBase64");
__name2(decodeBase64, "decodeBase64");
function base64urlToJSON(s3) {
  return JSON.parse(toString3(fromString2(s3, B64_URL)));
}
__name(base64urlToJSON, "base64urlToJSON");
__name2(base64urlToJSON, "base64urlToJSON");
function fromDagJWS(jws) {
  if (jws.signatures.length > 1)
    throw new Error("Cant convert to compact jws");
  return `${jws.signatures[0].protected}.${jws.payload}.${jws.signatures[0].signature}`;
}
__name(fromDagJWS, "fromDagJWS");
__name2(fromDagJWS, "fromDagJWS");
function didWithTime(did, atTime) {
  if (atTime) {
    const versionTime = atTime.toISOString().split(".")[0] + "Z";
    return `${did}?versionTime=${versionTime}`;
  } else {
    return did;
  }
}
__name(didWithTime, "didWithTime");
__name2(didWithTime, "didWithTime");
function extractControllers(controllerProperty) {
  if (controllerProperty) {
    if (Array.isArray(controllerProperty)) {
      return controllerProperty;
    } else {
      return [
        controllerProperty
      ];
    }
  } else {
    return [];
  }
}
__name(extractControllers, "extractControllers");
__name2(extractControllers, "extractControllers");
var verifiers = {
  ...getEIP191Verifier()
};
function isResolver(resolver) {
  return "registry" in resolver && "cache" in resolver;
}
__name(isResolver, "isResolver");
__name2(isResolver, "isResolver");
var DID = /* @__PURE__ */ __name(class {
  get capability() {
    if (!this._capability) {
      throw new Error("DID has no capability attached");
    }
    return this._capability;
  }
  get hasCapability() {
    return this._capability != null;
  }
  get parent() {
    if (!this._parentId) {
      throw new Error("DID has no parent DID");
    }
    return this._parentId;
  }
  get hasParent() {
    return this._parentId != null;
  }
  get id() {
    if (this._id == null) {
      throw new Error("DID is not authenticated");
    }
    return this._id;
  }
  get authenticated() {
    return this._id != null;
  }
  withCapability(cap) {
    return new DID({
      provider: this._client?.connection,
      resolver: this._resolver,
      capability: cap,
      parent: this._parentId
    });
  }
  setProvider(provider) {
    if (this._client == null) {
      this._client = new RPCClient(provider);
    } else if (this._client.connection !== provider) {
      throw new Error("A different provider is already set, create a new DID instance to use another provider");
    }
  }
  setResolver(resolver, resolverOptions) {
    this._resolver = isResolver(resolver) ? resolver : new Resolver2(resolver, resolverOptions);
  }
  async authenticate({ provider, paths = [], aud } = {}) {
    if (provider != null) {
      this.setProvider(provider);
    }
    if (this._client == null) {
      throw new Error("No provider available");
    }
    const nonce = randomString();
    const jws = await this._client.request("did_authenticate", {
      nonce,
      aud,
      paths
    });
    const { kid } = await this.verifyJWS(jws);
    const payload = base64urlToJSON(jws.payload);
    if (!kid.includes(payload.did))
      throw new Error("Invalid authencation response, kid mismatch");
    if (payload.nonce !== nonce)
      throw new Error("Invalid authencation response, wrong nonce");
    if (payload.aud !== aud)
      throw new Error("Invalid authencation response, wrong aud");
    if (payload.exp < Date.now() / 1e3)
      throw new Error("Invalid authencation response, expired");
    this._id = payload.did;
    return this._id;
  }
  async createJWS(payload, options = {}) {
    if (this._client == null)
      throw new Error("No provider available");
    if (this._id == null)
      throw new Error("DID is not authenticated");
    if (this._capability) {
      const exp = this._capability.p.exp;
      if (exp && Date.parse(exp) < Date.now()) {
        throw new Error("Capability is expired, cannot create a valid signature");
      }
      const cacaoBlock = await CacaoBlock.fromCacao(this._capability);
      const capCID = CID.asCID(cacaoBlock.cid);
      if (!capCID) {
        throw new Error(`Capability CID of the JWS cannot be set to the capability payload cid as they are incompatible`);
      }
      options.protected = options.protected || {};
      options.protected.cap = `ipfs://${capCID?.toString()}`;
    }
    const { jws } = await this._client.request("did_createJWS", {
      did: this._id,
      ...options,
      payload
    });
    return jws;
  }
  async createDagJWS(payload, options = {}) {
    const { cid, linkedBlock } = await encodePayload(payload);
    const payloadCid = encodeBase64Url(cid.bytes);
    Object.assign(options, {
      linkedBlock: encodeBase64(linkedBlock)
    });
    const jws = await this.createJWS(payloadCid, options);
    const compatibleCID = CID.asCID(cid);
    if (!compatibleCID) {
      throw new Error("CID of the JWS cannot be set to the encoded payload cid as they are incompatible");
    }
    jws.link = compatibleCID;
    if (this._capability) {
      const cacaoBlock = await CacaoBlock.fromCacao(this._capability);
      return {
        jws,
        linkedBlock,
        cacaoBlock: cacaoBlock.bytes
      };
    }
    return {
      jws,
      linkedBlock
    };
  }
  async verifyJWS(jws, options = {}) {
    options = Object.assign({
      verifiers
    }, options);
    if (typeof jws !== "string")
      jws = fromDagJWS(jws);
    const kid = base64urlToJSON(jws.split(".")[0]).kid;
    if (!kid)
      throw new Error('No "kid" found in jws');
    const didResolutionResult = await this.resolve(kid);
    const timecheckEnabled = !options.disableTimecheck;
    if (timecheckEnabled) {
      const nextUpdate = didResolutionResult.didDocumentMetadata?.nextUpdate;
      if (nextUpdate) {
        const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1e3 : 0;
        const revocationTime = new Date(nextUpdate).valueOf() + phaseOutMS;
        const isEarlier = options.atTime && options.atTime.getTime() < revocationTime;
        const isLater = !isEarlier;
        if (isLater) {
          throw new Error(`invalid_jws: signature authored with a revoked DID version: ${kid}`);
        }
      }
      const updated = didResolutionResult.didDocumentMetadata?.updated;
      if (updated && options.atTime && options.atTime.getTime() < new Date(updated).valueOf()) {
        throw new Error(`invalid_jws: signature authored before creation of DID version: ${kid}`);
      }
    }
    const signerDid = didResolutionResult.didDocument?.id;
    if (options.issuer && options.issuer === options.capability?.p.iss && signerDid === options.capability.p.aud) {
      if (!options.verifiers)
        throw new Error("Registered verifiers needed for CACAO");
      await Cacao.verify(options.capability, {
        disableExpirationCheck: options.disableTimecheck,
        atTime: options.atTime ? options.atTime : void 0,
        revocationPhaseOutSecs: options.revocationPhaseOutSecs,
        verifiers: options.verifiers ?? {}
      });
    } else if (options.issuer && options.issuer !== signerDid) {
      const issuerUrl = didWithTime(options.issuer, options.atTime);
      const issuerResolution = await this.resolve(issuerUrl);
      const controllerProperty = issuerResolution.didDocument?.controller;
      const controllers = extractControllers(controllerProperty);
      if (options.capability?.s && options.capability.p.aud === signerDid && controllers.includes(options.capability.p.iss)) {
        await Cacao.verify(options.capability, {
          atTime: options.atTime ? options.atTime : void 0,
          revocationPhaseOutSecs: options.revocationPhaseOutSecs,
          verifiers: options.verifiers ?? {}
        });
      } else {
        const signerIsController = signerDid ? controllers.includes(signerDid) : false;
        if (!signerIsController) {
          throw new Error(`invalid_jws: not a valid verificationMethod for issuer: ${kid}`);
        }
      }
    }
    const publicKeys = didResolutionResult.didDocument?.verificationMethod || [];
    verifyJWS(jws, publicKeys);
    let payload;
    try {
      payload = base64urlToJSON(jws.split(".")[1]);
    } catch (e2) {
    }
    return {
      kid,
      payload,
      didResolutionResult
    };
  }
  async createJWE(cleartext, recipients, options = {}) {
    const encrypters = await resolveX25519Encrypters(recipients, this._resolver);
    return createJWE(cleartext, encrypters, options.protectedHeader, options.aad);
  }
  async createDagJWE(cleartext, recipients, options = {}) {
    const preparedCleartext = await prepareCleartext(cleartext);
    return this.createJWE(preparedCleartext, recipients, options);
  }
  async decryptJWE(jwe, options = {}) {
    if (this._client == null)
      throw new Error("No provider available");
    if (this._id == null)
      throw new Error("DID is not authenticated");
    const { cleartext } = await this._client.request("did_decryptJWE", {
      did: this._id,
      ...options,
      jwe
    });
    return decodeBase64(cleartext);
  }
  async decryptDagJWE(jwe) {
    const bytes = await this.decryptJWE(jwe);
    return decodeCleartext(bytes);
  }
  async resolve(didUrl) {
    const result = await this._resolver.resolve(didUrl);
    if (result.didResolutionMetadata.error) {
      const { error, message } = result.didResolutionMetadata;
      const maybeMessage = message ? `, ${message}` : "";
      throw new Error(`Failed to resolve ${didUrl}: ${error}${maybeMessage}`);
    }
    return result;
  }
  constructor({ provider, resolver = {}, resolverOptions, capability, parent } = {}) {
    if (provider != null) {
      this._client = new RPCClient(provider);
    }
    if (capability) {
      this._capability = capability;
      this._parentId = this._capability.p.iss;
      if (parent && this._parentId !== parent)
        throw new Error("Capability issuer and parent not equal");
    } else if (parent) {
      this._parentId = parent;
    }
    this.setResolver(resolver, resolverOptions);
  }
}, "DID");
__name2(DID, "DID");
var import_varint2 = __toESM2(require_varint(), 1);
init_base58();
var secp256k1_exports = {};
__export2(secp256k1_exports, {
  keyToDidDoc: () => keyToDidDoc
});
function keyToDidDoc(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "Secp256k1VerificationKey2018",
        controller: did,
        publicKeyBase58: toString3(pubKeyBytes, "base58btc")
      }
    ],
    authentication: [keyId],
    assertionMethod: [keyId],
    capabilityDelegation: [keyId],
    capabilityInvocation: [keyId]
  };
}
__name(keyToDidDoc, "keyToDidDoc");
__name2(keyToDidDoc, "keyToDidDoc");
var ed25519_exports = {};
__export2(ed25519_exports, {
  keyToDidDoc: () => keyToDidDoc2
});
init_to_string();
var import_ed255192 = __toESM2(require_ed25519(), 1);
function encodeKey(key22) {
  const bytes = new Uint8Array(key22.length + 2);
  bytes[0] = 236;
  bytes[1] = 1;
  bytes.set(key22, 2);
  return `z${toString3(bytes, "base58btc")}`;
}
__name(encodeKey, "encodeKey");
__name2(encodeKey, "encodeKey");
function keyToDidDoc2(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const x25519PubBytes = (0, import_ed255192.convertPublicKeyToX25519)(pubKeyBytes);
  const x25519KeyId = `${did}#${encodeKey(x25519PubBytes)}`;
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "Ed25519VerificationKey2018",
        controller: did,
        publicKeyBase58: toString3(pubKeyBytes, "base58btc")
      }
    ],
    authentication: [keyId],
    assertionMethod: [keyId],
    capabilityDelegation: [keyId],
    capabilityInvocation: [keyId],
    keyAgreement: [
      {
        id: x25519KeyId,
        type: "X25519KeyAgreementKey2019",
        controller: did,
        publicKeyBase58: toString3(x25519PubBytes, "base58btc")
      }
    ]
  };
}
__name(keyToDidDoc2, "keyToDidDoc2");
__name2(keyToDidDoc2, "keyToDidDoc");
var secp256r1_exports2 = {};
__export2(secp256r1_exports2, {
  keyToDidDoc: () => keyToDidDoc3,
  pubKeyBytesToXY: () => pubKeyBytesToXY
});
var secp256r1_exports = {};
__export2(secp256r1_exports, {
  ECPointDecompress: () => ECPointDecompress
});
function abs(a3) {
  return a3 >= 0 ? a3 : -a3;
}
__name(abs, "abs");
__name2(abs, "abs");
function eGcd(a3, b2) {
  if (typeof a3 === "number")
    a3 = BigInt(a3);
  if (typeof b2 === "number")
    b2 = BigInt(b2);
  if (a3 <= 0n || b2 <= 0n)
    throw new RangeError("a and b MUST be > 0");
  let x2 = 0n;
  let y3 = 1n;
  let u2 = 1n;
  let v = 0n;
  while (a3 !== 0n) {
    const q2 = b2 / a3;
    const r2 = b2 % a3;
    const m3 = x2 - u2 * q2;
    const n = y3 - v * q2;
    b2 = a3;
    a3 = r2;
    x2 = u2;
    y3 = v;
    u2 = m3;
    v = n;
  }
  return {
    g: b2,
    x: x2,
    y: y3
  };
}
__name(eGcd, "eGcd");
__name2(eGcd, "eGcd");
function toZn(a3, n) {
  if (typeof a3 === "number")
    a3 = BigInt(a3);
  if (typeof n === "number")
    n = BigInt(n);
  if (n <= 0n) {
    throw new RangeError("n must be > 0");
  }
  const aZn = a3 % n;
  return aZn < 0n ? aZn + n : aZn;
}
__name(toZn, "toZn");
__name2(toZn, "toZn");
function modInv(a3, n) {
  const egcd = eGcd(toZn(a3, n), n);
  if (egcd.g !== 1n) {
    throw new RangeError(`${a3.toString()} does not have inverse modulo ${n.toString()}`);
  } else {
    return toZn(egcd.x, n);
  }
}
__name(modInv, "modInv");
__name2(modInv, "modInv");
function modPow(b2, e2, n) {
  if (typeof b2 === "number")
    b2 = BigInt(b2);
  if (typeof e2 === "number")
    e2 = BigInt(e2);
  if (typeof n === "number")
    n = BigInt(n);
  if (n <= 0n) {
    throw new RangeError("n must be > 0");
  } else if (n === 1n) {
    return 0n;
  }
  b2 = toZn(b2, n);
  if (e2 < 0n) {
    return modInv(modPow(b2, abs(e2), n), n);
  }
  let r2 = 1n;
  while (e2 > 0) {
    if (e2 % 2n === 1n) {
      r2 = r2 * b2 % n;
    }
    e2 = e2 / 2n;
    b2 = b2 ** 2n % n;
  }
  return r2;
}
__name(modPow, "modPow");
__name2(modPow, "modPow");
var nist_weierstrauss_common_exports = {};
__export2(nist_weierstrauss_common_exports, {
  pubKeyBytesToHex: () => pubKeyBytesToHex,
  publicKeyHexToUint8ArrayPointPair: () => publicKeyHexToUint8ArrayPointPair,
  publicKeyIntToUint8ArrayPointPair: () => publicKeyIntToUint8ArrayPointPair,
  publicKeyIntToXY: () => publicKeyIntToXY,
  publicKeyToXY: () => publicKeyToXY,
  testHexString: () => testHexString,
  testUint8Array: () => testUint8Array
});
init_base64();
function pubKeyBytesToHex(pubKeyBytes) {
  if (!testUint8Array(pubKeyBytes)) {
    throw new TypeError("input must be a Uint8Array");
  }
  const bbf = toString3(pubKeyBytes, "base16");
  return bbf;
}
__name(pubKeyBytesToHex, "pubKeyBytesToHex");
__name2(pubKeyBytesToHex, "pubKeyBytesToHex");
function publicKeyToXY(publicKeyHex) {
  if (!testHexString(publicKeyHex)) {
    throw new TypeError("input must be string with characters 0-9,A-F,a-f");
  }
  const u8aOctetPoint = publicKeyHexToUint8ArrayPointPair(publicKeyHex);
  const xm = base64url.encode(u8aOctetPoint.xOctet).slice(1);
  const ym = base64url.encode(u8aOctetPoint.yOctet).slice(1);
  return { xm, ym };
}
__name(publicKeyToXY, "publicKeyToXY");
__name2(publicKeyToXY, "publicKeyToXY");
function publicKeyHexToUint8ArrayPointPair(publicKeyHex) {
  if (!testHexString(publicKeyHex)) {
    throw new TypeError("input must be string with characters 0-9,A-F,a-f");
  }
  const xHex = publicKeyHex.slice(0, publicKeyHex.length / 2);
  const yHex = publicKeyHex.slice(publicKeyHex.length / 2, publicKeyHex.length);
  const xOctet = fromString2(xHex, "base16");
  const yOctet = fromString2(yHex, "base16");
  return { xOctet, yOctet };
}
__name(publicKeyHexToUint8ArrayPointPair, "publicKeyHexToUint8ArrayPointPair");
__name2(publicKeyHexToUint8ArrayPointPair, "publicKeyHexToUint8ArrayPointPair");
function testHexString(str) {
  const regex = /^[A-Fa-f0-9]+$/i;
  if (regex.exec(str) !== null && regex.test(str) && typeof str == "string") {
    return true;
  }
  return false;
}
__name(testHexString, "testHexString");
__name2(testHexString, "testHexString");
function testUint8Array(param) {
  if (param == null) {
    return false;
  }
  if (param.constructor === Uint8Array) {
    return true;
  } else {
    return false;
  }
}
__name(testUint8Array, "testUint8Array");
__name2(testUint8Array, "testUint8Array");
function publicKeyIntToXY(ecpoint) {
  if (ecpoint == null) {
    throw new TypeError("input cannot be null or undefined.");
  }
  if (typeof ecpoint !== "object") {
    throw new TypeError("Input must be an object with properties x and y");
  }
  if (!Object.prototype.hasOwnProperty.call(ecpoint, "x") || !Object.prototype.hasOwnProperty.call(ecpoint, "y")) {
    throw new Error("Input must have properties x and y");
  }
  if (typeof ecpoint.x !== "bigint" && typeof ecpoint.y !== "bigint") {
    throw new Error("Input coordinates must be BigInt");
  }
  const u8aOctetPoint = publicKeyIntToUint8ArrayPointPair(ecpoint);
  const xm = base64url.encode(u8aOctetPoint.xOctet).slice(1);
  const ym = base64url.encode(u8aOctetPoint.yOctet).slice(1);
  return { xm, ym };
}
__name(publicKeyIntToXY, "publicKeyIntToXY");
__name2(publicKeyIntToXY, "publicKeyIntToXY");
function publicKeyIntToUint8ArrayPointPair(ecpoint) {
  if (ecpoint == null) {
    throw new TypeError("input cannot be null or undefined.");
  }
  if (typeof ecpoint !== "object") {
    throw new TypeError("Input must be an object with properties x and y");
  }
  if (!Object.prototype.hasOwnProperty.call(ecpoint, "x") || !Object.prototype.hasOwnProperty.call(ecpoint, "y")) {
    throw new Error("Input must have properties x and y");
  }
  if (typeof ecpoint.x !== "bigint" && typeof ecpoint.y !== "bigint") {
    throw new Error("Input coordinates must be BigInt");
  }
  const xHex = ecpoint.x.toString();
  const yHex = ecpoint.y.toString();
  const xOctet = fromString2(xHex, "base10");
  const yOctet = fromString2(yHex, "base10");
  return { xOctet, yOctet };
}
__name(publicKeyIntToUint8ArrayPointPair, "publicKeyIntToUint8ArrayPointPair");
__name2(publicKeyIntToUint8ArrayPointPair, "publicKeyIntToUint8ArrayPointPair");
function ECPointDecompress(comp) {
  if (!testUint8Array(comp)) {
    throw new TypeError("input must be a Uint8Array");
  }
  const two = BigInt(2);
  const prime = two ** 256n - two ** 224n + two ** 192n + two ** 96n - 1n;
  const b2 = 41058363725152142129326129780047268409114441015993725554835256314039467401291n;
  const pIdent = (prime + 1n) / 4n;
  const signY = BigInt(comp[0] - 2);
  const x2 = comp.subarray(1);
  const xBig = BigInt(toString3(x2, "base10"));
  const a3 = xBig ** 3n - xBig * 3n + b2;
  let yBig = modPow(a3, pIdent, prime);
  if (yBig % 2n !== signY) {
    yBig = prime - yBig;
  }
  return {
    x: xBig,
    y: yBig
  };
}
__name(ECPointDecompress, "ECPointDecompress");
__name2(ECPointDecompress, "ECPointDecompress");
var secp384r1_exports = {};
__export2(secp384r1_exports, {
  ECPointDecompress: () => ECPointDecompress2
});
function ECPointDecompress2(comp) {
  if (!testUint8Array(comp)) {
    throw new TypeError("input must be a Uint8Array");
  }
  const two = BigInt(2);
  const prime = two ** 384n - two ** 128n - two ** 96n + two ** 32n - 1n;
  const b2 = 27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575n;
  const pIdent = (prime + 1n) / 4n;
  const signY = BigInt(comp[0] - 2);
  const x2 = comp.subarray(1);
  const xBig = BigInt(toString3(x2, "base10"));
  const a3 = xBig ** 3n - xBig * 3n + b2;
  let yBig = modPow(a3, pIdent, prime);
  if (yBig % 2n !== signY) {
    yBig = prime - yBig;
  }
  return {
    x: xBig,
    y: yBig
  };
}
__name(ECPointDecompress2, "ECPointDecompress2");
__name2(ECPointDecompress2, "ECPointDecompress");
var secp521r1_exports = {};
__export2(secp521r1_exports, {
  ECPointDecompress: () => ECPointDecompress3
});
function ECPointDecompress3(comp) {
  if (!testUint8Array(comp)) {
    throw new TypeError("input must be a Uint8Array");
  }
  const two = BigInt(2);
  const prime = two ** 521n - 1n;
  const b2 = 1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984n;
  const pIdent = (prime + 1n) / 4n;
  const signY = BigInt(comp[0] - 2);
  const x2 = comp.subarray(1);
  const xBig = BigInt(toString3(x2, "base10"));
  const a3 = xBig ** 3n - xBig * 3n + b2;
  let yBig = modPow(a3, pIdent, prime);
  if (yBig % 2n !== signY) {
    yBig = prime - yBig;
  }
  return {
    x: xBig,
    y: yBig
  };
}
__name(ECPointDecompress3, "ECPointDecompress3");
__name2(ECPointDecompress3, "ECPointDecompress");
function keyToDidDoc3(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const key22 = pubKeyBytesToXY(pubKeyBytes);
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "JsonWebKey2020",
        controller: did,
        publicKeyJwk: {
          kty: "EC",
          crv: "P-256",
          x: key22.xm,
          y: key22.ym
        }
      }
    ],
    authentication: [keyId],
    assertionMethod: [keyId],
    capabilityDelegation: [keyId],
    capabilityInvocation: [keyId]
  };
}
__name(keyToDidDoc3, "keyToDidDoc3");
__name2(keyToDidDoc3, "keyToDidDoc");
function pubKeyBytesToXY(pubKeyBytes) {
  if (!nist_weierstrauss_common_exports.testUint8Array(pubKeyBytes)) {
    throw new TypeError("input must be a Uint8Array");
  }
  const publicKeyHex = nist_weierstrauss_common_exports.pubKeyBytesToHex(pubKeyBytes);
  const bytesCount = publicKeyHex.length / 2;
  if (bytesCount == 64) {
    return nist_weierstrauss_common_exports.publicKeyToXY(publicKeyHex);
  }
  if (bytesCount == 65) {
    if (publicKeyHex.slice(0, 2) == "04") {
      const publicKey = publicKeyHex.slice(2);
      return nist_weierstrauss_common_exports.publicKeyToXY(publicKey);
    }
  }
  if (bytesCount == 33) {
    if (publicKeyHex.slice(0, 2) == "03" || publicKeyHex.slice(0, 2) == "02") {
      const publicKey = fromString2(publicKeyHex, "base16");
      const point32 = secp256r1_exports.ECPointDecompress(publicKey);
      return nist_weierstrauss_common_exports.publicKeyIntToXY(point32);
    }
  }
  throw new Error("Unexpected pubKeyBytes");
}
__name(pubKeyBytesToXY, "pubKeyBytesToXY");
__name2(pubKeyBytesToXY, "pubKeyBytesToXY");
var secp384r1_exports2 = {};
__export2(secp384r1_exports2, {
  keyToDidDoc: () => keyToDidDoc4,
  pubKeyBytesToXY: () => pubKeyBytesToXY2
});
function keyToDidDoc4(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const key22 = pubKeyBytesToXY2(pubKeyBytes);
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "JsonWebKey2020",
        controller: did,
        publicKeyJwk: {
          kty: "EC",
          crv: "P-384",
          x: key22.xm,
          y: key22.ym
        }
      }
    ],
    authentication: [keyId],
    assertionMethod: [keyId],
    capabilityDelegation: [keyId],
    capabilityInvocation: [keyId]
  };
}
__name(keyToDidDoc4, "keyToDidDoc4");
__name2(keyToDidDoc4, "keyToDidDoc");
function pubKeyBytesToXY2(pubKeyBytes) {
  if (!nist_weierstrauss_common_exports.testUint8Array(pubKeyBytes)) {
    throw new TypeError("input must be a Uint8Array");
  }
  const publicKeyHex = nist_weierstrauss_common_exports.pubKeyBytesToHex(pubKeyBytes);
  const bytesCount = publicKeyHex.length / 2;
  if (bytesCount == 96) {
    return nist_weierstrauss_common_exports.publicKeyToXY(publicKeyHex);
  }
  if (bytesCount == 97) {
    if (publicKeyHex.slice(0, 2) == "04") {
      const publicKey = publicKeyHex.slice(2);
      return nist_weierstrauss_common_exports.publicKeyToXY(publicKey);
    }
  }
  if (bytesCount == 49) {
    if (publicKeyHex.slice(0, 2) == "03" || publicKeyHex.slice(0, 2) == "02") {
      const publicKey = fromString2(publicKeyHex, "base16");
      const point32 = secp384r1_exports.ECPointDecompress(publicKey);
      return nist_weierstrauss_common_exports.publicKeyIntToXY(point32);
    }
  }
  throw new Error("Unexpected pubKeyBytes");
}
__name(pubKeyBytesToXY2, "pubKeyBytesToXY2");
__name2(pubKeyBytesToXY2, "pubKeyBytesToXY");
var secp521r1_exports2 = {};
__export2(secp521r1_exports2, {
  keyToDidDoc: () => keyToDidDoc5,
  pubKeyBytesToXY: () => pubKeyBytesToXY3
});
function keyToDidDoc5(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const key22 = pubKeyBytesToXY3(pubKeyBytes);
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "JsonWebKey2020",
        controller: did,
        publicKeyJwk: {
          kty: "EC",
          crv: "P-521",
          x: key22.xm,
          y: key22.ym
        }
      }
    ],
    authentication: [keyId],
    assertionMethod: [keyId],
    capabilityDelegation: [keyId],
    capabilityInvocation: [keyId]
  };
}
__name(keyToDidDoc5, "keyToDidDoc5");
__name2(keyToDidDoc5, "keyToDidDoc");
function pubKeyBytesToXY3(pubKeyBytes) {
  if (!nist_weierstrauss_common_exports.testUint8Array(pubKeyBytes)) {
    throw new TypeError("input must be a Uint8Array");
  }
  const publicKeyHex = nist_weierstrauss_common_exports.pubKeyBytesToHex(pubKeyBytes);
  if (132 <= publicKeyHex.length && publicKeyHex.length <= 134) {
    if (publicKeyHex.slice(0, 2) == "03" || publicKeyHex.slice(0, 2) == "02") {
      const publicKey = fromString2(publicKeyHex, "base16");
      const point32 = secp521r1_exports.ECPointDecompress(publicKey);
      return nist_weierstrauss_common_exports.publicKeyIntToXY(point32);
    }
  }
  throw new Error("Unexpected pubKeyBytes");
}
__name(pubKeyBytesToXY3, "pubKeyBytesToXY3");
__name2(pubKeyBytesToXY3, "pubKeyBytesToXY");
var DID_LD_JSON = "application/did+ld+json";
var DID_JSON = "application/did+json";
var prefixToDriverMap = {
  231: secp256k1_exports,
  237: ed25519_exports,
  4608: secp256r1_exports2,
  4609: secp384r1_exports2,
  4610: secp521r1_exports2
};
function getResolver() {
  return {
    key: async (did, parsed, r2, options) => {
      const contentType = options.accept || DID_JSON;
      const response = {
        didResolutionMetadata: { contentType },
        didDocument: null,
        didDocumentMetadata: {}
      };
      try {
        const multicodecPubKey = base58btc.decode(parsed.id);
        const keyType = import_varint2.default.decode(multicodecPubKey);
        const pubKeyBytes = multicodecPubKey.slice(import_varint2.default.decode.bytes);
        const doc = await prefixToDriverMap[keyType].keyToDidDoc(pubKeyBytes, parsed.id);
        if (contentType === DID_LD_JSON) {
          doc["@context"] = "https://w3id.org/did/v1";
          response.didDocument = doc;
        } else if (contentType === DID_JSON) {
          response.didDocument = doc;
        } else {
          delete response.didResolutionMetadata.contentType;
          response.didResolutionMetadata.error = "representationNotSupported";
        }
      } catch (e2) {
        response.didResolutionMetadata.error = "invalidDid";
        response.didResolutionMetadata.message = e2.toString();
      }
      return response;
    }
  };
}
__name(getResolver, "getResolver");
__name2(getResolver, "getResolver");
var lib_default = { getResolver };
var import_ed255193 = __toESM2(require_ed25519(), 1);
var import_fast_json_stable_stringify = __toESM2(require_fast_json_stable_stringify(), 1);
var B642 = "base64pad";
function toStableObject(obj) {
  return JSON.parse((0, import_fast_json_stable_stringify.default)(obj));
}
__name(toStableObject, "toStableObject");
__name2(toStableObject, "toStableObject");
function encodeDID(publicKey) {
  const bytes = new Uint8Array(publicKey.length + 2);
  bytes[0] = 237;
  bytes[1] = 1;
  bytes.set(publicKey, 2);
  return `did:key:z${toString3(bytes, "base58btc")}`;
}
__name(encodeDID, "encodeDID");
__name2(encodeDID, "encodeDID");
function toGeneralJWS(jws) {
  const [protectedHeader, payload, signature22] = jws.split(".");
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature: signature22 }]
  };
}
__name(toGeneralJWS, "toGeneralJWS");
__name2(toGeneralJWS, "toGeneralJWS");
var sign4 = /* @__PURE__ */ __name2(async (payload, did, secretKey, protectedHeader = {}) => {
  const kid = `${did}#${did.split(":")[2]}`;
  const signer = EdDSASigner(secretKey);
  const header = toStableObject(Object.assign(protectedHeader, { kid, alg: "EdDSA" }));
  return createJWS(typeof payload === "string" ? payload : toStableObject(payload), signer, header);
}, "sign");
var didMethods = {
  did_authenticate: async ({ did, secretKey }, params) => {
    const response = await sign4({
      did,
      aud: params.aud,
      nonce: params.nonce,
      paths: params.paths,
      exp: Math.floor(Date.now() / 1e3) + 600
    }, did, secretKey);
    return toGeneralJWS(response);
  },
  did_createJWS: async ({ did, secretKey }, params) => {
    const requestDid = params.did.split("#")[0];
    if (requestDid !== did)
      throw new RPCError(4100, `Unknown DID: ${did}`);
    const jws = await sign4(params.payload, did, secretKey, params.protected);
    return { jws: toGeneralJWS(jws) };
  },
  did_decryptJWE: async ({ secretKey }, params) => {
    const decrypter = x25519Decrypter((0, import_ed255193.convertSecretKeyToX25519)(secretKey));
    try {
      const bytes = await decryptJWE(params.jwe, decrypter);
      return { cleartext: toString3(bytes, B642) };
    } catch (e2) {
      throw new RPCError(-32e3, e2.message);
    }
  }
};
var Ed25519Provider = /* @__PURE__ */ __name(class {
  constructor(seed) {
    const { secretKey, publicKey } = (0, import_ed255193.generateKeyPairFromSeed)(seed);
    const did = encodeDID(publicKey);
    const handler = createHandler(didMethods);
    this._handle = async (msg) => await handler({ did, secretKey }, msg);
  }
  get isDidProvider() {
    return true;
  }
  async send(msg) {
    return await this._handle(msg);
  }
}, "Ed25519Provider");
__name2(Ed25519Provider, "Ed25519Provider");
var core_exports = {};
__export2(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate52,
  validator: () => validator
});
var __extends = function() {
  var extendStatics = /* @__PURE__ */ __name2(function(d3, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
      d4.__proto__ = b3;
    } || function(d4, b3) {
      for (var p in b3)
        if (b3.hasOwnProperty(p))
          d4[p] = b3[p];
    };
    return extendStatics(d3, b2);
  }, "extendStatics");
  return function(d3, b2) {
    extendStatics(d3, b2);
    function __() {
      this.constructor = d3;
    }
    __name(__, "__");
    __name2(__, "__");
    d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key22) {
  return _hasOwnProperty.call(obj, key22);
}
__name(hasOwnProperty, "hasOwnProperty");
__name2(hasOwnProperty, "hasOwnProperty");
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k2 = 0; k2 < keys_1.length; k2++) {
      keys_1[k2] = "" + k2;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys = [];
  for (var i22 in obj) {
    if (hasOwnProperty(obj, i22)) {
      keys.push(i22);
    }
  }
  return keys;
}
__name(_objectKeys, "_objectKeys");
__name2(_objectKeys, "_objectKeys");
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
__name(_deepClone, "_deepClone");
__name2(_deepClone, "_deepClone");
function isInteger22(str) {
  var i22 = 0;
  var len = str.length;
  var charCode;
  while (i22 < len) {
    charCode = str.charCodeAt(i22);
    if (charCode >= 48 && charCode <= 57) {
      i22++;
      continue;
    }
    return false;
  }
  return true;
}
__name(isInteger22, "isInteger2");
__name2(isInteger22, "isInteger");
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
__name(escapePathComponent, "escapePathComponent");
__name2(escapePathComponent, "escapePathComponent");
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
__name(unescapePathComponent, "unescapePathComponent");
__name2(unescapePathComponent, "unescapePathComponent");
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i22 = 0; i22 < objKeysLength; i22++) {
        if (hasUndefined(obj[objKeys[i22]])) {
          return true;
        }
      }
    }
  }
  return false;
}
__name(hasUndefined, "hasUndefined");
__name2(hasUndefined, "hasUndefined");
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key22 in args) {
    var value = typeof args[key22] === "object" ? JSON.stringify(args[key22], null, 2) : args[key22];
    if (typeof value !== "undefined") {
      messageParts.push(key22 + ": " + value);
    }
  }
  return messageParts.join("\n");
}
__name(patchErrorMessageFormatter, "patchErrorMessageFormatter");
__name2(patchErrorMessageFormatter, "patchErrorMessageFormatter");
var PatchError = function(_super) {
  __extends(PatchError2, _super);
  function PatchError2(message, name3, index, operation, tree2) {
    var _newTarget = this.constructor;
    var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name3, index, operation, tree: tree2 })) || this;
    _this.name = name3;
    _this.index = index;
    _this.operation = operation;
    _this.tree = tree2;
    Object.setPrototypeOf(_this, _newTarget.prototype);
    _this.message = patchErrorMessageFormatter(message, { name: name3, index, operation, tree: tree2 });
    return _this;
  }
  __name(PatchError2, "PatchError2");
  __name2(PatchError2, "PatchError");
  return PatchError2;
}(Error);
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key22, document2) {
    obj[key22] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key22, document2) {
    var removed = obj[key22];
    delete obj[key22];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key22, document2) {
    var removed = obj[key22];
    obj[key22] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key22, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
    applyOperation(document2, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key22, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document2 };
  },
  test: function(obj, key22, document2) {
    return { newDocument: document2, test: _areEquals(obj[key22], this.value) };
  },
  _get: function(obj, key22, document2) {
    this.value = obj[key22];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i22, document2) {
    if (isInteger22(i22)) {
      arr.splice(i22, 0, this.value);
    } else {
      arr[i22] = this.value;
    }
    return { newDocument: document2, index: i22 };
  },
  remove: function(arr, i22, document2) {
    var removedList = arr.splice(i22, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i22, document2) {
    var removed = arr[i22];
    arr[i22] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
__name(getValueByPointer, "getValueByPointer");
__name2(getValueByPointer, "getValueByPointer");
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index === void 0) {
    index = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path = operation.path || "";
    var keys = path.split("/");
    var obj = document2;
    var t2 = 1;
    var len = keys.length;
    var existingPathFragment = void 0;
    var key22 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key22 = keys[t2];
      if (key22 && key22.indexOf("~") != -1) {
        key22 = unescapePathComponent(key22);
      }
      if (banPrototypeModifications && (key22 == "__proto__" || key22 == "prototype" && t2 > 0 && keys[t2 - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key22] === void 0) {
            existingPathFragment = keys.slice(0, t2).join("/");
          } else if (t2 == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t2++;
      if (Array.isArray(obj)) {
        if (key22 === "-") {
          key22 = obj.length;
        } else {
          if (validateOperation && !isInteger22(key22)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
          } else if (isInteger22(key22)) {
            key22 = ~~key22;
          }
        }
        if (t2 >= len) {
          if (validateOperation && operation.op === "add" && key22 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key22, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t2 >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key22, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key22];
      if (validateOperation && t2 < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
__name(applyOperation, "applyOperation");
__name2(applyOperation, "applyOperation");
function applyPatch(document2, patch, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch.length);
  for (var i22 = 0, length_1 = patch.length; i22 < length_1; i22++) {
    results[i22] = applyOperation(document2, patch[i22], validateOperation, true, banPrototypeModifications, i22);
    document2 = results[i22].newDocument;
  }
  results.newDocument = document2;
  return results;
}
__name(applyPatch, "applyPatch");
__name2(applyPatch, "applyPatch");
function applyReducer(document2, operation, index) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
  }
  return operationResult.newDocument;
}
__name(applyReducer, "applyReducer");
__name2(applyReducer, "applyReducer");
function validator(operation, index, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error = validate52([existingValue], document2);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
__name(validator, "validator");
__name2(validator, "validator");
function validate52(sequence, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i22 = 0; i22 < sequence.length; i22++) {
        externalValidator(sequence[i22], i22, document2, void 0);
      }
    }
  } catch (e2) {
    if (e2 instanceof JsonPatchError) {
      return e2;
    } else {
      throw e2;
    }
  }
}
__name(validate52, "validate5");
__name2(validate52, "validate");
function _areEquals(a3, b2) {
  if (a3 === b2)
    return true;
  if (a3 && b2 && typeof a3 == "object" && typeof b2 == "object") {
    var arrA = Array.isArray(a3), arrB = Array.isArray(b2), i22, length2, key22;
    if (arrA && arrB) {
      length2 = a3.length;
      if (length2 != b2.length)
        return false;
      for (i22 = length2; i22-- !== 0; )
        if (!_areEquals(a3[i22], b2[i22]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a3);
    length2 = keys.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i22 = length2; i22-- !== 0; )
      if (!b2.hasOwnProperty(keys[i22]))
        return false;
    for (i22 = length2; i22-- !== 0; ) {
      key22 = keys[i22];
      if (!_areEquals(a3[key22], b2[key22]))
        return false;
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
__name(_areEquals, "_areEquals");
__name2(_areEquals, "_areEquals");
var duplex_exports = {};
__export2(duplex_exports, {
  compare: () => compare3,
  generate: () => generate22,
  observe: () => observe,
  unobserve: () => unobserve
});
var beforeDict = /* @__PURE__ */ new WeakMap();
var Mirror = function() {
  function Mirror2(obj) {
    this.observers = /* @__PURE__ */ new Map();
    this.obj = obj;
  }
  __name(Mirror2, "Mirror2");
  __name2(Mirror2, "Mirror");
  return Mirror2;
}();
var ObserverInfo = function() {
  function ObserverInfo2(callback, observer) {
    this.callback = callback;
    this.observer = observer;
  }
  __name(ObserverInfo2, "ObserverInfo2");
  __name2(ObserverInfo2, "ObserverInfo");
  return ObserverInfo2;
}();
function getMirror(obj) {
  return beforeDict.get(obj);
}
__name(getMirror, "getMirror");
__name2(getMirror, "getMirror");
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
__name(getObserverFromMirror, "getObserverFromMirror");
__name2(getObserverFromMirror, "getObserverFromMirror");
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
__name(removeObserverFromMirror, "removeObserverFromMirror");
__name2(removeObserverFromMirror, "removeObserverFromMirror");
function unobserve(root, observer) {
  observer.unobserve();
}
__name(unobserve, "unobserve");
__name2(unobserve, "unobserve");
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = /* @__PURE__ */ __name2(function() {
      generate22(observer);
    }, "dirtyCheck");
    var fastCheck = /* @__PURE__ */ __name2(function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    }, "fastCheck");
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate22(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
__name(observe, "observe");
__name2(observe, "observe");
function generate22(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp = observer.patches;
  if (temp.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp);
    }
  }
  return temp;
}
__name(generate22, "generate2");
__name2(generate22, "generate");
function _generate(mirror, obj, patches, path, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t2 = oldKeys.length - 1; t2 >= 0; t2--) {
    var key22 = oldKeys[t2];
    var oldVal = mirror[key22];
    if (hasOwnProperty(obj, key22) && !(obj[key22] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key22];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key22), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({ op: "test", path: path + "/" + escapePathComponent(key22), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path + "/" + escapePathComponent(key22), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path + "/" + escapePathComponent(key22), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path + "/" + escapePathComponent(key22) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path, value: mirror });
      }
      patches.push({ op: "replace", path, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t2 = 0; t2 < newKeys.length; t2++) {
    var key22 = newKeys[t2];
    if (!hasOwnProperty(mirror, key22) && obj[key22] !== void 0) {
      patches.push({ op: "add", path: path + "/" + escapePathComponent(key22), value: _deepClone(obj[key22]) });
    }
  }
}
__name(_generate, "_generate");
__name2(_generate, "_generate");
function compare3(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}
__name(compare3, "compare3");
__name2(compare3, "compare");
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});
var import_lodash3 = __toESM2(require_lodash2(), 1);
var import_random32 = __toESM2(require_random(), 1);
var SyncOptions;
(function(SyncOptions3) {
  SyncOptions3[SyncOptions3["PREFER_CACHE"] = 0] = "PREFER_CACHE";
  SyncOptions3[SyncOptions3["SYNC_ALWAYS"] = 1] = "SYNC_ALWAYS";
  SyncOptions3[SyncOptions3["NEVER_SYNC"] = 2] = "NEVER_SYNC";
})(SyncOptions || (SyncOptions = {}));
var import_lodash = __toESM2(require_lodash2(), 1);
init_cid();
init_base36();
var registry = {
  tile: 0,
  "caip10-link": 1,
  model: 2,
  MID: 3,
  UNLOADABLE: 4
};
function codeByName(name3) {
  const index = registry[name3];
  if (typeof index !== "undefined") {
    return index;
  } else {
    throw new Error(`No stream type registered for name ${name3}`);
  }
}
__name(codeByName, "codeByName");
__name2(codeByName, "codeByName");
function nameByCode(index) {
  const pair = Object.entries(registry).find(([, v]) => v === index);
  if (pair) {
    return pair[0];
  } else {
    throw new Error(`No stream type registered for index ${index}`);
  }
}
__name(nameByCode, "nameByCode");
__name2(nameByCode, "nameByCode");
var StreamType = /* @__PURE__ */ __name(class {
}, "StreamType");
__name2(StreamType, "StreamType");
StreamType.nameByCode = nameByCode;
StreamType.codeByName = codeByName;
var import_varint5 = __toESM2(require_varint(), 1);
function Memoize(args) {
  let hashFunction;
  let duration;
  let tags;
  if (typeof args === "object") {
    hashFunction = args.hashFunction;
    duration = args.expiring;
    tags = args.tags;
  } else {
    hashFunction = args;
  }
  return (target, propertyKey, descriptor) => {
    if (descriptor.value != null) {
      descriptor.value = getNewFunction(descriptor.value, hashFunction, duration, tags);
    } else if (descriptor.get != null) {
      descriptor.get = getNewFunction(descriptor.get, hashFunction, duration, tags);
    } else {
      throw "Only put a Memoize() decorator on a method or get accessor.";
    }
  };
}
__name(Memoize, "Memoize");
__name2(Memoize, "Memoize");
var clearCacheTagsMap = /* @__PURE__ */ new Map();
function getNewFunction(originalMethod, hashFunction, duration = 0, tags) {
  const propMapName = Symbol(`__memoized_map__`);
  return function(...args) {
    let returnedValue;
    if (!this.hasOwnProperty(propMapName)) {
      Object.defineProperty(this, propMapName, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: /* @__PURE__ */ new Map()
      });
    }
    let myMap = this[propMapName];
    if (Array.isArray(tags)) {
      for (const tag of tags) {
        if (clearCacheTagsMap.has(tag)) {
          clearCacheTagsMap.get(tag).push(myMap);
        } else {
          clearCacheTagsMap.set(tag, [myMap]);
        }
      }
    }
    if (hashFunction || args.length > 0 || duration > 0) {
      let hashKey;
      if (hashFunction === true) {
        hashKey = args.map((a3) => a3.toString()).join("!");
      } else if (hashFunction) {
        hashKey = hashFunction.apply(this, args);
      } else {
        hashKey = args[0];
      }
      const timestampKey = `${hashKey}__timestamp`;
      let isExpired = false;
      if (duration > 0) {
        if (!myMap.has(timestampKey)) {
          isExpired = true;
        } else {
          let timestamp = myMap.get(timestampKey);
          isExpired = Date.now() - timestamp > duration;
        }
      }
      if (myMap.has(hashKey) && !isExpired) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(this, args);
        myMap.set(hashKey, returnedValue);
        if (duration > 0) {
          myMap.set(timestampKey, Date.now());
        }
      }
    } else {
      const hashKey = this;
      if (myMap.has(hashKey)) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(this, args);
        myMap.set(hashKey, returnedValue);
      }
    }
    return returnedValue;
  };
}
__name(getNewFunction, "getNewFunction");
__name2(getNewFunction, "getNewFunction");
var STREAMID_CODEC = 206;
init_cid();
init_base36();
init_sha2_browser();
var import_varint4 = __toESM2(require_varint(), 1);
function tryCatch(fn) {
  try {
    return fn();
  } catch (e2) {
    return e2;
  }
}
__name(tryCatch, "tryCatch");
__name2(tryCatch, "tryCatch");
init_cid();
var import_varint3 = __toESM2(require_varint(), 1);
init_digest();
function readVarint(bytes) {
  const value = import_varint3.default.decode(bytes);
  const readLength = import_varint3.default.decode.bytes;
  const remainder = bytes.subarray(readLength);
  return [value, remainder, readLength];
}
__name(readVarint, "readVarint");
__name2(readVarint, "readVarint");
function isCidVersion(input) {
  return input === 0 || input === 1;
}
__name(isCidVersion, "isCidVersion");
__name2(isCidVersion, "isCidVersion");
function readCid(bytes) {
  const [cidVersion, cidVersionRemainder] = readVarint(bytes);
  if (!isCidVersion(cidVersion)) {
    throw new Error(`Unknown CID version ${cidVersion}`);
  }
  const [codec, codecRemainder] = readVarint(cidVersionRemainder);
  const [, mhCodecRemainder, mhCodecLength] = readVarint(codecRemainder);
  const [mhLength, , mhLengthLength] = readVarint(mhCodecRemainder);
  const multihashBytes = codecRemainder.subarray(0, mhCodecLength + mhLengthLength + mhLength);
  const multihashBytesRemainder = codecRemainder.subarray(mhCodecLength + mhLengthLength + mhLength);
  return [CID.create(cidVersion, codec, decode5(multihashBytes)), multihashBytesRemainder];
}
__name(readCid, "readCid");
__name2(readCid, "readCid");
init_cid();
init_base36();
function fromBytes(input, title = "StreamRef") {
  const [streamCodec, streamCodecRemainder] = readVarint(input);
  if (streamCodec !== STREAMID_CODEC)
    throw new Error(`Invalid ${title}, does not include streamid codec`);
  const [type, streamtypeRemainder] = readVarint(streamCodecRemainder);
  const cidResult = readCid(streamtypeRemainder);
  const [genesis, genesisRemainder] = cidResult;
  if (genesisRemainder.length === 0) {
    return {
      kind: "stream-id",
      type,
      genesis
    };
  } else if (genesisRemainder.length === 1 && genesisRemainder[0] === 0) {
    return {
      kind: "commit-id",
      type,
      genesis,
      commit: null
    };
  } else {
    const [commit] = readCid(genesisRemainder);
    return {
      kind: "commit-id",
      type,
      genesis,
      commit
    };
  }
}
__name(fromBytes, "fromBytes");
__name2(fromBytes, "fromBytes");
var URL_PATTERN = /(ceramic:\/\/|\/ceramic\/)?([a-zA-Z0-9]+)(\?commit=([a-zA-Z0-9]+))?/;
function fromString4(input, title = "StreamRef") {
  const protocolMatch = URL_PATTERN.exec(input) || [];
  const base4 = protocolMatch[2];
  if (!base4)
    throw new Error(`Malformed ${title} string: ${input}`);
  const bytes = base36.decode(base4);
  const streamRef = fromBytes(bytes);
  const commit = protocolMatch[4];
  if (commit) {
    return {
      kind: "commit-id",
      type: streamRef.type,
      genesis: streamRef.genesis,
      commit: parseCommit(streamRef.genesis, commit)
    };
  }
  return streamRef;
}
__name(fromString4, "fromString4");
__name2(fromString4, "fromString");
function parseCID(input) {
  try {
    return typeof input === "string" ? CID.parse(input) : CID.asCID(input);
  } catch {
    return null;
  }
}
__name(parseCID, "parseCID");
__name2(parseCID, "parseCID");
function parseCommit(genesis, commit = null) {
  if (!commit)
    return null;
  if (commit === "0")
    return null;
  const commitCID = parseCID(commit);
  if (commitCID) {
    if (genesis.equals(commitCID)) {
      return null;
    } else {
      return commitCID;
    }
  } else {
    throw new Error("Cannot specify commit as a number except to request commit 0 (the genesis commit)");
  }
}
__name(parseCommit, "parseCommit");
__name2(parseCommit, "parseCommit");
var __decorate = /* @__PURE__ */ __name(function(decorators, target, key22, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key22) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key22, desc);
  else
    for (var i22 = decorators.length - 1; i22 >= 0; i22--)
      if (d3 = decorators[i22])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key22, r2) : d3(target, key22)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key22, r2), r2;
}, "__decorate");
var __metadata = /* @__PURE__ */ __name(function(k2, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k2, v);
}, "__metadata");
var InvalidStreamIDBytesError = /* @__PURE__ */ __name(class extends Error {
  constructor(bytes) {
    super(`Invalid StreamID bytes ${base36.encode(bytes)}: contains commit`);
  }
}, "InvalidStreamIDBytesError");
__name2(InvalidStreamIDBytesError, "InvalidStreamIDBytesError");
var InvalidStreamIDStringError = /* @__PURE__ */ __name(class extends Error {
  constructor(input) {
    super(`Invalid StreamID string ${input}: contains commit`);
  }
}, "InvalidStreamIDStringError");
__name2(InvalidStreamIDStringError, "InvalidStreamIDStringError");
function fromBytes2(bytes) {
  const parsed = fromBytes(bytes, "StreamID");
  if (parsed.kind === "stream-id") {
    return new StreamID(parsed.type, parsed.genesis);
  }
  throw new InvalidStreamIDBytesError(bytes);
}
__name(fromBytes2, "fromBytes2");
__name2(fromBytes2, "fromBytes");
function fromBytesNoThrow(bytes) {
  return tryCatch(() => fromBytes2(bytes));
}
__name(fromBytesNoThrow, "fromBytesNoThrow");
__name2(fromBytesNoThrow, "fromBytesNoThrow");
function fromString5(input) {
  const parsed = fromString4(input, "StreamID");
  if (parsed.kind === "stream-id") {
    return new StreamID(parsed.type, parsed.genesis);
  }
  throw new InvalidStreamIDStringError(input);
}
__name(fromString5, "fromString5");
__name2(fromString5, "fromString");
function fromStringNoThrow(input) {
  return tryCatch(() => fromString5(input));
}
__name(fromStringNoThrow, "fromStringNoThrow");
__name2(fromStringNoThrow, "fromStringNoThrow");
var TAG = Symbol.for("@ceramicnetwork/streamid/StreamID");
var StreamID = /* @__PURE__ */ __name(class {
  constructor(type, cid) {
    this._tag = TAG;
    if (!(type || type === 0))
      throw new Error("StreamID constructor: type required");
    if (!cid)
      throw new Error("StreamID constructor: cid required");
    this._type = typeof type === "string" ? StreamType.codeByName(type) : type;
    this._cid = typeof cid === "string" ? CID.parse(cid) : cid;
  }
  static isInstance(instance) {
    return typeof instance === "object" && "_tag" in instance && instance._tag === TAG;
  }
  static async fromGenesis(type, genesis) {
    const block = await encode5({ value: genesis, codec: esm_exports, hasher: sha2563 });
    return new StreamID(type, block.cid);
  }
  get type() {
    return this._type;
  }
  get typeName() {
    return StreamType.nameByCode(this._type);
  }
  get cid() {
    return this._cid;
  }
  get bytes() {
    const codec = import_varint4.default.encode(STREAMID_CODEC);
    const type = import_varint4.default.encode(this.type);
    return concat2([codec, type, this.cid.bytes]);
  }
  get baseID() {
    return new StreamID(this._type, this._cid);
  }
  equals(other) {
    if (StreamID.isInstance(other)) {
      return this.type === other.type && this.cid.equals(other.cid);
    } else {
      return false;
    }
  }
  toString() {
    return base36.encode(this.bytes);
  }
  toUrl() {
    return `ceramic://${this.toString()}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `StreamID(${this.toString()})`;
  }
  [Symbol.toPrimitive]() {
    return this.toString();
  }
}, "StreamID");
__name2(StreamID, "StreamID");
StreamID.fromBytes = fromBytes2;
StreamID.fromBytesNoThrow = fromBytesNoThrow;
StreamID.fromString = fromString5;
StreamID.fromStringNoThrow = fromStringNoThrow;
__decorate([
  Memoize(),
  __metadata("design:type", String),
  __metadata("design:paramtypes", [])
], StreamID.prototype, "typeName", null);
__decorate([
  Memoize(),
  __metadata("design:type", Uint8Array),
  __metadata("design:paramtypes", [])
], StreamID.prototype, "bytes", null);
__decorate([
  Memoize(),
  __metadata("design:type", StreamID),
  __metadata("design:paramtypes", [])
], StreamID.prototype, "baseID", null);
__decorate([
  Memoize(),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", String)
], StreamID.prototype, "toString", null);
__decorate([
  Memoize(),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", String)
], StreamID.prototype, "toUrl", null);
var __decorate2 = /* @__PURE__ */ __name(function(decorators, target, key22, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key22) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key22, desc);
  else
    for (var i22 = decorators.length - 1; i22 >= 0; i22--)
      if (d3 = decorators[i22])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key22, r2) : d3(target, key22)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key22, r2), r2;
}, "__decorate2");
var __metadata2 = /* @__PURE__ */ __name(function(k2, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k2, v);
}, "__metadata2");
var __classPrivateFieldSet = /* @__PURE__ */ __name(function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}, "__classPrivateFieldSet");
var __classPrivateFieldGet = /* @__PURE__ */ __name(function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}, "__classPrivateFieldGet");
var _CommitID_type;
var _CommitID_cid;
var _CommitID_commit;
var InvalidCommitIDBytesError = /* @__PURE__ */ __name(class extends Error {
  constructor(bytes) {
    super(`Error while parsing CommitID from bytes ${base36.encode(bytes)}: no commit information provided`);
  }
}, "InvalidCommitIDBytesError");
__name2(InvalidCommitIDBytesError, "InvalidCommitIDBytesError");
var InvalidCommitIDStringError = /* @__PURE__ */ __name(class extends Error {
  constructor(input) {
    super(`Error while parsing CommitID from string ${input}: no commit information provided`);
  }
}, "InvalidCommitIDStringError");
__name2(InvalidCommitIDStringError, "InvalidCommitIDStringError");
function fromBytes3(bytes) {
  const parsed = fromBytes(bytes, "CommitID");
  if (parsed.kind === "commit-id") {
    return new CommitID(parsed.type, parsed.genesis, parsed.commit);
  }
  throw new InvalidCommitIDBytesError(bytes);
}
__name(fromBytes3, "fromBytes3");
__name2(fromBytes3, "fromBytes");
function fromBytesNoThrow2(bytes) {
  return tryCatch(() => fromBytes3(bytes));
}
__name(fromBytesNoThrow2, "fromBytesNoThrow2");
__name2(fromBytesNoThrow2, "fromBytesNoThrow");
function fromString6(input) {
  const parsed = fromString4(input, "CommitID");
  if (parsed.kind === "commit-id") {
    return new CommitID(parsed.type, parsed.genesis, parsed.commit);
  }
  throw new InvalidCommitIDStringError(input);
}
__name(fromString6, "fromString6");
__name2(fromString6, "fromString");
function fromStringNoThrow2(input) {
  return tryCatch(() => fromString6(input));
}
__name(fromStringNoThrow2, "fromStringNoThrow2");
__name2(fromStringNoThrow2, "fromStringNoThrow");
var TAG2 = Symbol.for("@ceramicnetwork/streamid/CommitID");
function make(stream, commit) {
  return new CommitID(stream.type, stream.cid, commit);
}
__name(make, "make");
__name2(make, "make");
var CommitID = /* @__PURE__ */ __name(class {
  constructor(type, cid, commit = null) {
    this._tag = TAG2;
    _CommitID_type.set(this, void 0);
    _CommitID_cid.set(this, void 0);
    _CommitID_commit.set(this, void 0);
    if (!type && type !== 0)
      throw new Error("constructor: type required");
    if (!cid)
      throw new Error("constructor: cid required");
    __classPrivateFieldSet(this, _CommitID_type, typeof type === "string" ? StreamType.codeByName(type) : type, "f");
    __classPrivateFieldSet(this, _CommitID_cid, typeof cid === "string" ? CID.parse(cid) : cid, "f");
    __classPrivateFieldSet(this, _CommitID_commit, parseCommit(__classPrivateFieldGet(this, _CommitID_cid, "f"), commit), "f");
  }
  static isInstance(instance) {
    return typeof instance === "object" && "_tag" in instance && instance._tag === TAG2;
  }
  get baseID() {
    return new StreamID(__classPrivateFieldGet(this, _CommitID_type, "f"), __classPrivateFieldGet(this, _CommitID_cid, "f"));
  }
  get type() {
    return __classPrivateFieldGet(this, _CommitID_type, "f");
  }
  get typeName() {
    return StreamType.nameByCode(__classPrivateFieldGet(this, _CommitID_type, "f"));
  }
  get cid() {
    return __classPrivateFieldGet(this, _CommitID_cid, "f");
  }
  get commit() {
    return __classPrivateFieldGet(this, _CommitID_commit, "f") || __classPrivateFieldGet(this, _CommitID_cid, "f");
  }
  get bytes() {
    const codec = import_varint5.default.encode(STREAMID_CODEC);
    const type = import_varint5.default.encode(this.type);
    const commitBytes = __classPrivateFieldGet(this, _CommitID_commit, "f")?.bytes || new Uint8Array([0]);
    return concat2([codec, type, this.cid.bytes, commitBytes]);
  }
  equals(other) {
    return this.type === other.type && this.cid.equals(other.cid) && this.commit.equals(other.commit);
  }
  toString() {
    return base36.encode(this.bytes);
  }
  toUrl() {
    return `ceramic://${this.toString()}`;
  }
  [(_CommitID_type = /* @__PURE__ */ new WeakMap(), _CommitID_cid = /* @__PURE__ */ new WeakMap(), _CommitID_commit = /* @__PURE__ */ new WeakMap(), Symbol.for("nodejs.util.inspect.custom"))]() {
    return `CommitID(${this.toString()})`;
  }
  [Symbol.toPrimitive]() {
    return this.toString();
  }
}, "CommitID");
__name2(CommitID, "CommitID");
CommitID.fromBytes = fromBytes3;
CommitID.fromBytesNoThrow = fromBytesNoThrow2;
CommitID.fromString = fromString6;
CommitID.fromStringNoThrow = fromStringNoThrow2;
CommitID.make = make;
__decorate2([
  Memoize(),
  __metadata2("design:type", StreamID),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "baseID", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", String),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "typeName", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", CID),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "commit", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", Uint8Array),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "bytes", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", Function),
  __metadata2("design:paramtypes", []),
  __metadata2("design:returntype", String)
], CommitID.prototype, "toString", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", Function),
  __metadata2("design:paramtypes", []),
  __metadata2("design:returntype", String)
], CommitID.prototype, "toUrl", null);
init_base36();
var StreamRef;
(function(StreamRef2) {
  function fromBytes4(input) {
    const parsed = fromBytes(input);
    switch (parsed.kind) {
      case "commit-id":
        return new CommitID(parsed.type, parsed.genesis, parsed.commit);
      case "stream-id":
        return new StreamID(parsed.type, parsed.genesis);
      default:
        throw new Error(`Malformed StreamRef bytes: ${base36.encode(input)}`);
    }
  }
  __name(fromBytes4, "fromBytes4");
  __name2(fromBytes4, "fromBytes");
  StreamRef2.fromBytes = fromBytes4;
  function fromString7(input) {
    const parsed = fromString4(input);
    switch (parsed.kind) {
      case "commit-id":
        return new CommitID(parsed.type, parsed.genesis, parsed.commit);
      case "stream-id":
        return new StreamID(parsed.type, parsed.genesis);
      default:
        throw new Error(`Malformed StreamRef string: ${input}`);
    }
  }
  __name(fromString7, "fromString7");
  __name2(fromString7, "fromString");
  StreamRef2.fromString = fromString7;
  function from4(input) {
    if (StreamID.isInstance(input)) {
      return input;
    }
    if (CommitID.isInstance(input)) {
      return input;
    }
    if (input instanceof Uint8Array) {
      return fromBytes4(input);
    }
    if (typeof input === "string") {
      return fromString7(input);
    }
    throw new Error(`Can not build CommitID or StreamID from ${JSON.stringify(input)}`);
  }
  __name(from4, "from4");
  __name2(from4, "from");
  StreamRef2.from = from4;
})(StreamRef || (StreamRef = {}));
var import_tslib = __toESM2(require_tslib(), 1);
var {
  __extends: __extends2,
  __assign,
  __rest,
  __decorate: __decorate3,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata: __metadata3,
  __awaiter: __awaiter17,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet: __classPrivateFieldGet2,
  __classPrivateFieldSet: __classPrivateFieldSet2,
  __classPrivateFieldIn
} = import_tslib.default;
function isFunction(value) {
  return typeof value === "function";
}
__name(isFunction, "isFunction");
__name2(isFunction, "isFunction");
function createErrorClass(createImpl) {
  var _super = /* @__PURE__ */ __name2(function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  }, "_super");
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
__name(createErrorClass, "createErrorClass");
__name2(createErrorClass, "createErrorClass");
var UnsubscriptionError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i22) {
      return i22 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  }, "UnsubscriptionErrorImpl"), "UnsubscriptionErrorImpl");
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
__name(arrRemove, "arrRemove");
__name2(arrRemove, "arrRemove");
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  __name(Subscription2, "Subscription2");
  __name2(Subscription2, "Subscription");
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
__name(isSubscription, "isSubscription");
__name2(isSubscription, "isSubscription");
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
__name(execFinalizer, "execFinalizer");
__name2(execFinalizer, "execFinalizer");
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
__name(reportUnhandledError, "reportUnhandledError");
__name2(reportUnhandledError, "reportUnhandledError");
function noop() {
}
__name(noop, "noop");
__name2(noop, "noop");
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
__name(errorNotification, "errorNotification");
__name2(errorNotification, "errorNotification");
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
__name(nextNotification, "nextNotification");
__name2(nextNotification, "nextNotification");
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
__name(createNotification, "createNotification");
__name2(createNotification, "createNotification");
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
__name(errorContext, "errorContext");
__name2(errorContext, "errorContext");
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
__name(captureError, "captureError");
__name2(captureError, "captureError");
var Subscriber = function(_super) {
  __extends2(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  __name(Subscriber2, "Subscriber2");
  __name2(Subscriber2, "Subscriber");
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
__name(bind, "bind");
__name2(bind, "bind");
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  __name(ConsumerObserver2, "ConsumerObserver2");
  __name2(ConsumerObserver2, "ConsumerObserver");
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends2(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  __name(SafeSubscriber2, "SafeSubscriber2");
  __name2(SafeSubscriber2, "SafeSubscriber");
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
__name(handleUnhandledError, "handleUnhandledError");
__name2(handleUnhandledError, "handleUnhandledError");
function defaultErrorHandler(err) {
  throw err;
}
__name(defaultErrorHandler, "defaultErrorHandler");
__name2(defaultErrorHandler, "defaultErrorHandler");
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
__name(handleStoppedNotification, "handleStoppedNotification");
__name2(handleStoppedNotification, "handleStoppedNotification");
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity3(x2) {
  return x2;
}
__name(identity3, "identity3");
__name2(identity3, "identity");
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity3;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  }, "piped"), "piped");
}
__name(pipeFromArray, "pipeFromArray");
__name2(pipeFromArray, "pipeFromArray");
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  __name(Observable2, "Observable2");
  __name2(Observable2, "Observable");
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
__name(getPromiseCtor, "getPromiseCtor");
__name2(getPromiseCtor, "getPromiseCtor");
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
__name(isObserver, "isObserver");
__name2(isObserver, "isObserver");
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
__name(isSubscriber, "isSubscriber");
__name2(isSubscriber, "isSubscriber");
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
__name(hasLift, "hasLift");
__name2(hasLift, "hasLift");
function operate(init4) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init4(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
__name(operate, "operate");
__name2(operate, "operate");
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
__name(createOperatorSubscriber, "createOperatorSubscriber");
__name2(createOperatorSubscriber, "createOperatorSubscriber");
var OperatorSubscriber = function(_super) {
  __extends2(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  __name(OperatorSubscriber2, "OperatorSubscriber2");
  __name2(OperatorSubscriber2, "OperatorSubscriber");
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  }, "ObjectUnsubscribedErrorImpl"), "ObjectUnsubscribedErrorImpl");
});
var Subject = function(_super) {
  __extends2(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  __name(Subject2, "Subject2");
  __name2(Subject2, "Subject");
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends2(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  __name(AnonymousSubject2, "AnonymousSubject2");
  __name2(AnonymousSubject2, "AnonymousSubject");
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var BehaviorSubject = function(_super) {
  __extends2(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  __name(BehaviorSubject2, "BehaviorSubject2");
  __name2(BehaviorSubject2, "BehaviorSubject");
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var Action = function(_super) {
  __extends2(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  __name(Action2, "Action2");
  __name2(Action2, "Action");
  Action2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends2(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  __name(AsyncAction2, "AsyncAction2");
  __name2(AsyncAction2, "AsyncAction");
  AsyncAction2.prototype.schedule = function(state, delay) {
    var _a;
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id2 = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  __name(Scheduler2, "Scheduler2");
  __name2(Scheduler2, "Scheduler");
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends2(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  __name(AsyncScheduler2, "AsyncScheduler2");
  __name2(AsyncScheduler2, "AsyncScheduler");
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
__name(isScheduler, "isScheduler");
__name2(isScheduler, "isScheduler");
function last(arr) {
  return arr[arr.length - 1];
}
__name(last, "last");
__name2(last, "last");
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
__name(popScheduler, "popScheduler");
__name2(popScheduler, "popScheduler");
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
__name(popNumber, "popNumber");
__name2(popNumber, "popNumber");
var isArrayLike = /* @__PURE__ */ __name2(function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
}, "isArrayLike");
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
__name(isPromise, "isPromise");
__name2(isPromise, "isPromise");
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
__name(isInteropObservable, "isInteropObservable");
__name2(isInteropObservable, "isInteropObservable");
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
__name(isAsyncIterable, "isAsyncIterable");
__name2(isAsyncIterable, "isAsyncIterable");
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
__name(createInvalidObservableTypeError, "createInvalidObservableTypeError");
__name2(createInvalidObservableTypeError, "createInvalidObservableTypeError");
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
__name(getSymbolIterator, "getSymbolIterator");
__name2(getSymbolIterator, "getSymbolIterator");
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
__name(isIterable, "isIterable");
__name2(isIterable, "isIterable");
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  }, "readableStreamLikeToAsyncGenerator_1"), "readableStreamLikeToAsyncGenerator_1"));
}
__name(readableStreamLikeToAsyncGenerator, "readableStreamLikeToAsyncGenerator");
__name2(readableStreamLikeToAsyncGenerator, "readableStreamLikeToAsyncGenerator");
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
__name(isReadableStreamLike, "isReadableStreamLike");
__name2(isReadableStreamLike, "isReadableStreamLike");
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(innerFrom, "innerFrom");
__name2(innerFrom, "innerFrom");
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
__name(fromInteropObservable, "fromInteropObservable");
__name2(fromInteropObservable, "fromInteropObservable");
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i22 = 0; i22 < array.length && !subscriber.closed; i22++) {
      subscriber.next(array[i22]);
    }
    subscriber.complete();
  });
}
__name(fromArrayLike, "fromArrayLike");
__name2(fromArrayLike, "fromArrayLike");
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
__name(fromPromise, "fromPromise");
__name2(fromPromise, "fromPromise");
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
__name(fromIterable, "fromIterable");
__name2(fromIterable, "fromIterable");
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
__name(fromAsyncIterable, "fromAsyncIterable");
__name2(fromAsyncIterable, "fromAsyncIterable");
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
__name(fromReadableStreamLike, "fromReadableStreamLike");
__name2(fromReadableStreamLike, "fromReadableStreamLike");
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter17(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
__name(process2, "process2");
__name2(process2, "process");
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
__name(executeSchedule, "executeSchedule");
__name2(executeSchedule, "executeSchedule");
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
__name(observeOn, "observeOn");
__name2(observeOn, "observeOn");
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
__name(subscribeOn, "subscribeOn");
__name2(subscribeOn, "subscribeOn");
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(scheduleObservable, "scheduleObservable");
__name2(scheduleObservable, "scheduleObservable");
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(schedulePromise, "schedulePromise");
__name2(schedulePromise, "schedulePromise");
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i22 = 0;
    return scheduler.schedule(function() {
      if (i22 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i22++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
__name(scheduleArray, "scheduleArray");
__name2(scheduleArray, "scheduleArray");
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
__name(scheduleIterable, "scheduleIterable");
__name2(scheduleIterable, "scheduleIterable");
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
__name(scheduleAsyncIterable, "scheduleAsyncIterable");
__name2(scheduleAsyncIterable, "scheduleAsyncIterable");
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
__name(scheduleReadableStreamLike, "scheduleReadableStreamLike");
__name2(scheduleReadableStreamLike, "scheduleReadableStreamLike");
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(scheduled, "scheduled");
__name2(scheduled, "scheduled");
function from3(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
__name(from3, "from3");
__name2(from3, "from");
var EmptyError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  }, "EmptyErrorImpl"), "EmptyErrorImpl");
});
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
__name(isValidDate, "isValidDate");
__name2(isValidDate, "isValidDate");
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
__name(map, "map");
__name2(map, "map");
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
__name(callOrApply, "callOrApply");
__name2(callOrApply, "callOrApply");
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
__name(mapOneOrManyArgs, "mapOneOrManyArgs");
__name2(mapOneOrManyArgs, "mapOneOrManyArgs");
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = /* @__PURE__ */ __name2(function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  }, "checkComplete");
  var outerNext = /* @__PURE__ */ __name2(function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  }, "outerNext");
  var doInnerSub = /* @__PURE__ */ __name2(function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = /* @__PURE__ */ __name2(function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          }, "_loop_1");
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  }, "doInnerSub");
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
__name(mergeInternals, "mergeInternals");
__name2(mergeInternals, "mergeInternals");
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a3, i22) {
      return map(function(b2, ii) {
        return resultSelector(a3, b2, i22, ii);
      })(innerFrom(project(a3, i22)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
__name(mergeMap, "mergeMap");
__name2(mergeMap, "mergeMap");
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity3, concurrent);
}
__name(mergeAll, "mergeAll");
__name2(mergeAll, "mergeAll");
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add32 = _a[0], remove = _a[1];
  if (!add32) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add32) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = /* @__PURE__ */ __name2(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    }, "handler");
    add32(handler);
    return function() {
      return remove(handler);
    };
  });
}
__name(fromEvent, "fromEvent");
__name2(fromEvent, "fromEvent");
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
__name(toCommonHandlerRegistry, "toCommonHandlerRegistry");
__name2(toCommonHandlerRegistry, "toCommonHandlerRegistry");
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
__name(isNodeStyleEventEmitter, "isNodeStyleEventEmitter");
__name2(isNodeStyleEventEmitter, "isNodeStyleEventEmitter");
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
__name(isJQueryStyleEventEmitter, "isJQueryStyleEventEmitter");
__name2(isJQueryStyleEventEmitter, "isJQueryStyleEventEmitter");
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
__name(isEventTarget, "isEventTarget");
__name2(isEventTarget, "isEventTarget");
function timer2(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
__name(timer2, "timer");
__name2(timer2, "timer");
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from3(sources, scheduler));
}
__name(merge, "merge");
__name2(merge, "merge");
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
__name(filter, "filter");
__name2(filter, "filter");
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
__name(defaultIfEmpty, "defaultIfEmpty");
__name2(defaultIfEmpty, "defaultIfEmpty");
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
__name(take, "take");
__name2(take, "take");
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
__name(throwIfEmpty, "throwIfEmpty");
__name2(throwIfEmpty, "throwIfEmpty");
function defaultErrorFactory() {
  return new EmptyError();
}
__name(defaultErrorFactory, "defaultErrorFactory");
__name2(defaultErrorFactory, "defaultErrorFactory");
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i22) {
      return predicate(v, i22, source);
    }) : identity3, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
__name(first, "first");
__name2(first, "first");
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return operate(function(source, subscriber) {
    var leading = config2.leading, trailing = config2.trailing;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = /* @__PURE__ */ __name2(function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    }, "endThrottling");
    var cleanupThrottling = /* @__PURE__ */ __name2(function() {
      throttled = null;
      isComplete && subscriber.complete();
    }, "cleanupThrottling");
    var startThrottle = /* @__PURE__ */ __name2(function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    }, "startThrottle");
    var send = /* @__PURE__ */ __name2(function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    }, "send");
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
__name(throttle, "throttle");
__name2(throttle, "throttle");
var SignatureStatus;
(function(SignatureStatus3) {
  SignatureStatus3[SignatureStatus3["GENESIS"] = 0] = "GENESIS";
  SignatureStatus3[SignatureStatus3["PARTIAL"] = 1] = "PARTIAL";
  SignatureStatus3[SignatureStatus3["SIGNED"] = 2] = "SIGNED";
})(SignatureStatus || (SignatureStatus = {}));
var AnchorStatus;
(function(AnchorStatus3) {
  AnchorStatus3[AnchorStatus3["NOT_REQUESTED"] = 0] = "NOT_REQUESTED";
  AnchorStatus3[AnchorStatus3["PENDING"] = 1] = "PENDING";
  AnchorStatus3[AnchorStatus3["PROCESSING"] = 2] = "PROCESSING";
  AnchorStatus3[AnchorStatus3["ANCHORED"] = 3] = "ANCHORED";
  AnchorStatus3[AnchorStatus3["FAILED"] = 4] = "FAILED";
})(AnchorStatus || (AnchorStatus = {}));
var CommitType;
(function(CommitType3) {
  CommitType3[CommitType3["GENESIS"] = 0] = "GENESIS";
  CommitType3[CommitType3["SIGNED"] = 1] = "SIGNED";
  CommitType3[CommitType3["ANCHOR"] = 2] = "ANCHOR";
})(CommitType || (CommitType = {}));
var Stream = /* @__PURE__ */ __name(class extends Observable {
  constructor(state$, _context) {
    super((subscriber) => {
      state$.subscribe(subscriber);
    });
    this.state$ = state$;
    this._context = _context;
  }
  get id() {
    return new StreamID(this.state$.value.type, this.state$.value.log[0].cid);
  }
  get api() {
    return this._context.api;
  }
  get content() {
    const { next, content } = this.state$.value;
    return (0, import_lodash.default)(next?.content ?? content);
  }
  get tip() {
    return this.state$.value.log[this.state$.value.log.length - 1].cid;
  }
  get commitId() {
    return CommitID.make(this.id, this.tip);
  }
  get allCommitIds() {
    return this.state$.value.log.map(({ cid }) => CommitID.make(this.id, cid));
  }
  get anchorCommitIds() {
    return this.state$.value.log.filter(({ type }) => type === CommitType.ANCHOR).map(({ cid }) => CommitID.make(this.id, cid));
  }
  get state() {
    return (0, import_lodash.default)(this.state$.value);
  }
  async sync(opts = {}) {
    opts = { sync: SyncOptions.PREFER_CACHE, ...opts };
    const stream = await this.api.loadStream(this.id, opts);
    this.state$.next(stream.state);
  }
  async requestAnchor() {
    return this.api.requestAnchor(this.id);
  }
}, "Stream");
__name2(Stream, "Stream");
function StreamStatic() {
  return (constructor) => {
    constructor;
  };
}
__name(StreamStatic, "StreamStatic");
__name2(StreamStatic, "StreamStatic");
function mergeAbortSignals(signals) {
  const controller = new AbortController();
  if (signals.length === 0) {
    throw Error("Need abort signals to create a merged abort signal");
  }
  if (signals.some((signal) => signal.aborted)) {
    controller.abort();
    return controller.signal;
  }
  merge(...signals.map((signal) => fromEvent(signal, "abort"))).pipe(first()).subscribe(() => {
    controller.abort();
  });
  return controller.signal;
}
__name(mergeAbortSignals, "mergeAbortSignals");
__name2(mergeAbortSignals, "mergeAbortSignals");
var TimedAbortSignal = /* @__PURE__ */ __name(class {
  constructor(timeout) {
    const controller = new AbortController();
    this.signal = controller.signal;
    if (timeout <= 0) {
      controller.abort();
      return;
    }
    this._subscription = timer2(timeout).subscribe(() => {
      controller.abort();
    });
  }
  clear() {
    this._subscription?.unsubscribe();
  }
}, "TimedAbortSignal");
__name2(TimedAbortSignal, "TimedAbortSignal");
async function abortable2(original, fn) {
  const controller = new AbortController();
  const onAbort = /* @__PURE__ */ __name2(() => {
    controller.abort();
  }, "onAbort");
  original.addEventListener("abort", onAbort);
  if (original.aborted)
    controller.abort();
  return fn(controller.signal).finally(() => {
    original.removeEventListener("abort", onAbort);
  });
}
__name(abortable2, "abortable2");
__name2(abortable2, "abortable");
var DEFAULT_FETCH_TIMEOUT = 60 * 1e3 * 3;
async function fetchJson2(url, opts = {}) {
  if (opts.body) {
    Object.assign(opts, {
      body: JSON.stringify(opts.body),
      headers: { ...opts.headers, "Content-Type": "application/json" }
    });
  }
  const timeoutLength = opts.timeout || DEFAULT_FETCH_TIMEOUT;
  const timedAbortSignal = new TimedAbortSignal(timeoutLength);
  const signal = opts.signal ? mergeAbortSignals([opts.signal, timedAbortSignal.signal]) : timedAbortSignal.signal;
  const res = await abortable2(signal, (abortSignal) => {
    return (0, import_cross_fetch.default)(String(url), { ...opts, signal: abortSignal });
  }).finally(() => timedAbortSignal.clear());
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`HTTP request to '${url}' failed with status '${res.statusText}': ${text}`);
  }
  return res.json();
}
__name(fetchJson2, "fetchJson");
__name2(fetchJson2, "fetchJson");
var import_lodash2 = __toESM2(require_lodash2(), 1);
init_cid();
function toCID(givenCid) {
  const cid = CID.asCID(givenCid);
  if (cid) {
    return cid;
  }
  if (typeof givenCid === "string") {
    return CID.parse(givenCid);
  }
  if (givenCid instanceof Uint8Array) {
    return CID.decode(givenCid);
  }
  throw new Error(`${givenCid} cannot be converted to a CID`);
}
__name(toCID, "toCID");
__name2(toCID, "toCID");
var TILE_TYPE_ID = 0;
var StreamUtils = /* @__PURE__ */ __name(class {
  static streamIdFromState(state) {
    return new StreamID(state.type, state.log[0].cid);
  }
  static serializeCommit(commit) {
    const cloned = (0, import_lodash2.default)(commit);
    if (StreamUtils.isSignedCommitContainer(cloned)) {
      cloned.jws.link = cloned.jws.link.toString();
      cloned.linkedBlock = toString3(cloned.linkedBlock, "base64");
      if (cloned.cacaoBlock) {
        cloned.cacaoBlock = toString3(cloned.cacaoBlock, "base64");
      }
      return cloned;
    }
    if (StreamUtils.isSignedCommit(commit)) {
      cloned.link = cloned.link.toString();
    }
    if (StreamUtils.isAnchorCommit(commit)) {
      cloned.proof = cloned.proof.toString();
    }
    if (cloned.id) {
      cloned.id = cloned.id.toString();
    }
    if (cloned.prev) {
      cloned.prev = cloned.prev.toString();
    }
    if (commit.header?.model) {
      cloned.header.model = toString3(commit.header.model, "base64");
    }
    return cloned;
  }
  static deserializeCommit(commit) {
    const cloned = (0, import_lodash2.default)(commit);
    if (StreamUtils.isSignedCommitContainer(cloned)) {
      cloned.jws.link = toCID(cloned.jws.link);
      cloned.linkedBlock = fromString2(cloned.linkedBlock, "base64");
      if (cloned.cacaoBlock) {
        cloned.cacaoBlock = fromString2(cloned.cacaoBlock, "base64");
      }
      return cloned;
    }
    if (StreamUtils.isSignedCommit(cloned)) {
      cloned.link = toCID(cloned.link);
    }
    if (StreamUtils.isAnchorCommit(cloned)) {
      cloned.proof = toCID(cloned.proof);
    }
    if (cloned.id) {
      cloned.id = toCID(cloned.id);
    }
    if (cloned.prev) {
      cloned.prev = toCID(cloned.prev);
    }
    if (cloned.header?.model) {
      cloned.header.model = fromString2(cloned.header.model, "base64");
    }
    return cloned;
  }
  static serializeState(state) {
    const cloned = (0, import_lodash2.default)(state);
    cloned.log = cloned.log.map((entry) => ({ ...entry, cid: entry.cid.toString() }));
    if (cloned.anchorStatus != null) {
      cloned.anchorStatus = AnchorStatus[cloned.anchorStatus];
    }
    if (cloned.anchorProof != null) {
      cloned.anchorProof.txHash = cloned.anchorProof.txHash.toString();
      cloned.anchorProof.root = cloned.anchorProof.root.toString();
    }
    if (state.metadata?.model) {
      cloned.metadata.model = state.metadata.model.toString();
    }
    if (state.next?.metadata?.model) {
      cloned.next.metadata.model = state.next.metadata.model.toString();
    }
    if (state.metadata?.unique && state.type != TILE_TYPE_ID) {
      cloned.metadata.unique = toString3(cloned.metadata.unique, "base64");
    }
    cloned.doctype = StreamType.nameByCode(cloned.type);
    return cloned;
  }
  static deserializeState(state) {
    if (!state)
      return null;
    const cloned = (0, import_lodash2.default)(state);
    if (cloned.doctype) {
      cloned.type = StreamType.codeByName(cloned.doctype);
      delete cloned.doctype;
    }
    cloned.log = cloned.log.map((entry) => ({ ...entry, cid: toCID(entry.cid) }));
    if (cloned.anchorProof) {
      cloned.anchorProof.txHash = toCID(cloned.anchorProof.txHash);
      cloned.anchorProof.root = toCID(cloned.anchorProof.root);
    }
    if (cloned.anchorStatus) {
      cloned.anchorStatus = AnchorStatus[cloned.anchorStatus];
    }
    if (state.metadata?.model) {
      cloned.metadata.model = StreamID.fromString(state.metadata.model);
    }
    if (state.next?.metadata?.model) {
      cloned.next.metadata.model = StreamID.fromString(state.next.metadata.model);
    }
    if (state.metadata?.unique && state.type != TILE_TYPE_ID) {
      cloned.metadata.unique = fromString2(state.metadata.unique, "base64");
    }
    return cloned;
  }
  static statesEqual(state1, state2) {
    return JSON.stringify(StreamUtils.serializeState(state1)) === JSON.stringify(StreamUtils.serializeState(state2));
  }
  static isStateSupersetOf(state, base4) {
    if (state.log.length < base4.log.length) {
      return false;
    }
    for (const i22 in base4.log) {
      if (!state.log[i22].cid.equals(base4.log[i22].cid)) {
        return false;
      }
    }
    if (state.log.length === base4.log.length && state.anchorStatus != base4.anchorStatus) {
      return false;
    }
    return true;
  }
  static assertCommitLinksToState(state, commit) {
    const streamId = this.streamIdFromState(state);
    if (commit.id && !commit.id.equals(state.log[0].cid)) {
      throw new Error(`Invalid genesis CID in commit for StreamID ${streamId.toString()}. Found: ${commit.id}, expected ${state.log[0].cid}`);
    }
    const expectedPrev = state.log[state.log.length - 1].cid;
    if (!commit.prev.equals(expectedPrev)) {
      throw new Error(`Commit doesn't properly point to previous commit in log. Expected ${expectedPrev}, found 'prev' ${commit.prev}`);
    }
  }
  static async convertCommitToSignedCommitContainer(commit, ipfs) {
    if (StreamUtils.isSignedCommit(commit)) {
      const block = await ipfs.block.get(commit.link);
      return {
        jws: commit,
        linkedBlock: block
      };
    }
    return commit;
  }
  static isSignedCommitContainer(commit) {
    return commit && commit.jws !== void 0;
  }
  static isSignedCommit(commit) {
    return commit && commit.link !== void 0;
  }
  static isAnchorCommit(commit) {
    return commit && commit.proof !== void 0;
  }
  static isSignedCommitData(commitData) {
    return commitData && commitData.envelope !== void 0;
  }
  static isAnchorCommitData(commitData) {
    return commitData && commitData.proof !== void 0;
  }
}, "StreamUtils");
__name2(StreamUtils, "StreamUtils");
var StreamStateSubject = /* @__PURE__ */ __name(class extends BehaviorSubject {
  next(next) {
    const current = this.value;
    if (!StreamUtils.statesEqual(current, next)) {
      super.next(next);
    }
  }
}, "StreamStateSubject");
__name2(StreamStateSubject, "StreamStateSubject");
var __decorate4 = /* @__PURE__ */ __name(function(decorators, target, key22, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key22) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key22, desc);
  else
    for (var i22 = decorators.length - 1; i22 >= 0; i22--)
      if (d3 = decorators[i22])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key22, r2) : d3(target, key22)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key22, r2), r2;
}, "__decorate4");
var TileDocument_1;
var DEFAULT_CREATE_OPTS = {
  anchor: true,
  publish: true,
  pin: true,
  sync: SyncOptions.PREFER_CACHE
};
var DEFAULT_LOAD_OPTS = { sync: SyncOptions.PREFER_CACHE };
var DEFAULT_UPDATE_OPTS = { anchor: true, publish: true, throwOnInvalidCommit: true };
function headerFromMetadata(metadata, genesis) {
  if (typeof metadata?.schema === "string") {
    try {
      CommitID.fromString(metadata.schema);
    } catch {
      throw new Error("Schema must be a CommitID");
    }
  }
  const header = {
    controllers: metadata?.controllers,
    family: metadata?.family,
    schema: metadata?.schema?.toString(),
    tags: metadata?.tags
  };
  if (genesis) {
    if (!metadata?.deterministic) {
      header["unique"] = toString3((0, import_random32.randomBytes)(12), "base64");
    }
    if (metadata?.forbidControllerChange) {
      header["forbidControllerChange"] = true;
    }
  } else {
    if (metadata?.deterministic !== void 0 || metadata?.unique !== void 0) {
      throw new Error("Cannot change 'deterministic' or 'unique' properties on existing Streams");
    }
    if (metadata?.forbidControllerChange !== void 0) {
      throw new Error("Cannot change 'forbidControllerChange' property on existing Streams");
    }
  }
  Object.keys(header).forEach((key22) => header[key22] === void 0 && delete header[key22]);
  return header;
}
__name(headerFromMetadata, "headerFromMetadata");
__name2(headerFromMetadata, "headerFromMetadata");
async function getAuthenticatedDID(signer) {
  if (!signer.did)
    throw new Error(`No DID provided`);
  if (!signer.did.authenticated) {
    await signer.did.authenticate();
    if (signer.loggerProvider) {
      signer.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${signer.did.id}`);
    }
  }
  return signer.did;
}
__name(getAuthenticatedDID, "getAuthenticatedDID");
__name2(getAuthenticatedDID, "getAuthenticatedDID");
async function throwReadOnlyError() {
  throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
}
__name(throwReadOnlyError, "throwReadOnlyError");
__name2(throwReadOnlyError, "throwReadOnlyError");
var TileDocument = TileDocument_1 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(class TileDocument2 extends Stream {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get content() {
    return super.content;
  }
  get metadata() {
    const { next, metadata } = this.state$.value;
    return (0, import_lodash3.default)(next?.metadata ?? metadata);
  }
  get controllers() {
    return this.metadata.controllers;
  }
  static async create(ceramic, content, metadata, opts = {}) {
    opts = { ...DEFAULT_CREATE_OPTS, ...opts };
    if (!metadata?.deterministic && opts.syncTimeoutSeconds == void 0) {
      opts.syncTimeoutSeconds = 0;
    }
    const signer = opts.asDID ? { did: opts.asDID } : ceramic;
    const commit = await TileDocument_1.makeGenesis(signer, content, metadata);
    return ceramic.createStreamFromGenesis(TileDocument_1.STREAM_TYPE_ID, commit, opts);
  }
  static async createFromGenesis(ceramic, genesisCommit, opts = {}) {
    opts = { ...DEFAULT_CREATE_OPTS, ...opts };
    if (genesisCommit.header?.unique && opts.syncTimeoutSeconds == void 0) {
      opts.syncTimeoutSeconds = 0;
    }
    const commit = genesisCommit.data ? await TileDocument_1._signDagJWS(ceramic, genesisCommit) : genesisCommit;
    return ceramic.createStreamFromGenesis(TileDocument_1.STREAM_TYPE_ID, commit, opts);
  }
  static async deterministic(ceramic, metadata, opts = {}) {
    opts = { ...DEFAULT_CREATE_OPTS, ...opts };
    metadata = { ...metadata, deterministic: true };
    if (metadata.family == null && metadata.tags == null) {
      throw new Error("Family and/or tags are required when creating a deterministic tile document");
    }
    const commit = await TileDocument_1.makeGenesis(ceramic, null, metadata);
    return ceramic.createStreamFromGenesis(TileDocument_1.STREAM_TYPE_ID, commit, opts);
  }
  static async load(ceramic, streamId, opts = {}) {
    opts = { ...DEFAULT_LOAD_OPTS, ...opts };
    const streamRef = StreamRef.from(streamId);
    if (streamRef.type != TileDocument_1.STREAM_TYPE_ID) {
      throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${TileDocument_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
    }
    return ceramic.loadStream(streamRef, opts);
  }
  async update(content, metadata, opts = {}) {
    opts = { ...DEFAULT_UPDATE_OPTS, ...opts };
    const signer = opts.asDID ? { did: opts.asDID } : this.api;
    const updateCommit = await this.makeCommit(signer, content, metadata);
    const updated = await this.api.applyCommit(this.id, updateCommit, opts);
    this.state$.next(updated.state);
  }
  async patch(jsonPatch, opts = {}) {
    opts = { ...DEFAULT_UPDATE_OPTS, ...opts };
    const header = headerFromMetadata(this.metadata, false);
    const rawCommit = {
      header,
      data: jsonPatch,
      prev: this.tip,
      id: this.id.cid
    };
    const commit = await TileDocument_1._signDagJWS(this.api, rawCommit);
    const updated = await this.api.applyCommit(this.id, commit, opts);
    this.state$.next(updated.state);
  }
  makeReadOnly() {
    this.update = throwReadOnlyError;
    this.patch = throwReadOnlyError;
    this.sync = throwReadOnlyError;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
  async makeCommit(signer, newContent, newMetadata) {
    const commit = await this._makeRawCommit(newContent, newMetadata);
    return TileDocument_1._signDagJWS(signer, commit);
  }
  async _makeRawCommit(newContent, newMetadata) {
    newMetadata || (newMetadata = {});
    const header = headerFromMetadata(newMetadata, false);
    if (newContent == null) {
      newContent = this.content;
    }
    if (header.controllers) {
      if (header.controllers.length !== 1) {
        throw new Error("Exactly one controller must be specified");
      }
      if (!header.controllers[0]) {
        throw new Error("Controller cannot be updated to an undefined value.");
      }
    }
    const patch = fast_json_patch_default.compare(this.content, newContent);
    const genesisLogEntry = this.state.log[0];
    return {
      header,
      data: patch,
      prev: this.tip,
      id: genesisLogEntry.cid
    };
  }
  static async makeGenesis(signer, content, metadata) {
    metadata || (metadata = {});
    if (!metadata.controllers || metadata.controllers.length === 0) {
      if (signer.did) {
        const did = await getAuthenticatedDID(signer);
        metadata.controllers = [did.hasParent ? did.parent : did.id];
      } else {
        throw new Error("No controllers specified");
      }
    }
    if (metadata.controllers?.length !== 1) {
      throw new Error("Exactly one controller must be specified");
    }
    const header = headerFromMetadata(metadata, true);
    if (metadata?.deterministic && content) {
      throw new Error("Initial content must be null when creating a deterministic Tile document");
    }
    if (content == null) {
      const result = { header };
      encode7(result);
      return result;
    }
    const commit = { data: content, header };
    return TileDocument_1._signDagJWS(signer, commit);
  }
  static async _signDagJWS(signer, commit) {
    const did = await getAuthenticatedDID(signer);
    return did.createDagJWS(commit);
  }
}, "TileDocument2"), "TileDocument");
TileDocument.STREAM_TYPE_NAME = "tile";
TileDocument.STREAM_TYPE_ID = 0;
TileDocument = TileDocument_1 = __decorate4([
  StreamStatic()
], TileDocument);
var import_dataloader = __toESM2(require_dataloader(), 1);
function _checkPrivateRedeclaration2(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration2, "_checkPrivateRedeclaration2");
__name2(_checkPrivateRedeclaration2, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet2(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet2, "_classApplyDescriptorGet2");
__name2(_classApplyDescriptorGet2, "_classApplyDescriptorGet");
function _classApplyDescriptorSet2(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet2, "_classApplyDescriptorSet2");
__name2(_classApplyDescriptorSet2, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor2(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor2, "_classExtractFieldDescriptor2");
__name2(_classExtractFieldDescriptor2, "_classExtractFieldDescriptor");
function _classPrivateFieldGet2(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
  return _classApplyDescriptorGet2(receiver, descriptor);
}
__name(_classPrivateFieldGet2, "_classPrivateFieldGet2");
__name2(_classPrivateFieldGet2, "_classPrivateFieldGet");
function _classPrivateFieldInit2(obj, privateMap, value) {
  _checkPrivateRedeclaration2(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit2, "_classPrivateFieldInit2");
__name2(_classPrivateFieldInit2, "_classPrivateFieldInit");
function _classPrivateFieldSet2(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
  _classApplyDescriptorSet2(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet2, "_classPrivateFieldSet2");
__name2(_classPrivateFieldSet2, "_classPrivateFieldSet");
function keyToQuery(key22) {
  return typeof key22 === "string" || CommitID.isInstance(key22) || StreamID.isInstance(key22) ? {
    streamId: key22
  } : {
    streamId: key22.streamId,
    genesis: key22.genesis
  };
}
__name(keyToQuery, "keyToQuery");
__name2(keyToQuery, "keyToQuery");
function keyToString(key22) {
  if (typeof key22 === "string") {
    return StreamRef.from(key22).toString();
  }
  if (CommitID.isInstance(key22) || StreamID.isInstance(key22)) {
    return key22.toString();
  }
  return key22.streamId.toString();
}
__name(keyToString, "keyToString");
__name2(keyToString, "keyToString");
async function getDeterministicQuery(metadata) {
  const genesis = await TileDocument.makeGenesis({}, null, {
    ...metadata,
    deterministic: true
  });
  const streamId = await StreamID.fromGenesis("tile", genesis);
  return {
    genesis,
    streamId
  };
}
__name(getDeterministicQuery, "getDeterministicQuery");
__name2(getDeterministicQuery, "getDeterministicQuery");
var tempBatchLoadFn = /* @__PURE__ */ __name2(() => Promise.resolve([]), "tempBatchLoadFn");
var _ceramic = /* @__PURE__ */ new WeakMap();
var _useCache = /* @__PURE__ */ new WeakMap();
var TileLoader = /* @__PURE__ */ __name(class extends import_dataloader.default {
  cache(stream) {
    if (!_classPrivateFieldGet2(this, _useCache)) {
      return false;
    }
    const id2 = stream.id.toString();
    this.clear(id2).prime(id2, stream);
    return true;
  }
  async create(content, metadata, options) {
    const stream = await TileDocument.create(_classPrivateFieldGet2(this, _ceramic), content, metadata, options);
    this.cache(stream);
    return stream;
  }
  async deterministic(metadata, options) {
    const query = await getDeterministicQuery(metadata);
    try {
      return await super.load(query);
    } catch (err) {
      const stream = await TileDocument.createFromGenesis(_classPrivateFieldGet2(this, _ceramic), query.genesis, options);
      this.cache(stream);
      return stream;
    }
  }
  async load(key22) {
    return await super.load(key22);
  }
  async update(streamID, content, metadata, options) {
    const id2 = keyToString(streamID);
    this.clear(id2);
    const stream = await this.load({
      streamId: id2
    });
    await stream.update(content, metadata, options);
    return stream;
  }
  constructor(params) {
    super(tempBatchLoadFn, {
      cache: true,
      cacheKeyFn: keyToString,
      cacheMap: params.cache != null && typeof params.cache !== "boolean" ? params.cache : void 0
    });
    _classPrivateFieldInit2(this, _ceramic, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit2(this, _useCache, {
      writable: true,
      value: void 0
    });
    this._batchLoadFn = async (keys) => {
      if (!params.cache) {
        this.clearAll();
      }
      const results = await params.ceramic.multiQuery(keys.map(keyToQuery), params.multiqueryTimeout);
      return keys.map((key22) => {
        const id2 = keyToString(key22);
        const doc = results[id2];
        return doc ? doc : new Error(`Failed to load stream: ${id2}`);
      });
    };
    _classPrivateFieldSet2(this, _ceramic, params.ceramic);
    _classPrivateFieldSet2(this, _useCache, !!params.cache);
  }
}, "TileLoader");
__name2(TileLoader, "TileLoader");
function typeStreamID(streamId) {
  return typeof streamId === "string" ? StreamID.fromString(streamId) : streamId;
}
__name(typeStreamID, "typeStreamID");
__name2(typeStreamID, "typeStreamID");
function serializeObjectToSearchParams(queryURL, queryObject) {
  const resultURL = new URL(queryURL);
  for (const [key22, value] of Object.entries(queryObject)) {
    if (StreamID.isInstance(value)) {
      resultURL.searchParams.set(key22, value.toString());
    } else if (typeof value == "object") {
      resultURL.searchParams.set(key22, JSON.stringify(value));
    } else {
      resultURL.searchParams.set(key22, value);
    }
  }
  return resultURL;
}
__name(serializeObjectToSearchParams, "serializeObjectToSearchParams");
__name2(serializeObjectToSearchParams, "serializeObjectToSearchParams");
function serializeObjectForHttpPost(query) {
  const result = {};
  for (const [key22, value] of Object.entries(query)) {
    if (StreamID.isInstance(value)) {
      result[key22] = value.toString();
    } else {
      result[key22] = value;
    }
  }
  return result;
}
__name(serializeObjectForHttpPost, "serializeObjectForHttpPost");
__name2(serializeObjectForHttpPost, "serializeObjectForHttpPost");
var Document = /* @__PURE__ */ __name(class extends Observable {
  constructor(initial, _apiUrl, syncInterval) {
    super((subscriber) => {
      const isFirstObserver = this.state$.observers.length === 0;
      if (isFirstObserver) {
        this.periodicSubscription = timer2(0, syncInterval).pipe(throttle(() => this._syncState(this.id, { sync: SyncOptions.PREFER_CACHE }))).subscribe();
      }
      this.state$.subscribe(subscriber).add(() => {
        const isNoObserversLeft = this.state$.observers.length === 0;
        if (isNoObserversLeft) {
          this.periodicSubscription?.unsubscribe();
        }
      });
    });
    this.state$ = new StreamStateSubject(initial);
    this._apiUrl = new URL(_apiUrl);
  }
  get value() {
    return this.state$.value;
  }
  get state() {
    return this.state$.value;
  }
  next(state) {
    this.state$.next(state);
  }
  async _syncState(streamId, opts) {
    const state = await Document._load(streamId, this._apiUrl, opts);
    this.state$.next(StreamUtils.deserializeState(state));
  }
  get id() {
    return new StreamID(this.state$.value.type, this.state$.value.log[0].cid);
  }
  static async createFromGenesis(apiUrl, type, genesis, opts, syncInterval) {
    const url = new URL("./streams", apiUrl);
    const { state } = await fetchJson2(url, {
      method: "post",
      body: {
        type,
        genesis: StreamUtils.serializeCommit(genesis),
        opts
      }
    });
    return new Document(StreamUtils.deserializeState(state), apiUrl, syncInterval);
  }
  static async applyCommit(apiUrl, streamId, commit, opts, syncInterval) {
    const url = new URL("./commits", apiUrl);
    const { state } = await fetchJson2(url, {
      method: "post",
      body: {
        streamId: streamId.toString(),
        commit: StreamUtils.serializeCommit(commit),
        opts
      }
    });
    return new Document(StreamUtils.deserializeState(state), apiUrl, syncInterval);
  }
  static async _load(streamId, apiUrl, opts) {
    const url = serializeObjectToSearchParams(new URL(`./streams/${streamId}`, apiUrl), opts);
    const { state } = await fetchJson2(url);
    return state;
  }
  static async load(streamId, apiUrl, syncInterval, opts) {
    const state = await Document._load(streamId, apiUrl, opts);
    return new Document(StreamUtils.deserializeState(state), apiUrl, syncInterval);
  }
  static async loadStreamCommits(streamId, apiUrl) {
    const url = new URL(`./commits/${streamId}`, apiUrl);
    const { commits } = await fetchJson2(url);
    return commits.map((r2) => {
      return {
        cid: r2.cid,
        value: StreamUtils.deserializeCommit(r2.value)
      };
    });
  }
  complete() {
    this.state$.complete();
  }
}, "Document");
__name2(Document, "Document");
var SyncOptions2;
(function(SyncOptions3) {
  SyncOptions3[SyncOptions3["PREFER_CACHE"] = 0] = "PREFER_CACHE";
  SyncOptions3[SyncOptions3["SYNC_ALWAYS"] = 1] = "SYNC_ALWAYS";
  SyncOptions3[SyncOptions3["NEVER_SYNC"] = 2] = "NEVER_SYNC";
  SyncOptions3[SyncOptions3["SYNC_ON_ERROR"] = 3] = "SYNC_ON_ERROR";
})(SyncOptions2 || (SyncOptions2 = {}));
var import_lodash4 = __toESM2(require_lodash2(), 1);
var SignatureStatus2;
(function(SignatureStatus3) {
  SignatureStatus3[SignatureStatus3["GENESIS"] = 0] = "GENESIS";
  SignatureStatus3[SignatureStatus3["PARTIAL"] = 1] = "PARTIAL";
  SignatureStatus3[SignatureStatus3["SIGNED"] = 2] = "SIGNED";
})(SignatureStatus2 || (SignatureStatus2 = {}));
var AnchorStatus2;
(function(AnchorStatus3) {
  AnchorStatus3[AnchorStatus3["NOT_REQUESTED"] = 0] = "NOT_REQUESTED";
  AnchorStatus3[AnchorStatus3["PENDING"] = 1] = "PENDING";
  AnchorStatus3[AnchorStatus3["PROCESSING"] = 2] = "PROCESSING";
  AnchorStatus3[AnchorStatus3["ANCHORED"] = 3] = "ANCHORED";
  AnchorStatus3[AnchorStatus3["FAILED"] = 4] = "FAILED";
})(AnchorStatus2 || (AnchorStatus2 = {}));
var CommitType2;
(function(CommitType3) {
  CommitType3[CommitType3["GENESIS"] = 0] = "GENESIS";
  CommitType3[CommitType3["SIGNED"] = 1] = "SIGNED";
  CommitType3[CommitType3["ANCHOR"] = 2] = "ANCHOR";
})(CommitType2 || (CommitType2 = {}));
var Stream2 = /* @__PURE__ */ __name(class extends Observable {
  constructor(state$, _context) {
    super((subscriber) => {
      state$.subscribe(subscriber);
    });
    this.state$ = state$;
    this._context = _context;
  }
  get id() {
    return new StreamID(this.state$.value.type, this.state$.value.log[0].cid);
  }
  get api() {
    return this._context.api;
  }
  get content() {
    const { next, content } = this.state$.value;
    return (0, import_lodash4.default)(next?.content ?? content);
  }
  get tip() {
    return this.state$.value.log[this.state$.value.log.length - 1].cid;
  }
  get commitId() {
    return CommitID.make(this.id, this.tip);
  }
  get allCommitIds() {
    return this.state$.value.log.map(({ cid }) => CommitID.make(this.id, cid));
  }
  get anchorCommitIds() {
    return this.state$.value.log.filter(({ type }) => type === CommitType2.ANCHOR).map(({ cid }) => CommitID.make(this.id, cid));
  }
  get state() {
    return (0, import_lodash4.default)(this.state$.value);
  }
  async sync(opts = {}) {
    opts = { sync: SyncOptions2.PREFER_CACHE, ...opts };
    const stream = await this.api.loadStream(this.id, opts);
    this.state$.next(stream.state);
  }
  async requestAnchor() {
    return this.api.requestAnchor(this.id);
  }
}, "Stream2");
__name2(Stream2, "Stream");
function StreamStatic2() {
  return (constructor) => {
    constructor;
  };
}
__name(StreamStatic2, "StreamStatic2");
__name2(StreamStatic2, "StreamStatic");
function normalizeAccountId(accountId) {
  if (typeof accountId === "string" && accountId.includes("@")) {
    const [address, chainId] = accountId.split("@");
    if (!address || !chainId) {
      throw new Error(`Invalid accountId provided`);
    }
    return new AccountId({ address, chainId });
  }
  return new AccountId(accountId);
}
__name(normalizeAccountId, "normalizeAccountId");
__name2(normalizeAccountId, "normalizeAccountId");
var import_lodash5 = __toESM2(require_lodash2(), 1);
var __decorate5 = /* @__PURE__ */ __name(function(decorators, target, key22, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key22) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key22, desc);
  else
    for (var i22 = decorators.length - 1; i22 >= 0; i22--)
      if (d3 = decorators[i22])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key22, r2) : d3(target, key22)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key22, r2), r2;
}, "__decorate5");
var Caip10Link_1;
var throwReadOnlyError2 = /* @__PURE__ */ __name2(() => {
  throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
}, "throwReadOnlyError");
var DEFAULT_CREATE_OPTS2 = {
  anchor: false,
  publish: true,
  pin: true,
  sync: SyncOptions2.PREFER_CACHE
};
var DEFAULT_UPDATE_OPTS2 = { anchor: true, publish: true };
var DEFAULT_LOAD_OPTS2 = { sync: SyncOptions2.PREFER_CACHE };
var Caip10Link = Caip10Link_1 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(class Caip10Link2 extends Stream2 {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get did() {
    return this.content;
  }
  get metadata() {
    const { next, metadata } = this.state$.value;
    return (0, import_lodash5.default)(next?.metadata ?? metadata);
  }
  get controllers() {
    return this.metadata.controllers;
  }
  static async fromAccount(ceramic, accountId, opts = {}) {
    opts = { ...DEFAULT_CREATE_OPTS2, ...opts };
    const normalizedAccountId = normalizeAccountId(accountId);
    const genesisCommit = Caip10Link_1.makeGenesis(normalizedAccountId);
    return Caip10Link_1.fromGenesis(ceramic, genesisCommit, opts);
  }
  static async fromGenesis(ceramic, genesisCommit, opts = {}) {
    opts = { ...DEFAULT_CREATE_OPTS2, ...opts };
    return ceramic.createStreamFromGenesis(Caip10Link_1.STREAM_TYPE_ID, genesisCommit, opts);
  }
  async setDid(did, authProvider, opts = {}) {
    opts = { ...DEFAULT_UPDATE_OPTS2, ...opts };
    const didStr = typeof did == "string" ? did.trim() : did.id;
    const parsedDid = parse2(didStr);
    if (parsedDid?.did !== didStr) {
      throw new Error(`DID is not valid: '${didStr}'`);
    }
    const linkProof = await authProvider.createLink(didStr);
    return this.setDidProof(linkProof, opts);
  }
  async setDidProof(proof, opts = {}) {
    opts = { ...DEFAULT_UPDATE_OPTS2, ...opts };
    const commit = this.makeCommit(proof);
    const updated = await this.api.applyCommit(this.id, commit, opts);
    this.state$.next(updated.state);
  }
  async clearDid(authProvider, opts = {}) {
    opts = { ...DEFAULT_UPDATE_OPTS2, ...opts };
    const linkProof = await authProvider.createLink("");
    return this.setDidProof(linkProof, opts);
  }
  static async load(ceramic, streamId, opts = {}) {
    opts = { ...DEFAULT_LOAD_OPTS2, ...opts };
    const streamRef = StreamRef.from(streamId);
    if (streamRef.type != Caip10Link_1.STREAM_TYPE_ID) {
      throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${Caip10Link_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
    }
    return ceramic.loadStream(streamRef, opts);
  }
  static makeGenesis(accountId) {
    if (accountId.chainId.namespace === "eip155") {
      accountId.address = accountId.address.toLowerCase();
    }
    const legacyAccountId = `${accountId.address}@${accountId.chainId.toString()}`;
    return {
      header: {
        controllers: [legacyAccountId],
        family: `caip10-${accountId.chainId.toString()}`
      }
    };
  }
  makeCommit(proof) {
    return { data: proof, prev: this.tip, id: this.id.cid };
  }
  makeReadOnly() {
    this.setDidProof = throwReadOnlyError2;
    this.setDid = throwReadOnlyError2;
    this.sync = throwReadOnlyError2;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
}, "Caip10Link2"), "Caip10Link");
Caip10Link.STREAM_TYPE_NAME = "caip10-link";
Caip10Link.STREAM_TYPE_ID = 1;
Caip10Link = Caip10Link_1 = __decorate5([
  StreamStatic2()
], Caip10Link);
init_cid();
init_digest();
var import_multihashes = __toESM2(require_src3(), 1);
var __decorate6 = /* @__PURE__ */ __name(function(decorators, target, key22, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key22) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key22, desc);
  else
    for (var i22 = decorators.length - 1; i22 >= 0; i22--)
      if (d3 = decorators[i22])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key22, r2) : d3(target, key22)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key22, r2), r2;
}, "__decorate6");
var Model_1;
var DEFAULT_LOAD_OPTS3 = { sync: SyncOptions.PREFER_CACHE };
async function _ensureAuthenticated(signer) {
  if (signer.did == null) {
    throw new Error("No DID provided");
  }
  if (!signer.did.authenticated) {
    await signer.did.authenticate();
    if (signer.loggerProvider) {
      signer.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${signer.did.id}`);
    }
  }
}
__name(_ensureAuthenticated, "_ensureAuthenticated");
__name2(_ensureAuthenticated, "_ensureAuthenticated");
async function throwReadOnlyError3() {
  throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
}
__name(throwReadOnlyError3, "throwReadOnlyError3");
__name2(throwReadOnlyError3, "throwReadOnlyError");
var Model = Model_1 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(class Model2 extends Stream {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get content() {
    return super.content;
  }
  get metadata() {
    return { controller: this.state$.value.metadata.controllers[0], model: Model_1.MODEL };
  }
  static async create(ceramic, content, metadata) {
    Model_1.assertComplete(content);
    const opts = {
      publish: true,
      anchor: true,
      pin: true,
      sync: SyncOptions.NEVER_SYNC,
      throwOnInvalidCommit: true
    };
    const commit = await Model_1._makeGenesis(ceramic, content, metadata);
    const model = await ceramic.createStreamFromGenesis(Model_1.STREAM_TYPE_ID, commit, opts);
    return model;
  }
  static assertComplete(content, streamId) {
    if (!content.name) {
      if (streamId) {
        throw new Error(`Model with StreamID ${streamId.toString()} is missing a 'name' field`);
      } else {
        throw new Error(`Model is missing a 'name' field`);
      }
    }
    if (!content.schema) {
      if (streamId) {
        throw new Error(`Model ${content.name} (${streamId.toString()}) is missing a 'schema' field`);
      } else {
        throw new Error(`Model ${content.name} is missing a 'schema' field`);
      }
    }
    if (!content.accountRelation) {
      if (streamId) {
        throw new Error(`Model ${content.name} (${streamId.toString()}) is missing a 'accountRelation' field`);
      } else {
        throw new Error(`Model ${content.name} is missing a 'accountRelation' field`);
      }
    }
  }
  static async load(ceramic, streamId, opts = {}) {
    opts = { ...DEFAULT_LOAD_OPTS3, ...opts };
    const streamRef = StreamRef.from(streamId);
    if (streamRef.type != Model_1.STREAM_TYPE_ID) {
      throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${Model_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
    }
    const model = await ceramic.loadStream(streamRef, opts);
    return model;
  }
  static async _makeGenesis(signer, content, metadata) {
    const commit = await this._makeRawGenesis(signer, content, metadata);
    return Model_1._signDagJWS(signer, commit);
  }
  static async _makeRawGenesis(signer, content, metadata) {
    if (content == null) {
      throw new Error(`Genesis content cannot be null`);
    }
    if (!metadata || !metadata.controller) {
      if (signer.did) {
        await _ensureAuthenticated(signer);
        metadata = { controller: signer.did.hasParent ? signer.did.parent : signer.did.id };
      } else {
        throw new Error("No controller specified");
      }
    }
    const header = {
      controllers: [metadata.controller],
      model: Model_1.MODEL.bytes
    };
    return { data: content, header };
  }
  makeReadOnly() {
    this.sync = throwReadOnlyError3;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
  static async _signDagJWS(signer, commit) {
    await _ensureAuthenticated(signer);
    return signer.did.createDagJWS(commit);
  }
}, "Model2"), "Model");
Model.STREAM_TYPE_NAME = "model";
Model.STREAM_TYPE_ID = 2;
Model.MODEL = function() {
  const data = encode7("model-v1");
  const multihash = import_multihashes.default.encode(data, "identity");
  const digest2 = create(code2, multihash);
  const cid = CID.createV1(code2, digest2);
  return new StreamID("UNLOADABLE", cid);
}();
Model = Model_1 = __decorate6([
  StreamStatic()
], Model);
var import_random42 = __toESM2(require_random(), 1);
var __decorate7 = /* @__PURE__ */ __name(function(decorators, target, key22, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key22) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key22, desc);
  else
    for (var i22 = decorators.length - 1; i22 >= 0; i22--)
      if (d3 = decorators[i22])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key22, r2) : d3(target, key22)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key22, r2), r2;
}, "__decorate7");
var ModelInstanceDocument_1;
var DEFAULT_CREATE_OPTS3 = {
  anchor: true,
  publish: true,
  pin: true,
  sync: SyncOptions.NEVER_SYNC,
  syncTimeoutSeconds: 0
};
var DEFAULT_DETERMINISTIC_OPTS = {
  anchor: false,
  publish: false,
  pin: true,
  sync: SyncOptions.PREFER_CACHE
};
var DEFAULT_LOAD_OPTS4 = { sync: SyncOptions.PREFER_CACHE };
var DEFAULT_UPDATE_OPTS3 = { anchor: true, publish: true, throwOnInvalidCommit: true };
async function _ensureAuthenticated2(signer) {
  if (signer.did == null) {
    throw new Error("No DID provided");
  }
  if (!signer.did.authenticated) {
    await signer.did.authenticate();
    if (signer.loggerProvider) {
      signer.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${signer.did.id}`);
    }
  }
}
__name(_ensureAuthenticated2, "_ensureAuthenticated2");
__name2(_ensureAuthenticated2, "_ensureAuthenticated");
async function throwReadOnlyError4() {
  throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
}
__name(throwReadOnlyError4, "throwReadOnlyError4");
__name2(throwReadOnlyError4, "throwReadOnlyError");
var ModelInstanceDocument = ModelInstanceDocument_1 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(class ModelInstanceDocument2 extends Stream {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get content() {
    return super.content;
  }
  get metadata() {
    const metadata = this.state$.value.metadata;
    return { controller: metadata.controllers[0], model: metadata.model };
  }
  static async create(ceramic, content, metadata, opts = {}) {
    opts = { ...DEFAULT_CREATE_OPTS3, ...opts };
    const signer = opts.asDID ? { did: opts.asDID } : ceramic;
    const commit = await ModelInstanceDocument_1._makeGenesis(signer, content, metadata);
    return ceramic.createStreamFromGenesis(ModelInstanceDocument_1.STREAM_TYPE_ID, commit, opts);
  }
  static async single(ceramic, metadata, opts = {}) {
    opts = { ...DEFAULT_DETERMINISTIC_OPTS, ...opts };
    const signer = opts.asDID ? { did: opts.asDID } : ceramic;
    metadata = { ...metadata, deterministic: true };
    const commit = await ModelInstanceDocument_1._makeGenesis(signer, null, metadata);
    return ceramic.createStreamFromGenesis(ModelInstanceDocument_1.STREAM_TYPE_ID, commit, opts);
  }
  static async load(ceramic, streamId, opts = {}) {
    opts = { ...DEFAULT_LOAD_OPTS4, ...opts };
    const streamRef = StreamRef.from(streamId);
    if (streamRef.type != ModelInstanceDocument_1.STREAM_TYPE_ID) {
      throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${ModelInstanceDocument_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
    }
    return ceramic.loadStream(streamRef, opts);
  }
  async replace(content, opts = {}) {
    opts = { ...DEFAULT_UPDATE_OPTS3, ...opts };
    const signer = opts.asDID ? { did: opts.asDID } : this.api;
    const updateCommit = await this._makeCommit(signer, content);
    const updated = await this.api.applyCommit(this.id, updateCommit, opts);
    this.state$.next(updated.state);
  }
  async patch(jsonPatch, opts = {}) {
    opts = { ...DEFAULT_UPDATE_OPTS3, ...opts };
    const rawCommit = {
      data: jsonPatch,
      prev: this.tip,
      id: this.id.cid
    };
    const commit = await ModelInstanceDocument_1._signDagJWS(this.api, rawCommit);
    const updated = await this.api.applyCommit(this.id, commit, opts);
    this.state$.next(updated.state);
  }
  makeReadOnly() {
    this.replace = throwReadOnlyError4;
    this.patch = throwReadOnlyError4;
    this.sync = throwReadOnlyError4;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
  _makeCommit(signer, newContent) {
    const commit = this._makeRawCommit(newContent);
    return ModelInstanceDocument_1._signDagJWS(signer, commit);
  }
  _makeRawCommit(newContent) {
    const patch = fast_json_patch_default.compare(this.content, newContent || {});
    return {
      data: patch,
      prev: this.tip,
      id: this.state.log[0].cid
    };
  }
  static async _makeGenesis(signer, content, metadata) {
    const commit = await this._makeRawGenesis(signer, content, metadata);
    if (metadata.deterministic) {
      encode7(commit);
      return commit;
    } else {
      return ModelInstanceDocument_1._signDagJWS(signer, commit);
    }
  }
  static async _makeRawGenesis(signer, content, metadata) {
    if (!metadata.model) {
      throw new Error(`Must specify a 'model' when creating a ModelInstanceDocument`);
    }
    let controller = metadata.controller;
    if (!controller) {
      if (signer.did) {
        await _ensureAuthenticated2(signer);
        controller = signer.did.hasParent ? signer.did.parent : signer.did.id;
      } else {
        throw new Error("No controller specified");
      }
    }
    const header = {
      controllers: [controller],
      model: metadata.model.bytes
    };
    if (!metadata.deterministic) {
      header.unique = (0, import_random42.randomBytes)(12);
    }
    return { data: content, header };
  }
  static async _signDagJWS(signer, commit) {
    await _ensureAuthenticated2(signer);
    return signer.did.createDagJWS(commit);
  }
}, "ModelInstanceDocument2"), "ModelInstanceDocument");
ModelInstanceDocument.STREAM_TYPE_NAME = "MID";
ModelInstanceDocument.STREAM_TYPE_ID = 3;
ModelInstanceDocument = ModelInstanceDocument_1 = __decorate7([
  StreamStatic()
], ModelInstanceDocument);
var RemotePinApi = /* @__PURE__ */ __name(class {
  constructor(_apiUrl) {
    this._apiUrl = _apiUrl;
  }
  async add(streamId, force) {
    const args = {};
    if (force) {
      args.force = true;
    }
    const url = new URL(`./pins/${streamId}`, this._apiUrl);
    await fetchJson2(url, {
      method: "post",
      body: args
    });
  }
  async rm(streamId, opts) {
    const url = new URL(`./pins/${streamId}`, this._apiUrl);
    await fetchJson2(url, {
      method: "delete",
      body: { opts }
    });
  }
  async ls(streamId) {
    let url = new URL("./pins", this._apiUrl);
    if (streamId) {
      url = new URL(`./pins/${streamId.toString()}`, this._apiUrl);
    }
    const result = await fetchJson2(url);
    const { pinnedStreamIds } = result;
    return {
      [Symbol.asyncIterator]() {
        let index = 0;
        return {
          next() {
            if (index === pinnedStreamIds.length) {
              return Promise.resolve({ value: null, done: true });
            }
            return Promise.resolve({ value: pinnedStreamIds[index++], done: false });
          }
        };
      }
    };
  }
}, "RemotePinApi");
__name2(RemotePinApi, "RemotePinApi");
var RemoteIndexApi = /* @__PURE__ */ __name(class {
  constructor(apiUrl) {
    this._fetchJson = fetchJson2;
    this._collectionURL = new URL("./collection", apiUrl);
    this._countURL = new URL("./collection/count", apiUrl);
  }
  async count(query) {
    const response = await this._fetchJson(this._countURL, {
      method: "POST",
      body: serializeObjectForHttpPost(query)
    });
    return response.count;
  }
  async query(query) {
    const response = await this._fetchJson(this._collectionURL, {
      method: "POST",
      body: serializeObjectForHttpPost(query)
    });
    const edges = response.edges.map((e2) => {
      return {
        cursor: e2.cursor,
        node: StreamUtils.deserializeState(e2.node)
      };
    });
    return {
      edges,
      pageInfo: response.pageInfo
    };
  }
}, "RemoteIndexApi");
__name2(RemoteIndexApi, "RemoteIndexApi");
var RemoteAdminApi = /* @__PURE__ */ __name(class {
  constructor(_apiUrl, _getDidFn) {
    this._apiUrl = _apiUrl;
    this._getDidFn = _getDidFn;
    this._fetchJson = fetchJson2;
    this.modelsPath = "./admin/models";
    this.getCodePath = "./admin/getCode";
  }
  getCodeUrl() {
    return new URL(this.getCodePath, this._apiUrl);
  }
  getModelsUrl() {
    return new URL(this.modelsPath, this._apiUrl);
  }
  async buildJWS(actingDid, code3, modelsIDs) {
    const body = modelsIDs ? { models: modelsIDs.map((streamID) => streamID.toString()) } : void 0;
    const jws = await actingDid.createJWS({
      code: code3,
      requestPath: this.getModelsUrl().pathname,
      requestBody: body
    });
    return `${jws.signatures[0].protected}.${jws.payload}.${jws.signatures[0].signature}`;
  }
  async generateCode() {
    return (await this._fetchJson(this.getCodeUrl())).code;
  }
  async startIndexingModels(modelsIDs) {
    const code3 = await this.generateCode();
    await this._fetchJson(this.getModelsUrl(), {
      method: "post",
      body: { jws: await this.buildJWS(this._getDidFn(), code3, modelsIDs) }
    });
  }
  async getIndexedModels() {
    const code3 = await this.generateCode();
    const response = await this._fetchJson(this.getModelsUrl(), {
      headers: { Authorization: `Basic ${await this.buildJWS(this._getDidFn(), code3)}` }
    });
    return response.models.map((modelStreamIDString) => {
      return StreamID.fromString(modelStreamIDString);
    });
  }
  async stopIndexingModels(modelsIDs) {
    const code3 = await this.generateCode();
    await this._fetchJson(this.getModelsUrl(), {
      method: "delete",
      body: { jws: await this.buildJWS(this._getDidFn(), code3, modelsIDs) }
    });
  }
}, "RemoteAdminApi");
__name2(RemoteAdminApi, "RemoteAdminApi");
var API_PATH = "/api/v0/";
var CERAMIC_HOST = "http://localhost:7007";
var DEFAULT_CLIENT_CONFIG = {
  syncInterval: 5e3
};
var DEFAULT_APPLY_COMMIT_OPTS = { anchor: true, publish: true, sync: SyncOptions.PREFER_CACHE };
var DEFAULT_CREATE_FROM_GENESIS_OPTS = {
  anchor: true,
  publish: true,
  sync: SyncOptions.PREFER_CACHE
};
var DEFAULT_LOAD_OPTS5 = { sync: SyncOptions.PREFER_CACHE };
var CeramicClient = /* @__PURE__ */ __name(class {
  constructor(apiHost = CERAMIC_HOST, config2 = {}) {
    this._config = { ...DEFAULT_CLIENT_CONFIG, ...config2 };
    this._apiUrl = new URL(API_PATH, apiHost);
    this._streamCache = /* @__PURE__ */ new Map();
    this.context = { api: this };
    this.pin = new RemotePinApi(this._apiUrl);
    this.index = new RemoteIndexApi(this._apiUrl);
    const getDidFn = (() => {
      return this.did;
    }).bind(this);
    this.admin = new RemoteAdminApi(this._apiUrl, getDidFn);
    this._streamConstructors = {
      [Caip10Link.STREAM_TYPE_ID]: Caip10Link,
      [Model.STREAM_TYPE_ID]: Model,
      [ModelInstanceDocument.STREAM_TYPE_ID]: ModelInstanceDocument,
      [TileDocument.STREAM_TYPE_ID]: TileDocument
    };
  }
  get did() {
    return this.context.did;
  }
  set did(did) {
    this.context.did = did;
  }
  async createStreamFromGenesis(type, genesis, opts = {}) {
    opts = { ...DEFAULT_CREATE_FROM_GENESIS_OPTS, ...opts };
    const stream = await Document.createFromGenesis(this._apiUrl, type, genesis, opts, this._config.syncInterval);
    const found = this._streamCache.get(stream.id.toString());
    if (found) {
      if (!StreamUtils.statesEqual(stream.state, found.state))
        found.next(stream.state);
      return this.buildStreamFromDocument(found);
    } else {
      this._streamCache.set(stream.id.toString(), stream);
      return this.buildStreamFromDocument(stream);
    }
  }
  async loadStream(streamId, opts = {}) {
    opts = { ...DEFAULT_LOAD_OPTS5, ...opts };
    const streamRef = StreamRef.from(streamId);
    let stream = this._streamCache.get(streamRef.baseID.toString());
    if (stream) {
      await stream._syncState(streamRef, opts);
    } else {
      stream = await Document.load(streamRef, this._apiUrl, this._config.syncInterval, opts);
      this._streamCache.set(stream.id.toString(), stream);
    }
    return this.buildStreamFromDocument(stream);
  }
  async multiQuery(queries, timeout) {
    const queriesJSON = queries.map((q2) => {
      return {
        ...q2,
        streamId: typeof q2.streamId === "string" ? q2.streamId : q2.streamId.toString()
      };
    });
    const url = new URL("./multiqueries", this._apiUrl);
    const results = await fetchJson2(url, {
      method: "post",
      body: {
        queries: queriesJSON,
        ...{ timeout }
      }
    });
    return Object.entries(results).reduce((acc, e2) => {
      const [k2, v] = e2;
      const state = StreamUtils.deserializeState(v);
      const stream = new Document(state, this._apiUrl, this._config.syncInterval);
      acc[k2] = this.buildStreamFromDocument(stream);
      return acc;
    }, {});
  }
  loadStreamCommits(streamId) {
    const effectiveStreamId = typeStreamID(streamId);
    return Document.loadStreamCommits(effectiveStreamId, this._apiUrl);
  }
  async applyCommit(streamId, commit, opts = {}) {
    opts = { ...DEFAULT_APPLY_COMMIT_OPTS, ...opts };
    const effectiveStreamId = typeStreamID(streamId);
    const document2 = await Document.applyCommit(this._apiUrl, effectiveStreamId, commit, opts, this._config.syncInterval);
    const fromCache = this._streamCache.get(effectiveStreamId.toString());
    if (fromCache) {
      fromCache.next(document2.state);
      return this.buildStreamFromDocument(document2);
    } else {
      this._streamCache.set(effectiveStreamId.toString(), document2);
      return this.buildStreamFromDocument(document2);
    }
  }
  async requestAnchor(streamId, opts = {}) {
    opts = { ...DEFAULT_LOAD_OPTS5, ...opts };
    const { anchorStatus } = await fetchJson2(`${this._apiUrl}/streams/${streamId.toString()}/anchor`, {
      method: "post",
      body: {
        opts
      }
    });
    return anchorStatus;
  }
  addStreamHandler(streamHandler) {
    this._streamConstructors[streamHandler.name] = streamHandler.stream_constructor;
  }
  buildStreamFromState(state) {
    const stream$ = new Document(state, this._apiUrl, this._config.syncInterval);
    return this.buildStreamFromDocument(stream$);
  }
  buildStreamFromDocument(stream) {
    const type = stream.state.type;
    const streamConstructor = this._streamConstructors[type];
    if (!streamConstructor)
      throw new Error(`Failed to find constructor for stream ${type}`);
    return new streamConstructor(stream, this.context);
  }
  async setDID(did) {
    this.context.did = did;
  }
  async getSupportedChains() {
    if (this._supportedChains) {
      return this._supportedChains;
    }
    const { supportedChains } = await fetchJson2(this._apiUrl + "/node/chains");
    this._supportedChains = supportedChains;
    return supportedChains;
  }
  async close() {
    Array.from(this._streamCache).map(([, stream]) => {
      stream.complete();
    });
    this._streamCache.clear();
  }
}, "CeramicClient");
__name2(CeramicClient, "CeramicClient");
var streamIdToCeramicURI = /* @__PURE__ */ __name2((id2) => `lc:ceramic:${id2}`, "streamIdToCeramicURI");
var CeramicURIValidator = mod.string().refine(
  (string2) => string2.split(":").length === 3 && string2.split(":")[0] === "lc",
  "URI must be of the form lc:${storage}:${url}"
).refine(
  (string2) => string2.split(":")[1] === "ceramic",
  "URI must use storage type ceramic (i.e. must be lc:ceramic:${streamID})"
);
var getCeramicPlugin = /* @__PURE__ */ __name2(async (learnCard, { ceramicEndpoint, defaultContentFamily }) => {
  const ceramic = new CeramicClient(ceramicEndpoint);
  const learnCardResolver = /* @__PURE__ */ __name2(async (did2, _parsedDid, _resolver, options) => learnCard.invoke.didResolver(did2, options), "learnCardResolver");
  const resolver = { ...lib_default.getResolver(), web: learnCardResolver };
  const did = new DID({ resolver });
  ceramic.did = did;
  const key22 = learnCard.invoke.getKey();
  const ceramicProvider = new Ed25519Provider(toUint8Array(key22));
  ceramic.did.setProvider(ceramicProvider);
  await ceramic.did.authenticate();
  const loader = new TileLoader({ ceramic });
  const publishContentToCeramic = /* @__PURE__ */ __name2(async (content, metadata = {}, options = {}, encryption) => {
    if (!content)
      throw new Error("content is required");
    if (!metadata.controllers)
      metadata.controllers = [ceramic.did.id];
    if (!metadata.family)
      metadata.family = defaultContentFamily;
    if (!("pin" in options))
      options.pin = true;
    if (encryption?.encrypt) {
      learnCard.debug?.(
        "learnCard.store.Ceramic.upload.publishContentToCeramic - encrypt enabled",
        encryption
      );
      let recipients = encryption?.recipients || [];
      if (encryption?.controllersCanDecrypt) {
        recipients = [...recipients, ...metadata.controllers];
      }
      content = await ceramic?.did?.createDagJWE(content, import_lodash6.default.uniq(recipients));
    }
    learnCard.debug?.(
      "learnCard.store.Ceramic.upload.publishContentToCeramic - content to upload",
      content,
      metadata,
      options
    );
    const doc = await TileDocument.create(ceramic, content, metadata, options);
    return doc.id.toString();
  }, "publishContentToCeramic");
  const readContentFromCeramic = /* @__PURE__ */ __name2(async (streamId) => {
    const content = (await loader.load(streamId))?.content;
    learnCard.debug?.("learnCard.read.get.readContentFromCeramic", content);
    if (content?.ciphertext) {
      try {
        return await did.decryptDagJWE(content);
      } catch (e2) {
        learnCard.debug?.(
          "learnCard.read.get.readContentFromCeramic - Could not decrypt credential - DID not authorized.",
          e2
        );
        throw new Error("Could not decrypt credential - DID not authorized.");
      }
    }
    return content;
  }, "readContentFromCeramic");
  const uploadCredential = /* @__PURE__ */ __name2(async (vc, encryption) => {
    await VCValidator.or(VPValidator).parseAsync(vc);
    return streamIdToCeramicURI(await publishContentToCeramic(vc, {}, {}, encryption));
  }, "uploadCredential");
  const resolveCredential = /* @__PURE__ */ __name2(async (uri = "") => {
    if (!uri)
      return void 0;
    if (uri.startsWith("ceramic://")) {
      return VCValidator.parseAsync(await readContentFromCeramic(uri));
    }
    const verificationResult = await CeramicURIValidator.spa(uri);
    if (!verificationResult.success)
      return learnCard.invoke.resolveCredential(uri);
    const streamId = verificationResult.data.split(":")[2];
    return VCValidator.parseAsync(await readContentFromCeramic(streamId));
  }, "resolveCredential");
  return {
    name: "Ceramic",
    displayName: "Ceramic",
    description: "Uploads/resolves credentials using the Ceramic Network (https://ceramic.network/)",
    store: {
      upload: async (_learnCard, vc) => {
        _learnCard.debug?.("learnCard.store.Ceramic.upload");
        return uploadCredential(vc);
      },
      uploadEncrypted: async (_learnCard, vc, params) => {
        _learnCard.debug?.("learnCard.store.Ceramic.uploadEncrypted");
        return uploadCredential(vc, {
          encrypt: true,
          controllersCanDecrypt: true,
          ...params ? { recipients: params.recipients } : {}
        });
      }
    },
    read: {
      get: async (_learnCard, uri) => {
        _learnCard.debug?.("learnCard.read.Ceramic.get");
        if (!uri)
          return void 0;
        const verificationResult = await CeramicURIValidator.spa(uri);
        if (!verificationResult.success)
          return void 0;
        const streamId = verificationResult.data.split(":")[2];
        try {
          return await VCValidator.or(VPValidator).parseAsync(
            await readContentFromCeramic(streamId)
          );
        } catch (e2) {
          _learnCard.debug?.(e2);
          return void 0;
        }
      }
    },
    methods: {
      publishContentToCeramic: async (_learnCard, cred, encryption) => streamIdToCeramicURI(await publishContentToCeramic(cred, {}, {}, encryption)),
      readContentFromCeramic: async (_learnCard, streamId) => readContentFromCeramic(streamId),
      resolveCredential: async (_learnCard, uri) => resolveCredential(uri),
      getCeramicClient: () => ceramic,
      getDIDObject: () => ceramic.did
    }
  };
}, "getCeramicPlugin");
var CIP11_DEFINITION_SCHEMA_URL = "ceramic://k3y52l7qbv1fry1fp4s0nwdarh0vahusarpposgevy0pemiykymd2ord6swtharcw";
var CIP11_INDEX_SCHEMA_URL = "ceramic://k3y52l7qbv1fryjn62sggjh1lpn11c56qfofzmty190d62hwk1cal1c7qc5he54ow";
function _checkPrivateRedeclaration3(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration3, "_checkPrivateRedeclaration3");
__name2(_checkPrivateRedeclaration3, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet3(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet3, "_classApplyDescriptorGet3");
__name2(_classApplyDescriptorGet3, "_classApplyDescriptorGet");
function _classApplyDescriptorSet3(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet3, "_classApplyDescriptorSet3");
__name2(_classApplyDescriptorSet3, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor3(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor3, "_classExtractFieldDescriptor3");
__name2(_classExtractFieldDescriptor3, "_classExtractFieldDescriptor");
function _classPrivateFieldGet3(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "get");
  return _classApplyDescriptorGet3(receiver, descriptor);
}
__name(_classPrivateFieldGet3, "_classPrivateFieldGet3");
__name2(_classPrivateFieldGet3, "_classPrivateFieldGet");
function _classPrivateFieldInit3(obj, privateMap, value) {
  _checkPrivateRedeclaration3(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit3, "_classPrivateFieldInit3");
__name2(_classPrivateFieldInit3, "_classPrivateFieldInit");
function _classPrivateFieldSet3(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "set");
  _classApplyDescriptorSet3(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet3, "_classPrivateFieldSet3");
__name2(_classPrivateFieldSet3, "_classPrivateFieldSet");
var _aliases = /* @__PURE__ */ new WeakMap();
var _loader = /* @__PURE__ */ new WeakMap();
var DataModel = /* @__PURE__ */ __name(class {
  get aliases() {
    return _classPrivateFieldGet3(this, _aliases);
  }
  get loader() {
    return _classPrivateFieldGet3(this, _loader);
  }
  getDefinitionID(alias) {
    return _classPrivateFieldGet3(this, _aliases).definitions[alias] ?? null;
  }
  getSchemaURL(alias) {
    return _classPrivateFieldGet3(this, _aliases).schemas[alias] ?? null;
  }
  getTileID(alias) {
    return _classPrivateFieldGet3(this, _aliases).tiles[alias] ?? null;
  }
  async loadTile(alias) {
    const id2 = this.getTileID(alias);
    if (id2 == null) {
      throw new Error(`Tile alias "${alias}" is not defined`);
    }
    return await _classPrivateFieldGet3(this, _loader).load(id2);
  }
  async createTile(schemaAlias, content, options = {}) {
    const schema = this.getSchemaURL(schemaAlias);
    if (schema == null) {
      throw new Error(`Schema alias "${schemaAlias}" is not defined`);
    }
    const { controller, ...opts } = options;
    const metadata = {
      schema
    };
    if (controller != null) {
      metadata.controllers = [
        controller
      ];
    }
    return await _classPrivateFieldGet3(this, _loader).create(content, metadata, opts);
  }
  constructor(params) {
    _classPrivateFieldInit3(this, _aliases, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit3(this, _loader, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet3(this, _aliases, params.aliases);
    if (params.loader != null) {
      _classPrivateFieldSet3(this, _loader, params.loader);
    } else if (params.ceramic == null) {
      throw new Error("Invalid DataModel parameters: missing ceramic or loader");
    } else {
      _classPrivateFieldSet3(this, _loader, new TileLoader({
        ceramic: params.ceramic,
        cache: params.cache
      }));
    }
  }
}, "DataModel");
__name2(DataModel, "DataModel");
function _checkPrivateRedeclaration4(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration4, "_checkPrivateRedeclaration4");
__name2(_checkPrivateRedeclaration4, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet4(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet4, "_classApplyDescriptorGet4");
__name2(_classApplyDescriptorGet4, "_classApplyDescriptorGet");
function _classApplyDescriptorSet4(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet4, "_classApplyDescriptorSet4");
__name2(_classApplyDescriptorSet4, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor4(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor4, "_classExtractFieldDescriptor4");
__name2(_classExtractFieldDescriptor4, "_classExtractFieldDescriptor");
function _classPrivateFieldGet4(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "get");
  return _classApplyDescriptorGet4(receiver, descriptor);
}
__name(_classPrivateFieldGet4, "_classPrivateFieldGet4");
__name2(_classPrivateFieldGet4, "_classPrivateFieldGet");
function _classPrivateFieldInit4(obj, privateMap, value) {
  _checkPrivateRedeclaration4(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit4, "_classPrivateFieldInit4");
__name2(_classPrivateFieldInit4, "_classPrivateFieldInit");
function _classPrivateFieldSet4(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "set");
  _classApplyDescriptorSet4(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet4, "_classPrivateFieldSet4");
__name2(_classPrivateFieldSet4, "_classPrivateFieldSet");
var _getRemote = /* @__PURE__ */ new WeakMap();
var _queue = /* @__PURE__ */ new WeakMap();
var _promiseValue = /* @__PURE__ */ new WeakMap();
var _deferValue = /* @__PURE__ */ new WeakMap();
var TileProxy = /* @__PURE__ */ __name(class {
  _createValuePromise() {
    _classPrivateFieldSet4(this, _promiseValue, new Promise((resolve, reject) => {
      _classPrivateFieldSet4(this, _deferValue, {
        resolve,
        reject
      });
    }));
  }
  change(mutation) {
    return new Promise((resolve, reject) => {
      const run = /* @__PURE__ */ __name2(async (current) => {
        try {
          const next = await mutation(current);
          resolve();
          this._next(next);
        } catch (err) {
          reject(err);
          this._next(current);
        }
      }, "run");
      _classPrivateFieldGet4(this, _queue).push({
        reject,
        run
      });
      if (_classPrivateFieldGet4(this, _queue).length === 1) {
        void this._start();
      }
    });
  }
  async changeContent(change) {
    const mutation = /* @__PURE__ */ __name2(async (doc) => {
      await doc.update(change(doc.content), doc.metadata);
      return doc;
    }, "mutation");
    return await this.change(mutation);
  }
  async get() {
    return _classPrivateFieldGet4(this, _queue).length === 0 ? await _classPrivateFieldGet4(this, _getRemote).call(this) : await _classPrivateFieldGet4(this, _promiseValue);
  }
  async _start() {
    try {
      const value = await _classPrivateFieldGet4(this, _getRemote).call(this);
      this._next(value);
    } catch (err) {
      _classPrivateFieldGet4(this, _queue).forEach((item) => {
        item.reject(err);
      });
      _classPrivateFieldSet4(this, _queue, []);
      _classPrivateFieldGet4(this, _deferValue).reject(err);
      this._createValuePromise();
    }
  }
  _next(value) {
    const item = _classPrivateFieldGet4(this, _queue).shift();
    if (item == null) {
      this._end(value);
    } else {
      void item.run(value);
    }
  }
  _end(value) {
    _classPrivateFieldGet4(this, _deferValue).resolve(value);
    this._createValuePromise();
  }
  constructor(getRemote) {
    _classPrivateFieldInit4(this, _getRemote, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit4(this, _queue, {
      writable: true,
      value: []
    });
    _classPrivateFieldInit4(this, _promiseValue, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit4(this, _deferValue, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet4(this, _getRemote, getRemote);
    this._createValuePromise();
  }
}, "TileProxy");
__name2(TileProxy, "TileProxy");
var didRegex = /^did:([A-Za-z0-9]+):([A-Za-z0-9.\-:_]+)$/;
function isDIDstring(did) {
  return didRegex.test(did);
}
__name(isDIDstring, "isDIDstring");
__name2(isDIDstring, "isDIDstring");
function assertDIDstring(did) {
  if (!isDIDstring(did)) {
    throw new Error(`Invalid DID: ${did}`);
  }
}
__name(assertDIDstring, "assertDIDstring");
__name2(assertDIDstring, "assertDIDstring");
function getIDXMetadata(did) {
  assertDIDstring(did);
  return {
    controllers: [
      did
    ],
    family: "IDX"
  };
}
__name(getIDXMetadata, "getIDXMetadata");
__name2(getIDXMetadata, "getIDXMetadata");
function _checkPrivateRedeclaration5(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration5, "_checkPrivateRedeclaration5");
__name2(_checkPrivateRedeclaration5, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet5(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet5, "_classApplyDescriptorGet5");
__name2(_classApplyDescriptorGet5, "_classApplyDescriptorGet");
function _classApplyDescriptorSet5(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet5, "_classApplyDescriptorSet5");
__name2(_classApplyDescriptorSet5, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor5(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor5, "_classExtractFieldDescriptor5");
__name2(_classExtractFieldDescriptor5, "_classExtractFieldDescriptor");
function _classPrivateFieldGet5(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "get");
  return _classApplyDescriptorGet5(receiver, descriptor);
}
__name(_classPrivateFieldGet5, "_classPrivateFieldGet5");
__name2(_classPrivateFieldGet5, "_classPrivateFieldGet");
function _classPrivateFieldInit5(obj, privateMap, value) {
  _checkPrivateRedeclaration5(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit5, "_classPrivateFieldInit5");
__name2(_classPrivateFieldInit5, "_classPrivateFieldInit");
function _classPrivateFieldSet5(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "set");
  _classApplyDescriptorSet5(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet5, "_classPrivateFieldSet5");
__name2(_classPrivateFieldSet5, "_classPrivateFieldSet");
var _ceramic2 = /* @__PURE__ */ new WeakMap();
var _id = /* @__PURE__ */ new WeakMap();
var _indexProxies = /* @__PURE__ */ new WeakMap();
var _loader2 = /* @__PURE__ */ new WeakMap();
var _model = /* @__PURE__ */ new WeakMap();
var DIDDataStore = /* @__PURE__ */ __name(class {
  get authenticated() {
    return _classPrivateFieldGet5(this, _ceramic2).did != null;
  }
  get ceramic() {
    return _classPrivateFieldGet5(this, _ceramic2);
  }
  get id() {
    if (_classPrivateFieldGet5(this, _id) != null) {
      return _classPrivateFieldGet5(this, _id);
    }
    if (_classPrivateFieldGet5(this, _ceramic2).did == null) {
      throw new Error("Ceramic instance is not authenticated");
    }
    return _classPrivateFieldGet5(this, _ceramic2).did.hasParent ? _classPrivateFieldGet5(this, _ceramic2).did.parent : _classPrivateFieldGet5(this, _ceramic2).did.id;
  }
  get loader() {
    return _classPrivateFieldGet5(this, _loader2);
  }
  get model() {
    return _classPrivateFieldGet5(this, _model);
  }
  async has(key22, did) {
    const definitionID = this.getDefinitionID(key22);
    const ref = await this.getRecordID(definitionID, did);
    return ref != null;
  }
  async get(key22, did) {
    const definitionID = this.getDefinitionID(key22);
    return await this.getRecord(definitionID, did);
  }
  async getMultiple(key22, dids) {
    const definitionID = this.getDefinitionID(key22);
    const queries = await Promise.all(dids.map(async (did) => {
      const { genesis, streamId } = await getDeterministicQuery(getIDXMetadata(did));
      return {
        genesis,
        streamId: streamId.toString(),
        paths: [
          definitionID
        ]
      };
    }));
    const streams = await _classPrivateFieldGet5(this, _ceramic2).multiQuery(queries);
    const results = [];
    for (const query of queries) {
      const recordURL = streams[query.streamId]?.content?.[definitionID];
      const record = recordURL ? streams[StreamID.fromString(recordURL).toString()] : null;
      results.push(record?.content ?? null);
    }
    return results;
  }
  async set(key22, content, options = {}) {
    const definitionID = this.getDefinitionID(key22);
    const [created, id2] = await this._setRecordOnly(definitionID, content, options);
    if (created) {
      await this._setReference(options.controller ?? this.id, definitionID, id2);
    }
    return id2;
  }
  async merge(key22, content, options = {}) {
    const definitionID = this.getDefinitionID(key22);
    const existing = await this.getRecord(definitionID);
    const newContent = existing ? {
      ...existing,
      ...content
    } : content;
    return await this.setRecord(definitionID, newContent, options);
  }
  async setAll(contents, options = {}) {
    const updates = Object.entries(contents).map(async ([alias, content]) => {
      const definitionID = this.getDefinitionID(alias);
      const [created, id2] = await this._setRecordOnly(definitionID, content, options);
      return [
        created,
        definitionID,
        id2
      ];
    });
    const changes = await Promise.all(updates);
    const newReferences = changes.reduce((acc, [created, key22, id2]) => {
      if (created) {
        acc[key22] = id2.toUrl();
      }
      return acc;
    }, {});
    await this._setReferences(options.controller ?? this.id, newReferences);
    return newReferences;
  }
  async setDefaults(contents, options = {}) {
    const index = await this.getIndex() ?? {};
    const updates = Object.entries(contents).map(
      ([alias, content]) => [
        this.getDefinitionID(alias),
        content
      ]
    ).filter(
      (entry) => index[entry[0]] == null
    ).map(async ([key22, content]) => {
      const definition = await this.getDefinition(key22);
      const id2 = await this._createRecord(definition, content, options);
      return {
        [key22]: id2.toUrl()
      };
    });
    const changes = await Promise.all(updates);
    const newReferences = changes.reduce((acc, keyToID) => {
      return Object.assign(acc, keyToID);
    }, {});
    await this._setReferences(options.controller ?? this.id, newReferences);
    return newReferences;
  }
  async remove(key22, controller = this.id) {
    await this._getIndexProxy(controller).changeContent((index) => {
      if (index != null) {
        delete index[this.getDefinitionID(key22)];
      }
      return index;
    });
  }
  async getIndex(did = this.id) {
    const rootDoc = this.authenticated && did === this.id ? await this._getIndexProxy(did).get() : await this._getIDXDoc(did);
    return rootDoc ? rootDoc.content : null;
  }
  iterator(did) {
    let list;
    let cursor = 0;
    return {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: async () => {
        if (list == null) {
          const index = await this.getIndex(did);
          list = Object.entries(index ?? {});
        }
        if (cursor === list.length) {
          return {
            done: true,
            value: null
          };
        }
        const [key22, id2] = list[cursor++];
        const doc = await _classPrivateFieldGet5(this, _loader2).load(id2);
        return {
          done: false,
          value: {
            key: key22,
            id: id2,
            record: doc.content
          }
        };
      }
    };
  }
  async _createIDXDoc(controller) {
    return await _classPrivateFieldGet5(this, _loader2).deterministic(getIDXMetadata(controller));
  }
  async _getIDXDoc(did) {
    const doc = await this._createIDXDoc(did);
    if (doc.content == null || doc.metadata.schema == null) {
      return null;
    }
    if (doc.metadata.schema !== CIP11_INDEX_SCHEMA_URL) {
      throw new Error("Invalid document: schema is not IdentityIndex");
    }
    return doc;
  }
  async _getOwnIDXDoc(did) {
    const doc = await this._createIDXDoc(did);
    if (doc.content == null || doc.metadata.schema == null) {
      await doc.update({}, {
        schema: CIP11_INDEX_SCHEMA_URL
      });
    } else if (doc.metadata.schema !== CIP11_INDEX_SCHEMA_URL) {
      throw new Error("Invalid document: schema is not IdentityIndex");
    }
    return doc;
  }
  _getIndexProxy(controller) {
    let proxy = _classPrivateFieldGet5(this, _indexProxies)[controller];
    if (proxy == null) {
      proxy = new TileProxy(
        async () => await this._getOwnIDXDoc(controller)
      );
      _classPrivateFieldGet5(this, _indexProxies)[controller] = proxy;
    }
    return proxy;
  }
  getDefinitionID(aliasOrID) {
    return _classPrivateFieldGet5(this, _model).getDefinitionID(aliasOrID) ?? aliasOrID;
  }
  async getDefinition(id2) {
    const doc = await _classPrivateFieldGet5(this, _loader2).load(id2);
    if (doc.metadata.schema !== CIP11_DEFINITION_SCHEMA_URL) {
      throw new Error("Invalid document: schema is not Definition");
    }
    return {
      ...doc.content,
      id: doc.id
    };
  }
  async getRecordID(definitionID, did) {
    const index = await this.getIndex(did ?? this.id);
    return index?.[definitionID] ?? null;
  }
  async getRecordDocument(definitionID, did) {
    const id2 = await this.getRecordID(definitionID, did);
    return id2 ? await _classPrivateFieldGet5(this, _loader2).load(id2) : null;
  }
  async getRecord(definitionID, did) {
    const doc = await this.getRecordDocument(definitionID, did);
    return doc ? doc.content : null;
  }
  async setRecord(definitionID, content, options = {}) {
    const [created, id2] = await this._setRecordOnly(definitionID, content, options);
    if (created) {
      await this._setReference(options.controller ?? this.id, definitionID, id2);
    }
    return id2;
  }
  async _setRecordOnly(definitionID, content, options) {
    const existing = await this.getRecordID(definitionID, options.controller ?? this.id);
    if (existing == null) {
      const definition = await this.getDefinition(definitionID);
      const ref = await this._createRecord(definition, content, options);
      return [
        true,
        ref
      ];
    } else {
      const doc = await _classPrivateFieldGet5(this, _loader2).update(existing, content);
      return [
        false,
        doc.id
      ];
    }
  }
  async _createRecord(definition, content, { controller, pin }) {
    const doc = await _classPrivateFieldGet5(this, _loader2).deterministic({
      controllers: [
        controller ?? this.id
      ],
      family: definition.id.toString()
    }, {
      pin
    });
    await doc.update(content, {
      schema: definition.schema
    });
    return doc.id;
  }
  async _setReference(controller, definitionID, id2) {
    await this._getIndexProxy(controller).changeContent((index) => {
      return {
        ...index,
        [definitionID]: id2.toUrl()
      };
    });
  }
  async _setReferences(controller, references) {
    if (Object.keys(references).length !== 0) {
      await this._getIndexProxy(controller).changeContent((index) => {
        return {
          ...index,
          ...references
        };
      });
    }
  }
  constructor(params) {
    _classPrivateFieldInit5(this, _ceramic2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit5(this, _id, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit5(this, _indexProxies, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInit5(this, _loader2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit5(this, _model, {
      writable: true,
      value: void 0
    });
    const { cache, ceramic, id: id2, loader, model } = params;
    _classPrivateFieldSet5(this, _ceramic2, ceramic);
    _classPrivateFieldSet5(this, _id, id2);
    _classPrivateFieldSet5(this, _loader2, loader ?? new TileLoader({
      ceramic,
      cache
    }));
    _classPrivateFieldSet5(this, _model, model instanceof DataModel ? model : new DataModel({
      loader: _classPrivateFieldGet5(this, _loader2),
      aliases: model
    }));
  }
}, "DIDDataStore");
__name2(DIDDataStore, "DIDDataStore");
var CredentialsListValidator = mod.object({
  credentials: CredentialRecordValidator.array()
}).catchall(mod.any());
var BackwardsCompatIDXCredentialValidator = mod.object({ id: mod.string(), title: mod.string(), storageType: mod.literal("ceramic").optional() }).catchall(mod.any());
var BackwardsCompatCredentialsListValidator = mod.object({
  credentials: CredentialRecordValidator.or(BackwardsCompatIDXCredentialValidator).array()
}).strict();
var getIDXPlugin = /* @__PURE__ */ __name2(async (learnCard, { modelData, credentialAlias }) => {
  const ceramic = learnCard.invoke.getCeramicClient();
  const dataStore = new DIDDataStore({ ceramic, model: modelData });
  const getCredentialsListFromIdx = /* @__PURE__ */ __name2(async (alias = credentialAlias) => {
    const list = await dataStore.get(alias);
    if (!list)
      return { credentials: [] };
    const validationResult = await CredentialsListValidator.spa(list);
    if (validationResult.success)
      return validationResult.data;
    const backwardsCompatValidationResult = await BackwardsCompatCredentialsListValidator.spa(
      list
    );
    if (backwardsCompatValidationResult.success) {
      const oldCreds = backwardsCompatValidationResult.data.credentials;
      const newCreds = oldCreds.map((cred) => {
        if ("uri" in cred)
          return cred;
        const { title, id: id2, storageType, ...rest } = cred;
        return {
          ...rest,
          id: title,
          uri: `lc:ceramic:${id2.replace("ceramic://", "")}`
        };
      });
      const credentialsList = { credentials: newCreds };
      await dataStore.set(credentialAlias, credentialsList);
      return credentialsList;
    }
    console.error(validationResult.error);
    throw new Error("Invalid credentials list stored in IDX");
  }, "getCredentialsListFromIdx");
  const removeCredentialFromIdx = /* @__PURE__ */ __name2(async (id2, alias) => {
    if (!id2)
      throw new Error("Must provide id to remove");
    if (!alias)
      alias = credentialAlias;
    const existing = await getCredentialsListFromIdx(alias);
    existing.credentials = existing.credentials.filter((credential) => credential.id !== id2);
    return dataStore.set(alias, existing);
  }, "removeCredentialFromIdx");
  const removeAllCredentialsFromIdx = /* @__PURE__ */ __name2(async (alias) => {
    if (!alias)
      alias = credentialAlias;
    return dataStore.set(alias, { credentials: [] });
  }, "removeAllCredentialsFromIdx");
  const addCredentialInIdx = /* @__PURE__ */ __name2(async (_record) => {
    const record = await CredentialRecordValidator.parseAsync(_record);
    if (!record)
      throw new Error("record is required");
    if (!record.uri)
      throw Error("No URI provided");
    await learnCard.read.get(record.uri);
    const existing = await getCredentialsListFromIdx(credentialAlias);
    const indexOfExistingCredential = existing.credentials.findIndex((credential) => {
      return credential.id === record.id;
    });
    if (indexOfExistingCredential > -1) {
      existing.credentials[indexOfExistingCredential] = record;
    } else
      existing.credentials.push(record);
    return streamIdToCeramicURI(await dataStore.set(credentialAlias, existing));
  }, "addCredentialInIdx");
  const addCredentialsInIdx = /* @__PURE__ */ __name2(async (_records) => {
    const records = CredentialRecordValidator.array().parse(_records);
    const existing = await getCredentialsListFromIdx(credentialAlias);
    await Promise.all(
      records.map(async (record) => {
        await learnCard.read.get(record.uri);
        const indexOfExistingCredential = existing.credentials.findIndex((credential) => {
          return credential.id === record.id;
        });
        if (indexOfExistingCredential > -1) {
          existing.credentials[indexOfExistingCredential] = record;
        } else
          existing.credentials.push(record);
      })
    );
    return streamIdToCeramicURI(await dataStore.set(credentialAlias, existing));
  }, "addCredentialsInIdx");
  return {
    name: "IDX",
    displayName: "IDX",
    description: "Stores a bespoke index of credentials for an individual based on their did",
    index: {
      get: async (_learnCard) => {
        _learnCard.debug?.("learnCard.index.IDX.get");
        const list = await getCredentialsListFromIdx();
        return list.credentials;
      },
      add: async (_learnCard, record) => {
        _learnCard.debug?.("learnCard.index.IDX.add");
        try {
          await addCredentialInIdx(record);
          return true;
        } catch (error) {
          console.error("Error adding credential with IDX:", error);
          return false;
        }
      },
      addMany: async (_learnCard, records) => {
        _learnCard.debug?.("learnCard.index.IDX.add");
        try {
          await addCredentialsInIdx(records);
          return true;
        } catch (error) {
          console.error("Error adding credential with IDX:", error);
          return false;
        }
      },
      update: async (_learnCard) => {
        _learnCard.debug?.("learnCard.index.IDX.update");
        return false;
      },
      remove: async (_learnCard, id2) => {
        _learnCard.debug?.("learnCard.index.IDX.remove");
        try {
          await removeCredentialFromIdx(id2);
          return true;
        } catch (error) {
          console.error("Error removing credential from IDX:", error);
          return false;
        }
      },
      removeAll: async (_learnCard) => {
        _learnCard.debug?.("learnCard.index.IDX.removeAll");
        try {
          await removeAllCredentialsFromIdx();
          return true;
        } catch (error) {
          console.error("Error removing credentials from IDX:", error);
          return false;
        }
      }
    },
    methods: {
      getCredentialsListFromIdx: async (_learnCard, alias = credentialAlias) => (await getCredentialsListFromIdx(alias)).credentials,
      getVerifiableCredentialFromIdx: async (_learnCard, id2) => {
        const credentialList = await getCredentialsListFromIdx();
        const credential = credentialList?.credentials?.find((cred) => cred?.id === id2);
        const result = _learnCard.read.get(credential?.uri);
        const validationResult = await VCValidator.safeParseAsync(result);
        return validationResult.success ? validationResult.data : void 0;
      },
      getVerifiableCredentialsFromIdx: async (_learnCard) => {
        const credentialList = await getCredentialsListFromIdx();
        const uris = credentialList?.credentials?.map((credential) => credential?.uri) ?? [];
        return (await Promise.all(uris.map(async (uri) => _learnCard.read.get(uri)))).filter(
          (vc) => !!vc
        );
      },
      addVerifiableCredentialInIdx: async (_learnCard, idxCredential) => {
        const record = CredentialRecordValidator.parse(idxCredential);
        if (!record)
          throw new Error("record is required");
        if (!record.uri)
          throw Error("No URI provided");
        await _learnCard.read.get(record.uri);
        const existing = await getCredentialsListFromIdx(credentialAlias);
        const indexOfExistingCredential = existing.credentials.findIndex((credential) => {
          return credential.id === record.id;
        });
        if (indexOfExistingCredential > -1) {
          existing.credentials[indexOfExistingCredential] = record;
        } else
          existing.credentials.push(record);
        return streamIdToCeramicURI(await dataStore.set(credentialAlias, existing));
      },
      removeVerifiableCredentialInIdx: async (_learnCard, id2) => {
        return removeCredentialFromIdx(id2);
      },
      removeAllVerifiableCredentialsInIdx: async () => {
        return removeAllCredentialsFromIdx();
      },
      getIDXIndex: async () => dataStore.get(credentialAlias),
      setIDXIndex: async (_learnCard, index) => dataStore.set(credentialAlias, index)
    }
  };
}, "getIDXPlugin");
var import_buffer = __toESM2(require_buffer22());
var isAddress2 = /* @__PURE__ */ __name2((maybeAddress) => {
  return maybeAddress.startsWith("0x") && maybeAddress.length === 42;
}, "isAddress");
var formatUnits2 = /* @__PURE__ */ __name2(async (units, symbolOrAddress, tokenList, chainId) => {
  const token = await getTokenFromSymbolOrAddress(symbolOrAddress, tokenList, chainId);
  return ethers_exports.utils.formatUnits(units, token?.decimals);
}, "formatUnits");
var parseUnits2 = /* @__PURE__ */ __name2(async (units, symbolOrAddress, tokenList, chainId) => {
  const token = await getTokenFromSymbolOrAddress(symbolOrAddress, tokenList, chainId);
  return ethers_exports.utils.parseUnits(units, token?.decimals);
}, "parseUnits");
var getTokenFromSymbolOrAddress = /* @__PURE__ */ __name2(async (symbolOrAddress, tokenList, chainId) => {
  let token;
  if (isAddress2(symbolOrAddress)) {
    token = await getTokenFromAddress(symbolOrAddress, tokenList, chainId);
  } else {
    token = await getTokenFromSymbol(symbolOrAddress, tokenList, chainId);
  }
  return token;
}, "getTokenFromSymbolOrAddress");
var getTokenFromAddress = /* @__PURE__ */ __name2(async (address, tokenList, chainId) => {
  const token = tokenList.find((token2) => token2.chainId === chainId && token2.address === address);
  return token;
}, "getTokenFromAddress");
var getTokenFromSymbol = /* @__PURE__ */ __name2(async (symbol, tokenList, chainId) => {
  const token = tokenList.find(
    (token2) => token2.chainId === chainId && token2.symbol.toUpperCase() === symbol.toUpperCase()
  );
  return token;
}, "getTokenFromSymbol");
var getChainIdFromProvider = /* @__PURE__ */ __name2(async (provider) => {
  return (await provider.getNetwork()).chainId;
}, "getChainIdFromProvider");
var hardcodedTokens = [
  {
    name: "USDCoin",
    address: "0x07865c6e87b9f70255377e024ace6630c1eaa37f",
    symbol: "USDC",
    decimals: 6,
    chainId: 5,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    extensions: {
      bridgeInfo: {
        "10": {
          tokenAddress: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
        },
        "137": {
          tokenAddress: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        },
        "42161": {
          tokenAddress: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8"
        }
      }
    }
  }
];
var hardcodedTokens_default = hardcodedTokens;
var ERC20ABI = require_erc20_abi();
var getEthereumPlugin = /* @__PURE__ */ __name2((initLearnCard2, config2) => {
  let { infuraProjectId, network = "mainnet" } = config2;
  const secpKeypair = initLearnCard2.id.keypair("secp256k1");
  if (!secpKeypair) {
    throw new Error("LearnCard must support secp256k1 JWK in order to add Ethereum Plugin");
  }
  const privateKey = import_buffer.Buffer.from(secpKeypair.d, "base64").toString("hex");
  let ethersWallet = new ethers_exports.Wallet(privateKey);
  const publicKey = ethersWallet.address;
  const getProvider = /* @__PURE__ */ __name2(() => {
    let provider2;
    if (infuraProjectId) {
      provider2 = new ethers_exports.providers.InfuraProvider(network, infuraProjectId);
    } else {
      provider2 = ethers_exports.getDefaultProvider(network);
    }
    ethersWallet = ethersWallet.connect(provider2);
    return provider2;
  }, "getProvider");
  let provider = getProvider();
  const getDefaultTokenList = /* @__PURE__ */ __name2(() => {
    return require_uniswap_default_tokenlist().tokens.concat(
      hardcodedTokens_default
    );
  }, "getDefaultTokenList");
  const defaultTokenList = getDefaultTokenList();
  const getTokenAddress = /* @__PURE__ */ __name2(async (tokenSymbolOrAddress) => {
    return (await getTokenFromSymbolOrAddress(
      tokenSymbolOrAddress,
      defaultTokenList,
      await getChainIdFromProvider(provider)
    ))?.address;
  }, "getTokenAddress");
  const getErc20TokenBalance = /* @__PURE__ */ __name2(async (tokenContractAddress, walletPublicAddress = publicKey) => {
    const contract = new ethers_exports.Contract(tokenContractAddress, ERC20ABI, provider);
    const balance = await contract.balanceOf(walletPublicAddress);
    const formattedBalance = formatUnits2(
      balance,
      tokenContractAddress,
      defaultTokenList,
      await getChainIdFromProvider(provider)
    );
    return formattedBalance;
  }, "getErc20TokenBalance");
  const getBalance = /* @__PURE__ */ __name2(async (walletAddress = publicKey, tokenSymbolOrAddress = "ETH") => {
    if (!tokenSymbolOrAddress || tokenSymbolOrAddress === "ETH") {
      const balance2 = await provider.getBalance(walletAddress);
      const formattedBalance = ethers_exports.utils.formatEther(balance2);
      return formattedBalance;
    }
    const tokenAddress = await getTokenAddress(tokenSymbolOrAddress);
    if (!tokenAddress) {
      throw new Error(`Unable to determine token address for "${tokenSymbolOrAddress}"`);
    }
    const balance = await getErc20TokenBalance(tokenAddress, walletAddress);
    return balance;
  }, "getBalance");
  return {
    name: "Ethereum",
    displayName: "Ethereum",
    description: "Provides access to currency",
    methods: {
      getEthereumAddress: () => publicKey,
      getBalance: async (_learnCard, symbolOrAddress = "ETH") => getBalance(publicKey, symbolOrAddress),
      getBalanceForAddress: async (_learnCard, walletAddress, symbolOrAddress) => getBalance(walletAddress, symbolOrAddress),
      transferTokens: async (_learnCard, tokenSymbolOrAddress, amount, toAddress) => {
        if (tokenSymbolOrAddress === "ETH") {
          const transaction = {
            to: toAddress,
            value: ethers_exports.utils.parseEther(amount.toString())
          };
          return (await ethersWallet.sendTransaction(transaction)).hash;
        }
        const tokenAddress = await getTokenAddress(tokenSymbolOrAddress);
        if (!tokenAddress) {
          throw new Error(
            `Unable to determine token address for "${tokenSymbolOrAddress}"`
          );
        }
        const tokenContract = new ethers_exports.Contract(tokenAddress, ERC20ABI, ethersWallet);
        return (await tokenContract.transfer(
          toAddress,
          await parseUnits2(
            amount.toString(),
            tokenContract.address,
            defaultTokenList,
            await getChainIdFromProvider(provider)
          )
        )).hash;
      },
      getGasPrice: async () => {
        return ethers_exports.utils.formatUnits(await provider.getGasPrice());
      },
      getCurrentNetwork: () => {
        return network;
      },
      changeNetwork: (_learnCard, _network) => {
        const oldNetwork = network;
        try {
          network = _network;
          provider = getProvider();
        } catch (e2) {
          network = oldNetwork;
          provider = getProvider();
          throw e2;
        }
      },
      addInfuraProjectId: (_learnCard, infuraProjectIdToAdd) => {
        infuraProjectId = infuraProjectIdToAdd;
        provider = getProvider();
      }
    }
  };
}, "getEthereumPlugin");
var CborldError = /* @__PURE__ */ __name(class extends Error {
  constructor(value, message) {
    super();
    this.message = message;
    this.value = value;
    this.stack = new Error(`${value}: ${message}`).stack;
    this.name = this.constructor.name;
  }
}, "CborldError");
__name2(CborldError, "CborldError");
var CborldDecoder = /* @__PURE__ */ __name(class {
  decode({ value } = {}) {
    throw new Error("Must be implemented by derived class.");
  }
  static createDecoder({ value, transformer } = {}) {
    throw new Error("Must be implemented by derived class.");
  }
}, "CborldDecoder");
__name2(CborldDecoder, "CborldDecoder");
var ID_TO_URL = /* @__PURE__ */ new Map();
var URL_TO_ID = /* @__PURE__ */ new Map();
_addRegistration(16, "https://www.w3.org/ns/activitystreams");
_addRegistration(17, "https://www.w3.org/2018/credentials/v1");
_addRegistration(18, "https://www.w3.org/ns/did/v1");
_addRegistration(19, "https://w3id.org/security/suites/ed25519-2018/v1");
_addRegistration(20, "https://w3id.org/security/suites/ed25519-2020/v1");
_addRegistration(21, "https://w3id.org/cit/v1");
_addRegistration(22, "https://w3id.org/age/v1");
_addRegistration(23, "https://w3id.org/security/suites/x25519-2020/v1");
_addRegistration(24, "https://w3id.org/veres-one/v1");
_addRegistration(25, "https://w3id.org/webkms/v1");
_addRegistration(26, "https://w3id.org/zcap/v1");
_addRegistration(27, "https://w3id.org/security/suites/hmac-2019/v1");
_addRegistration(28, "https://w3id.org/security/suites/aes-2019/v1");
_addRegistration(29, "https://w3id.org/vaccination/v1");
_addRegistration(30, "https://w3id.org/vc-revocation-list-2020/v1");
_addRegistration(31, "https://w3id.org/dcc/v1c");
_addRegistration(32, "https://w3id.org/vc/status-list/v1");
function _addRegistration(id2, url) {
  URL_TO_ID.set(url, id2);
  ID_TO_URL.set(id2, url);
}
__name(_addRegistration, "_addRegistration");
__name2(_addRegistration, "_addRegistration");
var ContextDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  constructor({ reverseAppContextMap } = {}) {
    super();
    this.reverseAppContextMap = reverseAppContextMap;
  }
  decode({ value } = {}) {
    if (typeof value !== "number") {
      return _mapToObject(value);
    }
    const url = ID_TO_URL.get(value) || this.reverseAppContextMap.get(value);
    if (url === void 0) {
      throw new CborldError(
        "ERR_UNDEFINED_COMPRESSED_CONTEXT",
        `Undefined compressed context "${value}".`
      );
    }
    return url;
  }
  static createDecoder({ transformer } = {}) {
    const { reverseAppContextMap } = transformer;
    return new ContextDecoder({ reverseAppContextMap });
  }
}, "ContextDecoder");
__name2(ContextDecoder, "ContextDecoder");
function _mapToObject(map2) {
  if (Array.isArray(map2)) {
    return map2.map(_mapToObject);
  }
  if (!(map2 instanceof Map)) {
    return map2;
  }
  const obj = {};
  for (const [key22, value] of map2) {
    obj[key22] = _mapToObject(value);
  }
  return obj;
}
__name(_mapToObject, "_mapToObject");
__name2(_mapToObject, "_mapToObject");
var version112 = "3.7.5";
var VERSION = version112;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a3) => {
  let tab = {};
  a3.forEach((c2, i22) => tab[c2] = i22);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = /* @__PURE__ */ __name2((src2) => src2.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_"), "_mkUriSafe");
var _tidyB64 = /* @__PURE__ */ __name2((s3) => s3.replace(/[^A-Za-z0-9\+\/]/g, ""), "_tidyB64");
var btoaPolyfill = /* @__PURE__ */ __name2((bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad2 = bin.length % 3;
  for (let i22 = 0; i22 < bin.length; ) {
    if ((c0 = bin.charCodeAt(i22++)) > 255 || (c1 = bin.charCodeAt(i22++)) > 255 || (c2 = bin.charCodeAt(i22++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad2 ? asc.slice(0, pad2 - 3) + "===".substring(pad2) : asc;
}, "btoaPolyfill");
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i22 = 0, l = u8a.length; i22 < l; i22 += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i22, i22 + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = /* @__PURE__ */ __name2((u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a), "fromUint8Array");
var cb_utob = /* @__PURE__ */ __name2((c2) => {
  if (c2.length < 2) {
    var cc = c2.charCodeAt(0);
    return cc < 128 ? c2 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
}, "cb_utob");
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = /* @__PURE__ */ __name2((u2) => u2.replace(re_utob, cb_utob), "utob");
var _encode22 = _hasBuffer ? (s3) => Buffer.from(s3, "utf8").toString("base64") : _TE ? (s3) => _fromUint8Array(_TE.encode(s3)) : (s3) => _btoa(utob(s3));
var encode9 = /* @__PURE__ */ __name2((src2, urlsafe = false) => urlsafe ? _mkUriSafe(_encode22(src2)) : _encode22(src2), "encode");
var encodeURI2 = /* @__PURE__ */ __name2((src2) => encode9(src2, true), "encodeURI");
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = /* @__PURE__ */ __name2((cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
}, "cb_btou");
var btou = /* @__PURE__ */ __name2((b2) => b2.replace(re_btou, cb_btou), "btou");
var atobPolyfill = /* @__PURE__ */ __name2((asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i22 = 0; i22 < asc.length; ) {
    u24 = b64tab[asc.charAt(i22++)] << 18 | b64tab[asc.charAt(i22++)] << 12 | (r1 = b64tab[asc.charAt(i22++)]) << 6 | (r2 = b64tab[asc.charAt(i22++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
}, "atobPolyfill");
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a3) => _U8Afrom(Buffer.from(a3, "base64")) : (a3) => _U8Afrom(_atob(a3).split("").map((c2) => c2.charCodeAt(0)));
var toUint8Array2 = /* @__PURE__ */ __name2((a3) => _toUint8Array(_unURI(a3)), "toUint8Array");
var _decode2 = _hasBuffer ? (a3) => Buffer.from(a3, "base64").toString("utf8") : _TD ? (a3) => _TD.decode(_toUint8Array(a3)) : (a3) => btou(_atob(a3));
var _unURI = /* @__PURE__ */ __name2((a3) => _tidyB64(a3.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/")), "_unURI");
var decode9 = /* @__PURE__ */ __name2((src2) => _decode2(_unURI(src2)), "decode");
var isValid3 = /* @__PURE__ */ __name2((src2) => {
  if (typeof src2 !== "string")
    return false;
  const s3 = src2.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s3) || !/[^\s0-9a-zA-Z\-_]/.test(s3);
}, "isValid");
var _noEnum = /* @__PURE__ */ __name2((v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
}, "_noEnum");
var extendString = /* @__PURE__ */ __name2(function() {
  const _add = /* @__PURE__ */ __name2((name3, body) => Object.defineProperty(String.prototype, name3, _noEnum(body)), "_add");
  _add("fromBase64", function() {
    return decode9(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode9(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode9(this, true);
  });
  _add("toBase64URL", function() {
    return encode9(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array2(this);
  });
}, "extendString");
var extendUint8Array = /* @__PURE__ */ __name2(function() {
  const _add = /* @__PURE__ */ __name2((name3, body) => Object.defineProperty(Uint8Array.prototype, name3, _noEnum(body)), "_add");
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
}, "extendUint8Array");
var extendBuiltins = /* @__PURE__ */ __name2(() => {
  extendString();
  extendUint8Array();
}, "extendBuiltins");
var gBase64 = {
  version: version112,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode9,
  toBase64: encode9,
  encode: encode9,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode: decode9,
  isValid: isValid3,
  fromUint8Array,
  toUint8Array: toUint8Array2,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var _reverseAlphabets = {};
function encode10(input, alphabet3, maxline) {
  if (!(input instanceof Uint8Array)) {
    throw new TypeError('"input" must be a Uint8Array.');
  }
  if (typeof alphabet3 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== void 0 && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  if (input.length === 0) {
    return "";
  }
  let output = "";
  let i22 = 0;
  const base4 = alphabet3.length;
  const first2 = alphabet3.charAt(0);
  const digits = [0];
  for (i22 = 0; i22 < input.length; ++i22) {
    let carry = input[i22];
    for (let j = 0; j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base4;
      carry = carry / base4 | 0;
    }
    while (carry > 0) {
      digits.push(carry % base4);
      carry = carry / base4 | 0;
    }
  }
  for (i22 = 0; input[i22] === 0 && i22 < input.length - 1; ++i22) {
    output += first2;
  }
  for (i22 = digits.length - 1; i22 >= 0; --i22) {
    output += alphabet3[digits[i22]];
  }
  if (maxline) {
    const regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join("\r\n");
  }
  return output;
}
__name(encode10, "encode10");
__name2(encode10, "encode");
function decode10(input, alphabet3) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet3 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (input.length === 0) {
    return new Uint8Array();
  }
  let table = _reverseAlphabets[alphabet3];
  if (!table) {
    table = _reverseAlphabets[alphabet3] = [];
    for (let i22 = 0; i22 < alphabet3.length; ++i22) {
      table[alphabet3.charCodeAt(i22)] = i22;
    }
  }
  input = input.replace(/\s/g, "");
  const base4 = alphabet3.length;
  const first2 = alphabet3.charAt(0);
  const bytes = [0];
  for (let i22 = 0; i22 < input.length; i22++) {
    const value = table[input.charCodeAt(i22)];
    if (value === void 0) {
      return;
    }
    let carry = value;
    for (let j = 0; j < bytes.length; ++j) {
      carry += bytes[j] * base4;
      bytes[j] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes.push(carry & 255);
      carry >>= 8;
    }
  }
  for (let k2 = 0; input[k2] === first2 && k2 < input.length - 1; ++k2) {
    bytes.push(0);
  }
  return new Uint8Array(bytes.reverse());
}
__name(decode10, "decode10");
__name2(decode10, "decode");
var alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encode11(input, maxline) {
  return encode10(input, alphabet2, maxline);
}
__name(encode11, "encode11");
__name2(encode11, "encode");
function decode11(input) {
  return decode10(input, alphabet2);
}
__name(decode11, "decode11");
__name2(decode11, "decode");
var MultibaseDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  decode({ value } = {}) {
    const { buffer: buffer2, byteOffset, length: length2 } = value;
    const suffix = new Uint8Array(buffer2, byteOffset + 1, length2 - 1);
    if (value[0] === 122) {
      return `z${encode11(suffix)}`;
    }
    if (value[0] === 77) {
      return `M${gBase64.fromUint8Array(suffix)}`;
    }
    return value;
  }
  static createDecoder({ value } = {}) {
    if (!(value instanceof Uint8Array)) {
      return false;
    }
    if (value[0] === 122 || value[0] === 77) {
      return new MultibaseDecoder();
    }
  }
}, "MultibaseDecoder");
__name2(MultibaseDecoder, "MultibaseDecoder");
var KEYWORDS = /* @__PURE__ */ new Map([
  ["@context", 0],
  ["@type", 2],
  ["@id", 4],
  ["@value", 6],
  ["@direction", 8],
  ["@graph", 10],
  ["@included", 12],
  ["@index", 14],
  ["@json", 16],
  ["@language", 18],
  ["@list", 20],
  ["@nest", 22],
  ["@reverse", 24],
  ["@base", 26],
  ["@container", 28],
  ["@default", 30],
  ["@embed", 32],
  ["@explicit", 34],
  ["@none", 36],
  ["@omitDefault", 38],
  ["@prefix", 40],
  ["@preserve", 42],
  ["@protected", 44],
  ["@requireAll", 46],
  ["@set", 48],
  ["@version", 50],
  ["@vocab", 52]
]);
var FIRST_CUSTOM_TERM_ID = 100;
var Transformer = /* @__PURE__ */ __name(class {
  constructor({ appContextMap, documentLoader } = {}) {
    this.appContextMap = appContextMap;
    this.documentLoader = documentLoader;
  }
  _beforeObjectContexts() {
  }
  _afterObjectContexts() {
  }
  _beforeTypeScopedContexts() {
  }
  async _transform({ obj, transformMap, contextStack = [] }) {
    this._beforeObjectContexts({ obj, transformMap });
    let activeCtx = await this._applyEmbeddedContexts({ obj, contextStack });
    this._afterObjectContexts({ obj, transformMap });
    const childContextStack = contextStack.slice();
    this._beforeTypeScopedContexts({ activeCtx, obj, transformMap });
    activeCtx = await this._applyTypeScopedContexts({ obj, contextStack });
    const { aliases, scopedContextMap, termMap } = activeCtx;
    const termEntries = this._getEntries(
      { obj, transformMap, transformer: this, termMap }
    );
    for (const [termInfo, value] of termEntries) {
      const { term } = termInfo;
      if (term === "@id" || aliases.id.has(term)) {
        this._transformObjectId({ obj, transformMap, termInfo, value });
        continue;
      }
      if (term === "@type" || aliases.type.has(term)) {
        this._transformObjectType({ obj, transformMap, termInfo, value });
        continue;
      }
      let propertyContextStack = childContextStack;
      let newActiveCtx;
      const propertyScopedContext = scopedContextMap.get(term);
      if (propertyScopedContext) {
        newActiveCtx = await this._applyEmbeddedContexts({
          obj: { "@context": propertyScopedContext },
          contextStack
        });
        propertyContextStack = contextStack.slice();
      }
      const { plural, def } = termInfo;
      const termType = this._getTermType(
        { activeCtx: newActiveCtx || activeCtx, def }
      );
      const values = plural ? value : [value];
      const entries = [];
      for (const value2 of values) {
        if (value2 === null) {
          entries.push(null);
          continue;
        }
        if (this._transformTypedValue({ entries, termType, value: value2, termInfo })) {
          continue;
        }
        if (typeof value2 !== "object") {
          entries.push(value2);
          continue;
        }
        if (Array.isArray(value2)) {
          await this._transformArray(
            { entries, contextStack: propertyContextStack, value: value2 }
          );
          continue;
        }
        await this._transformObject({
          entries,
          contextStack: propertyContextStack,
          value: value2
        });
      }
      if (newActiveCtx) {
        newActiveCtx.revert();
      }
      this._assignEntries({ entries, obj, transformMap, termInfo });
    }
    activeCtx.revert();
  }
  async _applyEmbeddedContexts({ obj, contextStack }) {
    const stackTop = contextStack.length;
    const localContexts = obj["@context"];
    await this._updateContextStack({ contextStack, contexts: localContexts });
    let active = contextStack[contextStack.length - 1];
    if (!active) {
      active = {
        aliases: {
          id: /* @__PURE__ */ new Set(),
          type: /* @__PURE__ */ new Set()
        },
        context: {},
        scopedContextMap: /* @__PURE__ */ new Map(),
        termMap: /* @__PURE__ */ new Map()
      };
    }
    return {
      ...active,
      revert() {
        contextStack.length = stackTop;
      }
    };
  }
  async _applyTypeScopedContexts({ obj, contextStack }) {
    const stackTop = contextStack.length;
    let active = contextStack[contextStack.length - 1];
    if (!active) {
      active = {
        aliases: {
          id: /* @__PURE__ */ new Set(),
          type: /* @__PURE__ */ new Set()
        },
        context: {},
        scopedContextMap: /* @__PURE__ */ new Map(),
        termMap: /* @__PURE__ */ new Map()
      };
    }
    const { aliases } = active;
    let totalTypes = [];
    const typeTerms = ["@type", ...aliases.type];
    for (const term of typeTerms) {
      const types = obj[term];
      if (Array.isArray(types)) {
        totalTypes.push(...types);
      } else {
        totalTypes.push(types);
      }
    }
    totalTypes = [...new Set(totalTypes)].sort();
    let { scopedContextMap } = active;
    for (const type of totalTypes) {
      const contexts = scopedContextMap.get(type);
      if (contexts) {
        await this._updateContextStack({ contextStack, contexts });
        active = contextStack[contextStack.length - 1];
        ({ scopedContextMap } = active);
      }
    }
    return {
      ...active,
      revert() {
        contextStack.length = stackTop;
      }
    };
  }
  async _updateContextStack({ contextStack, contexts, transformer }) {
    if (!contexts) {
      return;
    }
    if (!Array.isArray(contexts)) {
      contexts = [contexts];
    }
    const { contextMap } = this;
    for (const context2 of contexts) {
      let entry = contextMap.get(context2);
      if (!entry) {
        let ctx = context2;
        let contextUrl;
        if (typeof context2 === "string") {
          contextUrl = context2;
          ({ "@context": ctx } = await this._getDocument({ url: contextUrl }));
        }
        entry = await this._addContext({ context: ctx, contextUrl, transformer });
      }
      const newActive = {
        aliases: {
          id: new Set(entry.aliases.id),
          type: new Set(entry.aliases.type)
        },
        context: context2,
        scopedContextMap: new Map(entry.scopedContextMap),
        termMap: new Map(entry.termMap)
      };
      const oldActive = contextStack[contextStack.length - 1];
      contextStack.push(newActive);
      if (!oldActive) {
        continue;
      }
      const { aliases, termMap } = newActive;
      for (const key22 of ["id", "type"]) {
        for (const alias of oldActive.aliases[key22]) {
          if (!(context2[alias] === null || newActive.termMap.has(alias))) {
            aliases[key22].add(alias);
          }
        }
      }
      const { scopedContextMap } = newActive;
      for (const [key22, value] of oldActive.scopedContextMap) {
        if (!(context2[key22] === null || scopedContextMap.has(key22))) {
          scopedContextMap.set(key22, value);
        }
      }
      for (const [key22, value] of oldActive.termMap) {
        if (!(context2[key22] === null || termMap.has(key22))) {
          termMap.set(key22, value);
        }
      }
    }
  }
  async _addContext({ context: context2, contextUrl }) {
    const { contextMap, termToId, idToTerm } = this;
    const importUrl = context2["@import"];
    if (importUrl) {
      let importEntry = contextMap.get(importUrl);
      if (!importEntry) {
        const { "@context": importCtx } = await this._getDocument(
          { url: importUrl }
        );
        importEntry = await this._addContext(
          { context: importCtx, contextUrl: importUrl }
        );
      }
      context2 = { ...importEntry.context, ...context2 };
    }
    const scopedContextMap = /* @__PURE__ */ new Map();
    const termMap = /* @__PURE__ */ new Map();
    const entry = {
      aliases: { id: /* @__PURE__ */ new Set(), type: /* @__PURE__ */ new Set() },
      context: context2,
      scopedContextMap,
      termMap
    };
    const keys = Object.keys(context2).sort();
    for (const key22 of keys) {
      const def = context2[key22];
      if (!def) {
        continue;
      }
      if (def === "@id" || def.id === "@id") {
        entry.aliases.id.add(key22);
      } else if (def === "@type" || def.id === "@type") {
        entry.aliases.type.add(key22);
      }
      if (KEYWORDS.has(key22)) {
        continue;
      }
      if (!termToId.has(key22)) {
        const id2 = this.nextTermId;
        this.nextTermId += 2;
        termToId.set(key22, id2);
        if (idToTerm) {
          idToTerm.set(id2, key22);
        }
      }
      termMap.set(key22, def);
      const scopedContext = def["@context"];
      if (scopedContext) {
        scopedContextMap.set(key22, scopedContext);
      }
    }
    contextMap.set(contextUrl || context2, entry);
    return entry;
  }
  async _getDocument({ url }) {
    const { document: document2 } = await this.documentLoader(url);
    if (typeof document2 === "string") {
      return JSON.parse(document2);
    }
    return document2;
  }
  _getTermType({ activeCtx, def }) {
    const { "@type": type } = def;
    if (!type) {
      return;
    }
    const [prefix, ...suffix] = type.split(":");
    const prefixDef = activeCtx.termMap.get(prefix);
    if (prefixDef === void 0) {
      return type;
    }
    if (typeof prefixDef === "string") {
      return prefixDef + suffix.join(":");
    }
    if (!(typeof prefixDef === "object" && typeof prefixDef["@id"] === "string")) {
      throw new CborldError(
        "ERR_INVALID_TERM_DEFINITION",
        'JSON-LD term definitions must be strings or objects with "@id".'
      );
    }
    return prefixDef["@id"] + suffix.join(":");
  }
  _getIdForTerm({ term, plural }) {
    const id2 = this.termToId.get(term);
    if (id2 === void 0) {
      throw new CborldError(
        "ERR_UNDEFINED_TERM",
        "CBOR-LD compression requires all terms to be defined in a JSON-LD context."
      );
    }
    return plural ? id2 + 1 : id2;
  }
  _getTermForId({ id: id2 }) {
    const plural = (id2 & 1) === 1;
    const term = this.idToTerm.get(plural ? id2 - 1 : id2);
    return { term, plural };
  }
}, "Transformer");
__name2(Transformer, "Transformer");
var ID_TO_SCHEME = /* @__PURE__ */ new Map([
  [1024, "did:v1:nym:"],
  [1025, "did:key:"]
]);
var Base58DidUrlDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  decode({ value } = {}) {
    let url = ID_TO_SCHEME.get(value[0]);
    if (typeof value[1] === "string") {
      url += value[1];
    } else {
      url += `z${encode11(value[1])}`;
    }
    if (value.length > 2) {
      if (typeof value[2] === "string") {
        url += `#${value[2]}`;
      } else {
        url += `#z${encode11(value[2])}`;
      }
    }
    return url;
  }
  static createDecoder({ value } = {}) {
    if (!(Array.isArray(value) && value.length > 1 && value.length <= 3)) {
      return false;
    }
    if (!ID_TO_SCHEME.has(value[0])) {
      return false;
    }
    return new Base58DidUrlDecoder();
  }
}, "Base58DidUrlDecoder");
__name2(Base58DidUrlDecoder, "Base58DidUrlDecoder");
var HttpUrlDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  constructor({ secure } = {}) {
    super();
    this.secure = secure;
  }
  decode({ value } = {}) {
    const scheme = this.secure ? "https://" : "http://";
    return `${scheme}${value[1]}`;
  }
  static createDecoder({ value } = {}) {
    if (!(value.length === 2 && typeof value[1] === "string")) {
      return false;
    }
    return new HttpUrlDecoder({ secure: value[0] === 2 });
  }
}, "HttpUrlDecoder");
__name2(HttpUrlDecoder, "HttpUrlDecoder");
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate6(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
__name(validate6, "validate6");
__name2(validate6, "validate");
var validate_default = validate6;
var byteToHex = [];
for (i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
var i2;
function stringify2(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
__name(stringify2, "stringify2");
__name2(stringify2, "stringify");
var stringify_default = stringify2;
function parse22(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
__name(parse22, "parse2");
__name2(parse22, "parse");
var parse_default = parse22;
var UuidUrnDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  decode({ value } = {}) {
    const uuid = typeof value[1] === "string" ? value[1] : stringify_default(value[1]);
    return `urn:uuid:${uuid}`;
  }
  static createDecoder({ value } = {}) {
    if (value.length === 2 && (typeof value[1] === "string" || value[1] instanceof Uint8Array)) {
      return new UuidUrnDecoder();
    }
  }
}, "UuidUrnDecoder");
__name2(UuidUrnDecoder, "UuidUrnDecoder");
var SCHEME_ID_TO_DECODER = /* @__PURE__ */ new Map([
  [1, HttpUrlDecoder],
  [2, HttpUrlDecoder],
  [3, UuidUrnDecoder],
  [1024, Base58DidUrlDecoder],
  [1025, Base58DidUrlDecoder]
]);
var UriDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  static createDecoder({ value } = {}) {
    if (!(Array.isArray(value) || value.length > 1)) {
      return false;
    }
    const DecoderClass = SCHEME_ID_TO_DECODER.get(value[0]);
    return DecoderClass && DecoderClass.createDecoder({ value });
  }
}, "UriDecoder");
__name2(UriDecoder, "UriDecoder");
var VocabTermDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  constructor({ term } = {}) {
    super();
    this.term = term;
  }
  decode() {
    return this.term;
  }
  static createDecoder({ value, transformer } = {}) {
    if (Array.isArray(value)) {
      return UriDecoder.createDecoder({ value, transformer });
    }
    const term = transformer.idToTerm.get(value);
    if (term !== void 0) {
      return new VocabTermDecoder({ term });
    }
  }
}, "VocabTermDecoder");
__name2(VocabTermDecoder, "VocabTermDecoder");
var XsdDateDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  decode({ value } = {}) {
    const dateString = new Date(value * 1e3).toISOString();
    return dateString.substring(0, dateString.indexOf("T"));
  }
  static createDecoder({ value } = {}) {
    if (typeof value === "number") {
      return new XsdDateDecoder();
    }
  }
}, "XsdDateDecoder");
__name2(XsdDateDecoder, "XsdDateDecoder");
var XsdDateTimeDecoder = /* @__PURE__ */ __name(class extends CborldDecoder {
  constructor({ value } = {}) {
    super();
    this.value = value;
  }
  decode({ value } = {}) {
    if (typeof value === "number") {
      return new Date(value * 1e3).toISOString().replace(".000Z", "Z");
    }
    return new Date(value[0] * 1e3 + value[1]).toISOString();
  }
  static createDecoder({ value } = {}) {
    if (typeof value === "number") {
      return new XsdDateTimeDecoder();
    }
    if (Array.isArray(value) && value.length === 2 && (typeof value[0] === "number" || typeof value[1] === "number")) {
      return new XsdDateTimeDecoder();
    }
  }
}, "XsdDateTimeDecoder");
__name2(XsdDateTimeDecoder, "XsdDateTimeDecoder");
function inspect42(data, options) {
  return JSON.stringify(data, null, 2);
}
__name(inspect42, "inspect4");
__name2(inspect42, "inspect");
var TYPE_DECODERS = /* @__PURE__ */ new Map([
  ["@id", UriDecoder],
  ["@vocab", VocabTermDecoder],
  ["https://w3id.org/security#multibase", MultibaseDecoder],
  ["http://www.w3.org/2001/XMLSchema#date", XsdDateDecoder],
  ["http://www.w3.org/2001/XMLSchema#dateTime", XsdDateTimeDecoder]
]);
var CONTEXT_TERM_ID = KEYWORDS.get("@context");
var CONTEXT_TERM_ID_PLURAL = CONTEXT_TERM_ID + 1;
var Decompressor = /* @__PURE__ */ __name(class extends Transformer {
  constructor({ documentLoader, appContextMap } = {}) {
    super({ documentLoader, appContextMap });
    this.reverseAppContextMap = /* @__PURE__ */ new Map();
    if (appContextMap) {
      for (const [k2, v] of appContextMap) {
        this.reverseAppContextMap.set(v, k2);
      }
    }
  }
  async decompress({ compressedBytes, diagnose } = {}) {
    this.contextMap = /* @__PURE__ */ new Map();
    this.termToId = new Map(KEYWORDS);
    this.nextTermId = FIRST_CUSTOM_TERM_ID;
    this.idToTerm = /* @__PURE__ */ new Map();
    for (const [term, id2] of this.termToId) {
      this.idToTerm.set(id2, term);
    }
    const transformMap = decode7(compressedBytes, { useMaps: true });
    if (diagnose) {
      diagnose("Diagnostic CBOR-LD decompression transform map(s):");
      diagnose(inspect42(transformMap, { depth: null, colors: true }));
    }
    const results = [];
    const isArray2 = Array.isArray(transformMap);
    const transformMaps = isArray2 ? transformMap : [transformMap];
    for (const transformMap2 of transformMaps) {
      const obj = {};
      await this._transform({ obj, transformMap: transformMap2 });
      results.push(obj);
    }
    return isArray2 ? results : results[0];
  }
  _beforeObjectContexts({ obj, transformMap }) {
    const encodedContext = transformMap.get(CONTEXT_TERM_ID);
    if (encodedContext) {
      const decoder = ContextDecoder.createDecoder(
        { value: encodedContext, transformer: this }
      );
      obj["@context"] = decoder ? decoder.decode({ value: encodedContext }) : encodedContext;
    }
    const encodedContexts = transformMap.get(CONTEXT_TERM_ID_PLURAL);
    if (encodedContexts) {
      if (encodedContext) {
        throw new CborldError(
          "ERR_INVALID_ENCODED_CONTEXT",
          "Both singular and plural context IDs were found in the CBOR-LD input."
        );
      }
      if (!Array.isArray(encodedContexts)) {
        throw new CborldError(
          "ERR_INVALID_ENCODED_CONTEXT",
          "Encoded plural context value must be an array."
        );
      }
      const entries = [];
      for (const value of encodedContexts) {
        const decoder = ContextDecoder.createDecoder(
          { value, transformer: this }
        );
        entries.push(decoder ? decoder.decode({ value }) : value);
      }
      obj["@context"] = entries;
    }
  }
  _beforeTypeScopedContexts({ activeCtx, obj, transformMap }) {
    const { termToId } = this;
    const typeTerms = ["@type", ...activeCtx.aliases.type];
    for (const term of typeTerms) {
      const termId = termToId.get(term);
      let value = transformMap.get(termId);
      if (value === void 0) {
        value = transformMap.get(termId + 1);
      }
      if (value !== void 0) {
        if (Array.isArray(value)) {
          obj[term] = value.map((value2) => {
            const decoder = VocabTermDecoder.createDecoder(
              { value: value2, transformer: this }
            );
            return decoder ? decoder.decode({ value: value2 }) : value2;
          });
        } else {
          const decoder = VocabTermDecoder.createDecoder(
            { value, transformer: this }
          );
          obj[term] = decoder ? decoder.decode({ value }) : value;
        }
      }
    }
  }
  _getEntries({ transformMap, termMap }) {
    const entries = [];
    for (const [key22, value] of transformMap) {
      if (key22 === CONTEXT_TERM_ID || key22 === CONTEXT_TERM_ID_PLURAL) {
        continue;
      }
      const { term, plural } = this._getTermForId({ id: key22 });
      if (term === void 0) {
        throw new CborldError(
          "ERR_UNKNOWN_CBORLD_TERM_ID",
          `Unknown term ID '${key22}' was detected in the CBOR-LD input.`
        );
      }
      const def = termMap.get(term);
      if (def === void 0 && !(term.startsWith("@") && KEYWORDS.has(term))) {
        throw new CborldError(
          "ERR_UNKNOWN_CBORLD_TERM",
          `Unknown term "${term}" was detected in the CBOR-LD input.`
        );
      }
      entries.push([{ term, termId: key22, plural, def }, value]);
    }
    return entries.sort(_sortEntriesByTerm);
  }
  _getTermInfo({ termMap, key: key22 }) {
    const { term, plural } = this._getTermForId({ id: key22 });
    if (term === void 0) {
      throw new CborldError(
        "ERR_UNKNOWN_CBORLD_TERM_ID",
        `Unknown term ID '${key22}' was detected in the CBOR-LD input.`
      );
    }
    const def = termMap.get(term);
    if (def === void 0 && !(term.startsWith("@") && KEYWORDS.has(term))) {
      throw new CborldError(
        "ERR_UNKNOWN_CBORLD_TERM",
        `Unknown term "${term}" was detected in the CBOR-LD input.`
      );
    }
    return { term, termId: key22, plural, def };
  }
  _transformObjectId({ obj, termInfo, value }) {
    const decoder = UriDecoder.createDecoder({ value });
    obj[termInfo.term] = decoder ? decoder.decode({ value }) : value;
  }
  _transformObjectType({ obj, termInfo, value }) {
    const { term, plural } = termInfo;
    const values = plural ? value : [value];
    const entries = [];
    for (const value2 of values) {
      const decoder = VocabTermDecoder.createDecoder(
        { value: value2, transformer: this }
      );
      entries.push(decoder ? decoder.decode({ value: value2 }) : value2);
    }
    obj[term] = plural ? entries : entries[0];
  }
  _transformTypedValue({ entries, termType, value }) {
    const DecoderClass = TYPE_DECODERS.get(termType);
    const decoder = DecoderClass && DecoderClass.createDecoder(
      { value, transformer: this }
    );
    if (decoder) {
      entries.push(decoder.decode({ value }));
      return true;
    }
  }
  async _transformArray({ entries, contextStack, value }) {
    const children = [];
    for (const transformMap of value) {
      const obj = {};
      children.push(obj);
      await this._transform({ obj, transformMap, contextStack });
    }
    entries.push(children);
  }
  async _transformObject({ entries, contextStack, value }) {
    const child = {};
    entries.push(child);
    return this._transform({ obj: child, transformMap: value, contextStack });
  }
  _assignEntries({ entries, obj, termInfo }) {
    const { term, plural } = termInfo;
    obj[term] = plural ? entries : entries[0];
  }
}, "Decompressor");
__name2(Decompressor, "Decompressor");
function _sortEntriesByTerm([{ term: t1 }], [{ term: t2 }]) {
  return t1 < t2 ? -1 : t1 > t2 ? 1 : 0;
}
__name(_sortEntriesByTerm, "_sortEntriesByTerm");
__name2(_sortEntriesByTerm, "_sortEntriesByTerm");
async function decode12({
  cborldBytes,
  documentLoader,
  appContextMap = /* @__PURE__ */ new Map(),
  diagnose
}) {
  if (!(cborldBytes instanceof Uint8Array)) {
    throw new TypeError('"cborldBytes" must be a Uint8Array.');
  }
  let index = 0;
  if (cborldBytes[index++] !== 217) {
    throw new CborldError(
      "ERR_NOT_CBORLD",
      'CBOR-LD must start with a CBOR major type "Tag" header of `0xd9`.'
    );
  }
  if (cborldBytes[index++] !== 5) {
    throw new CborldError(
      "ERR_NOT_CBORLD",
      "CBOR-LD 16-bit tag must start with `0x05`."
    );
  }
  const compressionMode = cborldBytes[index];
  if (compressionMode === void 0) {
    throw new CborldError(
      "ERR_NOT_CBORLD",
      "Truncated CBOR-LD 16-bit tag."
    );
  }
  if (!(compressionMode === 0 || compressionMode === 1)) {
    throw new CborldError(
      "ERR_NOT_CBORLD",
      `Unsupported CBOR-LD compression mode "${compressionMode}".`
    );
  }
  index++;
  const { buffer: buffer2, byteOffset, length: length2 } = cborldBytes;
  const suffix = new Uint8Array(buffer2, byteOffset + index, length2 - index);
  if (compressionMode === 0) {
    return decode7(suffix, { useMaps: false });
  }
  const decompressor = new Decompressor({ documentLoader, appContextMap });
  const result = await decompressor.decompress(
    { compressedBytes: suffix, diagnose }
  );
  if (diagnose) {
    diagnose("Diagnostic JSON-LD result:");
    diagnose(inspect42(result, { depth: null, colors: true }));
  }
  return result;
}
__name(decode12, "decode12");
__name2(decode12, "decode");
var CborldEncoder = /* @__PURE__ */ __name(class {
  encode() {
    throw new Error("Must be implemented by derived class.");
  }
  static createEncoder({ value } = {}) {
    throw new Error("Must be implemented by derived class.");
  }
}, "CborldEncoder");
__name2(CborldEncoder, "CborldEncoder");
var ContextEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ context: context2, appContextMap } = {}) {
    super();
    this.context = context2;
    this.appContextMap = appContextMap;
  }
  encode() {
    const { context: context2 } = this;
    const id2 = URL_TO_ID.get(context2) || this.appContextMap.get(context2);
    if (id2 === void 0) {
      return new Token(Type.string, context2);
    }
    return new Token(Type.uint, id2);
  }
  static createEncoder({ value, transformer } = {}) {
    if (typeof value !== "string") {
      return false;
    }
    const { appContextMap } = transformer;
    return new ContextEncoder({ context: value, appContextMap });
  }
}, "ContextEncoder");
__name2(ContextEncoder, "ContextEncoder");
var MultibaseEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ value } = {}) {
    super();
    this.value = value;
  }
  encode() {
    const { value } = this;
    let prefix;
    let suffix;
    if (value[0] === "z") {
      prefix = 122;
      suffix = decode11(value.substr(1));
    } else if (value[0] === "M") {
      prefix = 77;
      suffix = gBase64.toUint8Array(value.substr(1));
    }
    const bytes = new Uint8Array(1 + suffix.length);
    bytes[0] = prefix;
    bytes.set(suffix, 1);
    return new Token(Type.bytes, bytes);
  }
  static createEncoder({ value } = {}) {
    if (typeof value !== "string") {
      return false;
    }
    if (value[0] === "z" || value[0] === "M") {
      return new MultibaseEncoder({ value });
    }
  }
}, "MultibaseEncoder");
__name2(MultibaseEncoder, "MultibaseEncoder");
var SCHEME_TO_ID = /* @__PURE__ */ new Map([
  ["did:v1:nym:", 1024],
  ["did:key:", 1025]
]);
var Base58DidUrlEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ value, scheme } = {}) {
    super();
    this.value = value;
    this.scheme = scheme;
  }
  encode() {
    const { value, scheme } = this;
    const suffix = value.substr(scheme.length);
    const [authority, fragment] = suffix.split("#");
    const entries = [
      new Token(Type.uint, SCHEME_TO_ID.get(scheme)),
      _multibase58ToToken(authority)
    ];
    if (fragment !== void 0) {
      entries.push(_multibase58ToToken(fragment));
    }
    return [new Token(Type.array, entries.length), entries];
  }
  static createEncoder({ value } = {}) {
    const keys = [...SCHEME_TO_ID.keys()];
    for (const key22 of keys) {
      if (value.startsWith(key22)) {
        return new Base58DidUrlEncoder({ value, scheme: key22 });
      }
    }
  }
}, "Base58DidUrlEncoder");
__name2(Base58DidUrlEncoder, "Base58DidUrlEncoder");
function _multibase58ToToken(str) {
  if (str.startsWith("z")) {
    const decoded = decode11(str.substr(1));
    if (decoded) {
      return new Token(Type.bytes, decoded);
    }
  }
  return new Token(Type.string, str);
}
__name(_multibase58ToToken, "_multibase58ToToken");
__name2(_multibase58ToToken, "_multibase58ToToken");
var HttpUrlEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ value, secure } = {}) {
    super();
    this.value = value;
    this.secure = secure;
  }
  encode() {
    const { value, secure } = this;
    const length2 = secure ? "https://".length : "http://".length;
    const entries = [
      new Token(Type.uint, secure ? 2 : 1),
      new Token(Type.string, value.substr(length2))
    ];
    return [new Token(Type.array, entries.length), entries];
  }
  static createEncoder({ value } = {}) {
    if (value.startsWith("https://")) {
      return new HttpUrlEncoder({ value, secure: true });
    }
    if (value.startsWith("http://")) {
      return new HttpUrlEncoder({ value, secure: false });
    }
  }
}, "HttpUrlEncoder");
__name2(HttpUrlEncoder, "HttpUrlEncoder");
var UuidUrnEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ value } = {}) {
    super();
    this.value = value;
  }
  encode() {
    const { value } = this;
    const rest = value.substr("urn:uuid:".length);
    const entries = [new Token(Type.uint, 3)];
    if (rest.toLowerCase() === rest) {
      const uuidBytes = parse_default(rest);
      entries.push(new Token(Type.bytes, uuidBytes));
    } else {
      entries.push(new Token(Type.string, rest));
    }
    return [new Token(Type.array, entries.length), entries];
  }
  static createEncoder({ value } = {}) {
    if (value.startsWith("urn:uuid:")) {
      return new UuidUrnEncoder({ value });
    }
  }
}, "UuidUrnEncoder");
__name2(UuidUrnEncoder, "UuidUrnEncoder");
var SCHEME_TO_ENCODER = /* @__PURE__ */ new Map([
  ["http", HttpUrlEncoder],
  ["https", HttpUrlEncoder],
  ["urn:uuid", UuidUrnEncoder],
  ["did:v1:nym", Base58DidUrlEncoder],
  ["did:key", Base58DidUrlEncoder]
]);
var UriEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  static createEncoder({ value } = {}) {
    if (typeof value !== "string") {
      return false;
    }
    let scheme;
    try {
      const { protocol, pathname } = new URL(value);
      scheme = protocol;
      if (pathname.includes(":")) {
        scheme += pathname;
      }
      const split = value.split(":");
      split.pop();
      scheme = split.join(":");
    } catch (e2) {
      return false;
    }
    const EncoderClass = SCHEME_TO_ENCODER.get(scheme);
    return EncoderClass && EncoderClass.createEncoder({ value });
  }
}, "UriEncoder");
__name2(UriEncoder, "UriEncoder");
var VocabTermEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ termId } = {}) {
    super();
    this.termId = termId;
  }
  encode() {
    return new Token(Type.uint, this.termId);
  }
  static createEncoder({ value, transformer } = {}) {
    const { termToId } = transformer;
    const termId = termToId.get(value);
    if (termId !== void 0) {
      return new VocabTermEncoder({ termId });
    }
    return UriEncoder.createEncoder({ value });
  }
}, "VocabTermEncoder");
__name2(VocabTermEncoder, "VocabTermEncoder");
var XsdDateEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ value, parsed } = {}) {
    super();
    this.value = value;
    this.parsed = parsed;
  }
  encode() {
    const { value, parsed } = this;
    const secondsSinceEpoch = Math.floor(parsed / 1e3);
    const dateString = new Date(secondsSinceEpoch * 1e3).toISOString();
    const expectedDate = dateString.substring(0, dateString.indexOf("T"));
    if (value !== expectedDate) {
      return new Token(Type.string, value);
    }
    return new Token(Type.uint, secondsSinceEpoch);
  }
  static createEncoder({ value } = {}) {
    if (value.includes("T")) {
      return false;
    }
    const parsed = Date.parse(value);
    if (isNaN(parsed)) {
      return false;
    }
    return new XsdDateEncoder({ value, parsed });
  }
}, "XsdDateEncoder");
__name2(XsdDateEncoder, "XsdDateEncoder");
var XsdDateTimeEncoder = /* @__PURE__ */ __name(class extends CborldEncoder {
  constructor({ value, parsed } = {}) {
    super();
    this.value = value;
    this.parsed = parsed;
  }
  encode() {
    const { value, parsed } = this;
    const secondsSinceEpoch = Math.floor(parsed / 1e3);
    const secondsToken = new Token(Type.uint, secondsSinceEpoch);
    const millisecondIndex = value.indexOf(".");
    if (millisecondIndex === -1) {
      const expectedDate2 = new Date(
        secondsSinceEpoch * 1e3
      ).toISOString().replace(".000Z", "Z");
      if (value !== expectedDate2) {
        return new Token(Type.string, value);
      }
      return secondsToken;
    }
    const milliseconds = parseInt(value.substr(millisecondIndex + 1), 10);
    const expectedDate = new Date(
      secondsSinceEpoch * 1e3 + milliseconds
    ).toISOString();
    if (value !== expectedDate) {
      return new Token(Type.string, value);
    }
    const entries = [
      secondsToken,
      new Token(Type.uint, milliseconds)
    ];
    return [new Token(Type.array, entries.length), entries];
  }
  static createEncoder({ value } = {}) {
    if (!value.includes("T")) {
      return false;
    }
    const parsed = Date.parse(value);
    if (isNaN(parsed)) {
      return false;
    }
    return new XsdDateTimeEncoder({ value, parsed });
  }
}, "XsdDateTimeEncoder");
__name2(XsdDateTimeEncoder, "XsdDateTimeEncoder");
var TYPE_ENCODERS = /* @__PURE__ */ new Map([
  ["@id", UriEncoder],
  ["@vocab", VocabTermEncoder],
  ["https://w3id.org/security#multibase", MultibaseEncoder],
  ["http://www.w3.org/2001/XMLSchema#date", XsdDateEncoder],
  ["http://www.w3.org/2001/XMLSchema#dateTime", XsdDateTimeEncoder]
]);
var CONTEXT_TERM_ID2 = KEYWORDS.get("@context");
var CONTEXT_TERM_ID_PLURAL2 = CONTEXT_TERM_ID2 + 1;
var typeEncoders2 = {
  Object(obj) {
    if (obj instanceof CborldEncoder) {
      return obj.encode({ obj });
    }
  }
};
var Compressor = /* @__PURE__ */ __name(class extends Transformer {
  constructor({ documentLoader, appContextMap } = {}) {
    super({ documentLoader, appContextMap });
  }
  async compress({ jsonldDocument, diagnose } = {}) {
    const transformMaps = await this._createTransformMaps({ jsonldDocument });
    if (diagnose) {
      diagnose("Diagnostic CBOR-LD compression transform map(s):");
      diagnose(inspect42(transformMaps, { depth: null, colors: true }));
    }
    return encode6(transformMaps, { typeEncoders: typeEncoders2 });
  }
  async _createTransformMaps({ jsonldDocument }) {
    this.contextMap = /* @__PURE__ */ new Map();
    this.termToId = new Map(KEYWORDS);
    this.nextTermId = FIRST_CUSTOM_TERM_ID;
    const transformMaps = [];
    const isArray2 = Array.isArray(jsonldDocument);
    const docs = isArray2 ? jsonldDocument : [jsonldDocument];
    for (const obj of docs) {
      const transformMap = /* @__PURE__ */ new Map();
      await this._transform({ obj, transformMap });
      transformMaps.push(transformMap);
    }
    return isArray2 ? transformMaps : transformMaps[0];
  }
  _afterObjectContexts({ obj, transformMap }) {
    const context2 = obj["@context"];
    if (!context2) {
      return;
    }
    const entries = [];
    const isArray2 = Array.isArray(context2);
    const contexts = isArray2 ? context2 : [context2];
    for (const value of contexts) {
      const encoder = ContextEncoder.createEncoder(
        { value, transformer: this }
      );
      entries.push(encoder || value);
    }
    const id2 = isArray2 ? CONTEXT_TERM_ID_PLURAL2 : CONTEXT_TERM_ID2;
    transformMap.set(id2, isArray2 ? entries : entries[0]);
  }
  _getEntries({ obj, termMap }) {
    const entries = [];
    const keys = Object.keys(obj).sort();
    for (const key22 of keys) {
      if (key22 === "@context") {
        continue;
      }
      const def = termMap.get(key22);
      if (def === void 0 && !(key22.startsWith("@") && KEYWORDS.has(key22))) {
        throw new CborldError(
          "ERR_UNKNOWN_CBORLD_TERM",
          `Unknown term '${key22}' was detected in the JSON-LD input.`
        );
      }
      const value = obj[key22];
      const plural = Array.isArray(value);
      const termId = this._getIdForTerm({ term: key22, plural });
      entries.push([{ term: key22, termId, plural, def }, value]);
    }
    return entries;
  }
  _transformObjectId({ transformMap, termInfo, value }) {
    const { termId } = termInfo;
    const encoder = UriEncoder.createEncoder(
      { value, transformer: this, termInfo }
    );
    transformMap.set(termId, encoder || value);
  }
  _transformObjectType({ transformMap, termInfo, value }) {
    const { termId, plural } = termInfo;
    const values = plural ? value : [value];
    const entries = [];
    for (const value2 of values) {
      const encoder = VocabTermEncoder.createEncoder(
        { value: value2, transformer: this, termInfo }
      );
      entries.push(encoder || value2);
    }
    transformMap.set(termId, plural ? entries : entries[0]);
  }
  _transformTypedValue({ entries, termType, value, termInfo }) {
    const EncoderClass = TYPE_ENCODERS.get(termType);
    const encoder = EncoderClass && EncoderClass.createEncoder(
      { value, transformer: this, termInfo }
    );
    if (encoder) {
      entries.push(encoder);
      return true;
    }
  }
  async _transformArray({ entries, contextStack, value }) {
    const children = [];
    for (const obj of value) {
      const childMap = /* @__PURE__ */ new Map();
      children.push(childMap);
      await this._transform({ obj, transformMap: childMap, contextStack });
    }
    entries.push(children);
  }
  async _transformObject({ entries, contextStack, value }) {
    const transformMap = /* @__PURE__ */ new Map();
    entries.push(transformMap);
    await this._transform({ obj: value, transformMap, contextStack });
  }
  _assignEntries({ entries, transformMap, termInfo }) {
    const { termId, plural } = termInfo;
    transformMap.set(termId, plural ? entries : entries[0]);
  }
}, "Compressor");
__name2(Compressor, "Compressor");
async function encode12({
  jsonldDocument,
  documentLoader,
  appContextMap = /* @__PURE__ */ new Map(),
  compressionMode = 1,
  diagnose
} = {}) {
  if (!(compressionMode === 0 || compressionMode === 1)) {
    throw new TypeError(
      '"compressionMode" must be "0" (no compression) or "1" for compression mode version 1.'
    );
  }
  const prefix = new Uint8Array([217, 5, compressionMode]);
  let suffix;
  if (compressionMode === 0) {
    suffix = encode6(jsonldDocument);
  } else {
    const compressor = new Compressor({ documentLoader, appContextMap });
    suffix = await compressor.compress({ jsonldDocument, diagnose });
  }
  const length2 = prefix.length + suffix.length;
  const bytes = new Uint8Array(length2);
  bytes.set(prefix);
  bytes.set(suffix, prefix.length);
  if (diagnose) {
    diagnose("Diagnostic CBOR-LD result:");
    diagnose(inspect42(bytes, { depth: null, colors: true }));
  }
  return bytes;
}
__name(encode12, "encode12");
__name2(encode12, "encode");
function toDataView(data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new TypeError("Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray");
}
__name(toDataView, "toDataView");
__name2(toDataView, "toDataView");
var RFC4648 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var RFC4648_HEX = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
var CROCKFORD = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
function base32Encode(data, variant, options) {
  options = options || {};
  let alphabet3, defaultPadding;
  switch (variant) {
    case "RFC3548":
    case "RFC4648":
      alphabet3 = RFC4648;
      defaultPadding = true;
      break;
    case "RFC4648-HEX":
      alphabet3 = RFC4648_HEX;
      defaultPadding = true;
      break;
    case "Crockford":
      alphabet3 = CROCKFORD;
      defaultPadding = false;
      break;
    default:
      throw new Error("Unknown base32 variant: " + variant);
  }
  const padding2 = options.padding !== void 0 ? options.padding : defaultPadding;
  const view = toDataView(data);
  let bits = 0;
  let value = 0;
  let output = "";
  for (let i22 = 0; i22 < view.byteLength; i22++) {
    value = value << 8 | view.getUint8(i22);
    bits += 8;
    while (bits >= 5) {
      output += alphabet3[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }
  if (bits > 0) {
    output += alphabet3[value << 5 - bits & 31];
  }
  if (padding2) {
    while (output.length % 8 !== 0) {
      output += "=";
    }
  }
  return output;
}
__name(base32Encode, "base32Encode");
__name2(base32Encode, "base32Encode");
var import_base32_decode = __toESM2(require_base32_decode(), 1);
var Mode;
(function(Mode2) {
  Mode2[Mode2["Terminator"] = 0] = "Terminator";
  Mode2[Mode2["Numeric"] = 1] = "Numeric";
  Mode2[Mode2["Alphanumeric"] = 2] = "Alphanumeric";
  Mode2[Mode2["StructuredAppend"] = 3] = "StructuredAppend";
  Mode2[Mode2["Byte"] = 4] = "Byte";
  Mode2[Mode2["Kanji"] = 8] = "Kanji";
  Mode2[Mode2["ECI"] = 7] = "ECI";
})(Mode || (Mode = {}));
var QRData = /* @__PURE__ */ function() {
  function QRData2(mode, data) {
    this.bytes = [];
    this.mode = mode;
    this.data = data;
  }
  __name(QRData2, "QRData2");
  __name2(QRData2, "QRData");
  QRData2.prototype.getLength = function() {
    return this.bytes.length;
  };
  QRData2.prototype.getLengthInBits = function(version122) {
    var mode = this.mode;
    var error = new Error("illegal mode: ".concat(mode));
    if (1 <= version122 && version122 < 10) {
      switch (mode) {
        case Mode.Numeric:
          return 10;
        case Mode.Alphanumeric:
          return 9;
        case Mode.Byte:
          return 8;
        case Mode.Kanji:
          return 8;
        default:
          throw error;
      }
    } else if (version122 < 27) {
      switch (mode) {
        case Mode.Numeric:
          return 12;
        case Mode.Alphanumeric:
          return 11;
        case Mode.Byte:
          return 16;
        case Mode.Kanji:
          return 10;
        default:
          throw error;
      }
    } else if (version122 < 41) {
      switch (mode) {
        case Mode.Numeric:
          return 14;
        case Mode.Alphanumeric:
          return 13;
        case Mode.Byte:
          return 16;
        case Mode.Kanji:
          return 12;
        default:
          throw error;
      }
    } else {
      throw new Error("illegal version: ".concat(version122));
    }
  };
  return QRData2;
}();
function encode13(text) {
  var pos = 0;
  var length2 = text.length;
  var bytes = [];
  for (var i22 = 0; i22 < length2; i22++) {
    var code3 = text.charCodeAt(i22);
    if (code3 < 128) {
      bytes[pos++] = code3;
    } else if (code3 < 2048) {
      bytes[pos++] = code3 >> 6 | 192;
      bytes[pos++] = code3 & 63 | 128;
    } else if ((code3 & 64512) === 55296 && i22 + 1 < length2 && (text.charCodeAt(i22 + 1) & 64512) === 56320) {
      code3 = 65536 + ((code3 & 1023) << 10) + (text.charCodeAt(++i22) & 1023);
      bytes[pos++] = code3 >> 18 | 240;
      bytes[pos++] = code3 >> 12 & 63 | 128;
      bytes[pos++] = code3 >> 6 & 63 | 128;
      bytes[pos++] = code3 & 63 | 128;
    } else {
      bytes[pos++] = code3 >> 12 | 224;
      bytes[pos++] = code3 >> 6 & 63 | 128;
      bytes[pos++] = code3 & 63 | 128;
    }
  }
  return bytes;
}
__name(encode13, "encode13");
__name2(encode13, "encode");
var QRByte = /* @__PURE__ */ function(_super) {
  __extends2(QRByte2, _super);
  function QRByte2(data, encode$1) {
    var _this = _super.call(this, Mode.Byte, data) || this;
    _this.encoding = -1;
    if (typeof encode$1 === "function") {
      var _a = encode$1(data), encoding = _a.encoding, bytes = _a.bytes;
      _this.bytes = bytes;
      _this.encoding = encoding;
    } else {
      _this.bytes = encode13(data);
      _this.encoding = 26;
    }
    return _this;
  }
  __name(QRByte2, "QRByte2");
  __name2(QRByte2, "QRByte");
  QRByte2.prototype.writeTo = function(buffer2) {
    var bytes = this.bytes;
    for (var _i = 0, bytes_1 = bytes; _i < bytes_1.length; _i++) {
      var byte = bytes_1[_i];
      buffer2.put(byte, 8);
    }
  };
  return QRByte2;
}(QRData);
var EXP_TABLE = [];
var LOG_TABLE = [];
for (i2 = 0; i2 < 256; i2++) {
  LOG_TABLE[i2] = 0;
  EXP_TABLE[i2] = i2 < 8 ? 1 << i2 : EXP_TABLE[i2 - 4] ^ EXP_TABLE[i2 - 5] ^ EXP_TABLE[i2 - 6] ^ EXP_TABLE[i2 - 8];
}
var i2;
for (i2 = 0; i2 < 255; i2++) {
  LOG_TABLE[EXP_TABLE[i2]] = i2;
}
var i2;
function glog(n) {
  if (n < 1) {
    throw new Error("illegal log: ".concat(n));
  }
  return LOG_TABLE[n];
}
__name(glog, "glog");
__name2(glog, "glog");
function gexp(n) {
  while (n < 0) {
    n += 255;
  }
  while (n >= 256) {
    n -= 255;
  }
  return EXP_TABLE[n];
}
__name(gexp, "gexp");
__name2(gexp, "gexp");
var Polynomial = /* @__PURE__ */ function() {
  function Polynomial2(num, shift) {
    if (shift === void 0) {
      shift = 0;
    }
    var offset = 0;
    var length2 = num.length;
    while (offset < length2 && num[offset] === 0) {
      offset++;
    }
    length2 -= offset;
    var numbers = [];
    for (var i22 = 0; i22 < length2; i22++) {
      numbers.push(num[offset + i22]);
    }
    for (var i22 = 0; i22 < shift; i22++) {
      numbers.push(0);
    }
    this.num = numbers;
  }
  __name(Polynomial2, "Polynomial2");
  __name2(Polynomial2, "Polynomial");
  Polynomial2.prototype.getAt = function(index) {
    return this.num[index];
  };
  Polynomial2.prototype.getLength = function() {
    return this.num.length;
  };
  Polynomial2.prototype.multiply = function(e2) {
    var num = [];
    var eLength = e2.getLength();
    var tLength = this.getLength();
    var dLength = tLength + eLength - 1;
    for (var i22 = 0; i22 < dLength; i22++) {
      num.push(0);
    }
    for (var i22 = 0; i22 < tLength; i22++) {
      for (var j = 0; j < eLength; j++) {
        num[i22 + j] ^= gexp(glog(this.getAt(i22)) + glog(e2.getAt(j)));
      }
    }
    return new Polynomial2(num);
  };
  Polynomial2.prototype.mod = function(e2) {
    var eLength = e2.getLength();
    var tLength = this.getLength();
    if (tLength - eLength < 0) {
      return this;
    }
    var ratio = glog(this.getAt(0)) - glog(e2.getAt(0));
    var num = [];
    for (var i22 = 0; i22 < tLength; i22++) {
      num.push(this.getAt(i22));
    }
    for (var i22 = 0; i22 < eLength; i22++) {
      num[i22] ^= gexp(glog(e2.getAt(i22)) + ratio);
    }
    return new Polynomial2(num).mod(e2);
  };
  return Polynomial2;
}();
var N12 = 3;
var N22 = 3;
var N32 = 40;
var N42 = 10;
var ALIGNMENT_PATTERN_TABLE = [
  [],
  [6, 18],
  [6, 22],
  [6, 26],
  [6, 30],
  [6, 34],
  [6, 22, 38],
  [6, 24, 42],
  [6, 26, 46],
  [6, 28, 50],
  [6, 30, 54],
  [6, 32, 58],
  [6, 34, 62],
  [6, 26, 46, 66],
  [6, 26, 48, 70],
  [6, 26, 50, 74],
  [6, 30, 54, 78],
  [6, 30, 56, 82],
  [6, 30, 58, 86],
  [6, 34, 62, 90],
  [6, 28, 50, 72, 94],
  [6, 26, 50, 74, 98],
  [6, 30, 54, 78, 102],
  [6, 28, 54, 80, 106],
  [6, 32, 58, 84, 110],
  [6, 30, 58, 86, 114],
  [6, 34, 62, 90, 118],
  [6, 26, 50, 74, 98, 122],
  [6, 30, 54, 78, 102, 126],
  [6, 26, 52, 78, 104, 130],
  [6, 30, 56, 82, 108, 134],
  [6, 34, 60, 86, 112, 138],
  [6, 30, 58, 86, 114, 142],
  [6, 34, 62, 90, 118, 146],
  [6, 30, 54, 78, 102, 126, 150],
  [6, 24, 50, 76, 102, 128, 154],
  [6, 28, 54, 80, 106, 132, 158],
  [6, 32, 58, 84, 110, 136, 162],
  [6, 26, 54, 82, 110, 138, 166],
  [6, 30, 58, 86, 114, 142, 170]
];
var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
function getAlignmentPattern(version122) {
  return ALIGNMENT_PATTERN_TABLE[version122 - 1];
}
__name(getAlignmentPattern, "getAlignmentPattern");
__name2(getAlignmentPattern, "getAlignmentPattern");
function getErrorCorrectionPolynomial(errorCorrectionLength) {
  var e2 = new Polynomial([1]);
  for (var i22 = 0; i22 < errorCorrectionLength; i22++) {
    e2 = e2.multiply(new Polynomial([1, gexp(i22)]));
  }
  return e2;
}
__name(getErrorCorrectionPolynomial, "getErrorCorrectionPolynomial");
__name2(getErrorCorrectionPolynomial, "getErrorCorrectionPolynomial");
function getBCHDigit(data) {
  var digit = 0;
  while (data !== 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
}
__name(getBCHDigit, "getBCHDigit");
__name2(getBCHDigit, "getBCHDigit");
var G18_BCH = getBCHDigit(G18);
function getBCHVersion(data) {
  var offset = data << 12;
  while (getBCHDigit(offset) - G18_BCH >= 0) {
    offset ^= G18 << getBCHDigit(offset) - G18_BCH;
  }
  return data << 12 | offset;
}
__name(getBCHVersion, "getBCHVersion");
__name2(getBCHVersion, "getBCHVersion");
var G15_BCH = getBCHDigit(G15);
function getBCHVersionInfo(data) {
  var offset = data << 10;
  while (getBCHDigit(offset) - G15_BCH >= 0) {
    offset ^= G15 << getBCHDigit(offset) - G15_BCH;
  }
  return (data << 10 | offset) ^ G15_MASK;
}
__name(getBCHVersionInfo, "getBCHVersionInfo");
__name2(getBCHVersionInfo, "getBCHVersionInfo");
function applyMaskPenaltyRule1Internal(qrcode, isHorizontal) {
  var matrixSize = qrcode.getMatrixSize();
  var penalty = 0;
  for (var i22 = 0; i22 < matrixSize; i22++) {
    var prevBit = false;
    var numSameBitCells = 0;
    for (var j = 0; j < matrixSize; j++) {
      var bit = isHorizontal ? qrcode.isDark(i22, j) : qrcode.isDark(j, i22);
      if (bit === prevBit) {
        numSameBitCells++;
        if (numSameBitCells === 5) {
          penalty += N12;
        } else if (numSameBitCells > 5) {
          penalty++;
        }
      } else {
        prevBit = bit;
        numSameBitCells = 1;
      }
    }
  }
  return penalty;
}
__name(applyMaskPenaltyRule1Internal, "applyMaskPenaltyRule1Internal");
__name2(applyMaskPenaltyRule1Internal, "applyMaskPenaltyRule1Internal");
function applyMaskPenaltyRule1(qrcode) {
  return applyMaskPenaltyRule1Internal(qrcode, true) + applyMaskPenaltyRule1Internal(qrcode, false);
}
__name(applyMaskPenaltyRule1, "applyMaskPenaltyRule1");
__name2(applyMaskPenaltyRule1, "applyMaskPenaltyRule1");
function applyMaskPenaltyRule2(qrcode) {
  var matrixSize = qrcode.getMatrixSize();
  var penalty = 0;
  for (var y3 = 0; y3 < matrixSize - 1; y3++) {
    for (var x2 = 0; x2 < matrixSize - 1; x2++) {
      var value = qrcode.isDark(y3, x2);
      if (value === qrcode.isDark(y3, x2 + 1) && value === qrcode.isDark(y3 + 1, x2) && value === qrcode.isDark(y3 + 1, x2 + 1)) {
        penalty += N22;
      }
    }
  }
  return penalty;
}
__name(applyMaskPenaltyRule2, "applyMaskPenaltyRule2");
__name2(applyMaskPenaltyRule2, "applyMaskPenaltyRule2");
function isFourWhite(qrcode, rangeIndex, from4, to, isHorizontal) {
  from4 = Math.max(from4, 0);
  to = Math.min(to, qrcode.getMatrixSize());
  for (var i22 = from4; i22 < to; i22++) {
    var value = isHorizontal ? qrcode.isDark(rangeIndex, i22) : qrcode.isDark(i22, rangeIndex);
    if (value) {
      return false;
    }
  }
  return true;
}
__name(isFourWhite, "isFourWhite");
__name2(isFourWhite, "isFourWhite");
function applyMaskPenaltyRule3(qrcode) {
  var matrixSize = qrcode.getMatrixSize();
  var penalty = 0;
  for (var y3 = 0; y3 < matrixSize; y3++) {
    for (var x2 = 0; x2 < matrixSize; x2++) {
      if (x2 + 6 < matrixSize && qrcode.isDark(y3, x2) && !qrcode.isDark(y3, x2 + 1) && qrcode.isDark(y3, x2 + 2) && qrcode.isDark(y3, x2 + 3) && qrcode.isDark(y3, x2 + 4) && !qrcode.isDark(y3, x2 + 5) && qrcode.isDark(y3, x2 + 6) && (isFourWhite(qrcode, y3, x2 - 4, x2, true) || isFourWhite(qrcode, y3, x2 + 7, x2 + 11, true))) {
        penalty += N32;
      }
      if (y3 + 6 < matrixSize && qrcode.isDark(y3, x2) && !qrcode.isDark(y3 + 1, x2) && qrcode.isDark(y3 + 2, x2) && qrcode.isDark(y3 + 3, x2) && qrcode.isDark(y3 + 4, x2) && !qrcode.isDark(y3 + 5, x2) && qrcode.isDark(y3 + 6, x2) && (isFourWhite(qrcode, x2, y3 - 4, y3, false) || isFourWhite(qrcode, x2, y3 + 7, y3 + 11, false))) {
        penalty += N32;
      }
    }
  }
  return penalty;
}
__name(applyMaskPenaltyRule3, "applyMaskPenaltyRule3");
__name2(applyMaskPenaltyRule3, "applyMaskPenaltyRule3");
function applyMaskPenaltyRule4(qrcode) {
  var matrixSize = qrcode.getMatrixSize();
  var numDarkCells = 0;
  for (var y3 = 0; y3 < matrixSize; y3++) {
    for (var x2 = 0; x2 < matrixSize; x2++) {
      if (qrcode.isDark(y3, x2)) {
        numDarkCells++;
      }
    }
  }
  var numTotalCells = matrixSize * matrixSize;
  var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 20 - numTotalCells * 10) / numTotalCells);
  return fivePercentVariances * N42;
}
__name(applyMaskPenaltyRule4, "applyMaskPenaltyRule4");
__name2(applyMaskPenaltyRule4, "applyMaskPenaltyRule4");
function calculateMaskPenalty(qrcode) {
  return applyMaskPenaltyRule1(qrcode) + applyMaskPenaltyRule2(qrcode) + applyMaskPenaltyRule3(qrcode) + applyMaskPenaltyRule4(qrcode);
}
__name(calculateMaskPenalty, "calculateMaskPenalty");
__name2(calculateMaskPenalty, "calculateMaskPenalty");
var ErrorCorrectionLevel;
(function(ErrorCorrectionLevel2) {
  ErrorCorrectionLevel2[ErrorCorrectionLevel2["L"] = 1] = "L";
  ErrorCorrectionLevel2[ErrorCorrectionLevel2["M"] = 0] = "M";
  ErrorCorrectionLevel2[ErrorCorrectionLevel2["Q"] = 3] = "Q";
  ErrorCorrectionLevel2[ErrorCorrectionLevel2["H"] = 2] = "H";
})(ErrorCorrectionLevel || (ErrorCorrectionLevel = {}));
var RSBlock = /* @__PURE__ */ function() {
  function RSBlock2(totalCount, dataCount) {
    this.dataCount = dataCount;
    this.totalCount = totalCount;
  }
  __name(RSBlock2, "RSBlock2");
  __name2(RSBlock2, "RSBlock");
  RSBlock2.prototype.getDataCount = function() {
    return this.dataCount;
  };
  RSBlock2.prototype.getTotalCount = function() {
    return this.totalCount;
  };
  RSBlock2.getRSBlocks = function(version122, errorCorrectionLevel) {
    var rsBlocks = [];
    var rsBlock = RSBlock2.getRSBlockTable(version122, errorCorrectionLevel);
    var length2 = rsBlock.length / 3;
    for (var i22 = 0; i22 < length2; i22++) {
      var count = rsBlock[i22 * 3 + 0];
      var totalCount = rsBlock[i22 * 3 + 1];
      var dataCount = rsBlock[i22 * 3 + 2];
      for (var j = 0; j < count; j++) {
        rsBlocks.push(new RSBlock2(totalCount, dataCount));
      }
    }
    return rsBlocks;
  };
  RSBlock2.getRSBlockTable = function(version122, errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ErrorCorrectionLevel.L:
        return RSBlock2.RS_BLOCK_TABLE[(version122 - 1) * 4 + 0];
      case ErrorCorrectionLevel.M:
        return RSBlock2.RS_BLOCK_TABLE[(version122 - 1) * 4 + 1];
      case ErrorCorrectionLevel.Q:
        return RSBlock2.RS_BLOCK_TABLE[(version122 - 1) * 4 + 2];
      case ErrorCorrectionLevel.H:
        return RSBlock2.RS_BLOCK_TABLE[(version122 - 1) * 4 + 3];
      default:
        throw new Error("illegal error correction level: ".concat(errorCorrectionLevel));
    }
  };
  RSBlock2.RS_BLOCK_TABLE = [
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12, 7, 37, 13],
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ];
  return RSBlock2;
}();
var BitBuffer = /* @__PURE__ */ function() {
  function BitBuffer2() {
    this.length = 0;
    this.buffer = [];
  }
  __name(BitBuffer2, "BitBuffer2");
  __name2(BitBuffer2, "BitBuffer");
  BitBuffer2.prototype.getBuffer = function() {
    return this.buffer;
  };
  BitBuffer2.prototype.getLengthInBits = function() {
    return this.length;
  };
  BitBuffer2.prototype.getBit = function(index) {
    return (this.buffer[index / 8 >> 0] >>> 7 - index % 8 & 1) === 1;
  };
  BitBuffer2.prototype.put = function(num, length2) {
    for (var i22 = 0; i22 < length2; i22++) {
      this.putBit((num >>> length2 - i22 - 1 & 1) === 1);
    }
  };
  BitBuffer2.prototype.putBit = function(bit) {
    var buffer2 = this.buffer;
    if (this.length === buffer2.length * 8) {
      buffer2.push(0);
    }
    if (bit) {
      buffer2[this.length / 8 >> 0] |= 128 >>> this.length % 8;
    }
    this.length++;
  };
  return BitBuffer2;
}();
var OutputStream = /* @__PURE__ */ function() {
  function OutputStream2() {
  }
  __name(OutputStream2, "OutputStream2");
  __name2(OutputStream2, "OutputStream");
  OutputStream2.prototype.writeBytes = function(bytes, offset, length2) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length2 === void 0) {
      length2 = bytes.length;
    }
    for (var i22 = 0; i22 < length2; i22++) {
      this.writeByte(bytes[i22 + offset]);
    }
  };
  OutputStream2.prototype.flush = function() {
  };
  OutputStream2.prototype.close = function() {
    this.flush();
  };
  return OutputStream2;
}();
var ByteArrayOutputStream = /* @__PURE__ */ function(_super) {
  __extends2(ByteArrayOutputStream2, _super);
  function ByteArrayOutputStream2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.bytes = [];
    return _this;
  }
  __name(ByteArrayOutputStream2, "ByteArrayOutputStream2");
  __name2(ByteArrayOutputStream2, "ByteArrayOutputStream");
  ByteArrayOutputStream2.prototype.writeByte = function(byte) {
    this.bytes.push(byte);
  };
  ByteArrayOutputStream2.prototype.writeInt16 = function(byte) {
    this.bytes.push(byte, byte >>> 8);
  };
  ByteArrayOutputStream2.prototype.toByteArray = function() {
    return this.bytes;
  };
  return ByteArrayOutputStream2;
}(OutputStream);
function encode14(ch) {
  if (ch >= 0) {
    if (ch < 26) {
      return 65 + ch;
    } else if (ch < 52) {
      return 97 + (ch - 26);
    } else if (ch < 62) {
      return 48 + (ch - 52);
    } else if (ch === 62) {
      return 43;
    } else if (ch === 63) {
      return 47;
    }
  }
  throw new Error("illegal char: ".concat(String.fromCharCode(ch)));
}
__name(encode14, "encode14");
__name2(encode14, "encode");
var Base64EncodeOutputStream = /* @__PURE__ */ function(_super) {
  __extends2(Base64EncodeOutputStream2, _super);
  function Base64EncodeOutputStream2(stream) {
    var _this = _super.call(this) || this;
    _this.buffer = 0;
    _this.length = 0;
    _this.bufLength = 0;
    _this.stream = stream;
    return _this;
  }
  __name(Base64EncodeOutputStream2, "Base64EncodeOutputStream2");
  __name2(Base64EncodeOutputStream2, "Base64EncodeOutputStream");
  Base64EncodeOutputStream2.prototype.writeByte = function(byte) {
    this.buffer = this.buffer << 8 | byte & 255;
    this.bufLength += 8;
    this.length++;
    while (this.bufLength >= 6) {
      this.writeEncoded(this.buffer >>> this.bufLength - 6);
      this.bufLength -= 6;
    }
  };
  Base64EncodeOutputStream2.prototype.flush = function() {
    if (this.bufLength > 0) {
      this.writeEncoded(this.buffer << 6 - this.bufLength);
      this.buffer = 0;
      this.bufLength = 0;
    }
    var stream = this.stream;
    if (this.length % 3 != 0) {
      var pad2 = 3 - this.length % 3;
      for (var i22 = 0; i22 < pad2; i22++) {
        stream.writeByte(61);
      }
    }
  };
  Base64EncodeOutputStream2.prototype.writeEncoded = function(byte) {
    this.stream.writeByte(encode14(byte & 63));
  };
  return Base64EncodeOutputStream2;
}(OutputStream);
function encodeToBase64(data) {
  var output = new ByteArrayOutputStream();
  var stream = new Base64EncodeOutputStream(output);
  stream.writeBytes(data);
  stream.close();
  output.close();
  return output.toByteArray();
}
__name(encodeToBase64, "encodeToBase64");
__name2(encodeToBase64, "encodeToBase64");
var LZWTable = /* @__PURE__ */ function() {
  function LZWTable2() {
    this.size = 0;
    this.map = {};
  }
  __name(LZWTable2, "LZWTable2");
  __name2(LZWTable2, "LZWTable");
  LZWTable2.prototype.add = function(key22) {
    if (!this.contains(key22)) {
      this.map[key22] = this.size++;
    }
  };
  LZWTable2.prototype.getSize = function() {
    return this.size;
  };
  LZWTable2.prototype.indexOf = function(key22) {
    return this.map[key22];
  };
  LZWTable2.prototype.contains = function(key22) {
    return this.map[key22] >= 0;
  };
  return LZWTable2;
}();
var BitOutputStream = /* @__PURE__ */ function() {
  function BitOutputStream2(output) {
    this.output = output;
    this.bitLength = 0;
    this.bitBuffer = 0;
  }
  __name(BitOutputStream2, "BitOutputStream2");
  __name2(BitOutputStream2, "BitOutputStream");
  BitOutputStream2.prototype.write = function(data, length2) {
    if (data >>> length2 !== 0) {
      throw new Error("length overflow");
    }
    var output = this.output;
    while (this.bitLength + length2 >= 8) {
      output.writeByte(255 & (data << this.bitLength | this.bitBuffer));
      length2 -= 8 - this.bitLength;
      data >>>= 8 - this.bitLength;
      this.bitBuffer = 0;
      this.bitLength = 0;
    }
    this.bitBuffer = data << this.bitLength | this.bitBuffer;
    this.bitLength = this.bitLength + length2;
  };
  BitOutputStream2.prototype.flush = function() {
    var output = this.output;
    if (this.bitLength > 0) {
      output.writeByte(this.bitBuffer);
    }
    output.flush();
  };
  BitOutputStream2.prototype.close = function() {
    this.flush();
    this.output.close();
  };
  return BitOutputStream2;
}();
var GIFImage = /* @__PURE__ */ function() {
  function GIFImage2(width, height) {
    this.data = [];
    this.width = width;
    this.height = height;
    var size = width * height;
    for (var i22 = 0; i22 < size; i22++) {
      this.data[i22] = 0;
    }
  }
  __name(GIFImage2, "GIFImage2");
  __name2(GIFImage2, "GIFImage");
  GIFImage2.prototype.getLZWRaster = function(lzwMinCodeSize) {
    var table = new LZWTable();
    var fromCharCode = String.fromCharCode;
    var clearCode = 1 << lzwMinCodeSize;
    var endCode = (1 << lzwMinCodeSize) + 1;
    for (var i22 = 0; i22 < clearCode; i22++) {
      table.add(fromCharCode(i22));
    }
    table.add(fromCharCode(clearCode));
    table.add(fromCharCode(endCode));
    var bitLength = lzwMinCodeSize + 1;
    var byteOutput = new ByteArrayOutputStream();
    var bitOutput = new BitOutputStream(byteOutput);
    try {
      var data = this.data;
      var length_1 = data.length;
      var fromCharCode_1 = String.fromCharCode;
      bitOutput.write(clearCode, bitLength);
      var dataIndex = 0;
      var words2 = fromCharCode_1(data[dataIndex++]);
      while (dataIndex < length_1) {
        var char = fromCharCode_1(data[dataIndex++]);
        if (table.contains(words2 + char)) {
          words2 += char;
        } else {
          bitOutput.write(table.indexOf(words2), bitLength);
          if (table.getSize() < 4095) {
            if (table.getSize() === 1 << bitLength) {
              bitLength++;
            }
            table.add(words2 + char);
          }
          words2 = char;
        }
      }
      bitOutput.write(table.indexOf(words2), bitLength);
      bitOutput.write(endCode, bitLength);
    } finally {
      bitOutput.close();
    }
    return byteOutput.toByteArray();
  };
  GIFImage2.prototype.setPixel = function(x2, y3, pixel) {
    var _a = this, width = _a.width, height = _a.height;
    if (x2 < 0 || width <= x2)
      throw new Error("illegal x axis: ".concat(x2));
    if (y3 < 0 || height <= y3)
      throw new Error("illegal y axis: ".concat(y3));
    this.data[y3 * width + x2] = pixel;
  };
  GIFImage2.prototype.getPixel = function(x2, y3) {
    var _a = this, width = _a.width, height = _a.height;
    if (x2 < 0 || width <= x2)
      throw new Error("illegal x axis: ".concat(x2));
    if (y3 < 0 || height <= y3)
      throw new Error("illegal y axis: ".concat(y3));
    return this.data[y3 * width + x2];
  };
  GIFImage2.prototype.write = function(output) {
    var _a = this, width = _a.width, height = _a.height;
    output.writeByte(71);
    output.writeByte(73);
    output.writeByte(70);
    output.writeByte(56);
    output.writeByte(55);
    output.writeByte(97);
    output.writeInt16(width);
    output.writeInt16(height);
    output.writeByte(128);
    output.writeByte(0);
    output.writeByte(0);
    output.writeByte(0);
    output.writeByte(0);
    output.writeByte(0);
    output.writeByte(255);
    output.writeByte(255);
    output.writeByte(255);
    output.writeByte(44);
    output.writeInt16(0);
    output.writeInt16(0);
    output.writeInt16(width);
    output.writeInt16(height);
    output.writeByte(0);
    var lzwMinCodeSize = 2;
    var raster = this.getLZWRaster(lzwMinCodeSize);
    var raLength = raster.length;
    output.writeByte(lzwMinCodeSize);
    var offset = 0;
    while (raLength - offset > 255) {
      output.writeByte(255);
      output.writeBytes(raster, offset, 255);
      offset += 255;
    }
    var length2 = raLength - offset;
    output.writeByte(length2);
    output.writeBytes(raster, offset, length2);
    output.writeByte(0);
    output.writeByte(59);
  };
  GIFImage2.prototype.toDataURL = function() {
    var output = new ByteArrayOutputStream();
    this.write(output);
    var bytes = encodeToBase64(output.toByteArray());
    output.close();
    var length2 = bytes.length;
    var fromCharCode = String.fromCharCode;
    var url = "data:image/gif;base64,";
    for (var i22 = 0; i22 < length2; i22++) {
      url += fromCharCode(bytes[i22]);
    }
    return url;
  };
  return GIFImage2;
}();
function getMaskFunc(maskPattern) {
  switch (maskPattern) {
    case 0:
      return function(x2, y3) {
        return (x2 + y3 & 1) === 0;
      };
    case 1:
      return function(_x, y3) {
        return (y3 & 1) === 0;
      };
    case 2:
      return function(x2, _y) {
        return x2 % 3 === 0;
      };
    case 3:
      return function(x2, y3) {
        return (x2 + y3) % 3 === 0;
      };
    case 4:
      return function(x2, y3) {
        return ((x2 / 3 >> 0) + (y3 / 2 >> 0) & 1) === 0;
      };
    case 5:
      return function(x2, y3) {
        return (x2 * y3 & 1) + x2 * y3 % 3 === 0;
      };
    case 6:
      return function(x2, y3) {
        return ((x2 * y3 & 1) + x2 * y3 % 3 & 1) === 0;
      };
    case 7:
      return function(x2, y3) {
        return (x2 * y3 % 3 + (x2 + y3 & 1) & 1) === 0;
      };
    default:
      throw new Error("illegal mask: ".concat(maskPattern));
  }
}
__name(getMaskFunc, "getMaskFunc");
__name2(getMaskFunc, "getMaskFunc");
var PAD0 = 236;
var PAD1 = 17;
var toString5 = Object.prototype.toString;
function appendECI(encoding, buffer2) {
  if (encoding < 0 || encoding >= 1e6) {
    throw new Error("byte mode encoding hint out of range");
  }
  buffer2.put(Mode.ECI, 4);
  if (encoding < 1 << 7) {
    buffer2.put(encoding, 8);
  } else if (encoding < 1 << 14) {
    buffer2.put(2, 2);
    buffer2.put(encoding, 14);
  } else {
    buffer2.put(6, 3);
    buffer2.put(encoding, 21);
  }
}
__name(appendECI, "appendECI");
__name2(appendECI, "appendECI");
function prepareData(version122, errorCorrectionLevel, encodingHint, chunks) {
  var buffer2 = new BitBuffer();
  var rsBlocks = RSBlock.getRSBlocks(version122, errorCorrectionLevel);
  for (var _i = 0, chunks_1 = chunks; _i < chunks_1.length; _i++) {
    var data = chunks_1[_i];
    var mode = data.mode;
    if (encodingHint && mode === Mode.Byte) {
      appendECI(data.encoding, buffer2);
    }
    buffer2.put(mode, 4);
    buffer2.put(data.getLength(), data.getLengthInBits(version122));
    data.writeTo(buffer2);
  }
  var maxDataCount = 0;
  for (var _a = 0, rsBlocks_1 = rsBlocks; _a < rsBlocks_1.length; _a++) {
    var rsBlock = rsBlocks_1[_a];
    maxDataCount += rsBlock.getDataCount();
  }
  maxDataCount *= 8;
  return [buffer2, rsBlocks, maxDataCount];
}
__name(prepareData, "prepareData");
__name2(prepareData, "prepareData");
function createBytes(buffer2, rsBlocks) {
  var offset = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;
  var dcData = [];
  var ecData = [];
  var rsLength = rsBlocks.length;
  var bufferData = buffer2.getBuffer();
  for (var r2 = 0; r2 < rsLength; r2++) {
    var rsBlock = rsBlocks[r2];
    var dcCount = rsBlock.getDataCount();
    var ecCount = rsBlock.getTotalCount() - dcCount;
    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);
    dcData[r2] = [];
    for (var i22 = 0; i22 < dcCount; i22++) {
      dcData[r2][i22] = 255 & bufferData[i22 + offset];
    }
    offset += dcCount;
    var rsPoly = getErrorCorrectionPolynomial(ecCount);
    var ecLength = rsPoly.getLength() - 1;
    var rawPoly = new Polynomial(dcData[r2], ecLength);
    var modPoly = rawPoly.mod(rsPoly);
    var mpLength = modPoly.getLength();
    ecData[r2] = [];
    for (var i22 = 0; i22 < ecLength; i22++) {
      var modIndex = i22 + mpLength - ecLength;
      ecData[r2][i22] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
    }
  }
  buffer2 = new BitBuffer();
  for (var i22 = 0; i22 < maxDcCount; i22++) {
    for (var r2 = 0; r2 < rsLength; r2++) {
      if (i22 < dcData[r2].length) {
        buffer2.put(dcData[r2][i22], 8);
      }
    }
  }
  for (var i22 = 0; i22 < maxEcCount; i22++) {
    for (var r2 = 0; r2 < rsLength; r2++) {
      if (i22 < ecData[r2].length) {
        buffer2.put(ecData[r2][i22], 8);
      }
    }
  }
  return buffer2;
}
__name(createBytes, "createBytes");
__name2(createBytes, "createBytes");
function createData(buffer2, rsBlocks, maxDataCount) {
  if (buffer2.getLengthInBits() + 4 <= maxDataCount) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(false);
  }
  while (true) {
    if (buffer2.getLengthInBits() >= maxDataCount) {
      break;
    }
    buffer2.put(PAD0, 8);
    if (buffer2.getLengthInBits() >= maxDataCount) {
      break;
    }
    buffer2.put(PAD1, 8);
  }
  return createBytes(buffer2, rsBlocks);
}
__name(createData, "createData");
__name2(createData, "createData");
var Encoder2 = /* @__PURE__ */ function() {
  function Encoder3(options) {
    if (options === void 0) {
      options = {};
    }
    this.matrixSize = 0;
    this.chunks = [];
    this.matrix = [];
    var _a = options.version, version122 = _a === void 0 ? 0 : _a, _b = options.encodingHint, encodingHint = _b === void 0 ? false : _b, _c = options.errorCorrectionLevel, errorCorrectionLevel = _c === void 0 ? ErrorCorrectionLevel.L : _c;
    this.setVersion(version122);
    this.setEncodingHint(encodingHint);
    this.setErrorCorrectionLevel(errorCorrectionLevel);
  }
  __name(Encoder3, "Encoder3");
  __name2(Encoder3, "Encoder");
  Encoder3.prototype.getMatrix = function() {
    return this.matrix;
  };
  Encoder3.prototype.getMatrixSize = function() {
    return this.matrixSize;
  };
  Encoder3.prototype.getVersion = function() {
    return this.version;
  };
  Encoder3.prototype.setVersion = function(version122) {
    this.version = Math.min(40, Math.max(0, version122 >> 0));
    this.auto = this.version === 0;
    return this;
  };
  Encoder3.prototype.getErrorCorrectionLevel = function() {
    return this.errorCorrectionLevel;
  };
  Encoder3.prototype.setErrorCorrectionLevel = function(errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ErrorCorrectionLevel.L:
      case ErrorCorrectionLevel.M:
      case ErrorCorrectionLevel.Q:
      case ErrorCorrectionLevel.H:
        this.errorCorrectionLevel = errorCorrectionLevel;
    }
    return this;
  };
  Encoder3.prototype.getEncodingHint = function() {
    return this.encodingHint;
  };
  Encoder3.prototype.setEncodingHint = function(encodingHint) {
    this.encodingHint = encodingHint;
    return this;
  };
  Encoder3.prototype.write = function(data) {
    var chunks = this.chunks;
    if (data instanceof QRData) {
      chunks.push(data);
    } else {
      var type = toString5.call(data);
      if (type === "[object String]") {
        chunks.push(new QRByte(data));
      } else {
        throw new Error("illegal data: ".concat(data));
      }
    }
    return this;
  };
  Encoder3.prototype.isDark = function(row, col) {
    return this.matrix[row][col] === true;
  };
  Encoder3.prototype.setupFinderPattern = function(row, col) {
    var matrix = this.matrix;
    var matrixSize = this.matrixSize;
    for (var r2 = -1; r2 <= 7; r2++) {
      for (var c2 = -1; c2 <= 7; c2++) {
        if (row + r2 <= -1 || matrixSize <= row + r2 || col + c2 <= -1 || matrixSize <= col + c2) {
          continue;
        }
        if (0 <= r2 && r2 <= 6 && (c2 === 0 || c2 === 6) || 0 <= c2 && c2 <= 6 && (r2 === 0 || r2 === 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
          matrix[row + r2][col + c2] = true;
        } else {
          matrix[row + r2][col + c2] = false;
        }
      }
    }
  };
  Encoder3.prototype.setupAlignmentPattern = function() {
    var matrix = this.matrix;
    var pos = getAlignmentPattern(this.version);
    var length2 = pos.length;
    for (var i22 = 0; i22 < length2; i22++) {
      for (var j = 0; j < length2; j++) {
        var row = pos[i22];
        var col = pos[j];
        if (matrix[row][col] !== null) {
          continue;
        }
        for (var r2 = -2; r2 <= 2; r2++) {
          for (var c2 = -2; c2 <= 2; c2++) {
            if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
              matrix[row + r2][col + c2] = true;
            } else {
              matrix[row + r2][col + c2] = false;
            }
          }
        }
      }
    }
  };
  Encoder3.prototype.setupTimingPattern = function() {
    var matrix = this.matrix;
    var count = this.matrixSize - 8;
    for (var i22 = 8; i22 < count; i22++) {
      var bit = i22 % 2 === 0;
      if (matrix[i22][6] === null) {
        matrix[i22][6] = bit;
      }
      if (matrix[6][i22] === null) {
        matrix[6][i22] = bit;
      }
    }
  };
  Encoder3.prototype.setupFormatInfo = function(maskPattern) {
    var matrix = this.matrix;
    var data = this.errorCorrectionLevel << 3 | maskPattern;
    var bits = getBCHVersionInfo(data);
    var matrixSize = this.matrixSize;
    for (var i22 = 0; i22 < 15; i22++) {
      var bit = (bits >> i22 & 1) === 1;
      if (i22 < 6) {
        matrix[i22][8] = bit;
      } else if (i22 < 8) {
        matrix[i22 + 1][8] = bit;
      } else {
        matrix[matrixSize - 15 + i22][8] = bit;
      }
      if (i22 < 8) {
        matrix[8][matrixSize - i22 - 1] = bit;
      } else if (i22 < 9) {
        matrix[8][15 - i22 - 1 + 1] = bit;
      } else {
        matrix[8][15 - i22 - 1] = bit;
      }
    }
    matrix[matrixSize - 8][8] = true;
  };
  Encoder3.prototype.setupVersionInfo = function() {
    if (this.version >= 7) {
      var matrix = this.matrix;
      var matrixSize = this.matrixSize;
      var bits = getBCHVersion(this.version);
      for (var i22 = 0; i22 < 18; i22++) {
        var bit = (bits >> i22 & 1) === 1;
        matrix[i22 / 3 >> 0][i22 % 3 + matrixSize - 8 - 3] = bit;
        matrix[i22 % 3 + matrixSize - 8 - 3][i22 / 3 >> 0] = bit;
      }
    }
  };
  Encoder3.prototype.setupCodewords = function(data, maskPattern) {
    var matrix = this.matrix;
    var matrixSize = this.matrixSize;
    var bitLength = data.getLengthInBits();
    var maskFunc = getMaskFunc(maskPattern);
    var bitIndex = 0;
    for (var right = matrixSize - 1; right >= 1; right -= 2) {
      if (right === 6) {
        right = 5;
      }
      for (var vert = 0; vert < matrixSize; vert++) {
        for (var j = 0; j < 2; j++) {
          var x2 = right - j;
          var upward = (right + 1 & 2) === 0;
          var y3 = upward ? matrixSize - 1 - vert : vert;
          if (matrix[y3][x2] !== null) {
            continue;
          }
          var bit = false;
          if (bitIndex < bitLength) {
            bit = data.getBit(bitIndex++);
          }
          var invert = maskFunc(x2, y3);
          if (invert) {
            bit = !bit;
          }
          matrix[y3][x2] = bit;
        }
      }
    }
  };
  Encoder3.prototype.buildMatrix = function(data, maskPattern) {
    var matrix = [];
    var matrixSize = this.matrixSize;
    for (var row = 0; row < matrixSize; row++) {
      matrix[row] = [];
      for (var col = 0; col < matrixSize; col++) {
        matrix[row][col] = null;
      }
    }
    this.matrix = matrix;
    this.setupFinderPattern(0, 0);
    this.setupFinderPattern(matrixSize - 7, 0);
    this.setupFinderPattern(0, matrixSize - 7);
    this.setupAlignmentPattern();
    this.setupTimingPattern();
    this.setupFormatInfo(maskPattern);
    this.setupVersionInfo();
    this.setupCodewords(data, maskPattern);
  };
  Encoder3.prototype.make = function() {
    var _a, _b;
    var buffer2;
    var rsBlocks;
    var maxDataCount;
    var _c = this, chunks = _c.chunks, errorCorrectionLevel = _c.errorCorrectionLevel;
    if (this.auto) {
      var version122 = 1;
      for (; version122 <= 40; version122++) {
        _a = prepareData(version122, errorCorrectionLevel, this.encodingHint, chunks), buffer2 = _a[0], rsBlocks = _a[1], maxDataCount = _a[2];
        if (buffer2.getLengthInBits() <= maxDataCount)
          break;
      }
      var dataLengthInBits = buffer2.getLengthInBits();
      if (dataLengthInBits > maxDataCount) {
        throw new Error("data overflow: ".concat(dataLengthInBits, " > ").concat(maxDataCount));
      }
      this.version = version122;
    } else {
      _b = prepareData(this.version, errorCorrectionLevel, this.encodingHint, chunks), buffer2 = _b[0], rsBlocks = _b[1], maxDataCount = _b[2];
    }
    this.matrixSize = this.version * 4 + 17;
    var matrices = [];
    var data = createData(buffer2, rsBlocks, maxDataCount);
    var bestMaskPattern = -1;
    var minPenalty = Number.MAX_VALUE;
    for (var maskPattern = 0; maskPattern < 8; maskPattern++) {
      this.buildMatrix(data, maskPattern);
      matrices.push(this.matrix);
      var penalty = calculateMaskPenalty(this);
      if (penalty < minPenalty) {
        minPenalty = penalty;
        bestMaskPattern = maskPattern;
      }
    }
    this.matrix = matrices[bestMaskPattern];
    return this;
  };
  Encoder3.prototype.toDataURL = function(moduleSize, margin) {
    if (moduleSize === void 0) {
      moduleSize = 2;
    }
    if (margin === void 0) {
      margin = moduleSize * 4;
    }
    moduleSize = Math.max(1, moduleSize >> 0);
    margin = Math.max(0, margin >> 0);
    var matrixSize = this.matrixSize;
    var size = moduleSize * matrixSize + margin * 2;
    var min = margin;
    var max = size - margin;
    var gif = new GIFImage(size, size);
    for (var y3 = 0; y3 < size; y3++) {
      for (var x2 = 0; x2 < size; x2++) {
        if (min <= x2 && x2 < max && min <= y3 && y3 < max) {
          var row = (y3 - min) / moduleSize >> 0;
          var col = (x2 - min) / moduleSize >> 0;
          gif.setPixel(x2, y3, this.isDark(row, col) ? 0 : 1);
        } else {
          gif.setPixel(x2, y3, 1);
        }
      }
    }
    return gif.toDataURL();
  };
  Encoder3.prototype.clear = function() {
    this.chunks = [];
  };
  return Encoder3;
}();
function encode15(text) {
  var length2 = text.length;
  var bytes = [];
  for (var i22 = 0; i22 < length2; i22++) {
    bytes.push(text.charCodeAt(i22));
  }
  return bytes;
}
__name(encode15, "encode15");
__name2(encode15, "encode");
function getByte(byte) {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  } else if (65 <= byte && byte <= 90) {
    return byte - 65 + 10;
  } else {
    switch (byte) {
      case 32:
        return 36;
      case 36:
        return 37;
      case 37:
        return 38;
      case 42:
        return 39;
      case 43:
        return 40;
      case 45:
        return 41;
      case 46:
        return 42;
      case 47:
        return 43;
      case 58:
        return 44;
      default:
        throw new Error("illegal char: ".concat(String.fromCharCode(byte)));
    }
  }
}
__name(getByte, "getByte");
__name2(getByte, "getByte");
var QRAlphanumeric = /* @__PURE__ */ function(_super) {
  __extends2(QRAlphanumeric2, _super);
  function QRAlphanumeric2(data) {
    var _this = _super.call(this, Mode.Alphanumeric, data) || this;
    _this.bytes = encode15(data);
    return _this;
  }
  __name(QRAlphanumeric2, "QRAlphanumeric2");
  __name2(QRAlphanumeric2, "QRAlphanumeric");
  QRAlphanumeric2.prototype.writeTo = function(buffer2) {
    var i22 = 0;
    var bytes = this.bytes;
    var length2 = bytes.length;
    while (i22 + 1 < length2) {
      buffer2.put(getByte(bytes[i22]) * 45 + getByte(bytes[i22 + 1]), 11);
      i22 += 2;
    }
    if (i22 < length2) {
      buffer2.put(getByte(bytes[i22]), 6);
    }
  };
  return QRAlphanumeric2;
}(QRData);
var VP_QR_VERSION = "VP1";
var BASE_32_UPPERCASE_MULTIBASE_PREFIX = "B";
function _bytesToQrCodeDataUrl({ bytes, size }) {
  const qrcode = new Encoder2();
  qrcode.setEncodingHint(true);
  const encoded = base32Encode(bytes, "RFC4648", { padding: false });
  const vpPayload = `${VP_QR_VERSION}-${BASE_32_UPPERCASE_MULTIBASE_PREFIX}${encoded}`;
  qrcode.write(new QRAlphanumeric(vpPayload));
  qrcode.make();
  return {
    payload: vpPayload,
    encodedCborld: encoded,
    version: qrcode.getVersion(),
    imageDataUrl: qrcode.toDataURL(size)
  };
}
__name(_bytesToQrCodeDataUrl, "_bytesToQrCodeDataUrl");
__name2(_bytesToQrCodeDataUrl, "_bytesToQrCodeDataUrl");
async function toQrCode({
  vp,
  documentLoader,
  size,
  diagnose
} = {}) {
  const cborldBytes = await encode12({
    jsonldDocument: vp,
    documentLoader,
    diagnose
  });
  const {
    payload,
    imageDataUrl,
    encodedCborld,
    version: version122
  } = _bytesToQrCodeDataUrl({
    bytes: cborldBytes,
    size
  });
  return {
    payload,
    imageDataUrl,
    encodedCborld,
    rawCborldBytes: cborldBytes,
    version: version122
  };
}
__name(toQrCode, "toQrCode");
__name2(toQrCode, "toQrCode");
async function fromQrCode({
  text,
  documentLoader,
  diagnose
} = {}) {
  const header = VP_QR_VERSION + "-";
  if (!(text && text.startsWith(header))) {
    throw TypeError("Unsupported VP QR format.");
  }
  const multibasePayload = text.slice(header.length);
  if (!multibasePayload.startsWith(BASE_32_UPPERCASE_MULTIBASE_PREFIX)) {
    throw TypeError("Payload must be multibase base32 (RFC4648) encoded.");
  }
  const cborldArrayBuffer = (0, import_base32_decode.default)(multibasePayload.slice(1), "RFC4648");
  const cborldBytes = new Uint8Array(cborldArrayBuffer);
  const vp = await decode12({
    cborldBytes,
    documentLoader,
    diagnose
  });
  return { vp };
}
__name(fromQrCode, "fromQrCode");
__name2(fromQrCode, "fromQrCode");
var getVpqrPlugin = /* @__PURE__ */ __name2((learnCard) => {
  return {
    name: "Vpqr",
    displayName: "VP QR",
    description: "Allows reading and creating QR codes with Verifiable Presentations in them",
    methods: {
      vpFromQrCode: async (_learnCard, text) => {
        return (await fromQrCode({
          text,
          documentLoader: async (url) => ({
            document: await learnCard.invoke.contextLoader(url)
          })
        }))?.vp;
      },
      vpToQrCode: async (_learnCard, vp) => {
        return (await toQrCode({
          vp,
          documentLoader: async (url) => ({
            document: await learnCard.invoke.contextLoader(url)
          })
        }))?.imageDataUrl;
      }
    }
  };
}, "getVpqrPlugin");
var defaultCeramicIDXArgs = {
  modelData: {
    definitions: {
      MyVerifiableCredentials: "kjzl6cwe1jw14am5tu5hh412s19o4zm8aq3g2lpd6s4paxj2nly2lj4drp3pun2"
    },
    schemas: {
      AchievementVerifiableCredential: "ceramic://k3y52l7qbv1frylibw2725v8gem3hxs1onoh6pvux0szdduugczh0hddxo6qsd6o0",
      VerifiableCredentialsList: "ceramic://k3y52l7qbv1frxkcwfpyauky3fyl4n44izridy3blvjjzgftis40sk9w8g3remghs"
    },
    tiles: {}
  },
  credentialAlias: "MyVerifiableCredentials",
  ceramicEndpoint: "https://ceramic-node.welibrary.io:7007",
  defaultContentFamily: "SuperSkills"
};
var defaultEthereumArgs = {
  infuraProjectId: "",
  network: "mainnet"
};
var learnCardFromSeed = /* @__PURE__ */ __name2(async (seed, {
  ceramicIdx = defaultCeramicIDXArgs,
  didkit,
  ethereumConfig = defaultEthereumArgs,
  debug
} = {}) => {
  const didkitLc = await (await generateLearnCard({ debug })).addPlugin(await getDidKitPlugin(didkit));
  const didkeyLc = await didkitLc.addPlugin(
    await getDidKeyPlugin(didkitLc, seed, "key")
  );
  const didkeyAndVCLc = await didkeyLc.addPlugin(getVCPlugin(didkeyLc));
  const templateLc = await didkeyAndVCLc.addPlugin(getVCTemplatesPlugin());
  const resolutionLc = await templateLc.addPlugin(VCResolutionPlugin);
  const ceramicLc = await resolutionLc.addPlugin(
    await getCeramicPlugin(resolutionLc, ceramicIdx)
  );
  const idxLc = await ceramicLc.addPlugin(await getIDXPlugin(ceramicLc, ceramicIdx));
  const expirationLc = await idxLc.addPlugin(expirationPlugin(idxLc));
  const ethLc = await expirationLc.addPlugin(getEthereumPlugin(expirationLc, ethereumConfig));
  const vpqrLc = await ethLc.addPlugin(getVpqrPlugin(ethLc));
  const chapiLc = await vpqrLc.addPlugin(await getCHAPIPlugin());
  return chapiLc.addPlugin(getLearnCardPlugin(chapiLc));
}, "learnCardFromSeed");
var post = /* @__PURE__ */ __name2(async (url, data) => fetch(url, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(data)
}), "post");
var isSuccessful = /* @__PURE__ */ __name2((status) => status.toString().startsWith("2"), "isSuccessful");
var getVCAPIPlugin = /* @__PURE__ */ __name2(async ({
  url: _url,
  did: _did
}) => {
  const url = _url.endsWith("/") ? _url.slice(0, -1) : _url;
  let did = _did;
  if (!did) {
    const res = await fetch(`${url}/did`);
    if (res.status === 200)
      did = await res.text();
  }
  if (!did)
    throw new Error("Could not retrieve did from VC API! Please suppy a did.");
  return {
    name: "VC API",
    displayName: "VC API",
    description: "Handles issuing and signing credentials/presentations using an external VC API",
    id: {
      did: () => did,
      keypair: () => {
        throw new Error("Cannot get keypair when using VC API");
      }
    },
    methods: {
      getSubjectDid: () => did,
      issueCredential: async (_learnCard, credential, options) => {
        await UnsignedVCValidator.parseAsync(credential);
        const response = await post(`${url}/credentials/issue`, { credential, options });
        if (!isSuccessful(response.status)) {
          throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }
        return VCValidator.parseAsync(await response.json());
      },
      verifyCredential: async (_learnCard, verifiableCredential, options) => {
        await VCValidator.parseAsync(verifiableCredential);
        const response = await post(`${url}/credentials/verify`, {
          verifiableCredential,
          options
        });
        if (!isSuccessful(response.status)) {
          throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }
        return VerificationCheckValidator.parseAsync(await response.json());
      },
      issuePresentation: async (_learnCard, presentation, options) => {
        await UnsignedVPValidator.parseAsync(presentation);
        const response = await post(`${url}/presentations/issue`, {
          presentation,
          options
        });
        if (!isSuccessful(response.status)) {
          throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }
        return VPValidator.parseAsync(await response.json());
      },
      verifyPresentation: async (_learnCard, verifiablePresentation, options) => {
        await VPValidator.parseAsync(verifiablePresentation);
        const response = await post(`${url}/presentations/verify`, {
          verifiablePresentation,
          options
        });
        if (!isSuccessful(response.status)) {
          throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }
        return VerificationCheckValidator.parseAsync(await response.json());
      },
      getTestVc: (_learnCard, subject = "did:example:d23dd687a7dc6787646f2eb98d0") => {
        return {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          id: "http://example.org/credentials/3731",
          type: ["VerifiableCredential"],
          issuer: did,
          issuanceDate: "2020-08-19T21:41:50Z",
          credentialSubject: { id: subject }
        };
      },
      getTestVp: async (_learnCard, _credential) => {
        const credential = _credential || await _learnCard.invoke.issueCredential(_learnCard.invoke.getTestVc());
        return {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          type: ["VerifiablePresentation"],
          holder: did,
          verifiableCredential: credential
        };
      }
    }
  };
}, "getVCAPIPlugin");
var learnCardFromApiUrl = /* @__PURE__ */ __name2(async ({
  url,
  did,
  debug
}) => {
  const apiLc = await (await generateLearnCard({ debug })).addPlugin(await getVCAPIPlugin({ url, did }));
  const expirationLc = await apiLc.addPlugin(expirationPlugin(apiLc));
  const templateLc = await expirationLc.addPlugin(getVCTemplatesPlugin());
  const chapiLc = await templateLc.addPlugin(await getCHAPIPlugin());
  return chapiLc.addPlugin(getLearnCardPlugin(chapiLc));
}, "learnCardFromApiUrl");
async function initLearnCard(config2 = {}) {
  if ("custom" in config2)
    return customLearnCard({ debug: config2.debug });
  if ("vcApi" in config2) {
    const { vcApi, did, debug } = config2;
    return learnCardFromApiUrl({
      url: typeof vcApi === "string" ? vcApi : "https://bridge.learncard.com",
      did: vcApi === true ? "did:key:z6MkjSz4mYqcn7dePGuktJ5PxecMkXQQHWRg8Lm6okATyFVh" : did,
      debug
    });
  }
  if ("seed" in config2) {
    const { seed, ...keyConfig } = config2;
    return learnCardFromSeed(seed, keyConfig);
  }
  return emptyLearnCard(config2);
}
__name(initLearnCard, "initLearnCard");
__name2(initLearnCard, "initLearnCard");

// src/learnCard.ts
var initDidWebLearnCard = /* @__PURE__ */ __name(async (_config) => {
  const { didWeb, seed, ...config2 } = _config;
  const baseLearnCard = await initLearnCard({ seed, ...config2 });
  return baseLearnCard.addPlugin(await getDidWebPlugin(baseLearnCard, didWeb));
}, "initDidWebLearnCard");
/*!
 * A CredentialHandlerRegistration provides a CredentialManager to enable Web
 * apps to register Profiles that can be presented to websites.
 *
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * A CredentialRequestEvent is emitted when a request has been made for
 * credentials.
 *
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * A CredentialStoreEvent is emitted when a request has been made to
 * store a credential.
 *
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * A WebApp is a remote application that runs in a WebAppContext.
 *
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * A WebCredential is a Credential that can be retrieved from or stored by a
 * "credential handler" that runs in a third party Web application.
 *
 * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2019-2022 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2020-2021 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * JSON-RPC for Web Request Polyfills.
 *
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * The core CredentialHandler class.
 *
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Utilities for Web Request RPC.
 *
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Wrapper for native CredentialsContainer that uses remote Credential Mediator
 * for WebCredential-related operations.
 *
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * @module QRCode
 * @package @nuintun/qrcode
 * @license MIT
 * @version 3.3.0
 * @author nuintun <nuintun@qq.com>
 * @description A pure JavaScript QRCode encode and decode library.
 * @see https://github.com/nuintun/qrcode#readme
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=did-web-plugin.cjs.development.js.map
