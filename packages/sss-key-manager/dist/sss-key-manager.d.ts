// Generated by dts-bundle-generator v6.13.0

/**
 * SSS Key Manager Types
 */
export type ContactMethodType = "email" | "phone";
export interface ContactMethod {
	type: ContactMethodType;
	value: string;
}
export type AuthProviderType = "firebase" | "supertokens" | "keycloak" | "oidc";
export interface AuthProviderMapping {
	type: AuthProviderType;
	id: string;
}
export interface AuthUser {
	id: string;
	email?: string;
	phone?: string;
	providerType: AuthProviderType;
}
export interface AuthProvider {
	getIdToken(): Promise<string>;
	getCurrentUser(): Promise<AuthUser | null>;
	getProviderType(): AuthProviderType;
	signOut(): Promise<void>;
}
export type SecurityLevel = "basic" | "enhanced" | "advanced";
export type RecoveryMethodType = "password" | "passkey" | "backup";
export interface RecoveryMethodInfo {
	type: RecoveryMethodType;
	createdAt: Date;
	credentialId?: string;
}
export interface PasswordRecoveryMethod {
	type: "password";
	password: string;
}
export interface PasskeyRecoveryMethod {
	type: "passkey";
	credentialId?: string;
}
export interface BackupFileRecoveryMethod {
	type: "backup";
	fileContents: string;
	password: string;
}
export type RecoveryMethod = PasswordRecoveryMethod | PasskeyRecoveryMethod | BackupFileRecoveryMethod;
export interface EncryptedShare {
	encryptedData: string;
	iv: string;
	salt?: string;
}
export interface ServerEncryptedShare {
	encryptedData: string;
	encryptedDek: string;
	iv: string;
}
export interface UserKeyRecord {
	contactMethod: ContactMethod;
	authProviders: AuthProviderMapping[];
	primaryDid: string;
	linkedDids: string[];
	keyProvider: "web3auth" | "sss";
	authShare?: ServerEncryptedShare;
	securityLevel: SecurityLevel;
	recoveryMethods: RecoveryMethodInfo[];
	migratedFromWeb3Auth: boolean;
	migratedAt?: Date;
	createdAt: Date;
	updatedAt: Date;
}
export interface BackupFile {
	version: 1;
	createdAt: string;
	primaryDid: string;
	encryptedShare: {
		ciphertext: string;
		iv: string;
		salt: string;
		kdfParams: {
			algorithm: "argon2id";
			timeCost: number;
			memoryCost: number;
			parallelism: number;
		};
	};
}
export interface SSSKeyManagerConfig {
	serverUrl: string;
	authProvider: AuthProvider;
	deviceStorageKey?: string;
}
export interface KeyDerivationProvider {
	readonly name: string;
	connect(): Promise<string>;
	disconnect(): Promise<void>;
	isInitialized(): boolean;
	hasLocalKey(): Promise<boolean>;
	canMigrate?(): Promise<boolean>;
	migrate?(privateKey: string): Promise<void>;
}
export interface SSSKeyDerivationProvider extends KeyDerivationProvider {
	addRecoveryMethod(method: RecoveryMethod): Promise<void>;
	getRecoveryMethods(): Promise<RecoveryMethodInfo[]>;
	recover(method: RecoveryMethod): Promise<string>;
	getSecurityLevel(): Promise<SecurityLevel>;
	exportBackup(password: string): Promise<BackupFile>;
}
export declare class SSSKeyManager implements SSSKeyDerivationProvider {
	readonly name = "sss";
	private config;
	private apiClient;
	private initialized;
	private currentPrivateKey;
	constructor(config: SSSKeyManagerConfig);
	isInitialized(): boolean;
	hasLocalKey(): Promise<boolean>;
	connect(): Promise<string>;
	disconnect(): Promise<void>;
	setupNewKey(): Promise<string>;
	setupWithKey(privateKey: string, primaryDid?: string): Promise<void>;
	migrate(privateKey: string): Promise<void>;
	canMigrate(): Promise<boolean>;
	addRecoveryMethod(method: RecoveryMethod): Promise<void>;
	getRecoveryMethods(): Promise<RecoveryMethodInfo[]>;
	recover(method: RecoveryMethod): Promise<string>;
	getSecurityLevel(): Promise<SecurityLevel>;
	exportBackup(password: string): Promise<BackupFile>;
	clearLocalData(): Promise<void>;
	deleteAccount(): Promise<void>;
}
export declare function createSSSKeyManager(config: SSSKeyManagerConfig): SSSKeyManager;
export interface GetAuthShareResponse {
	authShare: ServerEncryptedShare | null;
	primaryDid: string | null;
	securityLevel: SecurityLevel;
	recoveryMethods: RecoveryMethodInfo[];
	keyProvider: "web3auth" | "sss";
}
export interface StoreAuthShareInput {
	authShare: ServerEncryptedShare;
	primaryDid: string;
	securityLevel?: SecurityLevel;
}
export interface StoreRecoveryShareInput {
	type: "password" | "passkey" | "backup";
	encryptedShare: EncryptedShare;
	credentialId?: string;
}
export interface ApiClientConfig {
	serverUrl: string;
	authProvider: AuthProvider;
}
export declare class SSSApiClient {
	private serverUrl;
	private authProvider;
	constructor(config: ApiClientConfig);
	private getAuthHeaders;
	private getContactMethodFromUser;
	getAuthShare(): Promise<GetAuthShareResponse | null>;
	storeAuthShare(input: StoreAuthShareInput): Promise<void>;
	addRecoveryMethod(input: StoreRecoveryShareInput): Promise<void>;
	getRecoveryShare(type: "password" | "passkey" | "backup", credentialId?: string): Promise<EncryptedShare | null>;
	markMigrated(): Promise<void>;
	deleteUserKey(): Promise<void>;
}
/**
 * Shamir Secret Sharing operations
 */
export declare const SSS_TOTAL_SHARES = 3;
export declare const SSS_THRESHOLD = 2;
export interface SSSShares {
	deviceShare: string;
	authShare: string;
	recoveryShare: string;
}
export declare function splitPrivateKey(privateKeyHex: string): Promise<SSSShares>;
export declare function reconstructPrivateKey(share1Hex: string, share2Hex: string): Promise<string>;
export declare function reconstructFromShares(shares: string[]): Promise<string>;
/**
 * Device-side storage for SSS shares
 * Reuses patterns from webSecureStorage but specialized for SSS
 */
export declare function storeDeviceShare(share: string, id?: string): Promise<void>;
export declare function getDeviceShare(id?: string): Promise<string | null>;
export declare function hasDeviceShare(id?: string): Promise<boolean>;
export declare function deleteDeviceShare(id?: string): Promise<void>;
export declare function clearAllShares(): Promise<void>;
/**
 * Cryptographic utilities for SSS Key Manager
 */
export interface KdfParams {
	algorithm: "argon2id";
	timeCost: number;
	memoryCost: number;
	parallelism: number;
}
export declare const DEFAULT_KDF_PARAMS: KdfParams;
export declare function bufferToBase64(buf: ArrayBuffer): string;
export declare function base64ToBuffer(b64: string): Uint8Array;
export declare function hexToBytes(hex: string): Uint8Array;
export declare function bytesToHex(bytes: Uint8Array): string;
export declare function deriveKeyFromPassword(password: string, salt: Uint8Array, params?: KdfParams): Promise<Uint8Array>;
export declare function encryptWithPassword(plaintext: string, password: string): Promise<{
	ciphertext: string;
	iv: string;
	salt: string;
	kdfParams: KdfParams;
}>;
export declare function decryptWithPassword(ciphertext: string, iv: string, salt: string, password: string, params?: KdfParams): Promise<string>;
export declare function generateEd25519PrivateKey(): Promise<string>;

export {};
