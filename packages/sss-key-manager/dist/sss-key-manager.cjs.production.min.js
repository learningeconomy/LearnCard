"use strict";var le=Object.create;var P=Object.defineProperty;var fe=Object.getOwnPropertyDescriptor;var ve=Object.getOwnPropertyNames;var we=Object.getPrototypeOf,Se=Object.prototype.hasOwnProperty;var s=(a,e)=>P(a,"name",{value:e,configurable:!0});var ge=(a,e)=>{for(var t in e)P(a,t,{get:e[t],enumerable:!0})},Y=(a,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of ve(e))!Se.call(a,n)&&n!==t&&P(a,n,{get:()=>e[n],enumerable:!(r=fe(e,n))||r.enumerable});return a};var me=(a,e,t)=>(t=a!=null?le(we(a)):{},Y(e||!a||!a.__esModule?P(t,"default",{value:a,enumerable:!0}):t,a)),Pe=a=>Y(P({},"__esModule",{value:!0}),a);var De={};ge(De,{DEFAULT_KDF_PARAMS:()=>S,SSSApiClient:()=>g,SSSKeyManager:()=>D,SSS_THRESHOLD:()=>m,SSS_TOTAL_SHARES:()=>j,base64ToBuffer:()=>u,bufferToBase64:()=>h,bytesToHex:()=>y,clearAllShares:()=>G,countWords:()=>he,createPasskeyCredential:()=>H,createSSSKeyManager:()=>pe,decryptShareWithPasskey:()=>V,decryptWithPassword:()=>A,deleteDeviceShare:()=>_,deriveKeyFromPasskey:()=>W,deriveKeyFromPassword:()=>U,encryptShareWithPasskey:()=>$,encryptWithPassword:()=>b,generateEd25519PrivateKey:()=>I,generateRecoveryPhrase:()=>ye,getDeviceShare:()=>E,hasDeviceShare:()=>N,hexToBytes:()=>l,isPRFSupported:()=>se,isWebAuthnSupported:()=>K,reconstructFromShares:()=>X,reconstructPrivateKey:()=>v,recoveryPhraseToShare:()=>R,shareToRecoveryPhrase:()=>T,splitPrivateKey:()=>d,storeDeviceShare:()=>w,validateRecoveryPhrase:()=>de});module.exports=Pe(De);var g=class{static{s(this,"SSSApiClient")}constructor(e){this.serverUrl=e.serverUrl.replace(/\/$/,""),this.authProvider=e.authProvider}async getAuthHeaders(){return{"Content-Type":"application/json",Authorization:`Bearer ${await this.authProvider.getIdToken()}`}}async getContactMethodFromUser(){let e=await this.authProvider.getCurrentUser();return e?e.email?{type:"email",value:e.email.toLowerCase()}:e.phone?{type:"phone",value:e.phone}:null:null}async getAuthShare(){let e=await this.getAuthHeaders(),t=this.authProvider.getProviderType(),r=await fetch(`${this.serverUrl}/keys/auth-share`,{method:"POST",headers:e,body:JSON.stringify({providerType:t})});if(!r.ok){if(r.status===404)return null;throw new Error(`Failed to get auth share: ${r.statusText}`)}return r.json()}async storeAuthShare(e){let t=await this.getAuthHeaders(),r=this.authProvider.getProviderType(),n=await fetch(`${this.serverUrl}/keys/auth-share`,{method:"PUT",headers:t,body:JSON.stringify({...e,providerType:r})});if(!n.ok)throw new Error(`Failed to store auth share: ${n.statusText}`)}async addRecoveryMethod(e){let t=await this.getAuthHeaders(),r=this.authProvider.getProviderType(),n=await fetch(`${this.serverUrl}/keys/recovery`,{method:"POST",headers:t,body:JSON.stringify({...e,providerType:r})});if(!n.ok)throw new Error(`Failed to add recovery method: ${n.statusText}`)}async getRecoveryShare(e,t){let r=await this.authProvider.getIdToken(),n=this.authProvider.getProviderType(),i=new URLSearchParams({type:e,providerType:n,authToken:r});t&&i.append("credentialId",t);let o=await fetch(`${this.serverUrl}/keys/recovery?${i}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!o.ok){if(o.status===404)return null;throw new Error(`Failed to get recovery share: ${o.statusText}`)}return o.json()}async markMigrated(){let e=await this.getAuthHeaders(),t=this.authProvider.getProviderType(),r=await fetch(`${this.serverUrl}/keys/migrate`,{method:"POST",headers:e,body:JSON.stringify({providerType:t})});if(!r.ok)throw new Error(`Failed to mark as migrated: ${r.statusText}`)}async deleteUserKey(){let e=await this.getAuthHeaders(),t=this.authProvider.getProviderType(),r=await fetch(`${this.serverUrl}/keys`,{method:"DELETE",headers:e,body:JSON.stringify({providerType:t})});if(!r.ok)throw new Error(`Failed to delete user key: ${r.statusText}`)}};var x=require("shamir-secret-sharing");var Q=require("hash-wasm");var be=3,Ae=65536,xe=4,ke=32,S={algorithm:"argon2id",timeCost:be,memoryCost:Ae,parallelism:xe};function h(a){let e=new Uint8Array(a),t="";for(let r=0;r<e.byteLength;r++)t+=String.fromCharCode(e[r]);return btoa(t)}s(h,"bufferToBase64");function u(a){let e=atob(a),t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t}s(u,"base64ToBuffer");function l(a){let e=new Uint8Array(a.length/2);for(let t=0;t<a.length;t+=2)e[t/2]=parseInt(a.slice(t,t+2),16);return e}s(l,"hexToBytes");function y(a){return Array.from(a).map(e=>e.toString(16).padStart(2,"0")).join("")}s(y,"bytesToHex");async function U(a,e,t=S){let r=await(0,Q.argon2id)({password:a,salt:e,iterations:t.timeCost,memorySize:t.memoryCost,parallelism:t.parallelism,hashLength:ke,outputType:"binary"});return new Uint8Array(r)}s(U,"deriveKeyFromPassword");async function b(a,e){let t=crypto.getRandomValues(new Uint8Array(16)),r=crypto.getRandomValues(new Uint8Array(12)),n=await U(e,t),i=await crypto.subtle.importKey("raw",n.buffer,{name:"AES-GCM"},!1,["encrypt"]),o=new TextEncoder,c=await crypto.subtle.encrypt({name:"AES-GCM",iv:r},i,o.encode(a));return{ciphertext:h(c),iv:h(r.buffer),salt:h(t.buffer),kdfParams:S}}s(b,"encryptWithPassword");async function A(a,e,t,r,n=S){let i=u(t),o=u(e),c=u(a),f=await U(r,i,n),B=await crypto.subtle.importKey("raw",f.buffer,{name:"AES-GCM"},!1,["decrypt"]),z=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},B,c);return new TextDecoder().decode(z)}s(A,"decryptWithPassword");function Ce(a){return crypto.getRandomValues(new Uint8Array(a))}s(Ce,"generateRandomBytes");async function I(){let a=Ce(32);return y(a)}s(I,"generateEd25519PrivateKey");var j=3,m=2;async function d(a){let e=l(a),t=await(0,x.split)(e,j,m);return{deviceShare:y(t[0]),authShare:y(t[1]),recoveryShare:y(t[2])}}s(d,"splitPrivateKey");async function v(a,e){let t=l(a),r=l(e),n=await(0,x.combine)([t,r]);return y(n)}s(v,"reconstructPrivateKey");async function X(a){if(a.length<m)throw new Error(`Need at least ${m} shares to reconstruct key`);let e=a.slice(0,m).map(l),t=await(0,x.combine)(e);return y(t)}s(X,"reconstructFromShares");var te="lcb-sss-keys";var L="keys",k="shares",O="sss-device-share";function F(){return new Promise((a,e)=>{let t=indexedDB.open(te,1);t.onupgradeneeded=()=>{let r=t.result;r.objectStoreNames.contains(L)||r.createObjectStore(L),r.objectStoreNames.contains(k)||r.createObjectStore(k)},t.onsuccess=()=>a(t.result),t.onerror=()=>e(t.error)})}s(F,"openDB");function C(a,e,t,r){return new Promise((n,i)=>{let c=a.transaction(e,t).objectStore(e),f=r(c);f.onsuccess=()=>n(f.result),f.onerror=()=>i(f.error)})}s(C,"tx");async function re(){let a=await F();try{let e=await C(a,L,"readonly",r=>r.get("master-key"));if(e)return e;let t=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);return await C(a,L,"readwrite",r=>r.put(t,"master-key")),t}finally{a.close()}}s(re,"getOrCreateMasterKey");function Z(a){let e=new Uint8Array(a),t="";for(let r=0;r<e.byteLength;r++)t+=String.fromCharCode(e[r]);return btoa(t)}s(Z,"bufferToBase64");function ee(a){let e=atob(a),t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t.buffer}s(ee,"base64ToBuffer");async function Ee(a,e){let t=await re(),r=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder,i=n.encode(e),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:r,additionalData:i},t,n.encode(a));return{version:1,iv:Z(r.buffer),cipher:Z(o),keyVersion:1}}s(Ee,"encryptShare");async function Ke(a,e){let t=await re(),r=new Uint8Array(ee(a.iv)),n=ee(a.cipher),o=new TextEncoder().encode(e),c=await crypto.subtle.decrypt({name:"AES-GCM",iv:r,additionalData:o},t,n);return new TextDecoder().decode(c)}s(Ke,"decryptShare");async function w(a,e=O){let t=await F();try{let r=await Ee(a,e);await C(t,k,"readwrite",n=>n.put(r,e))}finally{t.close()}}s(w,"storeDeviceShare");async function E(a=O){let e=await F();try{let t=await C(e,k,"readonly",r=>r.get(a));if(!t)return null;try{return await Ke(t,a)}catch(r){return console.warn("SSS Storage: decryption failed",r),null}}finally{e.close()}}s(E,"getDeviceShare");async function N(a=O){return await E(a)!==null}s(N,"hasDeviceShare");async function _(a=O){let e=await F();try{await C(e,k,"readwrite",t=>t.delete(a))}finally{e.close()}}s(_,"deleteDeviceShare");async function G(){await new Promise((a,e)=>{let t=indexedDB.deleteDatabase(te);t.onsuccess=()=>a(),t.onerror=()=>e(t.error),t.onblocked=()=>a()})}s(G,"clearAllShares");var Te="LearnCard",ae=typeof window<"u"?window.location.hostname:"localhost",ne=new TextEncoder().encode("learncard-sss-recovery-v1");function K(){return typeof window<"u"&&typeof window.PublicKeyCredential<"u"&&typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable=="function"}s(K,"isWebAuthnSupported");async function se(){if(!K())return!1;try{return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}catch{return!1}}s(se,"isPRFSupported");async function H(a,e){if(!K())throw new Error("WebAuthn is not supported in this browser");let t=new TextEncoder().encode(a),r={challenge:crypto.getRandomValues(new Uint8Array(32)),rp:{name:Te,id:ae},user:{id:t,name:e,displayName:e},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required",residentKey:"required"},timeout:6e4,attestation:"none",extensions:{prf:{eval:{first:ne}}}},n=await navigator.credentials.create({publicKey:r});if(!n)throw new Error("Failed to create passkey credential");let i=n.response,o=n.getClientExtensionResults();return!o.prf?.enabled&&!o.prf?.results?.first&&console.warn("PRF extension may not be supported, passkey created but encryption key derivation may fail"),{credentialId:h(n.rawId),publicKey:h(i.getPublicKey()),transports:i.getTransports?.()}}s(H,"createPasskeyCredential");async function W(a){if(!K())throw new Error("WebAuthn is not supported in this browser");let e={challenge:crypto.getRandomValues(new Uint8Array(32)),rpId:ae,allowCredentials:[{id:u(a),type:"public-key"}],userVerification:"required",timeout:6e4,extensions:{prf:{eval:{first:ne}}}},t=await navigator.credentials.get({publicKey:e});if(!t)throw new Error("Failed to get passkey assertion");let r=t.getClientExtensionResults();if(!r.prf?.results?.first)throw new Error("PRF extension not available or failed. This passkey cannot be used for encryption.");let n=new Uint8Array(r.prf.results.first);return await crypto.subtle.importKey("raw",n,{name:"AES-GCM"},!1,["encrypt","decrypt"])}s(W,"deriveKeyFromPasskey");async function $(a,e){let t=await W(e),r=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder,i=await crypto.subtle.encrypt({name:"AES-GCM",iv:r},t,n.encode(a));return{encryptedData:h(i),iv:h(r.buffer),credentialId:e}}s($,"encryptShareWithPasskey");async function V(a){let e=await W(a.credentialId),t=u(a.iv),r=u(a.encryptedData),n=await crypto.subtle.decrypt({name:"AES-GCM",iv:t.buffer},e,r.buffer);return new TextDecoder().decode(n)}s(V,"decryptShareWithPasskey");var q=null;async function ie(){return q||(q=import("@scure/bip39/wordlists/english").then(a=>a.wordlist)),q}s(ie,"getWordlist");function oe(a){return Array.from(a).map(e=>e.toString(2).padStart(8,"0")).join("")}s(oe,"bytesToBits");function Re(a){let e=new Uint8Array(Math.ceil(a.length/8));for(let t=0;t<e.length;t++)e[t]=parseInt(a.slice(t*8,(t+1)*8).padEnd(8,"0"),2);return e}s(Re,"bitsToBytes");async function ce(a){let e=await crypto.subtle.digest("SHA-256",a),t=oe(new Uint8Array(e)),r=Math.floor(a.length/4);return t.slice(0,r)}s(ce,"computeChecksum");async function T(a){let e=await ie(),t=l(a),r=await ce(t),n=oe(t)+r,i=[];for(let o=0;o<n.length;o+=11){let c=parseInt(n.slice(o,o+11).padEnd(11,"0"),2);i.push(e[c])}return i.join(" ")}s(T,"shareToRecoveryPhrase");async function R(a){let e=await ie(),t=a.trim().toLowerCase().split(/\s+/);if(t.length<12||t.length>27)throw new Error("Recovery phrase must be 12-27 words");let r="";for(let p of t){let M=e.indexOf(p);if(M===-1)throw new Error(`Invalid word in recovery phrase: ${p}`);r+=M.toString(2).padStart(11,"0")}let n=0;for(let p=1;p<=64;p++){let M=Math.floor(p/4),ue=p*8+M,J=Math.ceil(ue/11);if(J===t.length)n=p;else if(J>t.length)break}if(n===0)throw new Error("Could not determine data size from word count");let i=Math.floor(n/4),o=n*8,c=r.slice(0,o),f=r.slice(o,o+i),B=Re(c),z=await ce(B);if(f!==z.slice(0,i))throw new Error("Invalid recovery phrase checksum");return y(B)}s(R,"recoveryPhraseToShare");async function ye(a){return{phrase:await T(a),shareHex:a}}s(ye,"generateRecoveryPhrase");async function de(a){try{return await R(a),!0}catch{return!1}}s(de,"validateRecoveryPhrase");function he(a){return a.trim().split(/\s+/).filter(e=>e.length>0).length}s(he,"countWords");var D=class{constructor(e){this.name="sss";this.initialized=!1;this.currentPrivateKey=null;this.config=e,this.apiClient=new g({serverUrl:e.serverUrl,authProvider:e.authProvider})}static{s(this,"SSSKeyManager")}isInitialized(){return this.initialized}async hasLocalKey(){return N(this.config.deviceStorageKey)}async connect(){let e=await E(this.config.deviceStorageKey);if(!e)throw new Error("No device share found. User needs to set up SSS or recover.");let t=await this.apiClient.getAuthShare();if(!t||!t.authShare)throw new Error("No auth share found on server. User may need to recover.");if(t.keyProvider!=="sss")throw new Error("User has not migrated to SSS yet.");let r=await v(e,t.authShare.encryptedData);return this.currentPrivateKey=r,this.initialized=!0,r}async disconnect(){this.currentPrivateKey=null,this.initialized=!1}async setupNewKey(){let e=await I();return await this.setupWithKey(e),e}async setupWithKey(e,t){let r=await d(e);await w(r.deviceShare,this.config.deviceStorageKey);let n=t||`did:key:placeholder-${Date.now()}`;await this.apiClient.storeAuthShare({authShare:{encryptedData:r.authShare,encryptedDek:"",iv:""},primaryDid:n,securityLevel:"basic"}),this.currentPrivateKey=e,this.initialized=!0}async migrate(e){await this.setupWithKey(e),await this.apiClient.markMigrated()}async canMigrate(){return(await this.apiClient.getAuthShare())?.keyProvider==="web3auth"}async addRecoveryMethod(e){if(!this.currentPrivateKey)throw new Error("No active key. Connect first.");let r=(await d(this.currentPrivateKey)).recoveryShare;if(e.type==="password"){let n=await b(r,e.password);await this.apiClient.addRecoveryMethod({type:"password",encryptedShare:{encryptedData:n.ciphertext,iv:n.iv,salt:n.salt}})}else if(e.type==="passkey"){let n=await this.config.authProvider.getCurrentUser();if(!n)throw new Error("No authenticated user");let i=await H(n.id,n.email||n.phone||n.id),o=await $(r,i.credentialId);await this.apiClient.addRecoveryMethod({type:"passkey",encryptedShare:{encryptedData:o.encryptedData,iv:o.iv},credentialId:i.credentialId})}else if(e.type==="backup")throw new Error("Use exportBackup() instead")}async generateRecoveryPhrase(){if(!this.currentPrivateKey)throw new Error("No active key. Connect first.");let e=await d(this.currentPrivateKey);return await T(e.recoveryShare)}async getRecoveryMethods(){return(await this.apiClient.getAuthShare())?.recoveryMethods||[]}async recover(e){if(e.type==="password"){let t=await this.apiClient.getRecoveryShare("password");if(!t||!t.salt)throw new Error("No password recovery share found");let r=await A(t.encryptedData,t.iv,t.salt,e.password,S),n=await this.apiClient.getAuthShare();if(!n||!n.authShare)throw new Error("No auth share found on server");let i=await v(r,n.authShare.encryptedData),o=await d(i);return await w(o.deviceShare,this.config.deviceStorageKey),this.currentPrivateKey=i,this.initialized=!0,i}else if(e.type==="backup"){let t=JSON.parse(e.fileContents);if(t.version!==1)throw new Error("Unsupported backup file version");let r=await A(t.encryptedShare.ciphertext,t.encryptedShare.iv,t.encryptedShare.salt,e.password,t.encryptedShare.kdfParams),n=await this.apiClient.getAuthShare();if(!n||!n.authShare)throw new Error("No auth share found on server");let i=await v(r,n.authShare.encryptedData),o=await d(i);return await w(o.deviceShare,this.config.deviceStorageKey),this.currentPrivateKey=i,this.initialized=!0,i}else if(e.type==="passkey"){let t=await this.apiClient.getRecoveryShare("passkey",e.credentialId);if(!t)throw new Error("No passkey recovery share found");let r=await V({encryptedData:t.encryptedData,iv:t.iv,credentialId:e.credentialId||""}),n=await this.apiClient.getAuthShare();if(!n||!n.authShare)throw new Error("No auth share found on server");let i=await v(r,n.authShare.encryptedData),o=await d(i);return await w(o.deviceShare,this.config.deviceStorageKey),this.currentPrivateKey=i,this.initialized=!0,i}else if(e.type==="phrase"){let t=await R(e.phrase),r=await this.apiClient.getAuthShare();if(!r||!r.authShare)throw new Error("No auth share found on server");let n=await v(t,r.authShare.encryptedData),i=await d(n);return await w(i.deviceShare,this.config.deviceStorageKey),this.currentPrivateKey=n,this.initialized=!0,n}throw new Error("Unknown recovery method")}async getSecurityLevel(){return(await this.apiClient.getAuthShare())?.securityLevel||"basic"}async exportBackup(e){if(!this.currentPrivateKey)throw new Error("No active key. Connect first.");let t=await d(this.currentPrivateKey),r=await b(t.recoveryShare,e),n=await this.apiClient.getAuthShare();return{version:1,createdAt:new Date().toISOString(),primaryDid:n?.primaryDid||"unknown",encryptedShare:{ciphertext:r.ciphertext,iv:r.iv,salt:r.salt,kdfParams:r.kdfParams}}}async clearLocalData(){await _(this.config.deviceStorageKey),this.currentPrivateKey=null,this.initialized=!1}async deleteAccount(){await this.apiClient.deleteUserKey(),await G(),this.currentPrivateKey=null,this.initialized=!1}};function pe(a){return new D(a)}s(pe,"createSSSKeyManager");
