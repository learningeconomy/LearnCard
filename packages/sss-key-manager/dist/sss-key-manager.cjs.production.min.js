"use strict";var T=Object.defineProperty;var V=Object.getOwnPropertyDescriptor;var W=Object.getOwnPropertyNames;var J=Object.prototype.hasOwnProperty;var s=(a,e)=>T(a,"name",{value:e,configurable:!0});var q=(a,e)=>{for(var r in e)T(a,r,{get:e[r],enumerable:!0})},Y=(a,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of W(e))!J.call(a,n)&&n!==r&&T(a,n,{get:()=>e[n],enumerable:!(t=V(e,n))||t.enumerable});return a};var Q=a=>Y(T({},"__esModule",{value:!0}),a);var se={};q(se,{DEFAULT_KDF_PARAMS:()=>d,SSSApiClient:()=>l,SSSKeyManager:()=>x,SSS_THRESHOLD:()=>v,SSS_TOTAL_SHARES:()=>O,base64ToBuffer:()=>g,bufferToBase64:()=>w,bytesToHex:()=>c,clearAllShares:()=>L,createSSSKeyManager:()=>$,decryptWithPassword:()=>P,deleteDeviceShare:()=>U,deriveKeyFromPassword:()=>k,encryptWithPassword:()=>m,generateEd25519PrivateKey:()=>C,getDeviceShare:()=>K,hasDeviceShare:()=>B,hexToBytes:()=>p,reconstructFromShares:()=>I,reconstructPrivateKey:()=>S,splitPrivateKey:()=>y,storeDeviceShare:()=>f});module.exports=Q(se);var l=class{static{s(this,"SSSApiClient")}constructor(e){this.serverUrl=e.serverUrl.replace(/\/$/,""),this.authProvider=e.authProvider}async getAuthHeaders(){return{"Content-Type":"application/json",Authorization:`Bearer ${await this.authProvider.getIdToken()}`}}async getContactMethodFromUser(){let e=await this.authProvider.getCurrentUser();return e?e.email?{type:"email",value:e.email.toLowerCase()}:e.phone?{type:"phone",value:e.phone}:null:null}async getAuthShare(){let e=await this.getAuthHeaders(),r=this.authProvider.getProviderType(),t=await fetch(`${this.serverUrl}/keys/auth-share`,{method:"POST",headers:e,body:JSON.stringify({providerType:r})});if(!t.ok){if(t.status===404)return null;throw new Error(`Failed to get auth share: ${t.statusText}`)}return t.json()}async storeAuthShare(e){let r=await this.getAuthHeaders(),t=this.authProvider.getProviderType(),n=await fetch(`${this.serverUrl}/keys/auth-share`,{method:"PUT",headers:r,body:JSON.stringify({...e,providerType:t})});if(!n.ok)throw new Error(`Failed to store auth share: ${n.statusText}`)}async addRecoveryMethod(e){let r=await this.getAuthHeaders(),t=this.authProvider.getProviderType(),n=await fetch(`${this.serverUrl}/keys/recovery`,{method:"POST",headers:r,body:JSON.stringify({...e,providerType:t})});if(!n.ok)throw new Error(`Failed to add recovery method: ${n.statusText}`)}async getRecoveryShare(e,r){let t=await this.getAuthHeaders(),n=this.authProvider.getProviderType(),o=new URLSearchParams({type:e,providerType:n});r&&o.append("credentialId",r);let i=await fetch(`${this.serverUrl}/keys/recovery?${o}`,{method:"GET",headers:t});if(!i.ok){if(i.status===404)return null;throw new Error(`Failed to get recovery share: ${i.statusText}`)}return i.json()}async markMigrated(){let e=await this.getAuthHeaders(),r=this.authProvider.getProviderType(),t=await fetch(`${this.serverUrl}/keys/migrate`,{method:"POST",headers:e,body:JSON.stringify({providerType:r})});if(!t.ok)throw new Error(`Failed to mark as migrated: ${t.statusText}`)}async deleteUserKey(){let e=await this.getAuthHeaders(),r=this.authProvider.getProviderType(),t=await fetch(`${this.serverUrl}/keys`,{method:"DELETE",headers:e,body:JSON.stringify({providerType:r})});if(!t.ok)throw new Error(`Failed to delete user key: ${t.statusText}`)}};var A=require("shamir-secret-sharing");var _=require("hash-wasm");var X=3,Z=65536,ee=4,re=32,d={algorithm:"argon2id",timeCost:X,memoryCost:Z,parallelism:ee};function w(a){let e=new Uint8Array(a),r="";for(let t=0;t<e.byteLength;t++)r+=String.fromCharCode(e[t]);return btoa(r)}s(w,"bufferToBase64");function g(a){let e=atob(a),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r}s(g,"base64ToBuffer");function p(a){let e=new Uint8Array(a.length/2);for(let r=0;r<a.length;r+=2)e[r/2]=parseInt(a.slice(r,r+2),16);return e}s(p,"hexToBytes");function c(a){return Array.from(a).map(e=>e.toString(16).padStart(2,"0")).join("")}s(c,"bytesToHex");async function k(a,e,r=d){let t=await(0,_.argon2id)({password:a,salt:e,iterations:r.timeCost,memorySize:r.memoryCost,parallelism:r.parallelism,hashLength:re,outputType:"binary"});return new Uint8Array(t)}s(k,"deriveKeyFromPassword");async function m(a,e){let r=crypto.getRandomValues(new Uint8Array(16)),t=crypto.getRandomValues(new Uint8Array(12)),n=await k(e,r),o=await crypto.subtle.importKey("raw",n.buffer,{name:"AES-GCM"},!1,["encrypt"]),i=new TextEncoder,h=await crypto.subtle.encrypt({name:"AES-GCM",iv:t},o,i.encode(a));return{ciphertext:w(h),iv:w(t.buffer),salt:w(r.buffer),kdfParams:d}}s(m,"encryptWithPassword");async function P(a,e,r,t,n=d){let o=g(r),i=g(e),h=g(a),u=await k(t,o,n),z=await crypto.subtle.importKey("raw",u.buffer,{name:"AES-GCM"},!1,["decrypt"]),j=await crypto.subtle.decrypt({name:"AES-GCM",iv:i},z,h);return new TextDecoder().decode(j)}s(P,"decryptWithPassword");function te(a){return crypto.getRandomValues(new Uint8Array(a))}s(te,"generateRandomBytes");async function C(){let a=te(32);return c(a)}s(C,"generateEd25519PrivateKey");var O=3,v=2;async function y(a){let e=p(a),r=await(0,A.split)(e,O,v);return{deviceShare:c(r[0]),authShare:c(r[1]),recoveryShare:c(r[2])}}s(y,"splitPrivateKey");async function S(a,e){let r=p(a),t=p(e),n=await(0,A.combine)([r,t]);return c(n)}s(S,"reconstructPrivateKey");async function I(a){if(a.length<v)throw new Error(`Need at least ${v} shares to reconstruct key`);let e=a.slice(0,v).map(p),r=await(0,A.combine)(e);return c(r)}s(I,"reconstructFromShares");var H="lcb-sss-keys";var D="keys",b="shares",R="sss-device-share";function M(){return new Promise((a,e)=>{let r=indexedDB.open(H,1);r.onupgradeneeded=()=>{let t=r.result;t.objectStoreNames.contains(D)||t.createObjectStore(D),t.objectStoreNames.contains(b)||t.createObjectStore(b)},r.onsuccess=()=>a(r.result),r.onerror=()=>e(r.error)})}s(M,"openDB");function E(a,e,r,t){return new Promise((n,o)=>{let h=a.transaction(e,r).objectStore(e),u=t(h);u.onsuccess=()=>n(u.result),u.onerror=()=>o(u.error)})}s(E,"tx");async function G(){let a=await M();try{let e=await E(a,D,"readonly",t=>t.get("master-key"));if(e)return e;let r=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);return await E(a,D,"readwrite",t=>t.put(r,"master-key")),r}finally{a.close()}}s(G,"getOrCreateMasterKey");function N(a){let e=new Uint8Array(a),r="";for(let t=0;t<e.byteLength;t++)r+=String.fromCharCode(e[t]);return btoa(r)}s(N,"bufferToBase64");function F(a){let e=atob(a),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r.buffer}s(F,"base64ToBuffer");async function ae(a,e){let r=await G(),t=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder,o=n.encode(e),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:t,additionalData:o},r,n.encode(a));return{version:1,iv:N(t.buffer),cipher:N(i),keyVersion:1}}s(ae,"encryptShare");async function ne(a,e){let r=await G(),t=new Uint8Array(F(a.iv)),n=F(a.cipher),i=new TextEncoder().encode(e),h=await crypto.subtle.decrypt({name:"AES-GCM",iv:t,additionalData:i},r,n);return new TextDecoder().decode(h)}s(ne,"decryptShare");async function f(a,e=R){let r=await M();try{let t=await ae(a,e);await E(r,b,"readwrite",n=>n.put(t,e))}finally{r.close()}}s(f,"storeDeviceShare");async function K(a=R){let e=await M();try{let r=await E(e,b,"readonly",t=>t.get(a));if(!r)return null;try{return await ne(r,a)}catch(t){return console.warn("SSS Storage: decryption failed",t),null}}finally{e.close()}}s(K,"getDeviceShare");async function B(a=R){return await K(a)!==null}s(B,"hasDeviceShare");async function U(a=R){let e=await M();try{await E(e,b,"readwrite",r=>r.delete(a))}finally{e.close()}}s(U,"deleteDeviceShare");async function L(){await new Promise((a,e)=>{let r=indexedDB.deleteDatabase(H);r.onsuccess=()=>a(),r.onerror=()=>e(r.error),r.onblocked=()=>a()})}s(L,"clearAllShares");var x=class{constructor(e){this.name="sss";this.initialized=!1;this.currentPrivateKey=null;this.config=e,this.apiClient=new l({serverUrl:e.serverUrl,authProvider:e.authProvider})}static{s(this,"SSSKeyManager")}isInitialized(){return this.initialized}async hasLocalKey(){return B(this.config.deviceStorageKey)}async connect(){let e=await K(this.config.deviceStorageKey);if(!e)throw new Error("No device share found. User needs to set up SSS or recover.");let r=await this.apiClient.getAuthShare();if(!r||!r.authShare)throw new Error("No auth share found on server. User may need to recover.");if(r.keyProvider!=="sss")throw new Error("User has not migrated to SSS yet.");let t=await S(e,r.authShare.encryptedData);return this.currentPrivateKey=t,this.initialized=!0,t}async disconnect(){this.currentPrivateKey=null,this.initialized=!1}async setupNewKey(){let e=await C();return await this.setupWithKey(e),e}async setupWithKey(e,r){let t=await y(e);await f(t.deviceShare,this.config.deviceStorageKey);let n=r||`did:key:placeholder-${Date.now()}`;await this.apiClient.storeAuthShare({authShare:{encryptedData:t.authShare,encryptedDek:"",iv:""},primaryDid:n,securityLevel:"basic"}),this.currentPrivateKey=e,this.initialized=!0}async migrate(e){await this.setupWithKey(e),await this.apiClient.markMigrated()}async canMigrate(){return(await this.apiClient.getAuthShare())?.keyProvider==="web3auth"}async addRecoveryMethod(e){if(!this.currentPrivateKey)throw new Error("No active key. Connect first.");let t=(await y(this.currentPrivateKey)).recoveryShare;if(e.type==="password"){let n=await m(t,e.password);await this.apiClient.addRecoveryMethod({type:"password",encryptedShare:{encryptedData:n.ciphertext,iv:n.iv,salt:n.salt}})}else{if(e.type==="passkey")throw new Error("Passkey recovery not yet implemented");if(e.type==="backup")throw new Error("Use exportBackup() instead")}}async getRecoveryMethods(){return(await this.apiClient.getAuthShare())?.recoveryMethods||[]}async recover(e){if(e.type==="password"){let r=await this.apiClient.getRecoveryShare("password");if(!r||!r.salt)throw new Error("No password recovery share found");let t=await P(r.encryptedData,r.iv,r.salt,e.password,d),n=await this.apiClient.getAuthShare();if(!n||!n.authShare)throw new Error("No auth share found on server");let o=await S(t,n.authShare.encryptedData),i=await y(o);return await f(i.deviceShare,this.config.deviceStorageKey),this.currentPrivateKey=o,this.initialized=!0,o}else if(e.type==="backup"){let r=JSON.parse(e.fileContents);if(r.version!==1)throw new Error("Unsupported backup file version");let t=await P(r.encryptedShare.ciphertext,r.encryptedShare.iv,r.encryptedShare.salt,e.password,r.encryptedShare.kdfParams),n=await this.apiClient.getAuthShare();if(!n||!n.authShare)throw new Error("No auth share found on server");let o=await S(t,n.authShare.encryptedData),i=await y(o);return await f(i.deviceShare,this.config.deviceStorageKey),this.currentPrivateKey=o,this.initialized=!0,o}else if(e.type==="passkey")throw new Error("Passkey recovery not yet implemented");throw new Error("Unknown recovery method")}async getSecurityLevel(){return(await this.apiClient.getAuthShare())?.securityLevel||"basic"}async exportBackup(e){if(!this.currentPrivateKey)throw new Error("No active key. Connect first.");let r=await y(this.currentPrivateKey),t=await m(r.recoveryShare,e),n=await this.apiClient.getAuthShare();return{version:1,createdAt:new Date().toISOString(),primaryDid:n?.primaryDid||"unknown",encryptedShare:{ciphertext:t.ciphertext,iv:t.iv,salt:t.salt,kdfParams:t.kdfParams}}}async clearLocalData(){await U(this.config.deviceStorageKey),this.currentPrivateKey=null,this.initialized=!1}async deleteAccount(){await this.apiClient.deleteUserKey(),await L(),this.currentPrivateKey=null,this.initialized=!1}};function $(a){return new x(a)}s($,"createSSSKeyManager");
