{
  "version": 3,
  "sources": ["../src/index.ts", "../src/api-client.ts", "../src/sss.ts", "../src/crypto.ts", "../src/storage.ts", "../src/passkey.ts", "../src/recovery-phrase.ts", "../src/key-manager.ts"],
  "sourcesContent": ["/**\n * @learncard/sss-key-manager\n *\n * Shamir Secret Sharing key manager for LearnCard - replaces Web3Auth SFA\n */\n\nexport { SSSKeyManager, createSSSKeyManager } from './key-manager';\nexport { SSSApiClient } from './api-client';\n\nexport {\n    splitPrivateKey,\n    reconstructPrivateKey,\n    reconstructFromShares,\n    SSS_TOTAL_SHARES,\n    SSS_THRESHOLD,\n} from './sss';\n\nexport {\n    storeDeviceShare,\n    getDeviceShare,\n    hasDeviceShare,\n    deleteDeviceShare,\n    clearAllShares,\n} from './storage';\n\nexport {\n    encryptWithPassword,\n    decryptWithPassword,\n    deriveKeyFromPassword,\n    generateEd25519PrivateKey,\n    hexToBytes,\n    bytesToHex,\n    bufferToBase64,\n    base64ToBuffer,\n    DEFAULT_KDF_PARAMS,\n} from './crypto';\n\nexport {\n    createPasskeyCredential,\n    deriveKeyFromPasskey,\n    encryptShareWithPasskey,\n    decryptShareWithPasskey,\n    isWebAuthnSupported,\n    isPRFSupported,\n} from './passkey';\n\nexport type { PasskeyCredential, PasskeyEncryptedShare } from './passkey';\n\nexport {\n    shareToRecoveryPhrase,\n    recoveryPhraseToShare,\n    generateRecoveryPhrase,\n    validateRecoveryPhrase,\n    countWords,\n} from './recovery-phrase';\n\nexport type { RecoveryPhraseData } from './recovery-phrase';\n\nexport type {\n    SSSKeyManagerConfig,\n    SSSKeyDerivationProvider,\n    KeyDerivationProvider,\n    AuthProvider,\n    AuthUser,\n    AuthProviderType,\n    ContactMethod,\n    ContactMethodType,\n    RecoveryMethod,\n    RecoveryMethodType,\n    RecoveryMethodInfo,\n    PasswordRecoveryMethod,\n    PasskeyRecoveryMethod,\n    BackupFileRecoveryMethod,\n    RecoveryPhraseRecoveryMethod,\n    SecurityLevel,\n    BackupFile,\n    EncryptedShare,\n    ServerEncryptedShare,\n    UserKeyRecord,\n    AuthProviderMapping,\n} from './types';\n", "/**\n * API client for SSS Key Manager server routes\n */\n\nimport type {\n    AuthProvider,\n    AuthProviderType,\n    ContactMethod,\n    ServerEncryptedShare,\n    RecoveryMethodInfo,\n    EncryptedShare,\n    SecurityLevel,\n} from './types';\n\nexport interface GetAuthShareResponse {\n    authShare: ServerEncryptedShare | null;\n    primaryDid: string | null;\n    securityLevel: SecurityLevel;\n    recoveryMethods: RecoveryMethodInfo[];\n    keyProvider: 'web3auth' | 'sss';\n}\n\nexport interface StoreAuthShareInput {\n    authShare: ServerEncryptedShare;\n    primaryDid: string;\n    securityLevel?: SecurityLevel;\n}\n\nexport interface StoreRecoveryShareInput {\n    type: 'password' | 'passkey' | 'backup';\n    encryptedShare: EncryptedShare;\n    credentialId?: string;\n}\n\nexport interface ApiClientConfig {\n    serverUrl: string;\n    authProvider: AuthProvider;\n}\n\nexport class SSSApiClient {\n    private serverUrl: string;\n    private authProvider: AuthProvider;\n\n    constructor(config: ApiClientConfig) {\n        this.serverUrl = config.serverUrl.replace(/\\/$/, '');\n        this.authProvider = config.authProvider;\n    }\n\n    private async getAuthHeaders(): Promise<Record<string, string>> {\n        const token = await this.authProvider.getIdToken();\n        return {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${token}`,\n        };\n    }\n\n    private async getContactMethodFromUser(): Promise<ContactMethod | null> {\n        const user = await this.authProvider.getCurrentUser();\n        if (!user) return null;\n\n        if (user.email) {\n            return { type: 'email' as const, value: user.email.toLowerCase() };\n        }\n        if (user.phone) {\n            return { type: 'phone' as const, value: user.phone };\n        }\n        return null;\n    }\n\n    async getAuthShare(): Promise<GetAuthShareResponse | null> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get auth share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async storeAuthShare(input: StoreAuthShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'PUT',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to store auth share: ${response.statusText}`);\n        }\n    }\n\n    async addRecoveryMethod(input: StoreRecoveryShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to add recovery method: ${response.statusText}`);\n        }\n    }\n\n    async getRecoveryShare(\n        type: 'password' | 'passkey' | 'backup',\n        credentialId?: string\n    ): Promise<EncryptedShare | null> {\n        const token = await this.authProvider.getIdToken();\n        const providerType = this.authProvider.getProviderType();\n\n        const params = new URLSearchParams({\n            type,\n            providerType,\n            authToken: token,\n        });\n\n        if (credentialId) {\n            params.append('credentialId', credentialId);\n        }\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery?${params}`, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get recovery share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async markMigrated(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/migrate`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to mark as migrated: ${response.statusText}`);\n        }\n    }\n\n    async deleteUserKey(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys`, {\n            method: 'DELETE',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to delete user key: ${response.statusText}`);\n        }\n    }\n}\n", "/**\n * Shamir Secret Sharing operations\n */\n\nimport { split, combine } from 'shamir-secret-sharing';\nimport { hexToBytes, bytesToHex } from './crypto';\n\nexport const SSS_TOTAL_SHARES = 3;\nexport const SSS_THRESHOLD = 2;\n\nexport interface SSSShares {\n    deviceShare: string;\n    authShare: string;\n    recoveryShare: string;\n}\n\nexport async function splitPrivateKey(privateKeyHex: string): Promise<SSSShares> {\n    const privateKeyBytes = hexToBytes(privateKeyHex);\n\n    const shares = await split(privateKeyBytes, SSS_TOTAL_SHARES, SSS_THRESHOLD);\n\n    return {\n        deviceShare: bytesToHex(shares[0]),\n        authShare: bytesToHex(shares[1]),\n        recoveryShare: bytesToHex(shares[2]),\n    };\n}\n\nexport async function reconstructPrivateKey(share1Hex: string, share2Hex: string): Promise<string> {\n    const share1 = hexToBytes(share1Hex);\n    const share2 = hexToBytes(share2Hex);\n\n    const reconstructed = await combine([share1, share2]);\n\n    return bytesToHex(reconstructed);\n}\n\nexport async function reconstructFromShares(shares: string[]): Promise<string> {\n    if (shares.length < SSS_THRESHOLD) {\n        throw new Error(`Need at least ${SSS_THRESHOLD} shares to reconstruct key`);\n    }\n\n    const shareBytes = shares.slice(0, SSS_THRESHOLD).map(hexToBytes);\n    const reconstructed = await combine(shareBytes);\n\n    return bytesToHex(reconstructed);\n}\n", "/**\n * Cryptographic utilities for SSS Key Manager\n */\n\nimport { argon2id } from 'hash-wasm';\n\nconst ARGON2_TIME_COST = 3;\nconst ARGON2_MEMORY_COST = 65536;\nconst ARGON2_PARALLELISM = 4;\nconst ARGON2_HASH_LENGTH = 32;\n\nexport interface KdfParams {\n    algorithm: 'argon2id';\n    timeCost: number;\n    memoryCost: number;\n    parallelism: number;\n}\n\nexport const DEFAULT_KDF_PARAMS: KdfParams = {\n    algorithm: 'argon2id',\n    timeCost: ARGON2_TIME_COST,\n    memoryCost: ARGON2_MEMORY_COST,\n    parallelism: ARGON2_PARALLELISM,\n};\n\nexport function bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nexport function base64ToBuffer(b64: string): Uint8Array {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n\nexport function hexToBytes(hex: string): Uint8Array {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n    }\n    return bytes;\n}\n\nexport function bytesToHex(bytes: Uint8Array): string {\n    return Array.from(bytes)\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n\nexport async function deriveKeyFromPassword(\n    password: string,\n    salt: Uint8Array,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<Uint8Array> {\n    const hash = await argon2id({\n        password,\n        salt: salt as unknown as Uint8Array,\n        iterations: params.timeCost,\n        memorySize: params.memoryCost,\n        parallelism: params.parallelism,\n        hashLength: ARGON2_HASH_LENGTH,\n        outputType: 'binary',\n    });\n    return new Uint8Array(hash as ArrayBuffer);\n}\n\nexport async function encryptWithPassword(\n    plaintext: string,\n    password: string\n): Promise<{ ciphertext: string; iv: string; salt: string; kdfParams: KdfParams }> {\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n\n    const keyMaterial = await deriveKeyFromPassword(password, salt);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['encrypt']\n    );\n\n    const encoder = new TextEncoder();\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv },\n        cryptoKey,\n        encoder.encode(plaintext)\n    );\n\n    return {\n        ciphertext: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n        salt: bufferToBase64(salt.buffer),\n        kdfParams: DEFAULT_KDF_PARAMS,\n    };\n}\n\nexport async function decryptWithPassword(\n    ciphertext: string,\n    iv: string,\n    salt: string,\n    password: string,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<string> {\n    const saltBytes = base64ToBuffer(salt);\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(ciphertext);\n\n    const keyMaterial = await deriveKeyFromPassword(password, saltBytes, params);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['decrypt']\n    );\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv: ivBytes },\n        cryptoKey,\n        ciphertextBytes\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function encryptShare(\n    share: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<{ encryptedData: string; iv: string }> {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n\n    const encryptParams: AesGcmParams = { name: 'AES-GCM', iv };\n    if (aad) {\n        encryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        encryptParams,\n        key,\n        encoder.encode(share) as ArrayBuffer\n    );\n\n    return {\n        encryptedData: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n    };\n}\n\nexport async function decryptShare(\n    encryptedData: string,\n    iv: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<string> {\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(encryptedData);\n    const encoder = new TextEncoder();\n\n    const decryptParams: AesGcmParams = { name: 'AES-GCM', iv: ivBytes.buffer as ArrayBuffer };\n    if (aad) {\n        decryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        decryptParams,\n        key,\n        ciphertextBytes.buffer as ArrayBuffer\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function generateAesKey(): Promise<CryptoKey> {\n    return crypto.subtle.generateKey(\n        { name: 'AES-GCM', length: 256 },\n        true,\n        ['encrypt', 'decrypt']\n    );\n}\n\nexport function generateRandomBytes(length: number): Uint8Array {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n\nexport async function generateEd25519PrivateKey(): Promise<string> {\n    const privateKeyBytes = generateRandomBytes(32);\n    return bytesToHex(privateKeyBytes);\n}\n", "/**\n * Device-side storage for SSS shares\n * Reuses patterns from webSecureStorage but specialized for SSS\n */\n\nconst DB_NAME = 'lcb-sss-keys';\nconst DB_VERSION = 1;\nconst KEYS_STORE = 'keys';\nconst SHARES_STORE = 'shares';\nconst DEFAULT_DEVICE_SHARE_ID = 'sss-device-share';\n\ntype EncryptedPayload = {\n    version: 1;\n    iv: string;\n    cipher: string;\n    keyVersion: number;\n};\n\nfunction openDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open(DB_NAME, DB_VERSION);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains(KEYS_STORE)) {\n                db.createObjectStore(KEYS_STORE);\n            }\n            if (!db.objectStoreNames.contains(SHARES_STORE)) {\n                db.createObjectStore(SHARES_STORE);\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nfunction tx<T = unknown>(\n    db: IDBDatabase,\n    store: string,\n    mode: IDBTransactionMode,\n    op: (store: IDBObjectStore) => IDBRequest<T>\n): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const t = db.transaction(store, mode);\n        const s = t.objectStore(store);\n        const request = op(s);\n        request.onsuccess = () => resolve(request.result as T);\n        request.onerror = () => reject(request.error);\n    });\n}\n\nasync function getOrCreateMasterKey(): Promise<CryptoKey> {\n    const db = await openDB();\n\n    try {\n        const existing = await tx<CryptoKey | undefined>(db, KEYS_STORE, 'readonly', s =>\n            s.get('master-key')\n        );\n\n        if (existing) {\n            return existing;\n        }\n\n        const key = await crypto.subtle.generateKey(\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt', 'decrypt']\n        );\n\n        await tx(db, KEYS_STORE, 'readwrite', s => s.put(key, 'master-key'));\n\n        return key;\n    } finally {\n        db.close();\n    }\n}\n\nfunction bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nfunction base64ToBuffer(b64: string): ArrayBuffer {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nasync function encryptShare(share: string, id: string): Promise<EncryptedPayload> {\n    const key = await getOrCreateMasterKey();\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const cipherBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        encoder.encode(share)\n    );\n\n    return {\n        version: 1,\n        iv: bufferToBase64(iv.buffer),\n        cipher: bufferToBase64(cipherBuffer),\n        keyVersion: 1,\n    };\n}\n\nasync function decryptShare(payload: EncryptedPayload, id: string): Promise<string> {\n    const key = await getOrCreateMasterKey();\n    const iv = new Uint8Array(base64ToBuffer(payload.iv));\n    const cipher = base64ToBuffer(payload.cipher);\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const plainBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        cipher\n    );\n\n    return new TextDecoder().decode(plainBuffer);\n}\n\nexport async function storeDeviceShare(share: string, id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        const payload = await encryptShare(share, id);\n        await tx(db, SHARES_STORE, 'readwrite', s => s.put(payload, id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function getDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<string | null> {\n    const db = await openDB();\n\n    try {\n        const payload = await tx<EncryptedPayload | undefined>(db, SHARES_STORE, 'readonly', s =>\n            s.get(id)\n        );\n\n        if (!payload) {\n            return null;\n        }\n\n        try {\n            return await decryptShare(payload, id);\n        } catch (e) {\n            console.warn('SSS Storage: decryption failed', e);\n            return null;\n        }\n    } finally {\n        db.close();\n    }\n}\n\nexport async function hasDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<boolean> {\n    const share = await getDeviceShare(id);\n    return share !== null;\n}\n\nexport async function deleteDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        await tx(db, SHARES_STORE, 'readwrite', s => s.delete(id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function clearAllShares(): Promise<void> {\n    await new Promise<void>((resolve, reject) => {\n        const req = indexedDB.deleteDatabase(DB_NAME);\n        req.onsuccess = () => resolve();\n        req.onerror = () => reject(req.error);\n        req.onblocked = () => resolve();\n    });\n}\n", "/**\n * WebAuthn Passkey utilities for SSS recovery\n * Uses the PRF (Pseudo-Random Function) extension to derive encryption keys\n */\n\nimport { bufferToBase64, base64ToBuffer, bytesToHex, hexToBytes } from './crypto';\n\nexport interface PasskeyCredential {\n    credentialId: string;\n    publicKey: string;\n    transports?: AuthenticatorTransport[];\n}\n\nexport interface PasskeyEncryptedShare {\n    encryptedData: string;\n    iv: string;\n    credentialId: string;\n}\n\nconst RP_NAME = 'LearnCard';\nconst RP_ID = typeof window !== 'undefined' ? window.location.hostname : 'localhost';\n\nconst PRF_SALT = new TextEncoder().encode('learncard-sss-recovery-v1');\n\nfunction isWebAuthnSupported(): boolean {\n    return typeof window !== 'undefined' &&\n        typeof window.PublicKeyCredential !== 'undefined' &&\n        typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === 'function';\n}\n\nasync function isPRFSupported(): Promise<boolean> {\n    if (!isWebAuthnSupported()) return false;\n\n    try {\n        const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n        return available;\n    } catch {\n        return false;\n    }\n}\n\nexport async function createPasskeyCredential(\n    userId: string,\n    userName: string\n): Promise<PasskeyCredential> {\n    if (!isWebAuthnSupported()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    const userIdBytes = new TextEncoder().encode(userId);\n\n    const createOptions: PublicKeyCredentialCreationOptions = {\n        challenge: crypto.getRandomValues(new Uint8Array(32)),\n        rp: {\n            name: RP_NAME,\n            id: RP_ID,\n        },\n        user: {\n            id: userIdBytes,\n            name: userName,\n            displayName: userName,\n        },\n        pubKeyCredParams: [\n            { alg: -7, type: 'public-key' },   // ES256\n            { alg: -257, type: 'public-key' }, // RS256\n        ],\n        authenticatorSelection: {\n            authenticatorAttachment: 'platform',\n            userVerification: 'required',\n            residentKey: 'required',\n        },\n        timeout: 60000,\n        attestation: 'none',\n        extensions: {\n            prf: {\n                eval: {\n                    first: PRF_SALT,\n                },\n            },\n        } as AuthenticationExtensionsClientInputs,\n    };\n\n    const credential = await navigator.credentials.create({\n        publicKey: createOptions,\n    }) as PublicKeyCredential;\n\n    if (!credential) {\n        throw new Error('Failed to create passkey credential');\n    }\n\n    const response = credential.response as AuthenticatorAttestationResponse;\n\n    const extensionResults = credential.getClientExtensionResults() as {\n        prf?: { enabled?: boolean; results?: { first?: ArrayBuffer } };\n    };\n\n    if (!extensionResults.prf?.enabled && !extensionResults.prf?.results?.first) {\n        console.warn('PRF extension may not be supported, passkey created but encryption key derivation may fail');\n    }\n\n    return {\n        credentialId: bufferToBase64(credential.rawId),\n        publicKey: bufferToBase64(response.getPublicKey() as ArrayBuffer),\n        transports: response.getTransports?.() as AuthenticatorTransport[],\n    };\n}\n\nexport async function deriveKeyFromPasskey(\n    credentialId: string\n): Promise<CryptoKey> {\n    if (!isWebAuthnSupported()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    const getOptions: PublicKeyCredentialRequestOptions = {\n        challenge: crypto.getRandomValues(new Uint8Array(32)),\n        rpId: RP_ID,\n        allowCredentials: [{\n            id: base64ToBuffer(credentialId),\n            type: 'public-key',\n        }],\n        userVerification: 'required',\n        timeout: 60000,\n        extensions: {\n            prf: {\n                eval: {\n                    first: PRF_SALT,\n                },\n            },\n        } as AuthenticationExtensionsClientInputs,\n    };\n\n    const assertion = await navigator.credentials.get({\n        publicKey: getOptions,\n    }) as PublicKeyCredential;\n\n    if (!assertion) {\n        throw new Error('Failed to get passkey assertion');\n    }\n\n    const extensionResults = assertion.getClientExtensionResults() as {\n        prf?: { results?: { first?: ArrayBuffer } };\n    };\n\n    if (!extensionResults.prf?.results?.first) {\n        throw new Error('PRF extension not available or failed. This passkey cannot be used for encryption.');\n    }\n\n    const prfOutput = new Uint8Array(extensionResults.prf.results.first);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        prfOutput,\n        { name: 'AES-GCM' },\n        false,\n        ['encrypt', 'decrypt']\n    );\n\n    return cryptoKey;\n}\n\nexport async function encryptShareWithPasskey(\n    share: string,\n    credentialId: string\n): Promise<PasskeyEncryptedShare> {\n    const key = await deriveKeyFromPasskey(credentialId);\n\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n\n    const ciphertext = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv },\n        key,\n        encoder.encode(share)\n    );\n\n    return {\n        encryptedData: bufferToBase64(ciphertext),\n        iv: bufferToBase64(iv.buffer),\n        credentialId,\n    };\n}\n\nexport async function decryptShareWithPasskey(\n    encryptedShare: PasskeyEncryptedShare\n): Promise<string> {\n    const key = await deriveKeyFromPasskey(encryptedShare.credentialId);\n\n    const iv = base64ToBuffer(encryptedShare.iv);\n    const ciphertext = base64ToBuffer(encryptedShare.encryptedData);\n\n    const plaintext = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv: iv.buffer },\n        key,\n        ciphertext.buffer\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintext);\n}\n\nexport async function listStoredPasskeys(): Promise<PasskeyCredential[]> {\n    if (!isWebAuthnSupported()) {\n        return [];\n    }\n\n    if (typeof PublicKeyCredential.isConditionalMediationAvailable !== 'function') {\n        return [];\n    }\n\n    const available = await PublicKeyCredential.isConditionalMediationAvailable();\n    if (!available) {\n        return [];\n    }\n\n    return [];\n}\n\nexport { isWebAuthnSupported, isPRFSupported };\n", "/**\n * BIP39 Recovery Phrase utilities for SSS recovery\n * The recovery phrase directly encodes a share (not encryption)\n */\n\nimport { bytesToHex, hexToBytes, bufferToBase64, base64ToBuffer } from './crypto';\n\nexport interface RecoveryPhraseData {\n    phrase: string;\n    shareHex: string;\n}\n\nconst WORDLIST_MODULE = '@scure/bip39/wordlists/english';\n\nlet wordlistPromise: Promise<string[]> | null = null;\n\nasync function getWordlist(): Promise<string[]> {\n    if (!wordlistPromise) {\n        wordlistPromise = import('@scure/bip39/wordlists/english').then(m => m.wordlist);\n    }\n    return wordlistPromise;\n}\n\nfunction bytesToBits(bytes: Uint8Array): string {\n    return Array.from(bytes)\n        .map(b => b.toString(2).padStart(8, '0'))\n        .join('');\n}\n\nfunction bitsToBytes(bits: string): Uint8Array {\n    const bytes = new Uint8Array(Math.ceil(bits.length / 8));\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = parseInt(bits.slice(i * 8, (i + 1) * 8).padEnd(8, '0'), 2);\n    }\n    return bytes;\n}\n\nasync function computeChecksum(data: Uint8Array): Promise<string> {\n    const hash = await crypto.subtle.digest('SHA-256', data);\n    const hashBits = bytesToBits(new Uint8Array(hash));\n    const checksumLength = Math.floor(data.length / 4);\n    return hashBits.slice(0, checksumLength);\n}\n\nexport async function shareToRecoveryPhrase(shareHex: string): Promise<string> {\n    const wordlist = await getWordlist();\n    const shareBytes = hexToBytes(shareHex);\n\n    const checksum = await computeChecksum(shareBytes);\n    const allBits = bytesToBits(shareBytes) + checksum;\n\n    const words: string[] = [];\n    for (let i = 0; i < allBits.length; i += 11) {\n        const index = parseInt(allBits.slice(i, i + 11).padEnd(11, '0'), 2);\n        words.push(wordlist[index]);\n    }\n\n    return words.join(' ');\n}\n\nexport async function recoveryPhraseToShare(phrase: string): Promise<string> {\n    const wordlist = await getWordlist();\n    const words = phrase.trim().toLowerCase().split(/\\s+/);\n\n    // SSS shares include an index byte, so they produce 25 words instead of standard BIP39 24\n    if (words.length < 12 || words.length > 27) {\n        throw new Error('Recovery phrase must be 12-27 words');\n    }\n\n    let bits = '';\n    for (const word of words) {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(`Invalid word in recovery phrase: ${word}`);\n        }\n        bits += index.toString(2).padStart(11, '0');\n    }\n\n    // Calculate the correct data byte count\n    // The encoding formula: totalBits = dataBytes * 8 + floor(dataBytes / 4)\n    // We need to find the LARGEST dataBytes such that ceil(totalBits / 11) == words.length\n    // Multiple byte counts can produce the same word count, so we want the largest (most likely)\n    let dataByteCount = 0;\n    for (let bytes = 1; bytes <= 64; bytes++) {\n        const checksumBits = Math.floor(bytes / 4);\n        const totalBits = bytes * 8 + checksumBits;\n        const wordsNeeded = Math.ceil(totalBits / 11);\n        if (wordsNeeded === words.length) {\n            dataByteCount = bytes; // Keep updating to get the largest match\n        } else if (wordsNeeded > words.length) {\n            break; // Gone past, stop\n        }\n    }\n\n    if (dataByteCount === 0) {\n        throw new Error('Could not determine data size from word count');\n    }\n\n    const checksumLength = Math.floor(dataByteCount / 4);\n    const dataBitCount = dataByteCount * 8;\n    \n    const dataBits = bits.slice(0, dataBitCount);\n    const checksumBits = bits.slice(dataBitCount, dataBitCount + checksumLength);\n\n    const dataBytes = bitsToBytes(dataBits);\n\n    const expectedChecksum = await computeChecksum(dataBytes);\n    if (checksumBits !== expectedChecksum.slice(0, checksumLength)) {\n        throw new Error('Invalid recovery phrase checksum');\n    }\n\n    return bytesToHex(dataBytes);\n}\n\nexport async function generateRecoveryPhrase(shareHex: string): Promise<RecoveryPhraseData> {\n    const phrase = await shareToRecoveryPhrase(shareHex);\n    return { phrase, shareHex };\n}\n\nexport async function validateRecoveryPhrase(phrase: string): Promise<boolean> {\n    try {\n        await recoveryPhraseToShare(phrase);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function countWords(phrase: string): number {\n    return phrase.trim().split(/\\s+/).filter(w => w.length > 0).length;\n}\n", "/**\n * SSS Key Manager - Main class\n */\n\nimport type {\n    SSSKeyManagerConfig,\n    SSSKeyDerivationProvider,\n    RecoveryMethod,\n    RecoveryMethodInfo,\n    SecurityLevel,\n    BackupFile,\n    AuthProvider,\n    RecoveryPhraseRecoveryMethod,\n} from './types';\n\nimport { SSSApiClient } from './api-client';\nimport { splitPrivateKey, reconstructPrivateKey } from './sss';\nimport {\n    storeDeviceShare,\n    getDeviceShare,\n    hasDeviceShare,\n    deleteDeviceShare,\n    clearAllShares,\n} from './storage';\nimport {\n    encryptWithPassword,\n    decryptWithPassword,\n    generateEd25519PrivateKey,\n    DEFAULT_KDF_PARAMS,\n} from './crypto';\n\nimport {\n    createPasskeyCredential,\n    encryptShareWithPasskey,\n    decryptShareWithPasskey,\n} from './passkey';\n\nimport {\n    shareToRecoveryPhrase,\n    recoveryPhraseToShare,\n} from './recovery-phrase';\n\nexport class SSSKeyManager implements SSSKeyDerivationProvider {\n    readonly name = 'sss';\n\n    private config: SSSKeyManagerConfig;\n    private apiClient: SSSApiClient;\n    private initialized = false;\n    private currentPrivateKey: string | null = null;\n\n    constructor(config: SSSKeyManagerConfig) {\n        this.config = config;\n        this.apiClient = new SSSApiClient({\n            serverUrl: config.serverUrl,\n            authProvider: config.authProvider,\n        });\n    }\n\n    isInitialized(): boolean {\n        return this.initialized;\n    }\n\n    async hasLocalKey(): Promise<boolean> {\n        return hasDeviceShare(this.config.deviceStorageKey);\n    }\n\n    async connect(): Promise<string> {\n        const deviceShare = await getDeviceShare(this.config.deviceStorageKey);\n\n        if (!deviceShare) {\n            throw new Error('No device share found. User needs to set up SSS or recover.');\n        }\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        if (!serverResponse || !serverResponse.authShare) {\n            throw new Error('No auth share found on server. User may need to recover.');\n        }\n\n        if (serverResponse.keyProvider !== 'sss') {\n            throw new Error('User has not migrated to SSS yet.');\n        }\n\n        const privateKey = await reconstructPrivateKey(\n            deviceShare,\n            serverResponse.authShare.encryptedData\n        );\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n\n        return privateKey;\n    }\n\n    async disconnect(): Promise<void> {\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async setupNewKey(): Promise<string> {\n        const privateKey = await generateEd25519PrivateKey();\n        await this.setupWithKey(privateKey);\n        return privateKey;\n    }\n\n    async setupWithKey(privateKey: string, primaryDid?: string): Promise<void> {\n        const shares = await splitPrivateKey(privateKey);\n\n        await storeDeviceShare(shares.deviceShare, this.config.deviceStorageKey);\n\n        const did = primaryDid || `did:key:placeholder-${Date.now()}`;\n\n        await this.apiClient.storeAuthShare({\n            authShare: {\n                encryptedData: shares.authShare,\n                encryptedDek: '',\n                iv: '',\n            },\n            primaryDid: did,\n            securityLevel: 'basic',\n        });\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n    }\n\n    async migrate(privateKey: string): Promise<void> {\n        await this.setupWithKey(privateKey);\n        await this.apiClient.markMigrated();\n    }\n\n    async canMigrate(): Promise<boolean> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.keyProvider === 'web3auth';\n    }\n\n    async addRecoveryMethod(method: RecoveryMethod): Promise<void> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const recoveryShare = shares.recoveryShare;\n\n        if (method.type === 'password') {\n            const encrypted = await encryptWithPassword(recoveryShare, method.password);\n\n            await this.apiClient.addRecoveryMethod({\n                type: 'password',\n                encryptedShare: {\n                    encryptedData: encrypted.ciphertext,\n                    iv: encrypted.iv,\n                    salt: encrypted.salt,\n                },\n            });\n        } else if (method.type === 'passkey') {\n            const user = await this.config.authProvider.getCurrentUser();\n            if (!user) {\n                throw new Error('No authenticated user');\n            }\n\n            const credential = await createPasskeyCredential(\n                user.id,\n                user.email || user.phone || user.id\n            );\n\n            const encryptedShare = await encryptShareWithPasskey(\n                recoveryShare,\n                credential.credentialId\n            );\n\n            await this.apiClient.addRecoveryMethod({\n                type: 'passkey',\n                encryptedShare: {\n                    encryptedData: encryptedShare.encryptedData,\n                    iv: encryptedShare.iv,\n                },\n                credentialId: credential.credentialId,\n            });\n        } else if (method.type === 'backup') {\n            throw new Error('Use exportBackup() instead');\n        }\n    }\n\n    async generateRecoveryPhrase(): Promise<string> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const phrase = await shareToRecoveryPhrase(shares.recoveryShare);\n\n        return phrase;\n    }\n\n    async getRecoveryMethods(): Promise<RecoveryMethodInfo[]> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.recoveryMethods || [];\n    }\n\n    async recover(method: RecoveryMethod): Promise<string> {\n        if (method.type === 'password') {\n            const encryptedShare = await this.apiClient.getRecoveryShare('password');\n\n            if (!encryptedShare || !encryptedShare.salt) {\n                throw new Error('No password recovery share found');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                encryptedShare.encryptedData,\n                encryptedShare.iv,\n                encryptedShare.salt,\n                method.password,\n                DEFAULT_KDF_PARAMS\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'backup') {\n            const backup: BackupFile = JSON.parse(method.fileContents);\n\n            if (backup.version !== 1) {\n                throw new Error('Unsupported backup file version');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                backup.encryptedShare.ciphertext,\n                backup.encryptedShare.iv,\n                backup.encryptedShare.salt,\n                method.password,\n                backup.encryptedShare.kdfParams\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'passkey') {\n            const encryptedShare = await this.apiClient.getRecoveryShare('passkey', method.credentialId);\n\n            if (!encryptedShare) {\n                throw new Error('No passkey recovery share found');\n            }\n\n            const recoveryShare = await decryptShareWithPasskey({\n                encryptedData: encryptedShare.encryptedData,\n                iv: encryptedShare.iv,\n                credentialId: method.credentialId || '',\n            });\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'phrase') {\n            const recoveryShare = await recoveryPhraseToShare(method.phrase);\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        }\n\n        throw new Error('Unknown recovery method');\n    }\n\n    async getSecurityLevel(): Promise<SecurityLevel> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.securityLevel || 'basic';\n    }\n\n    async exportBackup(password: string): Promise<BackupFile> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const encrypted = await encryptWithPassword(shares.recoveryShare, password);\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        return {\n            version: 1,\n            createdAt: new Date().toISOString(),\n            primaryDid: serverResponse?.primaryDid || 'unknown',\n            encryptedShare: {\n                ciphertext: encrypted.ciphertext,\n                iv: encrypted.iv,\n                salt: encrypted.salt,\n                kdfParams: encrypted.kdfParams,\n            },\n        };\n    }\n\n    async clearLocalData(): Promise<void> {\n        await deleteDeviceShare(this.config.deviceStorageKey);\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async deleteAccount(): Promise<void> {\n        await this.apiClient.deleteUserKey();\n        await clearAllShares();\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n}\n\nexport function createSSSKeyManager(config: SSSKeyManagerConfig): SSSKeyManager {\n    return new SSSKeyManager(config);\n}\n"],
  "mappings": "0nBAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,wBAAAE,EAAA,iBAAAC,EAAA,kBAAAC,EAAA,kBAAAC,EAAA,qBAAAC,EAAA,mBAAAC,EAAA,mBAAAC,EAAA,eAAAC,EAAA,mBAAAC,EAAA,eAAAC,GAAA,4BAAAC,EAAA,wBAAAC,GAAA,4BAAAC,EAAA,wBAAAC,EAAA,sBAAAC,EAAA,yBAAAC,EAAA,0BAAAC,EAAA,4BAAAC,EAAA,wBAAAC,EAAA,8BAAAC,EAAA,2BAAAC,GAAA,mBAAAC,EAAA,mBAAAC,EAAA,eAAAC,EAAA,mBAAAC,GAAA,wBAAAC,EAAA,0BAAAC,EAAA,0BAAAC,EAAA,0BAAAC,EAAA,0BAAAC,EAAA,oBAAAC,EAAA,qBAAAC,EAAA,2BAAAC,KAAA,eAAAC,GAAAnC,ICuCO,IAAMoC,EAAN,KAAmB,CAvC1B,MAuC0B,CAAAC,EAAA,qBAItB,YAAYC,EAAyB,CACjC,KAAK,UAAYA,EAAO,UAAU,QAAQ,MAAO,EAAE,EACnD,KAAK,aAAeA,EAAO,YAC/B,CAEA,MAAc,gBAAkD,CAE5D,MAAO,CACH,eAAgB,mBAChB,cAAe,UAHL,MAAM,KAAK,aAAa,WAAW,CAGf,EAClC,CACJ,CAEA,MAAc,0BAA0D,CACpE,IAAMC,EAAO,MAAM,KAAK,aAAa,eAAe,EACpD,OAAKA,EAEDA,EAAK,MACE,CAAE,KAAM,QAAkB,MAAOA,EAAK,MAAM,YAAY,CAAE,EAEjEA,EAAK,MACE,CAAE,KAAM,QAAkB,MAAOA,EAAK,KAAM,EAEhD,KARW,IAStB,CAEA,MAAM,cAAqD,CACvD,IAAMC,EAAU,MAAM,KAAK,eAAe,EACpCC,EAAe,KAAK,aAAa,gBAAgB,EAEjDC,EAAW,MAAM,MAAM,GAAG,KAAK,SAAS,mBAAoB,CAC9D,OAAQ,OACR,QAAAF,EACA,KAAM,KAAK,UAAU,CAAE,aAAAC,CAAa,CAAC,CACzC,CAAC,EAED,GAAI,CAACC,EAAS,GAAI,CACd,GAAIA,EAAS,SAAW,IACpB,OAAO,KAEX,MAAM,IAAI,MAAM,6BAA6BA,EAAS,UAAU,EAAE,CACtE,CAEA,OAAOA,EAAS,KAAK,CACzB,CAEA,MAAM,eAAeC,EAA2C,CAC5D,IAAMH,EAAU,MAAM,KAAK,eAAe,EACpCC,EAAe,KAAK,aAAa,gBAAgB,EAEjDC,EAAW,MAAM,MAAM,GAAG,KAAK,SAAS,mBAAoB,CAC9D,OAAQ,MACR,QAAAF,EACA,KAAM,KAAK,UAAU,CACjB,GAAGG,EACH,aAAAF,CACJ,CAAC,CACL,CAAC,EAED,GAAI,CAACC,EAAS,GACV,MAAM,IAAI,MAAM,+BAA+BA,EAAS,UAAU,EAAE,CAE5E,CAEA,MAAM,kBAAkBC,EAA+C,CACnE,IAAMH,EAAU,MAAM,KAAK,eAAe,EACpCC,EAAe,KAAK,aAAa,gBAAgB,EAEjDC,EAAW,MAAM,MAAM,GAAG,KAAK,SAAS,iBAAkB,CAC5D,OAAQ,OACR,QAAAF,EACA,KAAM,KAAK,UAAU,CACjB,GAAGG,EACH,aAAAF,CACJ,CAAC,CACL,CAAC,EAED,GAAI,CAACC,EAAS,GACV,MAAM,IAAI,MAAM,kCAAkCA,EAAS,UAAU,EAAE,CAE/E,CAEA,MAAM,iBACFE,EACAC,EAC8B,CAC9B,IAAMC,EAAQ,MAAM,KAAK,aAAa,WAAW,EAC3CL,EAAe,KAAK,aAAa,gBAAgB,EAEjDM,EAAS,IAAI,gBAAgB,CAC/B,KAAAH,EACA,aAAAH,EACA,UAAWK,CACf,CAAC,EAEGD,GACAE,EAAO,OAAO,eAAgBF,CAAY,EAG9C,IAAMH,EAAW,MAAM,MAAM,GAAG,KAAK,SAAS,kBAAkBK,CAAM,GAAI,CACtE,OAAQ,MACR,QAAS,CACL,eAAgB,kBACpB,CACJ,CAAC,EAED,GAAI,CAACL,EAAS,GAAI,CACd,GAAIA,EAAS,SAAW,IACpB,OAAO,KAEX,MAAM,IAAI,MAAM,iCAAiCA,EAAS,UAAU,EAAE,CAC1E,CAEA,OAAOA,EAAS,KAAK,CACzB,CAEA,MAAM,cAA8B,CAChC,IAAMF,EAAU,MAAM,KAAK,eAAe,EACpCC,EAAe,KAAK,aAAa,gBAAgB,EAEjDC,EAAW,MAAM,MAAM,GAAG,KAAK,SAAS,gBAAiB,CAC3D,OAAQ,OACR,QAAAF,EACA,KAAM,KAAK,UAAU,CAAE,aAAAC,CAAa,CAAC,CACzC,CAAC,EAED,GAAI,CAACC,EAAS,GACV,MAAM,IAAI,MAAM,+BAA+BA,EAAS,UAAU,EAAE,CAE5E,CAEA,MAAM,eAA+B,CACjC,IAAMF,EAAU,MAAM,KAAK,eAAe,EACpCC,EAAe,KAAK,aAAa,gBAAgB,EAEjDC,EAAW,MAAM,MAAM,GAAG,KAAK,SAAS,QAAS,CACnD,OAAQ,SACR,QAAAF,EACA,KAAM,KAAK,UAAU,CAAE,aAAAC,CAAa,CAAC,CACzC,CAAC,EAED,GAAI,CAACC,EAAS,GACV,MAAM,IAAI,MAAM,8BAA8BA,EAAS,UAAU,EAAE,CAE3E,CACJ,ECxLA,IAAAM,EAA+B,iCCA/B,IAAAC,EAAyB,qBAEzB,IAAMC,GAAmB,EACnBC,GAAqB,MACrBC,GAAqB,EACrBC,GAAqB,GASdC,EAAgC,CACzC,UAAW,WACX,SAAUJ,GACV,WAAYC,GACZ,YAAaC,EACjB,EAEO,SAASG,EAAeC,EAA0B,CACrD,IAAMC,EAAQ,IAAI,WAAWD,CAAG,EAC5BE,EAAS,GACb,QAASC,EAAI,EAAGA,EAAIF,EAAM,WAAYE,IAClCD,GAAU,OAAO,aAAaD,EAAME,CAAC,CAAC,EAE1C,OAAO,KAAKD,CAAM,CACtB,CAPgBE,EAAAL,EAAA,kBAST,SAASM,EAAeC,EAAyB,CACpD,IAAMJ,EAAS,KAAKI,CAAG,EACjBL,EAAQ,IAAI,WAAWC,EAAO,MAAM,EAC1C,QAASC,EAAI,EAAGA,EAAID,EAAO,OAAQC,IAC/BF,EAAME,CAAC,EAAID,EAAO,WAAWC,CAAC,EAElC,OAAOF,CACX,CAPgBG,EAAAC,EAAA,kBAST,SAASE,EAAWC,EAAyB,CAChD,IAAMP,EAAQ,IAAI,WAAWO,EAAI,OAAS,CAAC,EAC3C,QAASL,EAAI,EAAGA,EAAIK,EAAI,OAAQL,GAAK,EACjCF,EAAME,EAAI,CAAC,EAAI,SAASK,EAAI,MAAML,EAAGA,EAAI,CAAC,EAAG,EAAE,EAEnD,OAAOF,CACX,CANgBG,EAAAG,EAAA,cAQT,SAASE,EAAWR,EAA2B,CAClD,OAAO,MAAM,KAAKA,CAAK,EAClB,IAAIS,GAAKA,EAAE,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAAC,EACxC,KAAK,EAAE,CAChB,CAJgBN,EAAAK,EAAA,cAMhB,eAAsBE,EAClBC,EACAC,EACAC,EAAoBhB,EACD,CACnB,IAAMiB,EAAO,QAAM,YAAS,CACxB,SAAAH,EACA,KAAMC,EACN,WAAYC,EAAO,SACnB,WAAYA,EAAO,WACnB,YAAaA,EAAO,YACpB,WAAYjB,GACZ,WAAY,QAChB,CAAC,EACD,OAAO,IAAI,WAAWkB,CAAmB,CAC7C,CAfsBX,EAAAO,EAAA,yBAiBtB,eAAsBK,EAClBC,EACAL,EAC+E,CAC/E,IAAMC,EAAO,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,EAChDK,EAAK,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,EAE9CC,EAAc,MAAMR,EAAsBC,EAAUC,CAAI,EAExDO,EAAY,MAAM,OAAO,OAAO,UAClC,MACAD,EAAY,OACZ,CAAE,KAAM,SAAU,EAClB,GACA,CAAC,SAAS,CACd,EAEME,EAAU,IAAI,YACdC,EAAmB,MAAM,OAAO,OAAO,QACzC,CAAE,KAAM,UAAW,GAAAJ,CAAG,EACtBE,EACAC,EAAQ,OAAOJ,CAAS,CAC5B,EAEA,MAAO,CACH,WAAYlB,EAAeuB,CAAgB,EAC3C,GAAIvB,EAAemB,EAAG,MAAM,EAC5B,KAAMnB,EAAec,EAAK,MAAM,EAChC,UAAWf,CACf,CACJ,CA9BsBM,EAAAY,EAAA,uBAgCtB,eAAsBO,EAClBC,EACAN,EACAL,EACAD,EACAE,EAAoBhB,EACL,CACf,IAAM2B,EAAYpB,EAAeQ,CAAI,EAC/Ba,EAAUrB,EAAea,CAAE,EAC3BS,EAAkBtB,EAAemB,CAAU,EAE3CL,EAAc,MAAMR,EAAsBC,EAAUa,EAAWX,CAAM,EAErEM,EAAY,MAAM,OAAO,OAAO,UAClC,MACAD,EAAY,OACZ,CAAE,KAAM,SAAU,EAClB,GACA,CAAC,SAAS,CACd,EAEMS,EAAkB,MAAM,OAAO,OAAO,QACxC,CAAE,KAAM,UAAW,GAAIF,CAAQ,EAC/BN,EACAO,CACJ,EAGA,OADgB,IAAI,YAAY,EACjB,OAAOC,CAAe,CACzC,CA7BsBxB,EAAAmB,EAAA,uBAyFf,SAASM,GAAoBC,EAA4B,CAC5D,OAAO,OAAO,gBAAgB,IAAI,WAAWA,CAAM,CAAC,CACxD,CAFgBC,EAAAF,GAAA,uBAIhB,eAAsBG,GAA6C,CAC/D,IAAMC,EAAkBJ,GAAoB,EAAE,EAC9C,OAAOK,EAAWD,CAAe,CACrC,CAHsBF,EAAAC,EAAA,6BDhMf,IAAMG,EAAmB,EACnBC,EAAgB,EAQ7B,eAAsBC,EAAgBC,EAA2C,CAC7E,IAAMC,EAAkBC,EAAWF,CAAa,EAE1CG,EAAS,QAAM,SAAMF,EAAiBJ,EAAkBC,CAAa,EAE3E,MAAO,CACH,YAAaM,EAAWD,EAAO,CAAC,CAAC,EACjC,UAAWC,EAAWD,EAAO,CAAC,CAAC,EAC/B,cAAeC,EAAWD,EAAO,CAAC,CAAC,CACvC,CACJ,CAVsBE,EAAAN,EAAA,mBAYtB,eAAsBO,EAAsBC,EAAmBC,EAAoC,CAC/F,IAAMC,EAASP,EAAWK,CAAS,EAC7BG,EAASR,EAAWM,CAAS,EAE7BG,EAAgB,QAAM,WAAQ,CAACF,EAAQC,CAAM,CAAC,EAEpD,OAAON,EAAWO,CAAa,CACnC,CAPsBN,EAAAC,EAAA,yBAStB,eAAsBM,EAAsBT,EAAmC,CAC3E,GAAIA,EAAO,OAASL,EAChB,MAAM,IAAI,MAAM,iBAAiBA,CAAa,4BAA4B,EAG9E,IAAMe,EAAaV,EAAO,MAAM,EAAGL,CAAa,EAAE,IAAII,CAAU,EAC1DS,EAAgB,QAAM,WAAQE,CAAU,EAE9C,OAAOT,EAAWO,CAAa,CACnC,CATsBN,EAAAO,EAAA,yBEhCtB,IAAME,GAAU,eAEhB,IAAMC,EAAa,OACbC,EAAe,SACfC,EAA0B,mBAShC,SAASC,GAA+B,CACpC,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACpC,IAAMC,EAAM,UAAU,KAAKC,GAAS,CAAU,EAC9CD,EAAI,gBAAkB,IAAM,CACxB,IAAME,EAAKF,EAAI,OACVE,EAAG,iBAAiB,SAASR,CAAU,GACxCQ,EAAG,kBAAkBR,CAAU,EAE9BQ,EAAG,iBAAiB,SAASP,CAAY,GAC1CO,EAAG,kBAAkBP,CAAY,CAEzC,EACAK,EAAI,UAAY,IAAMF,EAAQE,EAAI,MAAM,EACxCA,EAAI,QAAU,IAAMD,EAAOC,EAAI,KAAK,CACxC,CAAC,CACL,CAfSG,EAAAN,EAAA,UAiBT,SAASO,EACLF,EACAG,EACAC,EACAC,EACU,CACV,OAAO,IAAI,QAAQ,CAACT,EAASC,IAAW,CAEpC,IAAMS,EADIN,EAAG,YAAYG,EAAOC,CAAI,EACxB,YAAYD,CAAK,EACvBI,EAAUF,EAAGC,CAAC,EACpBC,EAAQ,UAAY,IAAMX,EAAQW,EAAQ,MAAW,EACrDA,EAAQ,QAAU,IAAMV,EAAOU,EAAQ,KAAK,CAChD,CAAC,CACL,CAbSN,EAAAC,EAAA,MAeT,eAAeM,IAA2C,CACtD,IAAMR,EAAK,MAAML,EAAO,EAExB,GAAI,CACA,IAAMc,EAAW,MAAMP,EAA0BF,EAAIR,EAAY,WAAYc,GACzEA,EAAE,IAAI,YAAY,CACtB,EAEA,GAAIG,EACA,OAAOA,EAGX,IAAMC,EAAM,MAAM,OAAO,OAAO,YAC5B,CAAE,KAAM,UAAW,OAAQ,GAAI,EAC/B,GACA,CAAC,UAAW,SAAS,CACzB,EAEA,aAAMR,EAAGF,EAAIR,EAAY,YAAac,GAAKA,EAAE,IAAII,EAAK,YAAY,CAAC,EAE5DA,CACX,QAAE,CACEV,EAAG,MAAM,CACb,CACJ,CAxBeC,EAAAO,GAAA,wBA0Bf,SAASG,EAAeC,EAA0B,CAC9C,IAAMC,EAAQ,IAAI,WAAWD,CAAG,EAC5BE,EAAS,GACb,QAASC,EAAI,EAAGA,EAAIF,EAAM,WAAYE,IAClCD,GAAU,OAAO,aAAaD,EAAME,CAAC,CAAC,EAE1C,OAAO,KAAKD,CAAM,CACtB,CAPSb,EAAAU,EAAA,kBAST,SAASK,GAAeC,EAA0B,CAC9C,IAAMH,EAAS,KAAKG,CAAG,EACjBJ,EAAQ,IAAI,WAAWC,EAAO,MAAM,EAC1C,QAASC,EAAI,EAAGA,EAAID,EAAO,OAAQC,IAC/BF,EAAME,CAAC,EAAID,EAAO,WAAWC,CAAC,EAElC,OAAOF,EAAM,MACjB,CAPSZ,EAAAe,GAAA,kBAST,eAAeE,GAAaC,EAAeC,EAAuC,CAC9E,IAAMV,EAAM,MAAMF,GAAqB,EACjCa,EAAK,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,EAC9CC,EAAU,IAAI,YACdC,EAAKD,EAAQ,OAAOF,CAAE,EAEtBI,EAAe,MAAM,OAAO,OAAO,QACrC,CAAE,KAAM,UAAW,GAAAH,EAAI,eAAgBE,CAAG,EAC1Cb,EACAY,EAAQ,OAAOH,CAAK,CACxB,EAEA,MAAO,CACH,QAAS,EACT,GAAIR,EAAeU,EAAG,MAAM,EAC5B,OAAQV,EAAea,CAAY,EACnC,WAAY,CAChB,CACJ,CAlBevB,EAAAiB,GAAA,gBAoBf,eAAeO,GAAaC,EAA2BN,EAA6B,CAChF,IAAMV,EAAM,MAAMF,GAAqB,EACjCa,EAAK,IAAI,WAAWL,GAAeU,EAAQ,EAAE,CAAC,EAC9CC,EAASX,GAAeU,EAAQ,MAAM,EAEtCH,EADU,IAAI,YAAY,EACb,OAAOH,CAAE,EAEtBQ,EAAc,MAAM,OAAO,OAAO,QACpC,CAAE,KAAM,UAAW,GAAAP,EAAI,eAAgBE,CAAG,EAC1Cb,EACAiB,CACJ,EAEA,OAAO,IAAI,YAAY,EAAE,OAAOC,CAAW,CAC/C,CAde3B,EAAAwB,GAAA,gBAgBf,eAAsBI,EAAiBV,EAAeC,EAAa1B,EAAwC,CACvG,IAAMM,EAAK,MAAML,EAAO,EAExB,GAAI,CACA,IAAM+B,EAAU,MAAMR,GAAaC,EAAOC,CAAE,EAC5C,MAAMlB,EAAGF,EAAIP,EAAc,YAAaa,GAAKA,EAAE,IAAIoB,EAASN,CAAE,CAAC,CACnE,QAAE,CACEpB,EAAG,MAAM,CACb,CACJ,CATsBC,EAAA4B,EAAA,oBAWtB,eAAsBC,EAAeV,EAAa1B,EAAiD,CAC/F,IAAMM,EAAK,MAAML,EAAO,EAExB,GAAI,CACA,IAAM+B,EAAU,MAAMxB,EAAiCF,EAAIP,EAAc,WAAYa,GACjFA,EAAE,IAAIc,CAAE,CACZ,EAEA,GAAI,CAACM,EACD,OAAO,KAGX,GAAI,CACA,OAAO,MAAMD,GAAaC,EAASN,CAAE,CACzC,OAASW,EAAG,CACR,eAAQ,KAAK,iCAAkCA,CAAC,EACzC,IACX,CACJ,QAAE,CACE/B,EAAG,MAAM,CACb,CACJ,CArBsBC,EAAA6B,EAAA,kBAuBtB,eAAsBE,EAAeZ,EAAa1B,EAA2C,CAEzF,OADc,MAAMoC,EAAeV,CAAE,IACpB,IACrB,CAHsBnB,EAAA+B,EAAA,kBAKtB,eAAsBC,EAAkBb,EAAa1B,EAAwC,CACzF,IAAMM,EAAK,MAAML,EAAO,EAExB,GAAI,CACA,MAAMO,EAAGF,EAAIP,EAAc,YAAaa,GAAKA,EAAE,OAAOc,CAAE,CAAC,CAC7D,QAAE,CACEpB,EAAG,MAAM,CACb,CACJ,CARsBC,EAAAgC,EAAA,qBAUtB,eAAsBC,GAAgC,CAClD,MAAM,IAAI,QAAc,CAACtC,EAASC,IAAW,CACzC,IAAMC,EAAM,UAAU,eAAeC,EAAO,EAC5CD,EAAI,UAAY,IAAMF,EAAQ,EAC9BE,EAAI,QAAU,IAAMD,EAAOC,EAAI,KAAK,EACpCA,EAAI,UAAY,IAAMF,EAAQ,CAClC,CAAC,CACL,CAPsBK,EAAAiC,EAAA,kBChKtB,IAAMC,GAAU,YACVC,GAAQ,OAAO,OAAW,IAAc,OAAO,SAAS,SAAW,YAEnEC,GAAW,IAAI,YAAY,EAAE,OAAO,2BAA2B,EAErE,SAASC,GAA+B,CACpC,OAAO,OAAO,OAAW,KACrB,OAAO,OAAO,oBAAwB,KACtC,OAAO,OAAO,oBAAoB,+CAAkD,UAC5F,CAJSC,EAAAD,EAAA,uBAMT,eAAeE,IAAmC,CAC9C,GAAI,CAACF,EAAoB,EAAG,MAAO,GAEnC,GAAI,CAEA,OADkB,MAAM,oBAAoB,8CAA8C,CAE9F,MAAQ,CACJ,MAAO,EACX,CACJ,CATeC,EAAAC,GAAA,kBAWf,eAAsBC,EAClBC,EACAC,EAC0B,CAC1B,GAAI,CAACL,EAAoB,EACrB,MAAM,IAAI,MAAM,2CAA2C,EAG/D,IAAMM,EAAc,IAAI,YAAY,EAAE,OAAOF,CAAM,EAE7CG,EAAoD,CACtD,UAAW,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,EACpD,GAAI,CACA,KAAMV,GACN,GAAIC,EACR,EACA,KAAM,CACF,GAAIQ,EACJ,KAAMD,EACN,YAAaA,CACjB,EACA,iBAAkB,CACd,CAAE,IAAK,GAAI,KAAM,YAAa,EAC9B,CAAE,IAAK,KAAM,KAAM,YAAa,CACpC,EACA,uBAAwB,CACpB,wBAAyB,WACzB,iBAAkB,WAClB,YAAa,UACjB,EACA,QAAS,IACT,YAAa,OACb,WAAY,CACR,IAAK,CACD,KAAM,CACF,MAAON,EACX,CACJ,CACJ,CACJ,EAEMS,EAAa,MAAM,UAAU,YAAY,OAAO,CAClD,UAAWD,CACf,CAAC,EAED,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,qCAAqC,EAGzD,IAAMC,EAAWD,EAAW,SAEtBE,EAAmBF,EAAW,0BAA0B,EAI9D,MAAI,CAACE,EAAiB,KAAK,SAAW,CAACA,EAAiB,KAAK,SAAS,OAClE,QAAQ,KAAK,4FAA4F,EAGtG,CACH,aAAcC,EAAeH,EAAW,KAAK,EAC7C,UAAWG,EAAeF,EAAS,aAAa,CAAgB,EAChE,WAAYA,EAAS,gBAAgB,CACzC,CACJ,CAhEsBR,EAAAE,EAAA,2BAkEtB,eAAsBS,EAClBC,EACkB,CAClB,GAAI,CAACb,EAAoB,EACrB,MAAM,IAAI,MAAM,2CAA2C,EAG/D,IAAMc,EAAgD,CAClD,UAAW,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,EACpD,KAAMhB,GACN,iBAAkB,CAAC,CACf,GAAIiB,EAAeF,CAAY,EAC/B,KAAM,YACV,CAAC,EACD,iBAAkB,WAClB,QAAS,IACT,WAAY,CACR,IAAK,CACD,KAAM,CACF,MAAOd,EACX,CACJ,CACJ,CACJ,EAEMiB,EAAY,MAAM,UAAU,YAAY,IAAI,CAC9C,UAAWF,CACf,CAAC,EAED,GAAI,CAACE,EACD,MAAM,IAAI,MAAM,iCAAiC,EAGrD,IAAMN,EAAmBM,EAAU,0BAA0B,EAI7D,GAAI,CAACN,EAAiB,KAAK,SAAS,MAChC,MAAM,IAAI,MAAM,oFAAoF,EAGxG,IAAMO,EAAY,IAAI,WAAWP,EAAiB,IAAI,QAAQ,KAAK,EAUnE,OARkB,MAAM,OAAO,OAAO,UAClC,MACAO,EACA,CAAE,KAAM,SAAU,EAClB,GACA,CAAC,UAAW,SAAS,CACzB,CAGJ,CApDsBhB,EAAAW,EAAA,wBAsDtB,eAAsBM,EAClBC,EACAN,EAC8B,CAC9B,IAAMO,EAAM,MAAMR,EAAqBC,CAAY,EAE7CQ,EAAK,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,EAC9CC,EAAU,IAAI,YAEdC,EAAa,MAAM,OAAO,OAAO,QACnC,CAAE,KAAM,UAAW,GAAAF,CAAG,EACtBD,EACAE,EAAQ,OAAOH,CAAK,CACxB,EAEA,MAAO,CACH,cAAeR,EAAeY,CAAU,EACxC,GAAIZ,EAAeU,EAAG,MAAM,EAC5B,aAAAR,CACJ,CACJ,CApBsBZ,EAAAiB,EAAA,2BAsBtB,eAAsBM,EAClBC,EACe,CACf,IAAML,EAAM,MAAMR,EAAqBa,EAAe,YAAY,EAE5DJ,EAAKN,EAAeU,EAAe,EAAE,EACrCF,EAAaR,EAAeU,EAAe,aAAa,EAExDC,EAAY,MAAM,OAAO,OAAO,QAClC,CAAE,KAAM,UAAW,GAAIL,EAAG,MAAO,EACjCD,EACAG,EAAW,MACf,EAGA,OADgB,IAAI,YAAY,EACjB,OAAOG,CAAS,CACnC,CAhBsBzB,EAAAuB,EAAA,2BCzKtB,IAAIG,EAA4C,KAEhD,eAAeC,IAAiC,CAC5C,OAAKD,IACDA,EAAkB,OAAO,gCAAgC,EAAE,KAAKE,GAAKA,EAAE,QAAQ,GAE5EF,CACX,CALeG,EAAAF,GAAA,eAOf,SAASG,GAAYC,EAA2B,CAC5C,OAAO,MAAM,KAAKA,CAAK,EAClB,IAAIC,GAAKA,EAAE,SAAS,CAAC,EAAE,SAAS,EAAG,GAAG,CAAC,EACvC,KAAK,EAAE,CAChB,CAJSH,EAAAC,GAAA,eAMT,SAASG,GAAYC,EAA0B,CAC3C,IAAMH,EAAQ,IAAI,WAAW,KAAK,KAAKG,EAAK,OAAS,CAAC,CAAC,EACvD,QAASC,EAAI,EAAGA,EAAIJ,EAAM,OAAQI,IAC9BJ,EAAMI,CAAC,EAAI,SAASD,EAAK,MAAMC,EAAI,GAAIA,EAAI,GAAK,CAAC,EAAE,OAAO,EAAG,GAAG,EAAG,CAAC,EAExE,OAAOJ,CACX,CANSF,EAAAI,GAAA,eAQT,eAAeG,GAAgBC,EAAmC,CAC9D,IAAMC,EAAO,MAAM,OAAO,OAAO,OAAO,UAAWD,CAAI,EACjDE,EAAWT,GAAY,IAAI,WAAWQ,CAAI,CAAC,EAC3CE,EAAiB,KAAK,MAAMH,EAAK,OAAS,CAAC,EACjD,OAAOE,EAAS,MAAM,EAAGC,CAAc,CAC3C,CALeX,EAAAO,GAAA,mBAOf,eAAsBK,EAAsBC,EAAmC,CAC3E,IAAMC,EAAW,MAAMhB,GAAY,EAC7BiB,EAAaC,EAAWH,CAAQ,EAEhCI,EAAW,MAAMV,GAAgBQ,CAAU,EAC3CG,EAAUjB,GAAYc,CAAU,EAAIE,EAEpCE,EAAkB,CAAC,EACzB,QAASb,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,GAAK,GAAI,CACzC,IAAMc,EAAQ,SAASF,EAAQ,MAAMZ,EAAGA,EAAI,EAAE,EAAE,OAAO,GAAI,GAAG,EAAG,CAAC,EAClEa,EAAM,KAAKL,EAASM,CAAK,CAAC,CAC9B,CAEA,OAAOD,EAAM,KAAK,GAAG,CACzB,CAdsBnB,EAAAY,EAAA,yBAgBtB,eAAsBS,EAAsBC,EAAiC,CACzE,IAAMR,EAAW,MAAMhB,GAAY,EAC7BqB,EAAQG,EAAO,KAAK,EAAE,YAAY,EAAE,MAAM,KAAK,EAGrD,GAAIH,EAAM,OAAS,IAAMA,EAAM,OAAS,GACpC,MAAM,IAAI,MAAM,qCAAqC,EAGzD,IAAId,EAAO,GACX,QAAWkB,KAAQJ,EAAO,CACtB,IAAMC,EAAQN,EAAS,QAAQS,CAAI,EACnC,GAAIH,IAAU,GACV,MAAM,IAAI,MAAM,oCAAoCG,CAAI,EAAE,EAE9DlB,GAAQe,EAAM,SAAS,CAAC,EAAE,SAAS,GAAI,GAAG,CAC9C,CAMA,IAAII,EAAgB,EACpB,QAAStB,EAAQ,EAAGA,GAAS,GAAIA,IAAS,CACtC,IAAMuB,EAAe,KAAK,MAAMvB,EAAQ,CAAC,EACnCwB,GAAYxB,EAAQ,EAAIuB,EACxBE,EAAc,KAAK,KAAKD,GAAY,EAAE,EAC5C,GAAIC,IAAgBR,EAAM,OACtBK,EAAgBtB,UACTyB,EAAcR,EAAM,OAC3B,KAER,CAEA,GAAIK,IAAkB,EAClB,MAAM,IAAI,MAAM,+CAA+C,EAGnE,IAAMb,EAAiB,KAAK,MAAMa,EAAgB,CAAC,EAC7CI,EAAeJ,EAAgB,EAE/BK,EAAWxB,EAAK,MAAM,EAAGuB,CAAY,EACrCH,EAAepB,EAAK,MAAMuB,EAAcA,EAAejB,CAAc,EAErEmB,EAAY1B,GAAYyB,CAAQ,EAEhCE,EAAmB,MAAMxB,GAAgBuB,CAAS,EACxD,GAAIL,IAAiBM,EAAiB,MAAM,EAAGpB,CAAc,EACzD,MAAM,IAAI,MAAM,kCAAkC,EAGtD,OAAOqB,EAAWF,CAAS,CAC/B,CApDsB9B,EAAAqB,EAAA,yBAsDtB,eAAsBY,GAAuBpB,EAA+C,CAExF,MAAO,CAAE,OADM,MAAMD,EAAsBC,CAAQ,EAClC,SAAAA,CAAS,CAC9B,CAHsBb,EAAAiC,GAAA,0BAKtB,eAAsBC,GAAuBZ,EAAkC,CAC3E,GAAI,CACA,aAAMD,EAAsBC,CAAM,EAC3B,EACX,MAAQ,CACJ,MAAO,EACX,CACJ,CAPsBtB,EAAAkC,GAAA,0BASf,SAASC,GAAWb,EAAwB,CAC/C,OAAOA,EAAO,KAAK,EAAE,MAAM,KAAK,EAAE,OAAOc,GAAKA,EAAE,OAAS,CAAC,EAAE,MAChE,CAFgBpC,EAAAmC,GAAA,cCtFT,IAAME,EAAN,KAAwD,CAQ3D,YAAYC,EAA6B,CAPzC,KAAS,KAAO,MAIhB,KAAQ,YAAc,GACtB,KAAQ,kBAAmC,KAGvC,KAAK,OAASA,EACd,KAAK,UAAY,IAAIC,EAAa,CAC9B,UAAWD,EAAO,UAClB,aAAcA,EAAO,YACzB,CAAC,CACL,CAxDJ,MA0C+D,CAAAE,EAAA,sBAgB3D,eAAyB,CACrB,OAAO,KAAK,WAChB,CAEA,MAAM,aAAgC,CAClC,OAAOC,EAAe,KAAK,OAAO,gBAAgB,CACtD,CAEA,MAAM,SAA2B,CAC7B,IAAMC,EAAc,MAAMC,EAAe,KAAK,OAAO,gBAAgB,EAErE,GAAI,CAACD,EACD,MAAM,IAAI,MAAM,6DAA6D,EAGjF,IAAME,EAAiB,MAAM,KAAK,UAAU,aAAa,EAEzD,GAAI,CAACA,GAAkB,CAACA,EAAe,UACnC,MAAM,IAAI,MAAM,0DAA0D,EAG9E,GAAIA,EAAe,cAAgB,MAC/B,MAAM,IAAI,MAAM,mCAAmC,EAGvD,IAAMC,EAAa,MAAMC,EACrBJ,EACAE,EAAe,UAAU,aAC7B,EAEA,YAAK,kBAAoBC,EACzB,KAAK,YAAc,GAEZA,CACX,CAEA,MAAM,YAA4B,CAC9B,KAAK,kBAAoB,KACzB,KAAK,YAAc,EACvB,CAEA,MAAM,aAA+B,CACjC,IAAMA,EAAa,MAAME,EAA0B,EACnD,aAAM,KAAK,aAAaF,CAAU,EAC3BA,CACX,CAEA,MAAM,aAAaA,EAAoBG,EAAoC,CACvE,IAAMC,EAAS,MAAMC,EAAgBL,CAAU,EAE/C,MAAMM,EAAiBF,EAAO,YAAa,KAAK,OAAO,gBAAgB,EAEvE,IAAMG,EAAMJ,GAAc,uBAAuB,KAAK,IAAI,CAAC,GAE3D,MAAM,KAAK,UAAU,eAAe,CAChC,UAAW,CACP,cAAeC,EAAO,UACtB,aAAc,GACd,GAAI,EACR,EACA,WAAYG,EACZ,cAAe,OACnB,CAAC,EAED,KAAK,kBAAoBP,EACzB,KAAK,YAAc,EACvB,CAEA,MAAM,QAAQA,EAAmC,CAC7C,MAAM,KAAK,aAAaA,CAAU,EAClC,MAAM,KAAK,UAAU,aAAa,CACtC,CAEA,MAAM,YAA+B,CAEjC,OADuB,MAAM,KAAK,UAAU,aAAa,IAClC,cAAgB,UAC3C,CAEA,MAAM,kBAAkBQ,EAAuC,CAC3D,GAAI,CAAC,KAAK,kBACN,MAAM,IAAI,MAAM,+BAA+B,EAInD,IAAMC,GADS,MAAMJ,EAAgB,KAAK,iBAAiB,GAC9B,cAE7B,GAAIG,EAAO,OAAS,WAAY,CAC5B,IAAME,EAAY,MAAMC,EAAoBF,EAAeD,EAAO,QAAQ,EAE1E,MAAM,KAAK,UAAU,kBAAkB,CACnC,KAAM,WACN,eAAgB,CACZ,cAAeE,EAAU,WACzB,GAAIA,EAAU,GACd,KAAMA,EAAU,IACpB,CACJ,CAAC,CACL,SAAWF,EAAO,OAAS,UAAW,CAClC,IAAMI,EAAO,MAAM,KAAK,OAAO,aAAa,eAAe,EAC3D,GAAI,CAACA,EACD,MAAM,IAAI,MAAM,uBAAuB,EAG3C,IAAMC,EAAa,MAAMC,EACrBF,EAAK,GACLA,EAAK,OAASA,EAAK,OAASA,EAAK,EACrC,EAEMG,EAAiB,MAAMC,EACzBP,EACAI,EAAW,YACf,EAEA,MAAM,KAAK,UAAU,kBAAkB,CACnC,KAAM,UACN,eAAgB,CACZ,cAAeE,EAAe,cAC9B,GAAIA,EAAe,EACvB,EACA,aAAcF,EAAW,YAC7B,CAAC,CACL,SAAWL,EAAO,OAAS,SACvB,MAAM,IAAI,MAAM,4BAA4B,CAEpD,CAEA,MAAM,wBAA0C,CAC5C,GAAI,CAAC,KAAK,kBACN,MAAM,IAAI,MAAM,+BAA+B,EAGnD,IAAMJ,EAAS,MAAMC,EAAgB,KAAK,iBAAiB,EAG3D,OAFe,MAAMY,EAAsBb,EAAO,aAAa,CAGnE,CAEA,MAAM,oBAAoD,CAEtD,OADuB,MAAM,KAAK,UAAU,aAAa,IAClC,iBAAmB,CAAC,CAC/C,CAEA,MAAM,QAAQI,EAAyC,CACnD,GAAIA,EAAO,OAAS,WAAY,CAC5B,IAAMO,EAAiB,MAAM,KAAK,UAAU,iBAAiB,UAAU,EAEvE,GAAI,CAACA,GAAkB,CAACA,EAAe,KACnC,MAAM,IAAI,MAAM,kCAAkC,EAGtD,IAAMN,EAAgB,MAAMS,EACxBH,EAAe,cACfA,EAAe,GACfA,EAAe,KACfP,EAAO,SACPW,CACJ,EAEMpB,EAAiB,MAAM,KAAK,UAAU,aAAa,EAEzD,GAAI,CAACA,GAAkB,CAACA,EAAe,UACnC,MAAM,IAAI,MAAM,+BAA+B,EAGnD,IAAMC,EAAa,MAAMC,EACrBQ,EACAV,EAAe,UAAU,aAC7B,EAEMqB,EAAY,MAAMf,EAAgBL,CAAU,EAClD,aAAMM,EAAiBc,EAAU,YAAa,KAAK,OAAO,gBAAgB,EAE1E,KAAK,kBAAoBpB,EACzB,KAAK,YAAc,GAEZA,CACX,SAAWQ,EAAO,OAAS,SAAU,CACjC,IAAMa,EAAqB,KAAK,MAAMb,EAAO,YAAY,EAEzD,GAAIa,EAAO,UAAY,EACnB,MAAM,IAAI,MAAM,iCAAiC,EAGrD,IAAMZ,EAAgB,MAAMS,EACxBG,EAAO,eAAe,WACtBA,EAAO,eAAe,GACtBA,EAAO,eAAe,KACtBb,EAAO,SACPa,EAAO,eAAe,SAC1B,EAEMtB,EAAiB,MAAM,KAAK,UAAU,aAAa,EAEzD,GAAI,CAACA,GAAkB,CAACA,EAAe,UACnC,MAAM,IAAI,MAAM,+BAA+B,EAGnD,IAAMC,EAAa,MAAMC,EACrBQ,EACAV,EAAe,UAAU,aAC7B,EAEMqB,EAAY,MAAMf,EAAgBL,CAAU,EAClD,aAAMM,EAAiBc,EAAU,YAAa,KAAK,OAAO,gBAAgB,EAE1E,KAAK,kBAAoBpB,EACzB,KAAK,YAAc,GAEZA,CACX,SAAWQ,EAAO,OAAS,UAAW,CAClC,IAAMO,EAAiB,MAAM,KAAK,UAAU,iBAAiB,UAAWP,EAAO,YAAY,EAE3F,GAAI,CAACO,EACD,MAAM,IAAI,MAAM,iCAAiC,EAGrD,IAAMN,EAAgB,MAAMa,EAAwB,CAChD,cAAeP,EAAe,cAC9B,GAAIA,EAAe,GACnB,aAAcP,EAAO,cAAgB,EACzC,CAAC,EAEKT,EAAiB,MAAM,KAAK,UAAU,aAAa,EAEzD,GAAI,CAACA,GAAkB,CAACA,EAAe,UACnC,MAAM,IAAI,MAAM,+BAA+B,EAGnD,IAAMC,EAAa,MAAMC,EACrBQ,EACAV,EAAe,UAAU,aAC7B,EAEMqB,EAAY,MAAMf,EAAgBL,CAAU,EAClD,aAAMM,EAAiBc,EAAU,YAAa,KAAK,OAAO,gBAAgB,EAE1E,KAAK,kBAAoBpB,EACzB,KAAK,YAAc,GAEZA,CACX,SAAWQ,EAAO,OAAS,SAAU,CACjC,IAAMC,EAAgB,MAAMc,EAAsBf,EAAO,MAAM,EAEzDT,EAAiB,MAAM,KAAK,UAAU,aAAa,EAEzD,GAAI,CAACA,GAAkB,CAACA,EAAe,UACnC,MAAM,IAAI,MAAM,+BAA+B,EAGnD,IAAMC,EAAa,MAAMC,EACrBQ,EACAV,EAAe,UAAU,aAC7B,EAEMqB,EAAY,MAAMf,EAAgBL,CAAU,EAClD,aAAMM,EAAiBc,EAAU,YAAa,KAAK,OAAO,gBAAgB,EAE1E,KAAK,kBAAoBpB,EACzB,KAAK,YAAc,GAEZA,CACX,CAEA,MAAM,IAAI,MAAM,yBAAyB,CAC7C,CAEA,MAAM,kBAA2C,CAE7C,OADuB,MAAM,KAAK,UAAU,aAAa,IAClC,eAAiB,OAC5C,CAEA,MAAM,aAAawB,EAAuC,CACtD,GAAI,CAAC,KAAK,kBACN,MAAM,IAAI,MAAM,+BAA+B,EAGnD,IAAMpB,EAAS,MAAMC,EAAgB,KAAK,iBAAiB,EACrDK,EAAY,MAAMC,EAAoBP,EAAO,cAAeoB,CAAQ,EAEpEzB,EAAiB,MAAM,KAAK,UAAU,aAAa,EAEzD,MAAO,CACH,QAAS,EACT,UAAW,IAAI,KAAK,EAAE,YAAY,EAClC,WAAYA,GAAgB,YAAc,UAC1C,eAAgB,CACZ,WAAYW,EAAU,WACtB,GAAIA,EAAU,GACd,KAAMA,EAAU,KAChB,UAAWA,EAAU,SACzB,CACJ,CACJ,CAEA,MAAM,gBAAgC,CAClC,MAAMe,EAAkB,KAAK,OAAO,gBAAgB,EACpD,KAAK,kBAAoB,KACzB,KAAK,YAAc,EACvB,CAEA,MAAM,eAA+B,CACjC,MAAM,KAAK,UAAU,cAAc,EACnC,MAAMC,EAAe,EACrB,KAAK,kBAAoB,KACzB,KAAK,YAAc,EACvB,CACJ,EAEO,SAASC,GAAoBlC,EAA4C,CAC5E,OAAO,IAAID,EAAcC,CAAM,CACnC,CAFgBE,EAAAgC,GAAA",
  "names": ["index_exports", "__export", "DEFAULT_KDF_PARAMS", "SSSApiClient", "SSSKeyManager", "SSS_THRESHOLD", "SSS_TOTAL_SHARES", "base64ToBuffer", "bufferToBase64", "bytesToHex", "clearAllShares", "countWords", "createPasskeyCredential", "createSSSKeyManager", "decryptShareWithPasskey", "decryptWithPassword", "deleteDeviceShare", "deriveKeyFromPasskey", "deriveKeyFromPassword", "encryptShareWithPasskey", "encryptWithPassword", "generateEd25519PrivateKey", "generateRecoveryPhrase", "getDeviceShare", "hasDeviceShare", "hexToBytes", "isPRFSupported", "isWebAuthnSupported", "reconstructFromShares", "reconstructPrivateKey", "recoveryPhraseToShare", "shareToRecoveryPhrase", "splitPrivateKey", "storeDeviceShare", "validateRecoveryPhrase", "__toCommonJS", "SSSApiClient", "__name", "config", "user", "headers", "providerType", "response", "input", "type", "credentialId", "token", "params", "import_shamir_secret_sharing", "import_hash_wasm", "ARGON2_TIME_COST", "ARGON2_MEMORY_COST", "ARGON2_PARALLELISM", "ARGON2_HASH_LENGTH", "DEFAULT_KDF_PARAMS", "bufferToBase64", "buf", "bytes", "binary", "i", "__name", "base64ToBuffer", "b64", "hexToBytes", "hex", "bytesToHex", "b", "deriveKeyFromPassword", "password", "salt", "params", "hash", "encryptWithPassword", "plaintext", "iv", "keyMaterial", "cryptoKey", "encoder", "ciphertextBuffer", "decryptWithPassword", "ciphertext", "saltBytes", "ivBytes", "ciphertextBytes", "plaintextBuffer", "generateRandomBytes", "length", "__name", "generateEd25519PrivateKey", "privateKeyBytes", "bytesToHex", "SSS_TOTAL_SHARES", "SSS_THRESHOLD", "splitPrivateKey", "privateKeyHex", "privateKeyBytes", "hexToBytes", "shares", "bytesToHex", "__name", "reconstructPrivateKey", "share1Hex", "share2Hex", "share1", "share2", "reconstructed", "reconstructFromShares", "shareBytes", "DB_NAME", "KEYS_STORE", "SHARES_STORE", "DEFAULT_DEVICE_SHARE_ID", "openDB", "resolve", "reject", "req", "DB_NAME", "db", "__name", "tx", "store", "mode", "op", "s", "request", "getOrCreateMasterKey", "existing", "key", "bufferToBase64", "buf", "bytes", "binary", "i", "base64ToBuffer", "b64", "encryptShare", "share", "id", "iv", "encoder", "ad", "cipherBuffer", "decryptShare", "payload", "cipher", "plainBuffer", "storeDeviceShare", "getDeviceShare", "e", "hasDeviceShare", "deleteDeviceShare", "clearAllShares", "RP_NAME", "RP_ID", "PRF_SALT", "isWebAuthnSupported", "__name", "isPRFSupported", "createPasskeyCredential", "userId", "userName", "userIdBytes", "createOptions", "credential", "response", "extensionResults", "bufferToBase64", "deriveKeyFromPasskey", "credentialId", "getOptions", "base64ToBuffer", "assertion", "prfOutput", "encryptShareWithPasskey", "share", "key", "iv", "encoder", "ciphertext", "decryptShareWithPasskey", "encryptedShare", "plaintext", "wordlistPromise", "getWordlist", "m", "__name", "bytesToBits", "bytes", "b", "bitsToBytes", "bits", "i", "computeChecksum", "data", "hash", "hashBits", "checksumLength", "shareToRecoveryPhrase", "shareHex", "wordlist", "shareBytes", "hexToBytes", "checksum", "allBits", "words", "index", "recoveryPhraseToShare", "phrase", "word", "dataByteCount", "checksumBits", "totalBits", "wordsNeeded", "dataBitCount", "dataBits", "dataBytes", "expectedChecksum", "bytesToHex", "generateRecoveryPhrase", "validateRecoveryPhrase", "countWords", "w", "SSSKeyManager", "config", "SSSApiClient", "__name", "hasDeviceShare", "deviceShare", "getDeviceShare", "serverResponse", "privateKey", "reconstructPrivateKey", "generateEd25519PrivateKey", "primaryDid", "shares", "splitPrivateKey", "storeDeviceShare", "did", "method", "recoveryShare", "encrypted", "encryptWithPassword", "user", "credential", "createPasskeyCredential", "encryptedShare", "encryptShareWithPasskey", "shareToRecoveryPhrase", "decryptWithPassword", "DEFAULT_KDF_PARAMS", "newShares", "backup", "decryptShareWithPasskey", "recoveryPhraseToShare", "password", "deleteDeviceShare", "clearAllShares", "createSSSKeyManager"]
}
