{
  "version": 3,
  "sources": ["../src/index.ts", "../src/api-client.ts", "../src/sss.ts", "../src/crypto.ts", "../src/storage.ts", "../src/key-manager.ts"],
  "sourcesContent": ["/**\n * @learncard/sss-key-manager\n *\n * Shamir Secret Sharing key manager for LearnCard - replaces Web3Auth SFA\n */\n\nexport { SSSKeyManager, createSSSKeyManager } from './key-manager';\nexport { SSSApiClient } from './api-client';\n\nexport {\n    splitPrivateKey,\n    reconstructPrivateKey,\n    reconstructFromShares,\n    SSS_TOTAL_SHARES,\n    SSS_THRESHOLD,\n} from './sss';\n\nexport {\n    storeDeviceShare,\n    getDeviceShare,\n    hasDeviceShare,\n    deleteDeviceShare,\n    clearAllShares,\n} from './storage';\n\nexport {\n    encryptWithPassword,\n    decryptWithPassword,\n    deriveKeyFromPassword,\n    generateEd25519PrivateKey,\n    hexToBytes,\n    bytesToHex,\n    bufferToBase64,\n    base64ToBuffer,\n    DEFAULT_KDF_PARAMS,\n} from './crypto';\n\nexport type {\n    SSSKeyManagerConfig,\n    SSSKeyDerivationProvider,\n    KeyDerivationProvider,\n    AuthProvider,\n    AuthUser,\n    AuthProviderType,\n    ContactMethod,\n    ContactMethodType,\n    RecoveryMethod,\n    RecoveryMethodType,\n    RecoveryMethodInfo,\n    PasswordRecoveryMethod,\n    PasskeyRecoveryMethod,\n    BackupFileRecoveryMethod,\n    SecurityLevel,\n    BackupFile,\n    EncryptedShare,\n    ServerEncryptedShare,\n    UserKeyRecord,\n    AuthProviderMapping,\n} from './types';\n", "/**\n * API client for SSS Key Manager server routes\n */\n\nimport type {\n    AuthProvider,\n    AuthProviderType,\n    ContactMethod,\n    ServerEncryptedShare,\n    RecoveryMethodInfo,\n    EncryptedShare,\n    SecurityLevel,\n} from './types';\n\nexport interface GetAuthShareResponse {\n    authShare: ServerEncryptedShare | null;\n    primaryDid: string | null;\n    securityLevel: SecurityLevel;\n    recoveryMethods: RecoveryMethodInfo[];\n    keyProvider: 'web3auth' | 'sss';\n}\n\nexport interface StoreAuthShareInput {\n    authShare: ServerEncryptedShare;\n    primaryDid: string;\n    securityLevel?: SecurityLevel;\n}\n\nexport interface StoreRecoveryShareInput {\n    type: 'password' | 'passkey' | 'backup';\n    encryptedShare: EncryptedShare;\n    credentialId?: string;\n}\n\nexport interface ApiClientConfig {\n    serverUrl: string;\n    authProvider: AuthProvider;\n}\n\nexport class SSSApiClient {\n    private serverUrl: string;\n    private authProvider: AuthProvider;\n\n    constructor(config: ApiClientConfig) {\n        this.serverUrl = config.serverUrl.replace(/\\/$/, '');\n        this.authProvider = config.authProvider;\n    }\n\n    private async getAuthHeaders(): Promise<Record<string, string>> {\n        const token = await this.authProvider.getIdToken();\n        return {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${token}`,\n        };\n    }\n\n    private async getContactMethodFromUser(): Promise<ContactMethod | null> {\n        const user = await this.authProvider.getCurrentUser();\n        if (!user) return null;\n\n        if (user.email) {\n            return { type: 'email' as const, value: user.email.toLowerCase() };\n        }\n        if (user.phone) {\n            return { type: 'phone' as const, value: user.phone };\n        }\n        return null;\n    }\n\n    async getAuthShare(): Promise<GetAuthShareResponse | null> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get auth share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async storeAuthShare(input: StoreAuthShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'PUT',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to store auth share: ${response.statusText}`);\n        }\n    }\n\n    async addRecoveryMethod(input: StoreRecoveryShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to add recovery method: ${response.statusText}`);\n        }\n    }\n\n    async getRecoveryShare(\n        type: 'password' | 'passkey' | 'backup',\n        credentialId?: string\n    ): Promise<EncryptedShare | null> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const params = new URLSearchParams({\n            type,\n            providerType,\n        });\n\n        if (credentialId) {\n            params.append('credentialId', credentialId);\n        }\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery?${params}`, {\n            method: 'GET',\n            headers,\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get recovery share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async markMigrated(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/migrate`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to mark as migrated: ${response.statusText}`);\n        }\n    }\n\n    async deleteUserKey(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys`, {\n            method: 'DELETE',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to delete user key: ${response.statusText}`);\n        }\n    }\n}\n", "/**\n * Shamir Secret Sharing operations\n */\n\nimport { split, combine } from 'shamir-secret-sharing';\nimport { hexToBytes, bytesToHex } from './crypto';\n\nexport const SSS_TOTAL_SHARES = 3;\nexport const SSS_THRESHOLD = 2;\n\nexport interface SSSShares {\n    deviceShare: string;\n    authShare: string;\n    recoveryShare: string;\n}\n\nexport async function splitPrivateKey(privateKeyHex: string): Promise<SSSShares> {\n    const privateKeyBytes = hexToBytes(privateKeyHex);\n\n    const shares = await split(privateKeyBytes, SSS_TOTAL_SHARES, SSS_THRESHOLD);\n\n    return {\n        deviceShare: bytesToHex(shares[0]),\n        authShare: bytesToHex(shares[1]),\n        recoveryShare: bytesToHex(shares[2]),\n    };\n}\n\nexport async function reconstructPrivateKey(share1Hex: string, share2Hex: string): Promise<string> {\n    const share1 = hexToBytes(share1Hex);\n    const share2 = hexToBytes(share2Hex);\n\n    const reconstructed = await combine([share1, share2]);\n\n    return bytesToHex(reconstructed);\n}\n\nexport async function reconstructFromShares(shares: string[]): Promise<string> {\n    if (shares.length < SSS_THRESHOLD) {\n        throw new Error(`Need at least ${SSS_THRESHOLD} shares to reconstruct key`);\n    }\n\n    const shareBytes = shares.slice(0, SSS_THRESHOLD).map(hexToBytes);\n    const reconstructed = await combine(shareBytes);\n\n    return bytesToHex(reconstructed);\n}\n", "/**\n * Cryptographic utilities for SSS Key Manager\n */\n\nimport { argon2id } from 'hash-wasm';\n\nconst ARGON2_TIME_COST = 3;\nconst ARGON2_MEMORY_COST = 65536;\nconst ARGON2_PARALLELISM = 4;\nconst ARGON2_HASH_LENGTH = 32;\n\nexport interface KdfParams {\n    algorithm: 'argon2id';\n    timeCost: number;\n    memoryCost: number;\n    parallelism: number;\n}\n\nexport const DEFAULT_KDF_PARAMS: KdfParams = {\n    algorithm: 'argon2id',\n    timeCost: ARGON2_TIME_COST,\n    memoryCost: ARGON2_MEMORY_COST,\n    parallelism: ARGON2_PARALLELISM,\n};\n\nexport function bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nexport function base64ToBuffer(b64: string): Uint8Array {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n\nexport function hexToBytes(hex: string): Uint8Array {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n    }\n    return bytes;\n}\n\nexport function bytesToHex(bytes: Uint8Array): string {\n    return Array.from(bytes)\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n\nexport async function deriveKeyFromPassword(\n    password: string,\n    salt: Uint8Array,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<Uint8Array> {\n    const hash = await argon2id({\n        password,\n        salt: salt as unknown as Uint8Array,\n        iterations: params.timeCost,\n        memorySize: params.memoryCost,\n        parallelism: params.parallelism,\n        hashLength: ARGON2_HASH_LENGTH,\n        outputType: 'binary',\n    });\n    return new Uint8Array(hash as ArrayBuffer);\n}\n\nexport async function encryptWithPassword(\n    plaintext: string,\n    password: string\n): Promise<{ ciphertext: string; iv: string; salt: string; kdfParams: KdfParams }> {\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n\n    const keyMaterial = await deriveKeyFromPassword(password, salt);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['encrypt']\n    );\n\n    const encoder = new TextEncoder();\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv },\n        cryptoKey,\n        encoder.encode(plaintext)\n    );\n\n    return {\n        ciphertext: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n        salt: bufferToBase64(salt.buffer),\n        kdfParams: DEFAULT_KDF_PARAMS,\n    };\n}\n\nexport async function decryptWithPassword(\n    ciphertext: string,\n    iv: string,\n    salt: string,\n    password: string,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<string> {\n    const saltBytes = base64ToBuffer(salt);\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(ciphertext);\n\n    const keyMaterial = await deriveKeyFromPassword(password, saltBytes, params);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['decrypt']\n    );\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv: ivBytes },\n        cryptoKey,\n        ciphertextBytes\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function encryptShare(\n    share: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<{ encryptedData: string; iv: string }> {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n\n    const encryptParams: AesGcmParams = { name: 'AES-GCM', iv };\n    if (aad) {\n        encryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        encryptParams,\n        key,\n        encoder.encode(share) as ArrayBuffer\n    );\n\n    return {\n        encryptedData: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n    };\n}\n\nexport async function decryptShare(\n    encryptedData: string,\n    iv: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<string> {\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(encryptedData);\n    const encoder = new TextEncoder();\n\n    const decryptParams: AesGcmParams = { name: 'AES-GCM', iv: ivBytes.buffer as ArrayBuffer };\n    if (aad) {\n        decryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        decryptParams,\n        key,\n        ciphertextBytes.buffer as ArrayBuffer\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function generateAesKey(): Promise<CryptoKey> {\n    return crypto.subtle.generateKey(\n        { name: 'AES-GCM', length: 256 },\n        true,\n        ['encrypt', 'decrypt']\n    );\n}\n\nexport function generateRandomBytes(length: number): Uint8Array {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n\nexport async function generateEd25519PrivateKey(): Promise<string> {\n    const privateKeyBytes = generateRandomBytes(32);\n    return bytesToHex(privateKeyBytes);\n}\n", "/**\n * Device-side storage for SSS shares\n * Reuses patterns from webSecureStorage but specialized for SSS\n */\n\nconst DB_NAME = 'lcb-sss-keys';\nconst DB_VERSION = 1;\nconst KEYS_STORE = 'keys';\nconst SHARES_STORE = 'shares';\nconst DEFAULT_DEVICE_SHARE_ID = 'sss-device-share';\n\ntype EncryptedPayload = {\n    version: 1;\n    iv: string;\n    cipher: string;\n    keyVersion: number;\n};\n\nfunction openDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open(DB_NAME, DB_VERSION);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains(KEYS_STORE)) {\n                db.createObjectStore(KEYS_STORE);\n            }\n            if (!db.objectStoreNames.contains(SHARES_STORE)) {\n                db.createObjectStore(SHARES_STORE);\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nfunction tx<T = unknown>(\n    db: IDBDatabase,\n    store: string,\n    mode: IDBTransactionMode,\n    op: (store: IDBObjectStore) => IDBRequest<T>\n): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const t = db.transaction(store, mode);\n        const s = t.objectStore(store);\n        const request = op(s);\n        request.onsuccess = () => resolve(request.result as T);\n        request.onerror = () => reject(request.error);\n    });\n}\n\nasync function getOrCreateMasterKey(): Promise<CryptoKey> {\n    const db = await openDB();\n\n    try {\n        const existing = await tx<CryptoKey | undefined>(db, KEYS_STORE, 'readonly', s =>\n            s.get('master-key')\n        );\n\n        if (existing) {\n            return existing;\n        }\n\n        const key = await crypto.subtle.generateKey(\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt', 'decrypt']\n        );\n\n        await tx(db, KEYS_STORE, 'readwrite', s => s.put(key, 'master-key'));\n\n        return key;\n    } finally {\n        db.close();\n    }\n}\n\nfunction bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nfunction base64ToBuffer(b64: string): ArrayBuffer {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nasync function encryptShare(share: string, id: string): Promise<EncryptedPayload> {\n    const key = await getOrCreateMasterKey();\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const cipherBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        encoder.encode(share)\n    );\n\n    return {\n        version: 1,\n        iv: bufferToBase64(iv.buffer),\n        cipher: bufferToBase64(cipherBuffer),\n        keyVersion: 1,\n    };\n}\n\nasync function decryptShare(payload: EncryptedPayload, id: string): Promise<string> {\n    const key = await getOrCreateMasterKey();\n    const iv = new Uint8Array(base64ToBuffer(payload.iv));\n    const cipher = base64ToBuffer(payload.cipher);\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const plainBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        cipher\n    );\n\n    return new TextDecoder().decode(plainBuffer);\n}\n\nexport async function storeDeviceShare(share: string, id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        const payload = await encryptShare(share, id);\n        await tx(db, SHARES_STORE, 'readwrite', s => s.put(payload, id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function getDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<string | null> {\n    const db = await openDB();\n\n    try {\n        const payload = await tx<EncryptedPayload | undefined>(db, SHARES_STORE, 'readonly', s =>\n            s.get(id)\n        );\n\n        if (!payload) {\n            return null;\n        }\n\n        try {\n            return await decryptShare(payload, id);\n        } catch (e) {\n            console.warn('SSS Storage: decryption failed', e);\n            return null;\n        }\n    } finally {\n        db.close();\n    }\n}\n\nexport async function hasDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<boolean> {\n    const share = await getDeviceShare(id);\n    return share !== null;\n}\n\nexport async function deleteDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        await tx(db, SHARES_STORE, 'readwrite', s => s.delete(id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function clearAllShares(): Promise<void> {\n    await new Promise<void>((resolve, reject) => {\n        const req = indexedDB.deleteDatabase(DB_NAME);\n        req.onsuccess = () => resolve();\n        req.onerror = () => reject(req.error);\n        req.onblocked = () => resolve();\n    });\n}\n", "/**\n * SSS Key Manager - Main class\n */\n\nimport type {\n    SSSKeyManagerConfig,\n    SSSKeyDerivationProvider,\n    RecoveryMethod,\n    RecoveryMethodInfo,\n    SecurityLevel,\n    BackupFile,\n    AuthProvider,\n} from './types';\n\nimport { SSSApiClient } from './api-client';\nimport { splitPrivateKey, reconstructPrivateKey } from './sss';\nimport {\n    storeDeviceShare,\n    getDeviceShare,\n    hasDeviceShare,\n    deleteDeviceShare,\n    clearAllShares,\n} from './storage';\nimport {\n    encryptWithPassword,\n    decryptWithPassword,\n    generateEd25519PrivateKey,\n    DEFAULT_KDF_PARAMS,\n} from './crypto';\n\nexport class SSSKeyManager implements SSSKeyDerivationProvider {\n    readonly name = 'sss';\n\n    private config: SSSKeyManagerConfig;\n    private apiClient: SSSApiClient;\n    private initialized = false;\n    private currentPrivateKey: string | null = null;\n\n    constructor(config: SSSKeyManagerConfig) {\n        this.config = config;\n        this.apiClient = new SSSApiClient({\n            serverUrl: config.serverUrl,\n            authProvider: config.authProvider,\n        });\n    }\n\n    isInitialized(): boolean {\n        return this.initialized;\n    }\n\n    async hasLocalKey(): Promise<boolean> {\n        return hasDeviceShare(this.config.deviceStorageKey);\n    }\n\n    async connect(): Promise<string> {\n        const deviceShare = await getDeviceShare(this.config.deviceStorageKey);\n\n        if (!deviceShare) {\n            throw new Error('No device share found. User needs to set up SSS or recover.');\n        }\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        if (!serverResponse || !serverResponse.authShare) {\n            throw new Error('No auth share found on server. User may need to recover.');\n        }\n\n        if (serverResponse.keyProvider !== 'sss') {\n            throw new Error('User has not migrated to SSS yet.');\n        }\n\n        const privateKey = await reconstructPrivateKey(\n            deviceShare,\n            serverResponse.authShare.encryptedData\n        );\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n\n        return privateKey;\n    }\n\n    async disconnect(): Promise<void> {\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async setupNewKey(): Promise<string> {\n        const privateKey = await generateEd25519PrivateKey();\n        await this.setupWithKey(privateKey);\n        return privateKey;\n    }\n\n    async setupWithKey(privateKey: string, primaryDid?: string): Promise<void> {\n        const shares = await splitPrivateKey(privateKey);\n\n        await storeDeviceShare(shares.deviceShare, this.config.deviceStorageKey);\n\n        const did = primaryDid || `did:key:placeholder-${Date.now()}`;\n\n        await this.apiClient.storeAuthShare({\n            authShare: {\n                encryptedData: shares.authShare,\n                encryptedDek: '',\n                iv: '',\n            },\n            primaryDid: did,\n            securityLevel: 'basic',\n        });\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n    }\n\n    async migrate(privateKey: string): Promise<void> {\n        await this.setupWithKey(privateKey);\n        await this.apiClient.markMigrated();\n    }\n\n    async canMigrate(): Promise<boolean> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.keyProvider === 'web3auth';\n    }\n\n    async addRecoveryMethod(method: RecoveryMethod): Promise<void> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const recoveryShare = shares.recoveryShare;\n\n        if (method.type === 'password') {\n            const encrypted = await encryptWithPassword(recoveryShare, method.password);\n\n            await this.apiClient.addRecoveryMethod({\n                type: 'password',\n                encryptedShare: {\n                    encryptedData: encrypted.ciphertext,\n                    iv: encrypted.iv,\n                    salt: encrypted.salt,\n                },\n            });\n        } else if (method.type === 'passkey') {\n            throw new Error('Passkey recovery not yet implemented');\n        } else if (method.type === 'backup') {\n            throw new Error('Use exportBackup() instead');\n        }\n    }\n\n    async getRecoveryMethods(): Promise<RecoveryMethodInfo[]> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.recoveryMethods || [];\n    }\n\n    async recover(method: RecoveryMethod): Promise<string> {\n        if (method.type === 'password') {\n            const encryptedShare = await this.apiClient.getRecoveryShare('password');\n\n            if (!encryptedShare || !encryptedShare.salt) {\n                throw new Error('No password recovery share found');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                encryptedShare.encryptedData,\n                encryptedShare.iv,\n                encryptedShare.salt,\n                method.password,\n                DEFAULT_KDF_PARAMS\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'backup') {\n            const backup: BackupFile = JSON.parse(method.fileContents);\n\n            if (backup.version !== 1) {\n                throw new Error('Unsupported backup file version');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                backup.encryptedShare.ciphertext,\n                backup.encryptedShare.iv,\n                backup.encryptedShare.salt,\n                method.password,\n                backup.encryptedShare.kdfParams\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'passkey') {\n            throw new Error('Passkey recovery not yet implemented');\n        }\n\n        throw new Error('Unknown recovery method');\n    }\n\n    async getSecurityLevel(): Promise<SecurityLevel> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.securityLevel || 'basic';\n    }\n\n    async exportBackup(password: string): Promise<BackupFile> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const encrypted = await encryptWithPassword(shares.recoveryShare, password);\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        return {\n            version: 1,\n            createdAt: new Date().toISOString(),\n            primaryDid: serverResponse?.primaryDid || 'unknown',\n            encryptedShare: {\n                ciphertext: encrypted.ciphertext,\n                iv: encrypted.iv,\n                salt: encrypted.salt,\n                kdfParams: encrypted.kdfParams,\n            },\n        };\n    }\n\n    async clearLocalData(): Promise<void> {\n        await deleteDeviceShare(this.config.deviceStorageKey);\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async deleteAccount(): Promise<void> {\n        await this.apiClient.deleteUserKey();\n        await clearAllShares();\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n}\n\nexport function createSSSKeyManager(config: SSSKeyManagerConfig): SSSKeyManager {\n    return new SSSKeyManager(config);\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "DEFAULT_KDF_PARAMS", "SSSApiClient", "SSSKeyManager", "SSS_THRESHOLD", "SSS_TOTAL_SHARES", "base64ToBuffer", "bufferToBase64", "bytesToHex", "clearAllShares", "createSSSKeyManager", "decryptWithPassword", "deleteDeviceShare", "deriveKeyFromPassword", "encryptWithPassword", "generateEd25519PrivateKey", "getDeviceShare", "hasDeviceShare", "hexToBytes", "reconstructFromShares", "reconstructPrivateKey", "splitPrivateKey", "storeDeviceShare", "__toCommonJS", "SSSApiClient", "__name", "config", "user", "headers", "providerType", "response", "input", "type", "credentialId", "params", "import_shamir_secret_sharing", "import_hash_wasm", "ARGON2_TIME_COST", "ARGON2_MEMORY_COST", "ARGON2_PARALLELISM", "ARGON2_HASH_LENGTH", "DEFAULT_KDF_PARAMS", "bufferToBase64", "buf", "bytes", "binary", "i", "__name", "base64ToBuffer", "b64", "hexToBytes", "hex", "bytesToHex", "b", "deriveKeyFromPassword", "password", "salt", "params", "hash", "encryptWithPassword", "plaintext", "iv", "keyMaterial", "cryptoKey", "encoder", "ciphertextBuffer", "decryptWithPassword", "ciphertext", "saltBytes", "ivBytes", "ciphertextBytes", "plaintextBuffer", "generateRandomBytes", "length", "__name", "generateEd25519PrivateKey", "privateKeyBytes", "bytesToHex", "SSS_TOTAL_SHARES", "SSS_THRESHOLD", "splitPrivateKey", "privateKeyHex", "privateKeyBytes", "hexToBytes", "shares", "bytesToHex", "__name", "reconstructPrivateKey", "share1Hex", "share2Hex", "share1", "share2", "reconstructed", "reconstructFromShares", "shareBytes", "DB_NAME", "KEYS_STORE", "SHARES_STORE", "DEFAULT_DEVICE_SHARE_ID", "openDB", "resolve", "reject", "req", "DB_NAME", "db", "__name", "tx", "store", "mode", "op", "s", "request", "getOrCreateMasterKey", "existing", "key", "bufferToBase64", "buf", "bytes", "binary", "i", "base64ToBuffer", "b64", "encryptShare", "share", "id", "iv", "encoder", "ad", "cipherBuffer", "decryptShare", "payload", "cipher", "plainBuffer", "storeDeviceShare", "getDeviceShare", "e", "hasDeviceShare", "deleteDeviceShare", "clearAllShares", "SSSKeyManager", "config", "SSSApiClient", "__name", "hasDeviceShare", "deviceShare", "getDeviceShare", "serverResponse", "privateKey", "reconstructPrivateKey", "generateEd25519PrivateKey", "primaryDid", "shares", "splitPrivateKey", "storeDeviceShare", "did", "method", "recoveryShare", "encrypted", "encryptWithPassword", "encryptedShare", "decryptWithPassword", "DEFAULT_KDF_PARAMS", "newShares", "backup", "password", "deleteDeviceShare", "clearAllShares", "createSSSKeyManager"]
}
