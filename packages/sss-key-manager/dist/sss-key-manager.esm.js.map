{
  "version": 3,
  "sources": ["../src/api-client.ts", "../src/sss.ts", "../src/crypto.ts", "../src/storage.ts", "../src/key-manager.ts"],
  "sourcesContent": ["/**\n * API client for SSS Key Manager server routes\n */\n\nimport type {\n    AuthProvider,\n    AuthProviderType,\n    ContactMethod,\n    ServerEncryptedShare,\n    RecoveryMethodInfo,\n    EncryptedShare,\n    SecurityLevel,\n} from './types';\n\nexport interface GetAuthShareResponse {\n    authShare: ServerEncryptedShare | null;\n    primaryDid: string | null;\n    securityLevel: SecurityLevel;\n    recoveryMethods: RecoveryMethodInfo[];\n    keyProvider: 'web3auth' | 'sss';\n}\n\nexport interface StoreAuthShareInput {\n    authShare: ServerEncryptedShare;\n    primaryDid: string;\n    securityLevel?: SecurityLevel;\n}\n\nexport interface StoreRecoveryShareInput {\n    type: 'password' | 'passkey' | 'backup';\n    encryptedShare: EncryptedShare;\n    credentialId?: string;\n}\n\nexport interface ApiClientConfig {\n    serverUrl: string;\n    authProvider: AuthProvider;\n}\n\nexport class SSSApiClient {\n    private serverUrl: string;\n    private authProvider: AuthProvider;\n\n    constructor(config: ApiClientConfig) {\n        this.serverUrl = config.serverUrl.replace(/\\/$/, '');\n        this.authProvider = config.authProvider;\n    }\n\n    private async getAuthHeaders(): Promise<Record<string, string>> {\n        const token = await this.authProvider.getIdToken();\n        return {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${token}`,\n        };\n    }\n\n    private async getContactMethodFromUser(): Promise<ContactMethod | null> {\n        const user = await this.authProvider.getCurrentUser();\n        if (!user) return null;\n\n        if (user.email) {\n            return { type: 'email' as const, value: user.email.toLowerCase() };\n        }\n        if (user.phone) {\n            return { type: 'phone' as const, value: user.phone };\n        }\n        return null;\n    }\n\n    async getAuthShare(): Promise<GetAuthShareResponse | null> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get auth share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async storeAuthShare(input: StoreAuthShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'PUT',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to store auth share: ${response.statusText}`);\n        }\n    }\n\n    async addRecoveryMethod(input: StoreRecoveryShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to add recovery method: ${response.statusText}`);\n        }\n    }\n\n    async getRecoveryShare(\n        type: 'password' | 'passkey' | 'backup',\n        credentialId?: string\n    ): Promise<EncryptedShare | null> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const params = new URLSearchParams({\n            type,\n            providerType,\n        });\n\n        if (credentialId) {\n            params.append('credentialId', credentialId);\n        }\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery?${params}`, {\n            method: 'GET',\n            headers,\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get recovery share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async markMigrated(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/migrate`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to mark as migrated: ${response.statusText}`);\n        }\n    }\n\n    async deleteUserKey(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys`, {\n            method: 'DELETE',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to delete user key: ${response.statusText}`);\n        }\n    }\n}\n", "/**\n * Shamir Secret Sharing operations\n */\n\nimport { split, combine } from 'shamir-secret-sharing';\nimport { hexToBytes, bytesToHex } from './crypto';\n\nexport const SSS_TOTAL_SHARES = 3;\nexport const SSS_THRESHOLD = 2;\n\nexport interface SSSShares {\n    deviceShare: string;\n    authShare: string;\n    recoveryShare: string;\n}\n\nexport async function splitPrivateKey(privateKeyHex: string): Promise<SSSShares> {\n    const privateKeyBytes = hexToBytes(privateKeyHex);\n\n    const shares = await split(privateKeyBytes, SSS_TOTAL_SHARES, SSS_THRESHOLD);\n\n    return {\n        deviceShare: bytesToHex(shares[0]),\n        authShare: bytesToHex(shares[1]),\n        recoveryShare: bytesToHex(shares[2]),\n    };\n}\n\nexport async function reconstructPrivateKey(share1Hex: string, share2Hex: string): Promise<string> {\n    const share1 = hexToBytes(share1Hex);\n    const share2 = hexToBytes(share2Hex);\n\n    const reconstructed = await combine([share1, share2]);\n\n    return bytesToHex(reconstructed);\n}\n\nexport async function reconstructFromShares(shares: string[]): Promise<string> {\n    if (shares.length < SSS_THRESHOLD) {\n        throw new Error(`Need at least ${SSS_THRESHOLD} shares to reconstruct key`);\n    }\n\n    const shareBytes = shares.slice(0, SSS_THRESHOLD).map(hexToBytes);\n    const reconstructed = await combine(shareBytes);\n\n    return bytesToHex(reconstructed);\n}\n", "/**\n * Cryptographic utilities for SSS Key Manager\n */\n\nimport { argon2id } from 'hash-wasm';\n\nconst ARGON2_TIME_COST = 3;\nconst ARGON2_MEMORY_COST = 65536;\nconst ARGON2_PARALLELISM = 4;\nconst ARGON2_HASH_LENGTH = 32;\n\nexport interface KdfParams {\n    algorithm: 'argon2id';\n    timeCost: number;\n    memoryCost: number;\n    parallelism: number;\n}\n\nexport const DEFAULT_KDF_PARAMS: KdfParams = {\n    algorithm: 'argon2id',\n    timeCost: ARGON2_TIME_COST,\n    memoryCost: ARGON2_MEMORY_COST,\n    parallelism: ARGON2_PARALLELISM,\n};\n\nexport function bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nexport function base64ToBuffer(b64: string): Uint8Array {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n\nexport function hexToBytes(hex: string): Uint8Array {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n    }\n    return bytes;\n}\n\nexport function bytesToHex(bytes: Uint8Array): string {\n    return Array.from(bytes)\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n\nexport async function deriveKeyFromPassword(\n    password: string,\n    salt: Uint8Array,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<Uint8Array> {\n    const hash = await argon2id({\n        password,\n        salt: salt as unknown as Uint8Array,\n        iterations: params.timeCost,\n        memorySize: params.memoryCost,\n        parallelism: params.parallelism,\n        hashLength: ARGON2_HASH_LENGTH,\n        outputType: 'binary',\n    });\n    return new Uint8Array(hash as ArrayBuffer);\n}\n\nexport async function encryptWithPassword(\n    plaintext: string,\n    password: string\n): Promise<{ ciphertext: string; iv: string; salt: string; kdfParams: KdfParams }> {\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n\n    const keyMaterial = await deriveKeyFromPassword(password, salt);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['encrypt']\n    );\n\n    const encoder = new TextEncoder();\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv },\n        cryptoKey,\n        encoder.encode(plaintext)\n    );\n\n    return {\n        ciphertext: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n        salt: bufferToBase64(salt.buffer),\n        kdfParams: DEFAULT_KDF_PARAMS,\n    };\n}\n\nexport async function decryptWithPassword(\n    ciphertext: string,\n    iv: string,\n    salt: string,\n    password: string,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<string> {\n    const saltBytes = base64ToBuffer(salt);\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(ciphertext);\n\n    const keyMaterial = await deriveKeyFromPassword(password, saltBytes, params);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['decrypt']\n    );\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv: ivBytes },\n        cryptoKey,\n        ciphertextBytes\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function encryptShare(\n    share: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<{ encryptedData: string; iv: string }> {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n\n    const encryptParams: AesGcmParams = { name: 'AES-GCM', iv };\n    if (aad) {\n        encryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        encryptParams,\n        key,\n        encoder.encode(share) as ArrayBuffer\n    );\n\n    return {\n        encryptedData: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n    };\n}\n\nexport async function decryptShare(\n    encryptedData: string,\n    iv: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<string> {\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(encryptedData);\n    const encoder = new TextEncoder();\n\n    const decryptParams: AesGcmParams = { name: 'AES-GCM', iv: ivBytes.buffer as ArrayBuffer };\n    if (aad) {\n        decryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        decryptParams,\n        key,\n        ciphertextBytes.buffer as ArrayBuffer\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function generateAesKey(): Promise<CryptoKey> {\n    return crypto.subtle.generateKey(\n        { name: 'AES-GCM', length: 256 },\n        true,\n        ['encrypt', 'decrypt']\n    );\n}\n\nexport function generateRandomBytes(length: number): Uint8Array {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n\nexport async function generateEd25519PrivateKey(): Promise<string> {\n    const privateKeyBytes = generateRandomBytes(32);\n    return bytesToHex(privateKeyBytes);\n}\n", "/**\n * Device-side storage for SSS shares\n * Reuses patterns from webSecureStorage but specialized for SSS\n */\n\nconst DB_NAME = 'lcb-sss-keys';\nconst DB_VERSION = 1;\nconst KEYS_STORE = 'keys';\nconst SHARES_STORE = 'shares';\nconst DEFAULT_DEVICE_SHARE_ID = 'sss-device-share';\n\ntype EncryptedPayload = {\n    version: 1;\n    iv: string;\n    cipher: string;\n    keyVersion: number;\n};\n\nfunction openDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open(DB_NAME, DB_VERSION);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains(KEYS_STORE)) {\n                db.createObjectStore(KEYS_STORE);\n            }\n            if (!db.objectStoreNames.contains(SHARES_STORE)) {\n                db.createObjectStore(SHARES_STORE);\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nfunction tx<T = unknown>(\n    db: IDBDatabase,\n    store: string,\n    mode: IDBTransactionMode,\n    op: (store: IDBObjectStore) => IDBRequest<T>\n): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const t = db.transaction(store, mode);\n        const s = t.objectStore(store);\n        const request = op(s);\n        request.onsuccess = () => resolve(request.result as T);\n        request.onerror = () => reject(request.error);\n    });\n}\n\nasync function getOrCreateMasterKey(): Promise<CryptoKey> {\n    const db = await openDB();\n\n    try {\n        const existing = await tx<CryptoKey | undefined>(db, KEYS_STORE, 'readonly', s =>\n            s.get('master-key')\n        );\n\n        if (existing) {\n            return existing;\n        }\n\n        const key = await crypto.subtle.generateKey(\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt', 'decrypt']\n        );\n\n        await tx(db, KEYS_STORE, 'readwrite', s => s.put(key, 'master-key'));\n\n        return key;\n    } finally {\n        db.close();\n    }\n}\n\nfunction bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nfunction base64ToBuffer(b64: string): ArrayBuffer {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nasync function encryptShare(share: string, id: string): Promise<EncryptedPayload> {\n    const key = await getOrCreateMasterKey();\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const cipherBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        encoder.encode(share)\n    );\n\n    return {\n        version: 1,\n        iv: bufferToBase64(iv.buffer),\n        cipher: bufferToBase64(cipherBuffer),\n        keyVersion: 1,\n    };\n}\n\nasync function decryptShare(payload: EncryptedPayload, id: string): Promise<string> {\n    const key = await getOrCreateMasterKey();\n    const iv = new Uint8Array(base64ToBuffer(payload.iv));\n    const cipher = base64ToBuffer(payload.cipher);\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const plainBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        cipher\n    );\n\n    return new TextDecoder().decode(plainBuffer);\n}\n\nexport async function storeDeviceShare(share: string, id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        const payload = await encryptShare(share, id);\n        await tx(db, SHARES_STORE, 'readwrite', s => s.put(payload, id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function getDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<string | null> {\n    const db = await openDB();\n\n    try {\n        const payload = await tx<EncryptedPayload | undefined>(db, SHARES_STORE, 'readonly', s =>\n            s.get(id)\n        );\n\n        if (!payload) {\n            return null;\n        }\n\n        try {\n            return await decryptShare(payload, id);\n        } catch (e) {\n            console.warn('SSS Storage: decryption failed', e);\n            return null;\n        }\n    } finally {\n        db.close();\n    }\n}\n\nexport async function hasDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<boolean> {\n    const share = await getDeviceShare(id);\n    return share !== null;\n}\n\nexport async function deleteDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        await tx(db, SHARES_STORE, 'readwrite', s => s.delete(id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function clearAllShares(): Promise<void> {\n    await new Promise<void>((resolve, reject) => {\n        const req = indexedDB.deleteDatabase(DB_NAME);\n        req.onsuccess = () => resolve();\n        req.onerror = () => reject(req.error);\n        req.onblocked = () => resolve();\n    });\n}\n", "/**\n * SSS Key Manager - Main class\n */\n\nimport type {\n    SSSKeyManagerConfig,\n    SSSKeyDerivationProvider,\n    RecoveryMethod,\n    RecoveryMethodInfo,\n    SecurityLevel,\n    BackupFile,\n    AuthProvider,\n} from './types';\n\nimport { SSSApiClient } from './api-client';\nimport { splitPrivateKey, reconstructPrivateKey } from './sss';\nimport {\n    storeDeviceShare,\n    getDeviceShare,\n    hasDeviceShare,\n    deleteDeviceShare,\n    clearAllShares,\n} from './storage';\nimport {\n    encryptWithPassword,\n    decryptWithPassword,\n    generateEd25519PrivateKey,\n    DEFAULT_KDF_PARAMS,\n} from './crypto';\n\nexport class SSSKeyManager implements SSSKeyDerivationProvider {\n    readonly name = 'sss';\n\n    private config: SSSKeyManagerConfig;\n    private apiClient: SSSApiClient;\n    private initialized = false;\n    private currentPrivateKey: string | null = null;\n\n    constructor(config: SSSKeyManagerConfig) {\n        this.config = config;\n        this.apiClient = new SSSApiClient({\n            serverUrl: config.serverUrl,\n            authProvider: config.authProvider,\n        });\n    }\n\n    isInitialized(): boolean {\n        return this.initialized;\n    }\n\n    async hasLocalKey(): Promise<boolean> {\n        return hasDeviceShare(this.config.deviceStorageKey);\n    }\n\n    async connect(): Promise<string> {\n        const deviceShare = await getDeviceShare(this.config.deviceStorageKey);\n\n        if (!deviceShare) {\n            throw new Error('No device share found. User needs to set up SSS or recover.');\n        }\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        if (!serverResponse || !serverResponse.authShare) {\n            throw new Error('No auth share found on server. User may need to recover.');\n        }\n\n        if (serverResponse.keyProvider !== 'sss') {\n            throw new Error('User has not migrated to SSS yet.');\n        }\n\n        const privateKey = await reconstructPrivateKey(\n            deviceShare,\n            serverResponse.authShare.encryptedData\n        );\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n\n        return privateKey;\n    }\n\n    async disconnect(): Promise<void> {\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async setupNewKey(): Promise<string> {\n        const privateKey = await generateEd25519PrivateKey();\n        await this.setupWithKey(privateKey);\n        return privateKey;\n    }\n\n    async setupWithKey(privateKey: string, primaryDid?: string): Promise<void> {\n        const shares = await splitPrivateKey(privateKey);\n\n        await storeDeviceShare(shares.deviceShare, this.config.deviceStorageKey);\n\n        const did = primaryDid || `did:key:placeholder-${Date.now()}`;\n\n        await this.apiClient.storeAuthShare({\n            authShare: {\n                encryptedData: shares.authShare,\n                encryptedDek: '',\n                iv: '',\n            },\n            primaryDid: did,\n            securityLevel: 'basic',\n        });\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n    }\n\n    async migrate(privateKey: string): Promise<void> {\n        await this.setupWithKey(privateKey);\n        await this.apiClient.markMigrated();\n    }\n\n    async canMigrate(): Promise<boolean> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.keyProvider === 'web3auth';\n    }\n\n    async addRecoveryMethod(method: RecoveryMethod): Promise<void> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const recoveryShare = shares.recoveryShare;\n\n        if (method.type === 'password') {\n            const encrypted = await encryptWithPassword(recoveryShare, method.password);\n\n            await this.apiClient.addRecoveryMethod({\n                type: 'password',\n                encryptedShare: {\n                    encryptedData: encrypted.ciphertext,\n                    iv: encrypted.iv,\n                    salt: encrypted.salt,\n                },\n            });\n        } else if (method.type === 'passkey') {\n            throw new Error('Passkey recovery not yet implemented');\n        } else if (method.type === 'backup') {\n            throw new Error('Use exportBackup() instead');\n        }\n    }\n\n    async getRecoveryMethods(): Promise<RecoveryMethodInfo[]> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.recoveryMethods || [];\n    }\n\n    async recover(method: RecoveryMethod): Promise<string> {\n        if (method.type === 'password') {\n            const encryptedShare = await this.apiClient.getRecoveryShare('password');\n\n            if (!encryptedShare || !encryptedShare.salt) {\n                throw new Error('No password recovery share found');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                encryptedShare.encryptedData,\n                encryptedShare.iv,\n                encryptedShare.salt,\n                method.password,\n                DEFAULT_KDF_PARAMS\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'backup') {\n            const backup: BackupFile = JSON.parse(method.fileContents);\n\n            if (backup.version !== 1) {\n                throw new Error('Unsupported backup file version');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                backup.encryptedShare.ciphertext,\n                backup.encryptedShare.iv,\n                backup.encryptedShare.salt,\n                method.password,\n                backup.encryptedShare.kdfParams\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'passkey') {\n            throw new Error('Passkey recovery not yet implemented');\n        }\n\n        throw new Error('Unknown recovery method');\n    }\n\n    async getSecurityLevel(): Promise<SecurityLevel> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.securityLevel || 'basic';\n    }\n\n    async exportBackup(password: string): Promise<BackupFile> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const encrypted = await encryptWithPassword(shares.recoveryShare, password);\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        return {\n            version: 1,\n            createdAt: new Date().toISOString(),\n            primaryDid: serverResponse?.primaryDid || 'unknown',\n            encryptedShare: {\n                ciphertext: encrypted.ciphertext,\n                iv: encrypted.iv,\n                salt: encrypted.salt,\n                kdfParams: encrypted.kdfParams,\n            },\n        };\n    }\n\n    async clearLocalData(): Promise<void> {\n        await deleteDeviceShare(this.config.deviceStorageKey);\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async deleteAccount(): Promise<void> {\n        await this.apiClient.deleteUserKey();\n        await clearAllShares();\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n}\n\nexport function createSSSKeyManager(config: SSSKeyManagerConfig): SSSKeyManager {\n    return new SSSKeyManager(config);\n}\n"],
  "mappings": "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",
  "names": ["bufferToBase64", "base64ToBuffer"]
}
