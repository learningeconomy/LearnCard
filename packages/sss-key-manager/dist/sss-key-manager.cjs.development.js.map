{
  "version": 3,
  "sources": ["../src/index.ts", "../src/api-client.ts", "../src/sss.ts", "../src/crypto.ts", "../src/storage.ts", "../src/passkey.ts", "../src/recovery-phrase.ts", "../src/key-manager.ts"],
  "sourcesContent": ["/**\n * @learncard/sss-key-manager\n *\n * Shamir Secret Sharing key manager for LearnCard - replaces Web3Auth SFA\n */\n\nexport { SSSKeyManager, createSSSKeyManager } from './key-manager';\nexport { SSSApiClient } from './api-client';\n\nexport {\n    splitPrivateKey,\n    reconstructPrivateKey,\n    reconstructFromShares,\n    SSS_TOTAL_SHARES,\n    SSS_THRESHOLD,\n} from './sss';\n\nexport {\n    storeDeviceShare,\n    getDeviceShare,\n    hasDeviceShare,\n    deleteDeviceShare,\n    clearAllShares,\n} from './storage';\n\nexport {\n    encryptWithPassword,\n    decryptWithPassword,\n    deriveKeyFromPassword,\n    generateEd25519PrivateKey,\n    hexToBytes,\n    bytesToHex,\n    bufferToBase64,\n    base64ToBuffer,\n    DEFAULT_KDF_PARAMS,\n} from './crypto';\n\nexport {\n    createPasskeyCredential,\n    deriveKeyFromPasskey,\n    encryptShareWithPasskey,\n    decryptShareWithPasskey,\n    isWebAuthnSupported,\n    isPRFSupported,\n} from './passkey';\n\nexport type { PasskeyCredential, PasskeyEncryptedShare } from './passkey';\n\nexport {\n    shareToRecoveryPhrase,\n    recoveryPhraseToShare,\n    generateRecoveryPhrase,\n    validateRecoveryPhrase,\n    countWords,\n} from './recovery-phrase';\n\nexport type { RecoveryPhraseData } from './recovery-phrase';\n\nexport type {\n    SSSKeyManagerConfig,\n    SSSKeyDerivationProvider,\n    KeyDerivationProvider,\n    AuthProvider,\n    AuthUser,\n    AuthProviderType,\n    ContactMethod,\n    ContactMethodType,\n    RecoveryMethod,\n    RecoveryMethodType,\n    RecoveryMethodInfo,\n    PasswordRecoveryMethod,\n    PasskeyRecoveryMethod,\n    BackupFileRecoveryMethod,\n    RecoveryPhraseRecoveryMethod,\n    SecurityLevel,\n    BackupFile,\n    EncryptedShare,\n    ServerEncryptedShare,\n    UserKeyRecord,\n    AuthProviderMapping,\n} from './types';\n", "/**\n * API client for SSS Key Manager server routes\n */\n\nimport type {\n    AuthProvider,\n    AuthProviderType,\n    ContactMethod,\n    ServerEncryptedShare,\n    RecoveryMethodInfo,\n    EncryptedShare,\n    SecurityLevel,\n} from './types';\n\nexport interface GetAuthShareResponse {\n    authShare: ServerEncryptedShare | null;\n    primaryDid: string | null;\n    securityLevel: SecurityLevel;\n    recoveryMethods: RecoveryMethodInfo[];\n    keyProvider: 'web3auth' | 'sss';\n}\n\nexport interface StoreAuthShareInput {\n    authShare: ServerEncryptedShare;\n    primaryDid: string;\n    securityLevel?: SecurityLevel;\n}\n\nexport interface StoreRecoveryShareInput {\n    type: 'password' | 'passkey' | 'backup';\n    encryptedShare: EncryptedShare;\n    credentialId?: string;\n}\n\nexport interface ApiClientConfig {\n    serverUrl: string;\n    authProvider: AuthProvider;\n}\n\nexport class SSSApiClient {\n    private serverUrl: string;\n    private authProvider: AuthProvider;\n\n    constructor(config: ApiClientConfig) {\n        this.serverUrl = config.serverUrl.replace(/\\/$/, '');\n        this.authProvider = config.authProvider;\n    }\n\n    private async getAuthHeaders(): Promise<Record<string, string>> {\n        const token = await this.authProvider.getIdToken();\n        return {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${token}`,\n        };\n    }\n\n    private async getContactMethodFromUser(): Promise<ContactMethod | null> {\n        const user = await this.authProvider.getCurrentUser();\n        if (!user) return null;\n\n        if (user.email) {\n            return { type: 'email' as const, value: user.email.toLowerCase() };\n        }\n        if (user.phone) {\n            return { type: 'phone' as const, value: user.phone };\n        }\n        return null;\n    }\n\n    async getAuthShare(): Promise<GetAuthShareResponse | null> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get auth share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async storeAuthShare(input: StoreAuthShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/auth-share`, {\n            method: 'PUT',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to store auth share: ${response.statusText}`);\n        }\n    }\n\n    async addRecoveryMethod(input: StoreRecoveryShareInput): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({\n                ...input,\n                providerType,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to add recovery method: ${response.statusText}`);\n        }\n    }\n\n    async getRecoveryShare(\n        type: 'password' | 'passkey' | 'backup',\n        credentialId?: string\n    ): Promise<EncryptedShare | null> {\n        const token = await this.authProvider.getIdToken();\n        const providerType = this.authProvider.getProviderType();\n\n        const params = new URLSearchParams({\n            type,\n            providerType,\n            authToken: token,\n        });\n\n        if (credentialId) {\n            params.append('credentialId', credentialId);\n        }\n\n        const response = await fetch(`${this.serverUrl}/keys/recovery?${params}`, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        });\n\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n            throw new Error(`Failed to get recovery share: ${response.statusText}`);\n        }\n\n        return response.json();\n    }\n\n    async markMigrated(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys/migrate`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to mark as migrated: ${response.statusText}`);\n        }\n    }\n\n    async deleteUserKey(): Promise<void> {\n        const headers = await this.getAuthHeaders();\n        const providerType = this.authProvider.getProviderType();\n\n        const response = await fetch(`${this.serverUrl}/keys`, {\n            method: 'DELETE',\n            headers,\n            body: JSON.stringify({ providerType }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to delete user key: ${response.statusText}`);\n        }\n    }\n}\n", "/**\n * Shamir Secret Sharing operations\n */\n\nimport { split, combine } from 'shamir-secret-sharing';\nimport { hexToBytes, bytesToHex } from './crypto';\n\nexport const SSS_TOTAL_SHARES = 3;\nexport const SSS_THRESHOLD = 2;\n\nexport interface SSSShares {\n    deviceShare: string;\n    authShare: string;\n    recoveryShare: string;\n}\n\nexport async function splitPrivateKey(privateKeyHex: string): Promise<SSSShares> {\n    const privateKeyBytes = hexToBytes(privateKeyHex);\n\n    const shares = await split(privateKeyBytes, SSS_TOTAL_SHARES, SSS_THRESHOLD);\n\n    return {\n        deviceShare: bytesToHex(shares[0]),\n        authShare: bytesToHex(shares[1]),\n        recoveryShare: bytesToHex(shares[2]),\n    };\n}\n\nexport async function reconstructPrivateKey(share1Hex: string, share2Hex: string): Promise<string> {\n    const share1 = hexToBytes(share1Hex);\n    const share2 = hexToBytes(share2Hex);\n\n    const reconstructed = await combine([share1, share2]);\n\n    return bytesToHex(reconstructed);\n}\n\nexport async function reconstructFromShares(shares: string[]): Promise<string> {\n    if (shares.length < SSS_THRESHOLD) {\n        throw new Error(`Need at least ${SSS_THRESHOLD} shares to reconstruct key`);\n    }\n\n    const shareBytes = shares.slice(0, SSS_THRESHOLD).map(hexToBytes);\n    const reconstructed = await combine(shareBytes);\n\n    return bytesToHex(reconstructed);\n}\n", "/**\n * Cryptographic utilities for SSS Key Manager\n */\n\nimport { argon2id } from 'hash-wasm';\n\nconst ARGON2_TIME_COST = 3;\nconst ARGON2_MEMORY_COST = 65536;\nconst ARGON2_PARALLELISM = 4;\nconst ARGON2_HASH_LENGTH = 32;\n\nexport interface KdfParams {\n    algorithm: 'argon2id';\n    timeCost: number;\n    memoryCost: number;\n    parallelism: number;\n}\n\nexport const DEFAULT_KDF_PARAMS: KdfParams = {\n    algorithm: 'argon2id',\n    timeCost: ARGON2_TIME_COST,\n    memoryCost: ARGON2_MEMORY_COST,\n    parallelism: ARGON2_PARALLELISM,\n};\n\nexport function bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nexport function base64ToBuffer(b64: string): Uint8Array {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n\nexport function hexToBytes(hex: string): Uint8Array {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n    }\n    return bytes;\n}\n\nexport function bytesToHex(bytes: Uint8Array): string {\n    return Array.from(bytes)\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n\nexport async function deriveKeyFromPassword(\n    password: string,\n    salt: Uint8Array,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<Uint8Array> {\n    const hash = await argon2id({\n        password,\n        salt: salt as unknown as Uint8Array,\n        iterations: params.timeCost,\n        memorySize: params.memoryCost,\n        parallelism: params.parallelism,\n        hashLength: ARGON2_HASH_LENGTH,\n        outputType: 'binary',\n    });\n    return new Uint8Array(hash as ArrayBuffer);\n}\n\nexport async function encryptWithPassword(\n    plaintext: string,\n    password: string\n): Promise<{ ciphertext: string; iv: string; salt: string; kdfParams: KdfParams }> {\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n\n    const keyMaterial = await deriveKeyFromPassword(password, salt);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['encrypt']\n    );\n\n    const encoder = new TextEncoder();\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv },\n        cryptoKey,\n        encoder.encode(plaintext)\n    );\n\n    return {\n        ciphertext: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n        salt: bufferToBase64(salt.buffer),\n        kdfParams: DEFAULT_KDF_PARAMS,\n    };\n}\n\nexport async function decryptWithPassword(\n    ciphertext: string,\n    iv: string,\n    salt: string,\n    password: string,\n    params: KdfParams = DEFAULT_KDF_PARAMS\n): Promise<string> {\n    const saltBytes = base64ToBuffer(salt);\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(ciphertext);\n\n    const keyMaterial = await deriveKeyFromPassword(password, saltBytes, params);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyMaterial.buffer as ArrayBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['decrypt']\n    );\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv: ivBytes },\n        cryptoKey,\n        ciphertextBytes\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function encryptShare(\n    share: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<{ encryptedData: string; iv: string }> {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n\n    const encryptParams: AesGcmParams = { name: 'AES-GCM', iv };\n    if (aad) {\n        encryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n        encryptParams,\n        key,\n        encoder.encode(share) as ArrayBuffer\n    );\n\n    return {\n        encryptedData: bufferToBase64(ciphertextBuffer),\n        iv: bufferToBase64(iv.buffer),\n    };\n}\n\nexport async function decryptShare(\n    encryptedData: string,\n    iv: string,\n    key: CryptoKey,\n    aad?: string\n): Promise<string> {\n    const ivBytes = base64ToBuffer(iv);\n    const ciphertextBytes = base64ToBuffer(encryptedData);\n    const encoder = new TextEncoder();\n\n    const decryptParams: AesGcmParams = { name: 'AES-GCM', iv: ivBytes.buffer as ArrayBuffer };\n    if (aad) {\n        decryptParams.additionalData = encoder.encode(aad);\n    }\n\n    const plaintextBuffer = await crypto.subtle.decrypt(\n        decryptParams,\n        key,\n        ciphertextBytes.buffer as ArrayBuffer\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintextBuffer);\n}\n\nexport async function generateAesKey(): Promise<CryptoKey> {\n    return crypto.subtle.generateKey(\n        { name: 'AES-GCM', length: 256 },\n        true,\n        ['encrypt', 'decrypt']\n    );\n}\n\nexport function generateRandomBytes(length: number): Uint8Array {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n\nexport async function generateEd25519PrivateKey(): Promise<string> {\n    const privateKeyBytes = generateRandomBytes(32);\n    return bytesToHex(privateKeyBytes);\n}\n", "/**\n * Device-side storage for SSS shares\n * Reuses patterns from webSecureStorage but specialized for SSS\n */\n\nconst DB_NAME = 'lcb-sss-keys';\nconst DB_VERSION = 1;\nconst KEYS_STORE = 'keys';\nconst SHARES_STORE = 'shares';\nconst DEFAULT_DEVICE_SHARE_ID = 'sss-device-share';\n\ntype EncryptedPayload = {\n    version: 1;\n    iv: string;\n    cipher: string;\n    keyVersion: number;\n};\n\nfunction openDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open(DB_NAME, DB_VERSION);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains(KEYS_STORE)) {\n                db.createObjectStore(KEYS_STORE);\n            }\n            if (!db.objectStoreNames.contains(SHARES_STORE)) {\n                db.createObjectStore(SHARES_STORE);\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nfunction tx<T = unknown>(\n    db: IDBDatabase,\n    store: string,\n    mode: IDBTransactionMode,\n    op: (store: IDBObjectStore) => IDBRequest<T>\n): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const t = db.transaction(store, mode);\n        const s = t.objectStore(store);\n        const request = op(s);\n        request.onsuccess = () => resolve(request.result as T);\n        request.onerror = () => reject(request.error);\n    });\n}\n\nasync function getOrCreateMasterKey(): Promise<CryptoKey> {\n    const db = await openDB();\n\n    try {\n        const existing = await tx<CryptoKey | undefined>(db, KEYS_STORE, 'readonly', s =>\n            s.get('master-key')\n        );\n\n        if (existing) {\n            return existing;\n        }\n\n        const key = await crypto.subtle.generateKey(\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt', 'decrypt']\n        );\n\n        await tx(db, KEYS_STORE, 'readwrite', s => s.put(key, 'master-key'));\n\n        return key;\n    } finally {\n        db.close();\n    }\n}\n\nfunction bufferToBase64(buf: ArrayBuffer): string {\n    const bytes = new Uint8Array(buf);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nfunction base64ToBuffer(b64: string): ArrayBuffer {\n    const binary = atob(b64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nasync function encryptShare(share: string, id: string): Promise<EncryptedPayload> {\n    const key = await getOrCreateMasterKey();\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const cipherBuffer = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        encoder.encode(share)\n    );\n\n    return {\n        version: 1,\n        iv: bufferToBase64(iv.buffer),\n        cipher: bufferToBase64(cipherBuffer),\n        keyVersion: 1,\n    };\n}\n\nasync function decryptShare(payload: EncryptedPayload, id: string): Promise<string> {\n    const key = await getOrCreateMasterKey();\n    const iv = new Uint8Array(base64ToBuffer(payload.iv));\n    const cipher = base64ToBuffer(payload.cipher);\n    const encoder = new TextEncoder();\n    const ad = encoder.encode(id);\n\n    const plainBuffer = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv, additionalData: ad },\n        key,\n        cipher\n    );\n\n    return new TextDecoder().decode(plainBuffer);\n}\n\nexport async function storeDeviceShare(share: string, id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        const payload = await encryptShare(share, id);\n        await tx(db, SHARES_STORE, 'readwrite', s => s.put(payload, id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function getDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<string | null> {\n    const db = await openDB();\n\n    try {\n        const payload = await tx<EncryptedPayload | undefined>(db, SHARES_STORE, 'readonly', s =>\n            s.get(id)\n        );\n\n        if (!payload) {\n            return null;\n        }\n\n        try {\n            return await decryptShare(payload, id);\n        } catch (e) {\n            console.warn('SSS Storage: decryption failed', e);\n            return null;\n        }\n    } finally {\n        db.close();\n    }\n}\n\nexport async function hasDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<boolean> {\n    const share = await getDeviceShare(id);\n    return share !== null;\n}\n\nexport async function deleteDeviceShare(id: string = DEFAULT_DEVICE_SHARE_ID): Promise<void> {\n    const db = await openDB();\n\n    try {\n        await tx(db, SHARES_STORE, 'readwrite', s => s.delete(id));\n    } finally {\n        db.close();\n    }\n}\n\nexport async function clearAllShares(): Promise<void> {\n    await new Promise<void>((resolve, reject) => {\n        const req = indexedDB.deleteDatabase(DB_NAME);\n        req.onsuccess = () => resolve();\n        req.onerror = () => reject(req.error);\n        req.onblocked = () => resolve();\n    });\n}\n", "/**\n * WebAuthn Passkey utilities for SSS recovery\n * Uses the PRF (Pseudo-Random Function) extension to derive encryption keys\n */\n\nimport { bufferToBase64, base64ToBuffer, bytesToHex, hexToBytes } from './crypto';\n\nexport interface PasskeyCredential {\n    credentialId: string;\n    publicKey: string;\n    transports?: AuthenticatorTransport[];\n}\n\nexport interface PasskeyEncryptedShare {\n    encryptedData: string;\n    iv: string;\n    credentialId: string;\n}\n\nconst RP_NAME = 'LearnCard';\nconst RP_ID = typeof window !== 'undefined' ? window.location.hostname : 'localhost';\n\nconst PRF_SALT = new TextEncoder().encode('learncard-sss-recovery-v1');\n\nfunction isWebAuthnSupported(): boolean {\n    return typeof window !== 'undefined' &&\n        typeof window.PublicKeyCredential !== 'undefined' &&\n        typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === 'function';\n}\n\nasync function isPRFSupported(): Promise<boolean> {\n    if (!isWebAuthnSupported()) return false;\n\n    try {\n        const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n        return available;\n    } catch {\n        return false;\n    }\n}\n\nexport async function createPasskeyCredential(\n    userId: string,\n    userName: string\n): Promise<PasskeyCredential> {\n    if (!isWebAuthnSupported()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    const userIdBytes = new TextEncoder().encode(userId);\n\n    const createOptions: PublicKeyCredentialCreationOptions = {\n        challenge: crypto.getRandomValues(new Uint8Array(32)),\n        rp: {\n            name: RP_NAME,\n            id: RP_ID,\n        },\n        user: {\n            id: userIdBytes,\n            name: userName,\n            displayName: userName,\n        },\n        pubKeyCredParams: [\n            { alg: -7, type: 'public-key' },   // ES256\n            { alg: -257, type: 'public-key' }, // RS256\n        ],\n        authenticatorSelection: {\n            authenticatorAttachment: 'platform',\n            userVerification: 'required',\n            residentKey: 'required',\n        },\n        timeout: 60000,\n        attestation: 'none',\n        extensions: {\n            prf: {\n                eval: {\n                    first: PRF_SALT,\n                },\n            },\n        } as AuthenticationExtensionsClientInputs,\n    };\n\n    const credential = await navigator.credentials.create({\n        publicKey: createOptions,\n    }) as PublicKeyCredential;\n\n    if (!credential) {\n        throw new Error('Failed to create passkey credential');\n    }\n\n    const response = credential.response as AuthenticatorAttestationResponse;\n\n    const extensionResults = credential.getClientExtensionResults() as {\n        prf?: { enabled?: boolean; results?: { first?: ArrayBuffer } };\n    };\n\n    if (!extensionResults.prf?.enabled && !extensionResults.prf?.results?.first) {\n        console.warn('PRF extension may not be supported, passkey created but encryption key derivation may fail');\n    }\n\n    return {\n        credentialId: bufferToBase64(credential.rawId),\n        publicKey: bufferToBase64(response.getPublicKey() as ArrayBuffer),\n        transports: response.getTransports?.() as AuthenticatorTransport[],\n    };\n}\n\nexport async function deriveKeyFromPasskey(\n    credentialId: string\n): Promise<CryptoKey> {\n    if (!isWebAuthnSupported()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    const getOptions: PublicKeyCredentialRequestOptions = {\n        challenge: crypto.getRandomValues(new Uint8Array(32)),\n        rpId: RP_ID,\n        allowCredentials: [{\n            id: base64ToBuffer(credentialId),\n            type: 'public-key',\n        }],\n        userVerification: 'required',\n        timeout: 60000,\n        extensions: {\n            prf: {\n                eval: {\n                    first: PRF_SALT,\n                },\n            },\n        } as AuthenticationExtensionsClientInputs,\n    };\n\n    const assertion = await navigator.credentials.get({\n        publicKey: getOptions,\n    }) as PublicKeyCredential;\n\n    if (!assertion) {\n        throw new Error('Failed to get passkey assertion');\n    }\n\n    const extensionResults = assertion.getClientExtensionResults() as {\n        prf?: { results?: { first?: ArrayBuffer } };\n    };\n\n    if (!extensionResults.prf?.results?.first) {\n        throw new Error('PRF extension not available or failed. This passkey cannot be used for encryption.');\n    }\n\n    const prfOutput = new Uint8Array(extensionResults.prf.results.first);\n\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        prfOutput,\n        { name: 'AES-GCM' },\n        false,\n        ['encrypt', 'decrypt']\n    );\n\n    return cryptoKey;\n}\n\nexport async function encryptShareWithPasskey(\n    share: string,\n    credentialId: string\n): Promise<PasskeyEncryptedShare> {\n    const key = await deriveKeyFromPasskey(credentialId);\n\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n\n    const ciphertext = await crypto.subtle.encrypt(\n        { name: 'AES-GCM', iv },\n        key,\n        encoder.encode(share)\n    );\n\n    return {\n        encryptedData: bufferToBase64(ciphertext),\n        iv: bufferToBase64(iv.buffer),\n        credentialId,\n    };\n}\n\nexport async function decryptShareWithPasskey(\n    encryptedShare: PasskeyEncryptedShare\n): Promise<string> {\n    const key = await deriveKeyFromPasskey(encryptedShare.credentialId);\n\n    const iv = base64ToBuffer(encryptedShare.iv);\n    const ciphertext = base64ToBuffer(encryptedShare.encryptedData);\n\n    const plaintext = await crypto.subtle.decrypt(\n        { name: 'AES-GCM', iv: iv.buffer },\n        key,\n        ciphertext.buffer\n    );\n\n    const decoder = new TextDecoder();\n    return decoder.decode(plaintext);\n}\n\nexport async function listStoredPasskeys(): Promise<PasskeyCredential[]> {\n    if (!isWebAuthnSupported()) {\n        return [];\n    }\n\n    if (typeof PublicKeyCredential.isConditionalMediationAvailable !== 'function') {\n        return [];\n    }\n\n    const available = await PublicKeyCredential.isConditionalMediationAvailable();\n    if (!available) {\n        return [];\n    }\n\n    return [];\n}\n\nexport { isWebAuthnSupported, isPRFSupported };\n", "/**\n * BIP39 Recovery Phrase utilities for SSS recovery\n * The recovery phrase directly encodes a share (not encryption)\n */\n\nimport { bytesToHex, hexToBytes, bufferToBase64, base64ToBuffer } from './crypto';\n\nexport interface RecoveryPhraseData {\n    phrase: string;\n    shareHex: string;\n}\n\nconst WORDLIST_MODULE = '@scure/bip39/wordlists/english';\n\nlet wordlistPromise: Promise<string[]> | null = null;\n\nasync function getWordlist(): Promise<string[]> {\n    if (!wordlistPromise) {\n        wordlistPromise = import('@scure/bip39/wordlists/english').then(m => m.wordlist);\n    }\n    return wordlistPromise;\n}\n\nfunction bytesToBits(bytes: Uint8Array): string {\n    return Array.from(bytes)\n        .map(b => b.toString(2).padStart(8, '0'))\n        .join('');\n}\n\nfunction bitsToBytes(bits: string): Uint8Array {\n    const bytes = new Uint8Array(Math.ceil(bits.length / 8));\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = parseInt(bits.slice(i * 8, (i + 1) * 8).padEnd(8, '0'), 2);\n    }\n    return bytes;\n}\n\nasync function computeChecksum(data: Uint8Array): Promise<string> {\n    const hash = await crypto.subtle.digest('SHA-256', data);\n    const hashBits = bytesToBits(new Uint8Array(hash));\n    const checksumLength = Math.floor(data.length / 4);\n    return hashBits.slice(0, checksumLength);\n}\n\nexport async function shareToRecoveryPhrase(shareHex: string): Promise<string> {\n    const wordlist = await getWordlist();\n    const shareBytes = hexToBytes(shareHex);\n\n    const checksum = await computeChecksum(shareBytes);\n    const allBits = bytesToBits(shareBytes) + checksum;\n\n    const words: string[] = [];\n    for (let i = 0; i < allBits.length; i += 11) {\n        const index = parseInt(allBits.slice(i, i + 11).padEnd(11, '0'), 2);\n        words.push(wordlist[index]);\n    }\n\n    return words.join(' ');\n}\n\nexport async function recoveryPhraseToShare(phrase: string): Promise<string> {\n    const wordlist = await getWordlist();\n    const words = phrase.trim().toLowerCase().split(/\\s+/);\n\n    // SSS shares include an index byte, so they produce 25 words instead of standard BIP39 24\n    if (words.length < 12 || words.length > 27) {\n        throw new Error('Recovery phrase must be 12-27 words');\n    }\n\n    let bits = '';\n    for (const word of words) {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(`Invalid word in recovery phrase: ${word}`);\n        }\n        bits += index.toString(2).padStart(11, '0');\n    }\n\n    // Calculate the correct data byte count\n    // The encoding formula: totalBits = dataBytes * 8 + floor(dataBytes / 4)\n    // We need to find the LARGEST dataBytes such that ceil(totalBits / 11) == words.length\n    // Multiple byte counts can produce the same word count, so we want the largest (most likely)\n    let dataByteCount = 0;\n    for (let bytes = 1; bytes <= 64; bytes++) {\n        const checksumBits = Math.floor(bytes / 4);\n        const totalBits = bytes * 8 + checksumBits;\n        const wordsNeeded = Math.ceil(totalBits / 11);\n        if (wordsNeeded === words.length) {\n            dataByteCount = bytes; // Keep updating to get the largest match\n        } else if (wordsNeeded > words.length) {\n            break; // Gone past, stop\n        }\n    }\n\n    if (dataByteCount === 0) {\n        throw new Error('Could not determine data size from word count');\n    }\n\n    const checksumLength = Math.floor(dataByteCount / 4);\n    const dataBitCount = dataByteCount * 8;\n    \n    const dataBits = bits.slice(0, dataBitCount);\n    const checksumBits = bits.slice(dataBitCount, dataBitCount + checksumLength);\n\n    const dataBytes = bitsToBytes(dataBits);\n\n    const expectedChecksum = await computeChecksum(dataBytes);\n    if (checksumBits !== expectedChecksum.slice(0, checksumLength)) {\n        throw new Error('Invalid recovery phrase checksum');\n    }\n\n    return bytesToHex(dataBytes);\n}\n\nexport async function generateRecoveryPhrase(shareHex: string): Promise<RecoveryPhraseData> {\n    const phrase = await shareToRecoveryPhrase(shareHex);\n    return { phrase, shareHex };\n}\n\nexport async function validateRecoveryPhrase(phrase: string): Promise<boolean> {\n    try {\n        await recoveryPhraseToShare(phrase);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function countWords(phrase: string): number {\n    return phrase.trim().split(/\\s+/).filter(w => w.length > 0).length;\n}\n", "/**\n * SSS Key Manager - Main class\n */\n\nimport type {\n    SSSKeyManagerConfig,\n    SSSKeyDerivationProvider,\n    RecoveryMethod,\n    RecoveryMethodInfo,\n    SecurityLevel,\n    BackupFile,\n    AuthProvider,\n    RecoveryPhraseRecoveryMethod,\n} from './types';\n\nimport { SSSApiClient } from './api-client';\nimport { splitPrivateKey, reconstructPrivateKey } from './sss';\nimport {\n    storeDeviceShare,\n    getDeviceShare,\n    hasDeviceShare,\n    deleteDeviceShare,\n    clearAllShares,\n} from './storage';\nimport {\n    encryptWithPassword,\n    decryptWithPassword,\n    generateEd25519PrivateKey,\n    DEFAULT_KDF_PARAMS,\n} from './crypto';\n\nimport {\n    createPasskeyCredential,\n    encryptShareWithPasskey,\n    decryptShareWithPasskey,\n} from './passkey';\n\nimport {\n    shareToRecoveryPhrase,\n    recoveryPhraseToShare,\n} from './recovery-phrase';\n\nexport class SSSKeyManager implements SSSKeyDerivationProvider {\n    readonly name = 'sss';\n\n    private config: SSSKeyManagerConfig;\n    private apiClient: SSSApiClient;\n    private initialized = false;\n    private currentPrivateKey: string | null = null;\n\n    constructor(config: SSSKeyManagerConfig) {\n        this.config = config;\n        this.apiClient = new SSSApiClient({\n            serverUrl: config.serverUrl,\n            authProvider: config.authProvider,\n        });\n    }\n\n    isInitialized(): boolean {\n        return this.initialized;\n    }\n\n    async hasLocalKey(): Promise<boolean> {\n        return hasDeviceShare(this.config.deviceStorageKey);\n    }\n\n    async connect(): Promise<string> {\n        const deviceShare = await getDeviceShare(this.config.deviceStorageKey);\n\n        if (!deviceShare) {\n            throw new Error('No device share found. User needs to set up SSS or recover.');\n        }\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        if (!serverResponse || !serverResponse.authShare) {\n            throw new Error('No auth share found on server. User may need to recover.');\n        }\n\n        if (serverResponse.keyProvider !== 'sss') {\n            throw new Error('User has not migrated to SSS yet.');\n        }\n\n        const privateKey = await reconstructPrivateKey(\n            deviceShare,\n            serverResponse.authShare.encryptedData\n        );\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n\n        return privateKey;\n    }\n\n    async disconnect(): Promise<void> {\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async setupNewKey(): Promise<string> {\n        const privateKey = await generateEd25519PrivateKey();\n        await this.setupWithKey(privateKey);\n        return privateKey;\n    }\n\n    async setupWithKey(privateKey: string, primaryDid?: string): Promise<void> {\n        const shares = await splitPrivateKey(privateKey);\n\n        await storeDeviceShare(shares.deviceShare, this.config.deviceStorageKey);\n\n        const did = primaryDid || `did:key:placeholder-${Date.now()}`;\n\n        await this.apiClient.storeAuthShare({\n            authShare: {\n                encryptedData: shares.authShare,\n                encryptedDek: '',\n                iv: '',\n            },\n            primaryDid: did,\n            securityLevel: 'basic',\n        });\n\n        this.currentPrivateKey = privateKey;\n        this.initialized = true;\n    }\n\n    async migrate(privateKey: string): Promise<void> {\n        await this.setupWithKey(privateKey);\n        await this.apiClient.markMigrated();\n    }\n\n    async canMigrate(): Promise<boolean> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.keyProvider === 'web3auth';\n    }\n\n    async addRecoveryMethod(method: RecoveryMethod): Promise<void> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const recoveryShare = shares.recoveryShare;\n\n        if (method.type === 'password') {\n            const encrypted = await encryptWithPassword(recoveryShare, method.password);\n\n            await this.apiClient.addRecoveryMethod({\n                type: 'password',\n                encryptedShare: {\n                    encryptedData: encrypted.ciphertext,\n                    iv: encrypted.iv,\n                    salt: encrypted.salt,\n                },\n            });\n        } else if (method.type === 'passkey') {\n            const user = await this.config.authProvider.getCurrentUser();\n            if (!user) {\n                throw new Error('No authenticated user');\n            }\n\n            const credential = await createPasskeyCredential(\n                user.id,\n                user.email || user.phone || user.id\n            );\n\n            const encryptedShare = await encryptShareWithPasskey(\n                recoveryShare,\n                credential.credentialId\n            );\n\n            await this.apiClient.addRecoveryMethod({\n                type: 'passkey',\n                encryptedShare: {\n                    encryptedData: encryptedShare.encryptedData,\n                    iv: encryptedShare.iv,\n                },\n                credentialId: credential.credentialId,\n            });\n        } else if (method.type === 'backup') {\n            throw new Error('Use exportBackup() instead');\n        }\n    }\n\n    async generateRecoveryPhrase(): Promise<string> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const phrase = await shareToRecoveryPhrase(shares.recoveryShare);\n\n        return phrase;\n    }\n\n    async getRecoveryMethods(): Promise<RecoveryMethodInfo[]> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.recoveryMethods || [];\n    }\n\n    async recover(method: RecoveryMethod): Promise<string> {\n        if (method.type === 'password') {\n            const encryptedShare = await this.apiClient.getRecoveryShare('password');\n\n            if (!encryptedShare || !encryptedShare.salt) {\n                throw new Error('No password recovery share found');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                encryptedShare.encryptedData,\n                encryptedShare.iv,\n                encryptedShare.salt,\n                method.password,\n                DEFAULT_KDF_PARAMS\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'backup') {\n            const backup: BackupFile = JSON.parse(method.fileContents);\n\n            if (backup.version !== 1) {\n                throw new Error('Unsupported backup file version');\n            }\n\n            const recoveryShare = await decryptWithPassword(\n                backup.encryptedShare.ciphertext,\n                backup.encryptedShare.iv,\n                backup.encryptedShare.salt,\n                method.password,\n                backup.encryptedShare.kdfParams\n            );\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'passkey') {\n            const encryptedShare = await this.apiClient.getRecoveryShare('passkey', method.credentialId);\n\n            if (!encryptedShare) {\n                throw new Error('No passkey recovery share found');\n            }\n\n            const recoveryShare = await decryptShareWithPasskey({\n                encryptedData: encryptedShare.encryptedData,\n                iv: encryptedShare.iv,\n                credentialId: method.credentialId || '',\n            });\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        } else if (method.type === 'phrase') {\n            const recoveryShare = await recoveryPhraseToShare(method.phrase);\n\n            const serverResponse = await this.apiClient.getAuthShare();\n\n            if (!serverResponse || !serverResponse.authShare) {\n                throw new Error('No auth share found on server');\n            }\n\n            const privateKey = await reconstructPrivateKey(\n                recoveryShare,\n                serverResponse.authShare.encryptedData\n            );\n\n            const newShares = await splitPrivateKey(privateKey);\n            await storeDeviceShare(newShares.deviceShare, this.config.deviceStorageKey);\n\n            this.currentPrivateKey = privateKey;\n            this.initialized = true;\n\n            return privateKey;\n        }\n\n        throw new Error('Unknown recovery method');\n    }\n\n    async getSecurityLevel(): Promise<SecurityLevel> {\n        const serverResponse = await this.apiClient.getAuthShare();\n        return serverResponse?.securityLevel || 'basic';\n    }\n\n    async exportBackup(password: string): Promise<BackupFile> {\n        if (!this.currentPrivateKey) {\n            throw new Error('No active key. Connect first.');\n        }\n\n        const shares = await splitPrivateKey(this.currentPrivateKey);\n        const encrypted = await encryptWithPassword(shares.recoveryShare, password);\n\n        const serverResponse = await this.apiClient.getAuthShare();\n\n        return {\n            version: 1,\n            createdAt: new Date().toISOString(),\n            primaryDid: serverResponse?.primaryDid || 'unknown',\n            encryptedShare: {\n                ciphertext: encrypted.ciphertext,\n                iv: encrypted.iv,\n                salt: encrypted.salt,\n                kdfParams: encrypted.kdfParams,\n            },\n        };\n    }\n\n    async clearLocalData(): Promise<void> {\n        await deleteDeviceShare(this.config.deviceStorageKey);\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n\n    async deleteAccount(): Promise<void> {\n        await this.apiClient.deleteUserKey();\n        await clearAllShares();\n        this.currentPrivateKey = null;\n        this.initialized = false;\n    }\n}\n\nexport function createSSSKeyManager(config: SSSKeyManagerConfig): SSSKeyManager {\n    return new SSSKeyManager(config);\n}\n"],
  "mappings": "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",
  "names": ["bufferToBase64", "base64ToBuffer", "checksumBits"]
}
