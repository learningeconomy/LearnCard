'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var global$1 =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  (typeof global$1 !== 'undefined' && global$1);

var support = {
  searchParams: 'URLSearchParams' in global$1,
  iterable: 'Symbol' in global$1 && 'iterator' in Symbol,
  blob:
    'FileReader' in global$1 &&
    'Blob' in global$1 &&
    (function() {
      try {
        new Blob();
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in global$1,
  arrayBuffer: 'ArrayBuffer' in global$1
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ];

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value
}


function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value}
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    };
  }

  return iterator
}

function Headers$1(headers) {
  this.map = {};

  if (headers instanceof Headers$1) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers$1.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers$1.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)];
};

Headers$1.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null
};

Headers$1.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
};

Headers$1.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers$1.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers$1.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items)
};

Headers$1.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items)
};

Headers$1.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items)
};

if (support.iterable) {
  Headers$1.prototype[Symbol.iterator] = Headers$1.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function(body) {
        this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    };

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);
        if (isConsumed) {
          return isConsumed
        }
        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          )
        } else {
          return Promise.resolve(this._bodyArrayBuffer)
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    };
  }

  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  };

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode$1)
    };
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  };

  return this
}


var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request$1(input, options) {
  if (!(this instanceof Request$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {};
  var body = options.body;

  if (input instanceof Request$1) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers$1(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers$1(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body);

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
      } else {
        
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
      }
    }
  }
}

Request$1.prototype.clone = function() {
  return new Request$1(this, {body: this._bodyInit})
};

function decode$1(body) {
  var form = new FormData();
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers$1();
  
  
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  
  
  
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
  return headers
}

Body.call(Request$1.prototype);

function Response$1(bodyInit, options) {
  if (!(this instanceof Response$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
  this.headers = new Headers$1(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}

Body.call(Response$1.prototype);

Response$1.prototype.clone = function() {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers$1(this.headers),
    url: this.url
  })
};

Response$1.error = function() {
  var response = new Response$1(null, {status: 0, statusText: ''});
  response.type = 'error';
  return response
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response$1.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response$1(null, {status: status, headers: {location: url}})
};

var DOMException = global$1.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch$1(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request$1(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response$1(body, options));
      }, 0);
    };

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'));
      }, 0);
    };

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'));
      }, 0);
    };

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'));
      }, 0);
    };

    function fixUrl(url) {
      try {
        return url === '' && global$1.location.href ? global$1.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob';
      } else if (
        support.arrayBuffer &&
        request.headers.get('Content-Type') &&
        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
      ) {
        xhr.responseType = 'arraybuffer';
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers$1)) {
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function() {
        
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  })
}

fetch$1.polyfill = true;

if (!global$1.fetch) {
  global$1.fetch = fetch$1;
  global$1.Headers = Headers$1;
  global$1.Request = Request$1;
  global$1.Response = Response$1;
}






self.fetch.bind(self);

(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        
        define([], function () {
            return factory(global);
        });
    } else if (typeof module === 'object' && module.exports) {
        
        module.exports = factory(global);
    } else {
        factory(global);
    }
}(typeof self !== 'undefined' ? self : undefined, function (global) {

    if ( typeof Promise !== 'function' )
        throw "Promise support required";

    var _crypto = global.crypto || global.msCrypto;
    if ( !_crypto ) return;

    var _subtle = _crypto.subtle || _crypto.webkitSubtle;
    if ( !_subtle ) return;

    var _Crypto     = global.Crypto || _crypto.constructor || Object,
        _SubtleCrypto = global.SubtleCrypto || _subtle.constructor || Object;
        global.CryptoKey || global.Key || Object;

    var isEdge = global.navigator && global.navigator.userAgent.indexOf('Edge/') > -1;
    var isIE    = !!global.msCrypto && !isEdge;
    var isWebkit = !_crypto.subtle && !!_crypto.webkitSubtle;
    if ( !isIE && !isWebkit ) return;

    function s2a ( s ) {
        return btoa(s).replace(/\=+$/, '').replace(/\+/g, '-').replace(/\//g, '_');
    }

    function a2s ( s ) {
        s += '===', s = s.slice( 0, -s.length % 4 );
        return atob( s.replace(/-/g, '+').replace(/_/g, '/') );
    }

    function s2b ( s ) {
        var b = new Uint8Array(s.length);
        for ( var i = 0; i < s.length; i++ ) b[i] = s.charCodeAt(i);
        return b;
    }

    function b2s ( b ) {
        if ( b instanceof ArrayBuffer ) b = new Uint8Array(b);
        return String.fromCharCode.apply( String, b );
    }

    function alg ( a ) {
        var r = { 'name': (a.name || a || '').toUpperCase().replace('V','v') };
        switch ( r.name ) {
            case 'SHA-1':
            case 'SHA-256':
            case 'SHA-384':
            case 'SHA-512':
                break;
            case 'AES-CBC':
            case 'AES-GCM':
            case 'AES-KW':
                if ( a.length ) r['length'] = a.length;
                break;
            case 'HMAC':
                if ( a.hash ) r['hash'] = alg(a.hash);
                if ( a.length ) r['length'] = a.length;
                break;
            case 'RSAES-PKCS1-v1_5':
                if ( a.publicExponent ) r['publicExponent'] = new Uint8Array(a.publicExponent);
                if ( a.modulusLength ) r['modulusLength'] = a.modulusLength;
                break;
            case 'RSASSA-PKCS1-v1_5':
            case 'RSA-OAEP':
                if ( a.hash ) r['hash'] = alg(a.hash);
                if ( a.publicExponent ) r['publicExponent'] = new Uint8Array(a.publicExponent);
                if ( a.modulusLength ) r['modulusLength'] = a.modulusLength;
                break;
            default:
                throw new SyntaxError("Bad algorithm name");
        }
        return r;
    }
    function jwkAlg ( a ) {
        return {
            'HMAC': {
                'SHA-1': 'HS1',
                'SHA-256': 'HS256',
                'SHA-384': 'HS384',
                'SHA-512': 'HS512',
            },
            'RSASSA-PKCS1-v1_5': {
                'SHA-1': 'RS1',
                'SHA-256': 'RS256',
                'SHA-384': 'RS384',
                'SHA-512': 'RS512',
            },
            'RSAES-PKCS1-v1_5': {
                '': 'RSA1_5',
            },
            'RSA-OAEP': {
                'SHA-1': 'RSA-OAEP',
                'SHA-256': 'RSA-OAEP-256',
            },
            'AES-KW': {
                '128': 'A128KW',
                '192': 'A192KW',
                '256': 'A256KW',
            },
            'AES-GCM': {
                '128': 'A128GCM',
                '192': 'A192GCM',
                '256': 'A256GCM',
            },
            'AES-CBC': {
                '128': 'A128CBC',
                '192': 'A192CBC',
                '256': 'A256CBC',
            },
        }[a.name][ ( a.hash || {} ).name || a.length || '' ];
    }

    function b2jwk ( k ) {
        if ( k instanceof ArrayBuffer || k instanceof Uint8Array ) k = JSON.parse( decodeURIComponent( escape( b2s(k) ) ) );
        var jwk = { 'kty': k.kty, 'alg': k.alg, 'ext': k.ext || k.extractable };
        switch ( jwk.kty ) {
            case 'oct':
                jwk.k = k.k;
            case 'RSA':
                [ 'n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi', 'oth' ].forEach( function ( x ) { if ( x in k ) jwk[x] = k[x]; } );
                break;
            default:
                throw new TypeError("Unsupported key type");
        }
        return jwk;
    }

    function jwk2b ( k ) {
        var jwk = b2jwk(k);
        if ( isIE ) jwk['extractable'] = jwk.ext, delete jwk.ext;
        return s2b( unescape( encodeURIComponent( JSON.stringify(jwk) ) ) ).buffer;
    }

    function pkcs2jwk ( k ) {
        var info = b2der(k), prv = false;
        if ( info.length > 2 ) prv = true, info.shift(); 
        var jwk = { 'ext': true };
        switch ( info[0][0] ) {
            case '1.2.840.113549.1.1.1':
                var rsaComp = [ 'n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi' ],
                    rsaKey  = b2der( info[1] );
                if ( prv ) rsaKey.shift(); 
                for ( var i = 0; i < rsaKey.length; i++ ) {
                    if ( !rsaKey[i][0] ) rsaKey[i] = rsaKey[i].subarray(1);
                    jwk[ rsaComp[i] ] = s2a( b2s( rsaKey[i] ) );
                }
                jwk['kty'] = 'RSA';
                break;
            default:
                throw new TypeError("Unsupported key type");
        }
        return jwk;
    }

    function jwk2pkcs ( k ) {
        var key, info = [ [ '', null ] ], prv = false;
        switch ( k.kty ) {
            case 'RSA':
                var rsaComp = [ 'n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi' ],
                    rsaKey = [];
                for ( var i = 0; i < rsaComp.length; i++ ) {
                    if ( !( rsaComp[i] in k ) ) break;
                    var b = rsaKey[i] = s2b( a2s( k[ rsaComp[i] ] ) );
                    if ( b[0] & 0x80 ) rsaKey[i] = new Uint8Array(b.length + 1), rsaKey[i].set( b, 1 );
                }
                if ( rsaKey.length > 2 ) prv = true, rsaKey.unshift( new Uint8Array([0]) ); 
                info[0][0] = '1.2.840.113549.1.1.1';
                key = rsaKey;
                break;
            default:
                throw new TypeError("Unsupported key type");
        }
        info.push( new Uint8Array( der2b(key) ).buffer );
        if ( !prv ) info[1] = { 'tag': 0x03, 'value': info[1] };
        else info.unshift( new Uint8Array([0]) ); 
        return new Uint8Array( der2b(info) ).buffer;
    }

    var oid2str = { 'KoZIhvcNAQEB': '1.2.840.113549.1.1.1' },
        str2oid = { '1.2.840.113549.1.1.1': 'KoZIhvcNAQEB' };

    function b2der ( buf, ctx ) {
        if ( buf instanceof ArrayBuffer ) buf = new Uint8Array(buf);
        if ( !ctx ) ctx = { pos: 0, end: buf.length };

        if ( ctx.end - ctx.pos < 2 || ctx.end > buf.length ) throw new RangeError("Malformed DER");

        var tag = buf[ctx.pos++],
            len = buf[ctx.pos++];

        if ( len >= 0x80 ) {
            len &= 0x7f;
            if ( ctx.end - ctx.pos < len ) throw new RangeError("Malformed DER");
            for ( var xlen = 0; len--; ) xlen <<= 8, xlen |= buf[ctx.pos++];
            len = xlen;
        }

        if ( ctx.end - ctx.pos < len ) throw new RangeError("Malformed DER");

        var rv;

        switch ( tag ) {
            case 0x02: 
                rv = buf.subarray( ctx.pos, ctx.pos += len );
                break;
            case 0x03: 
                if ( buf[ctx.pos++] ) throw new Error( "Unsupported bit string" );
                len--;
            case 0x04: 
                rv = new Uint8Array( buf.subarray( ctx.pos, ctx.pos += len ) ).buffer;
                break;
            case 0x05: 
                rv = null;
                break;
            case 0x06: 
                var oid = btoa( b2s( buf.subarray( ctx.pos, ctx.pos += len ) ) );
                if ( !( oid in oid2str ) ) throw new Error( "Unsupported OBJECT ID " + oid );
                rv = oid2str[oid];
                break;
            case 0x30: 
                rv = [];
                for ( var end = ctx.pos + len; ctx.pos < end; ) rv.push( b2der( buf, ctx ) );
                break;
            default:
                throw new Error( "Unsupported DER tag 0x" + tag.toString(16) );
        }

        return rv;
    }

    function der2b ( val, buf ) {
        if ( !buf ) buf = [];

        var tag = 0, len = 0,
            pos = buf.length + 2;

        buf.push( 0, 0 ); 

        if ( val instanceof Uint8Array ) {  
            tag = 0x02, len = val.length;
            for ( var i = 0; i < len; i++ ) buf.push( val[i] );
        }
        else if ( val instanceof ArrayBuffer ) { 
            tag = 0x04, len = val.byteLength, val = new Uint8Array(val);
            for ( var i = 0; i < len; i++ ) buf.push( val[i] );
        }
        else if ( val === null ) { 
            tag = 0x05, len = 0;
        }
        else if ( typeof val === 'string' && val in str2oid ) { 
            var oid = s2b( atob( str2oid[val] ) );
            tag = 0x06, len = oid.length;
            for ( var i = 0; i < len; i++ ) buf.push( oid[i] );
        }
        else if ( val instanceof Array ) { 
            for ( var i = 0; i < val.length; i++ ) der2b( val[i], buf );
            tag = 0x30, len = buf.length - pos;
        }
        else if ( typeof val === 'object' && val.tag === 0x03 && val.value instanceof ArrayBuffer ) { 
            val = new Uint8Array(val.value), tag = 0x03, len = val.byteLength;
            buf.push(0); for ( var i = 0; i < len; i++ ) buf.push( val[i] );
            len++;
        }
        else {
            throw new Error( "Unsupported DER value " + val );
        }

        if ( len >= 0x80 ) {
            var xlen = len, len = 4;
            buf.splice( pos, 0, (xlen >> 24) & 0xff, (xlen >> 16) & 0xff, (xlen >> 8) & 0xff, xlen & 0xff );
            while ( len > 1 && !(xlen >> 24) ) xlen <<= 8, len--;
            if ( len < 4 ) buf.splice( pos, 4 - len );
            len |= 0x80;
        }

        buf.splice( pos - 2, 2, tag, len );

        return buf;
    }

    function CryptoKey ( key, alg, ext, use ) {
        Object.defineProperties( this, {
            _key: {
                value: key
            },
            type: {
                value: key.type,
                enumerable: true,
            },
            extractable: {
                value: (ext === undefined) ? key.extractable : ext,
                enumerable: true,
            },
            algorithm: {
                value: (alg === undefined) ? key.algorithm : alg,
                enumerable: true,
            },
            usages: {
                value: (use === undefined) ? key.usages : use,
                enumerable: true,
            },
        });
    }

    function isPubKeyUse ( u ) {
        return u === 'verify' || u === 'encrypt' || u === 'wrapKey';
    }

    function isPrvKeyUse ( u ) {
        return u === 'sign' || u === 'decrypt' || u === 'unwrapKey';
    }

    [ 'generateKey', 'importKey', 'unwrapKey' ]
        .forEach( function ( m ) {
            var _fn = _subtle[m];

            _subtle[m] = function ( a, b, c ) {
                var args = [].slice.call(arguments),
                    ka, kx, ku;

                switch ( m ) {
                    case 'generateKey':
                        ka = alg(a), kx = b, ku = c;
                        break;
                    case 'importKey':
                        ka = alg(c), kx = args[3], ku = args[4];
                        if ( a === 'jwk' ) {
                            b = b2jwk(b);
                            if ( !b.alg ) b.alg = jwkAlg(ka);
                            if ( !b.key_ops ) b.key_ops = ( b.kty !== 'oct' ) ? ( 'd' in b ) ? ku.filter(isPrvKeyUse) : ku.filter(isPubKeyUse) : ku.slice();
                            args[1] = jwk2b(b);
                        }
                        break;
                    case 'unwrapKey':
                        ka = args[4], kx = args[5], ku = args[6];
                        args[2] = c._key;
                        break;
                }

                if ( m === 'generateKey' && ka.name === 'HMAC' && ka.hash ) {
                    ka.length = ka.length || { 'SHA-1': 512, 'SHA-256': 512, 'SHA-384': 1024, 'SHA-512': 1024 }[ka.hash.name];
                    return _subtle.importKey( 'raw', _crypto.getRandomValues( new Uint8Array( (ka.length+7)>>3 ) ), ka, kx, ku );
                }

                if ( isWebkit && m === 'generateKey' && ka.name === 'RSASSA-PKCS1-v1_5' && ( !ka.modulusLength || ka.modulusLength >= 2048 ) ) {
                    a = alg(a), a.name = 'RSAES-PKCS1-v1_5', delete a.hash;
                    return _subtle.generateKey( a, true, [ 'encrypt', 'decrypt' ] )
                        .then( function ( k ) {
                            return Promise.all([
                                _subtle.exportKey( 'jwk', k.publicKey ),
                                _subtle.exportKey( 'jwk', k.privateKey ),
                            ]);
                        })
                        .then( function ( keys ) {
                            keys[0].alg = keys[1].alg = jwkAlg(ka);
                            keys[0].key_ops = ku.filter(isPubKeyUse), keys[1].key_ops = ku.filter(isPrvKeyUse);
                            return Promise.all([
                                _subtle.importKey( 'jwk', keys[0], ka, true, keys[0].key_ops ),
                                _subtle.importKey( 'jwk', keys[1], ka, kx, keys[1].key_ops ),
                            ]);
                        })
                        .then( function ( keys ) {
                            return {
                                publicKey: keys[0],
                                privateKey: keys[1],
                            };
                        });
                }

                if ( ( isWebkit || ( isIE && ( ka.hash || {} ).name === 'SHA-1' ) )
                        && m === 'importKey' && a === 'jwk' && ka.name === 'HMAC' && b.kty === 'oct' ) {
                    return _subtle.importKey( 'raw', s2b( a2s(b.k) ), c, args[3], args[4] );
                }

                if ( isWebkit && m === 'importKey' && ( a === 'spki' || a === 'pkcs8' ) ) {
                    return _subtle.importKey( 'jwk', pkcs2jwk(b), c, args[3], args[4] );
                }

                if ( isIE && m === 'unwrapKey' ) {
                    return _subtle.decrypt( args[3], c, b )
                        .then( function ( k ) {
                            return _subtle.importKey( a, k, args[4], args[5], args[6] );
                        });
                }

                var op;
                try {
                    op = _fn.apply( _subtle, args );
                }
                catch ( e ) {
                    return Promise.reject(e);
                }

                if ( isIE ) {
                    op = new Promise( function ( res, rej ) {
                        op.onabort =
                        op.onerror =    function ( e ) { rej(e);               };
                        op.oncomplete = function ( r ) { res(r.target.result); };
                    });
                }

                op = op.then( function ( k ) {
                    if ( ka.name === 'HMAC' ) {
                        if ( !ka.length ) ka.length = 8 * k.algorithm.length;
                    }
                    if ( ka.name.search('RSA') == 0 ) {
                        if ( !ka.modulusLength ) ka.modulusLength = (k.publicKey || k).algorithm.modulusLength;
                        if ( !ka.publicExponent ) ka.publicExponent = (k.publicKey || k).algorithm.publicExponent;
                    }
                    if ( k.publicKey && k.privateKey ) {
                        k = {
                            publicKey: new CryptoKey( k.publicKey, ka, kx, ku.filter(isPubKeyUse) ),
                            privateKey: new CryptoKey( k.privateKey, ka, kx, ku.filter(isPrvKeyUse) ),
                        };
                    }
                    else {
                        k = new CryptoKey( k, ka, kx, ku );
                    }
                    return k;
                });

                return op;
            };
        });

    [ 'exportKey', 'wrapKey' ]
        .forEach( function ( m ) {
            var _fn = _subtle[m];

            _subtle[m] = function ( a, b, c ) {
                var args = [].slice.call(arguments);

                switch ( m ) {
                    case 'exportKey':
                        args[1] = b._key;
                        break;
                    case 'wrapKey':
                        args[1] = b._key, args[2] = c._key;
                        break;
                }

                if ( ( isWebkit || ( isIE && ( b.algorithm.hash || {} ).name === 'SHA-1' ) )
                        && m === 'exportKey' && a === 'jwk' && b.algorithm.name === 'HMAC' ) {
                    args[0] = 'raw';
                }

                if ( isWebkit && m === 'exportKey' && ( a === 'spki' || a === 'pkcs8' ) ) {
                    args[0] = 'jwk';
                }

                if ( isIE && m === 'wrapKey' ) {
                    return _subtle.exportKey( a, b )
                        .then( function ( k ) {
                            if ( a === 'jwk' ) k = s2b( unescape( encodeURIComponent( JSON.stringify( b2jwk(k) ) ) ) );
                            return  _subtle.encrypt( args[3], c, k );
                        });
                }

                var op;
                try {
                    op = _fn.apply( _subtle, args );
                }
                catch ( e ) {
                    return Promise.reject(e);
                }

                if ( isIE ) {
                    op = new Promise( function ( res, rej ) {
                        op.onabort =
                        op.onerror =    function ( e ) { rej(e);               };
                        op.oncomplete = function ( r ) { res(r.target.result); };
                    });
                }

                if ( m === 'exportKey' && a === 'jwk' ) {
                    op = op.then( function ( k ) {
                        if ( ( isWebkit || ( isIE && ( b.algorithm.hash || {} ).name === 'SHA-1' ) )
                                && b.algorithm.name === 'HMAC') {
                            return { 'kty': 'oct', 'alg': jwkAlg(b.algorithm), 'key_ops': b.usages.slice(), 'ext': true, 'k': s2a( b2s(k) ) };
                        }
                        k = b2jwk(k);
                        if ( !k.alg ) k['alg'] = jwkAlg(b.algorithm);
                        if ( !k.key_ops ) k['key_ops'] = ( b.type === 'public' ) ? b.usages.filter(isPubKeyUse) : ( b.type === 'private' ) ? b.usages.filter(isPrvKeyUse) : b.usages.slice();
                        return k;
                    });
                }

                if ( isWebkit && m === 'exportKey' && ( a === 'spki' || a === 'pkcs8' ) ) {
                    op = op.then( function ( k ) {
                        k = jwk2pkcs( b2jwk(k) );
                        return k;
                    });
                }

                return op;
            };
        });

    [ 'encrypt', 'decrypt', 'sign', 'verify' ]
        .forEach( function ( m ) {
            var _fn = _subtle[m];

            _subtle[m] = function ( a, b, c, d ) {
                if ( isIE && ( !c.byteLength || ( d && !d.byteLength ) ) )
                    throw new Error("Empy input is not allowed");

                var args = [].slice.call(arguments),
                    ka = alg(a);

                if ( isIE && m === 'decrypt' && ka.name === 'AES-GCM' ) {
                    var tl = a.tagLength >> 3;
                    args[2] = (c.buffer || c).slice( 0, c.byteLength - tl ),
                    a.tag = (c.buffer || c).slice( c.byteLength - tl );
                }

                args[1] = b._key;

                var op;
                try {
                    op = _fn.apply( _subtle, args );
                }
                catch ( e ) {
                    return Promise.reject(e);
                }

                if ( isIE ) {
                    op = new Promise( function ( res, rej ) {
                        op.onabort =
                        op.onerror = function ( e ) {
                            rej(e);
                        };

                        op.oncomplete = function ( r ) {
                            var r = r.target.result;

                            if ( m === 'encrypt' && r instanceof AesGcmEncryptResult ) {
                                var c = r.ciphertext, t = r.tag;
                                r = new Uint8Array( c.byteLength + t.byteLength );
                                r.set( new Uint8Array(c), 0 );
                                r.set( new Uint8Array(t), c.byteLength );
                                r = r.buffer;
                            }

                            res(r);
                        };
                    });
                }

                return op;
            };
        });

    if ( isIE ) {
        var _digest = _subtle.digest;

        _subtle['digest'] = function ( a, b ) {
            if ( !b.byteLength )
                throw new Error("Empy input is not allowed");

            var op;
            try {
                op = _digest.call( _subtle, a, b );
            }
            catch ( e ) {
                return Promise.reject(e);
            }

            op = new Promise( function ( res, rej ) {
                op.onabort =
                op.onerror =    function ( e ) { rej(e);               };
                op.oncomplete = function ( r ) { res(r.target.result); };
            });

            return op;
        };

        global.crypto = Object.create( _crypto, {
            getRandomValues: { value: function ( a ) { return _crypto.getRandomValues(a) } },
            subtle:          { value: _subtle },
        });

        global.CryptoKey = CryptoKey;
    }

    if ( isWebkit ) {
        _crypto.subtle = _subtle;

        global.Crypto = _Crypto;
        global.SubtleCrypto = _SubtleCrypto;
        global.CryptoKey = CryptoKey;
    }
}));

var crypto2 = window.crypto;

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __pow = Math.pow;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require =  ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name5 in all)
    __defProp(target, name5, { get: all[name5], enumerable: true });
};
var __copyProps = (to, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key2 of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from4[key2], enumerable: !(desc = __getOwnPropDesc(from4, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target, mod2));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __superGet = (cls, obj, key2) => __reflectGet(__getProtoOf(cls), key2, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var concat_exports = {};
__export(concat_exports, {
  concat: () => concat
});
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = new Uint8Array(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}
var init_concat = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/concat.js"() {
    __name(concat, "concat");
  }
});
function base(ALPHABET, name5) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode11(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  __name(encode11, "encode");
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode10(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name5} character`);
  }
  __name(decode10, "decode");
  return {
    encode: encode11,
    decodeUnsafe,
    decode: decode10
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/vendor/base-x.js"() {
    __name(base, "base");
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString2
});
var empty, toHex, fromHex, equals, coerce, isBinary, fromString, toString2;
var init_bytes = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    toHex =  __name((d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), ""), "toHex");
    fromHex =  __name((hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty;
    }, "fromHex");
    equals =  __name((aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    }, "equals");
    coerce =  __name((o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    }, "coerce");
    isBinary =  __name((o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o), "isBinary");
    fromString =  __name((str) => new TextEncoder().encode(str), "fromString");
    toString2 =  __name((b) => new TextDecoder().decode(b), "toString");
  }
});
var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode, encode, rfc4648;
var init_base = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name5, prefix, baseEncode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    __name(Encoder, "Encoder");
    Decoder = class {
      constructor(name5, prefix, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    __name(Decoder, "Decoder");
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    __name(ComposedDecoder, "ComposedDecoder");
    or =  __name((left, right) => new ComposedDecoder(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right })), "or");
    Codec = class {
      constructor(name5, prefix, baseEncode, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name5, prefix, baseEncode);
        this.decoder = new Decoder(name5, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    __name(Codec, "Codec");
    from =  __name(({ name: name5, prefix, encode: encode11, decode: decode10 }) => new Codec(name5, prefix, encode11, decode10), "from");
    baseX =  __name(({ prefix, name: name5, alphabet: alphabet2 }) => {
      const { encode: encode11, decode: decode10 } = base_x_default(alphabet2, name5);
      return from({
        prefix,
        name: name5,
        encode: encode11,
        decode: (text) => coerce(decode10(text))
      });
    }, "baseX");
    decode =  __name((string2, alphabet2, bitsPerChar, name5) => {
      const codes = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes[alphabet2[i]] = i;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string2[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name5} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    }, "decode");
    encode =  __name((data, alphabet2, bitsPerChar) => {
      const pad2 = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer2 = buffer2 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    }, "encode");
    rfc4648 =  __name(({ name: name5, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from({
        prefix,
        name: name5,
        encode(input) {
          return encode(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode(input, alphabet2, bitsPerChar, name5);
        }
      });
    }, "rfc4648");
  }
});
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base();
    init_bytes();
    identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf2) => toString2(buf2),
      decode: (str) => fromString(str)
    });
  }
});
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode2(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
var init_base256emoji = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base();
    alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    __name(encode2, "encode");
    __name(decode2, "decode");
    base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode2,
      decode: decode2
    });
  }
});
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode3;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    __name(encode3, "encode");
    decode3 = read;
    MSB$1 = 128;
    REST$1 = 127;
    __name(read, "read");
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length =  __name(function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    }, "length");
    varint = {
      encode: encode_1,
      decode: decode3,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});
var varint_exports = {};
__export(varint_exports, {
  decode: () => decode4,
  encodeTo: () => encodeTo,
  encodingLength: () => encodingLength
});
var decode4, encodeTo, encodingLength;
var init_varint2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode4 =  __name((data) => {
      const code5 = varint_default.decode(data);
      return [
        code5,
        varint_default.decode.bytes
      ];
    }, "decode");
    encodeTo =  __name((int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    }, "encodeTo");
    encodingLength =  __name((int) => {
      return varint_default.encodingLength(int);
    }, "encodingLength");
  }
});
var digest_exports = {};
__export(digest_exports, {
  Digest: () => Digest,
  create: () => create,
  decode: () => decode5,
  equals: () => equals2
});
var create, decode5, equals2, Digest;
var init_digest = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create =  __name((code5, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = encodingLength(code5);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code5, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest2, digestOffset);
      return new Digest(code5, size, digest2, bytes);
    }, "create");
    decode5 =  __name((multihash) => {
      const bytes = coerce(multihash);
      const [code5, sizeOffset] = decode4(bytes);
      const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
      const digest2 = bytes.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code5, size, digest2, bytes);
    }, "decode");
    equals2 =  __name((a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
      }
    }, "equals");
    Digest = class {
      constructor(code5, size, digest2, bytes) {
        this.code = code5;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes;
      }
    };
    __name(Digest, "Digest");
  }
});
var hasher_exports = {};
__export(hasher_exports, {
  Hasher: () => Hasher,
  from: () => from2
});
var from2, Hasher;
var init_hasher = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from2 =  __name(({ name: name5, code: code5, encode: encode11 }) => new Hasher(name5, code5, encode11), "from");
    Hasher = class {
      constructor(name5, code5, encode11) {
        this.name = name5;
        this.code = code5;
        this.encode = encode11;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    __name(Hasher, "Hasher");
  }
});
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var sha, sha256, sha512;
var init_sha2_browser = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_hasher();
    sha =  __name((name5) => (data) => __async(void 0, null, function* () {
      return new Uint8Array(yield crypto.subtle.digest(name5, data));
    }), "sha");
    sha256 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha512 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code, name, encode4, digest, identity2;
var init_identity2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code = 0;
    name = "identity";
    encode4 = coerce;
    digest =  __name((input) => create(code, encode4(input)), "digest");
    identity2 = {
      code,
      name,
      encode: encode4,
      digest
    };
  }
});
var raw_exports = {};
__export(raw_exports, {
  code: () => code2,
  decode: () => decode6,
  encode: () => encode5,
  name: () => name2
});
var name2, code2, encode5, decode6;
var init_raw = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
    name2 = "raw";
    code2 = 85;
    encode5 =  __name((node) => coerce(node), "encode");
    decode6 =  __name((data) => coerce(data), "decode");
  }
});
var json_exports = {};
__export(json_exports, {
  code: () => code3,
  decode: () => decode7,
  encode: () => encode6,
  name: () => name3
});
var textEncoder, textDecoder, name3, code3, encode6, decode7;
var init_json = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
    name3 = "json";
    code3 = 512;
    encode6 =  __name((node) => textEncoder.encode(JSON.stringify(node)), "encode");
    decode7 =  __name((data) => JSON.parse(textDecoder.decode(data)), "decode");
  }
});
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class {
      constructor(version11, code5, multihash, bytes) {
        this.code = code5;
        this.version = version11;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache =  new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code5, multihash } = this;
            if (code5 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code5, digest: digest2 } = this.multihash;
            const multihash = create(code5, digest2);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base4) {
        const { bytes, version: version11, _baseCache } = this;
        switch (version11) {
          case 0:
            return toStringV0(bytes, _baseCache, base4 || base58btc.encoder);
          default:
            return toStringV1(bytes, _baseCache, base4 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version11, code: code5, multihash, bytes } = value;
          return new CID(version11, code5, multihash, bytes || encodeCID(version11, code5, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version11, multihash, code: code5 } = value;
          const digest2 = decode5(multihash);
          return CID.create(version11, code5, digest2);
        } else {
          return null;
        }
      }
      static create(version11, code5, digest2) {
        if (typeof code5 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version11) {
          case 0: {
            if (code5 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version11, code5, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version11, code5, digest2.bytes);
            return new CID(version11, code5, digest2, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code5, digest2) {
        return CID.create(1, code5, digest2);
      }
      static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
        return [
          cid,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next =  __name(() => {
          const [i, length2] = decode4(initialBytes.subarray(offset));
          offset += length2;
          return i;
        }, "next");
        let version11 = next();
        let codec = DAG_PB_CODE;
        if (version11 === 18) {
          version11 = 0;
          offset = 0;
        } else if (version11 === 1) {
          codec = next();
        }
        if (version11 !== 0 && version11 !== 1) {
          throw new RangeError(`Invalid CID version ${version11}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version11,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base4) {
        const [prefix, bytes] = parseCIDtoBytes(source, base4);
        const cid = CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    __name(CID, "CID");
    parseCIDtoBytes =  __name((source, base4) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base4 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base4 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base4.decode(source)
          ];
        }
      }
    }, "parseCIDtoBytes");
    toStringV0 =  __name((bytes, cache, base4) => {
      const { prefix } = base4;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    }, "toStringV0");
    toStringV1 =  __name((bytes, cache, base4) => {
      const { prefix } = base4;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    }, "toStringV1");
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID =  __name((version11, code5, multihash) => {
      const codeOffset = encodingLength(version11);
      const hashOffset = codeOffset + encodingLength(code5);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version11, bytes, 0);
      encodeTo(code5, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    }, "encodeCID");
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate =  __name((range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    }, "deprecate");
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});
var init_src = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});
var basics_exports = {};
__export(basics_exports, {
  CID: () => CID,
  bases: () => bases,
  bytes: () => bytes_exports,
  codecs: () => codecs,
  digest: () => digest_exports,
  hasher: () => hasher_exports,
  hashes: () => hashes,
  varint: () => varint_exports
});
var bases, hashes, codecs;
var init_basics = __esm({
  "../../node_modules/.pnpm/multiformats@9.7.0/node_modules/multiformats/esm/src/basics.js"() {
    init_identity();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2_browser();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity_exports), base2_exports), base8_exports), base10_exports), base16_exports), base32_exports), base36_exports), base58_exports), base64_exports), base256emoji_exports);
    hashes = __spreadValues(__spreadValues({}, sha2_browser_exports), identity_exports2);
    codecs = {
      raw: raw_exports,
      json: json_exports
    };
  }
});
function createCodec(name5, prefix, encode11, decode10) {
  return {
    name: name5,
    prefix,
    encoder: {
      name: name5,
      prefix,
      encode: encode11
    },
    decoder: { decode: decode10 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    __name(createCodec, "createCodec");
    string = createCodec("utf8", "u", (buf2) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf2);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf2) => {
      let string2 = "a";
      for (let i = 0; i < buf2.length; i++) {
        string2 += String.fromCharCode(buf2[i]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf2 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf2[i] = str.charCodeAt(i);
      }
      return buf2;
    });
    BASES = __spreadValues({
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii
    }, bases);
    bases_default = BASES;
  }
});
var from_string_exports = {};
__export(from_string_exports, {
  fromString: () => fromString2
});
function fromString2(string2, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.decoder.decode(`${base4.prefix}${string2}`);
}
var init_from_string = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
    __name(fromString2, "fromString");
  }
});
var to_string_exports = {};
__export(to_string_exports, {
  toString: () => toString3
});
function toString3(array, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
    __name(toString3, "toString");
  }
});
var require_int = __commonJS({
  "../../node_modules/.pnpm/@stablelib+int@1.0.1/node_modules/@stablelib/int/lib/int.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    __name(imulShim, "imulShim");
    exports.mul = Math.imul || imulShim;
    function add3(a, b) {
      return a + b | 0;
    }
    __name(add3, "add");
    exports.add = add3;
    function sub(a, b) {
      return a - b | 0;
    }
    __name(sub, "sub");
    exports.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    __name(rotl, "rotl");
    exports.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    __name(rotr, "rotr");
    exports.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    __name(isIntegerShim, "isIntegerShim");
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n) {
      return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
    };
  }
});
var require_binary = __commonJS({
  "../../node_modules/.pnpm/@stablelib+binary@1.0.1/node_modules/@stablelib/binary/lib/binary.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    __name(readInt16BE, "readInt16BE");
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    __name(readUint16BE, "readUint16BE");
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    __name(readInt16LE, "readInt16LE");
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    __name(readUint16LE, "readUint16LE");
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    __name(writeUint16BE, "writeUint16BE");
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    __name(writeUint16LE, "writeUint16LE");
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    __name(readInt32BE, "readInt32BE");
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    __name(readUint32BE, "readUint32BE");
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    __name(readInt32LE, "readInt32LE");
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    __name(readUint32LE, "readUint32LE");
    exports.readUint32LE = readUint32LE;
    function writeUint32BE2(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    __name(writeUint32BE2, "writeUint32BE");
    exports.writeUint32BE = writeUint32BE2;
    exports.writeInt32BE = writeUint32BE2;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    __name(writeUint32LE, "writeUint32LE");
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    __name(readInt64BE, "readInt64BE");
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    __name(readUint64BE, "readUint64BE");
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    __name(readInt64LE, "readInt64LE");
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    __name(readUint64LE, "readUint64LE");
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE2(value / 4294967296 >>> 0, out, offset);
      writeUint32BE2(value >>> 0, out, offset + 4);
      return out;
    }
    __name(writeUint64BE, "writeUint64BE");
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    __name(writeUint64LE, "writeUint64LE");
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul3 = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul3;
        mul3 *= 256;
      }
      return result;
    }
    __name(readUintBE, "readUintBE");
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul3 = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul3;
        mul3 *= 256;
      }
      return result;
    }
    __name(readUintLE, "readUintLE");
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    __name(writeUintBE, "writeUintBE");
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    __name(writeUintLE, "writeUintLE");
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    __name(readFloat32BE, "readFloat32BE");
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    __name(readFloat32LE, "readFloat32LE");
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    __name(readFloat64BE, "readFloat64BE");
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    __name(readFloat64LE, "readFloat64LE");
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    __name(writeFloat32BE, "writeFloat32BE");
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    __name(writeFloat32LE, "writeFloat32LE");
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    __name(writeFloat64BE, "writeFloat64BE");
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    __name(writeFloat64LE, "writeFloat64LE");
    exports.writeFloat64LE = writeFloat64LE;
  }
});
var require_wipe = __commonJS({
  "../../node_modules/.pnpm/@stablelib+wipe@1.0.1/node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i = 0; i < array.length; i++) {
        array[i] = 0;
      }
      return array;
    }
    __name(wipe, "wipe");
    exports.wipe = wipe;
  }
});
var require_sha256 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+sha256@1.0.1/node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA256 = function() {
      function SHA2562() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      __name(SHA2562, "SHA256");
      SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2562.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
      };
      SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i = left + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
          binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
      };
      SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2562.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2562.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2562;
    }();
    exports.SHA256 = SHA256;
    var K = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
          var j = pos + i * 4;
          w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
          var u = w[i - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    __name(hashBlocks, "hashBlocks");
    function hash3(data) {
      var h = new SHA256();
      h.update(data);
      var digest2 = h.digest();
      h.clean();
      return digest2;
    }
    __name(hash3, "hash");
    exports.hash = hash3;
  }
});
var require_sha3 = __commonJS({
  "../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod =  __name(function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      }, "createOutputMethod");
      var createShakeOutputMethod =  __name(function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      }, "createShakeOutputMethod");
      var createCshakeOutputMethod =  __name(function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      }, "createCshakeOutputMethod");
      var createKmacOutputMethod =  __name(function(bits2, padding, outputType) {
        return function(key2, message, outputBits, s) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s)[outputType]();
        };
      }, "createKmacOutputMethod");
      var createOutputMethods =  __name(function(method, createMethod2, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      }, "createOutputMethods");
      var createMethod =  __name(function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      }, "createMethod");
      var createShakeMethod =  __name(function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      }, "createShakeMethod");
      var createCshakeMethod =  __name(function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      }, "createCshakeMethod");
      var createKmacMethod =  __name(function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key2, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key2], w);
        };
        method.update = function(key2, message, outputBits, s) {
          return method.create(key2, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      }, "createKmacMethod");
      var algorithms2 = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms2.length; ++i) {
        var algorithm = algorithms2[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      __name(Keccak, "Keccak");
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code5;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length2 && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length2 && i2 < byteCount; ++index) {
              code5 = message.charCodeAt(index);
              if (code5 < 128) {
                blocks[i2 >> 2] |= code5 << SHIFT[i2++ & 3];
              } else if (code5 < 2048) {
                blocks[i2 >> 2] |= (192 | code5 >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code5 & 63) << SHIFT[i2++ & 3];
              } else if (code5 < 55296 || code5 >= 57344) {
                blocks[i2 >> 2] |= (224 | code5 >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code5 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code5 & 63) << SHIFT[i2++ & 3];
              } else {
                code5 = 65536 + ((code5 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code5 >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code5 >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code5 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code5 & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length2 = str.length;
        if (notString) {
          bytes = length2;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code5 = str.charCodeAt(i2);
            if (code5 < 128) {
              bytes += 1;
            } else if (code5 < 2048) {
              bytes += 2;
            } else if (code5 < 55296 || code5 >= 57344) {
              bytes += 3;
            } else {
              code5 = 65536 + ((code5 & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer2);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      __name(Kmac, "Kmac");
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f =  __name(function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      }, "f");
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});
var require_package = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});
var require_buffer = __commonJS({
  "(disabled):../../node_modules/.pnpm/buffer@5.2.1/node_modules/buffer/index.js"() {
  }
});
var require_bn = __commonJS({
  "../../node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      __name(assert2, "assert");
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor =  __name(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      __name(inherits, "inherits");
      function BN3(number, base4, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base4 === "le" || base4 === "be") {
            endian = base4;
            base4 = 10;
          }
          this._init(number || 0, base4 || 10, endian || "be");
        }
      }
      __name(BN3, "BN");
      if (typeof module2 === "object") {
        module2.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN =  __name(function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      }, "isBN");
      BN3.max =  __name(function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, "max");
      BN3.min =  __name(function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, "min");
      BN3.prototype._init =  __name(function init4(number, base4, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base4, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base4, endian);
        }
        if (base4 === "hex") {
          base4 = 16;
        }
        assert2(base4 === (base4 | 0) && base4 >= 2 && base4 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base4 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base4, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base4, endian);
            }
          }
        }
      }, "init");
      BN3.prototype._initNumber =  __name(function _initNumber(number, base4, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base4, endian);
      }, "_initNumber");
      BN3.prototype._initArray =  __name(function _initArray(number, base4, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      }, "_initArray");
      function parseHex4Bits(string2, index) {
        var c = string2.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      __name(parseHex4Bits, "parseHex4Bits");
      function parseHexByte(string2, lowerBound, index) {
        var r = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r;
      }
      __name(parseHexByte, "parseHexByte");
      BN3.prototype._parseHex =  __name(function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      }, "_parseHex");
      function parseBase(str, start, end, mul3) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul3;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      __name(parseBase, "parseBase");
      BN3.prototype._parseBase =  __name(function _parseBase(number, base4, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base4) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base4 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base4);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base4);
          for (i = 0; i < mod2; i++) {
            pow *= base4;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      }, "_parseBase");
      BN3.prototype.copy =  __name(function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      }, "copy");
      BN3.prototype.clone =  __name(function clone() {
        var r = new BN3(null);
        this.copy(r);
        return r;
      }, "clone");
      BN3.prototype._expand =  __name(function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      }, "_expand");
      BN3.prototype.strip =  __name(function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      }, "strip");
      BN3.prototype._normSign =  __name(function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      }, "_normSign");
      BN3.prototype.inspect =  __name(function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }, "inspect");
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString =  __name(function toString5(base4, padding) {
        base4 = base4 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base4 === 16 || base4 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base4 === (base4 | 0) && base4 >= 2 && base4 <= 36) {
          var groupSize = groupSizes[base4];
          var groupBase = groupBases[base4];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base4);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      }, "toString");
      BN3.prototype.toNumber =  __name(function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      }, "toNumber");
      BN3.prototype.toJSON =  __name(function toJSON2() {
        return this.toString(16);
      }, "toJSON");
      BN3.prototype.toBuffer =  __name(function toBuffer(endian, length2) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length2);
      }, "toBuffer");
      BN3.prototype.toArray =  __name(function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      }, "toArray");
      BN3.prototype.toArrayLike =  __name(function toArrayLike(ArrayType, endian, length2) {
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      }, "toArrayLike");
      if (Math.clz32) {
        BN3.prototype._countBits =  __name(function _countBits(w) {
          return 32 - Math.clz32(w);
        }, "_countBits");
      } else {
        BN3.prototype._countBits =  __name(function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        }, "_countBits");
      }
      BN3.prototype._zeroBits =  __name(function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      }, "_zeroBits");
      BN3.prototype.bitLength =  __name(function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      }, "bitLength");
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      __name(toBitArray, "toBitArray");
      BN3.prototype.zeroBits =  __name(function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      }, "zeroBits");
      BN3.prototype.byteLength =  __name(function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, "byteLength");
      BN3.prototype.toTwos =  __name(function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      }, "toTwos");
      BN3.prototype.fromTwos =  __name(function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      }, "fromTwos");
      BN3.prototype.isNeg =  __name(function isNeg() {
        return this.negative !== 0;
      }, "isNeg");
      BN3.prototype.neg =  __name(function neg3() {
        return this.clone().ineg();
      }, "neg");
      BN3.prototype.ineg =  __name(function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      }, "ineg");
      BN3.prototype.iuor =  __name(function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      }, "iuor");
      BN3.prototype.ior =  __name(function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      }, "ior");
      BN3.prototype.or =  __name(function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, "or");
      BN3.prototype.uor =  __name(function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, "uor");
      BN3.prototype.iuand =  __name(function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      }, "iuand");
      BN3.prototype.iand =  __name(function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      }, "iand");
      BN3.prototype.and =  __name(function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, "and");
      BN3.prototype.uand =  __name(function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, "uand");
      BN3.prototype.iuxor =  __name(function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      }, "iuxor");
      BN3.prototype.ixor =  __name(function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }, "ixor");
      BN3.prototype.xor =  __name(function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, "xor");
      BN3.prototype.uxor =  __name(function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, "uxor");
      BN3.prototype.inotn =  __name(function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      }, "inotn");
      BN3.prototype.notn =  __name(function notn(width) {
        return this.clone().inotn(width);
      }, "notn");
      BN3.prototype.setn =  __name(function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      }, "setn");
      BN3.prototype.iadd =  __name(function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      }, "iadd");
      BN3.prototype.add =  __name(function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, "add");
      BN3.prototype.isub =  __name(function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      }, "isub");
      BN3.prototype.sub =  __name(function sub(num) {
        return this.clone().isub(num);
      }, "sub");
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      __name(smallMulTo, "smallMulTo");
      var comb10MulTo =  __name(function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      }, "comb10MulTo");
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      __name(bigMulTo, "bigMulTo");
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      __name(jumboMulTo, "jumboMulTo");
      BN3.prototype.mulTo =  __name(function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      }, "mulTo");
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      __name(FFTM, "FFTM");
      FFTM.prototype.makeRBT =  __name(function makeRBT(N) {
        var t = new Array(N);
        var l = BN3.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      }, "makeRBT");
      FFTM.prototype.revBin =  __name(function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      }, "revBin");
      FFTM.prototype.permute =  __name(function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      }, "permute");
      FFTM.prototype.transform =  __name(function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      }, "transform");
      FFTM.prototype.guessLen13b =  __name(function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      }, "guessLen13b");
      FFTM.prototype.conjugate =  __name(function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      }, "conjugate");
      FFTM.prototype.normalize13b =  __name(function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      }, "normalize13b");
      FFTM.prototype.convert13b =  __name(function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      }, "convert13b");
      FFTM.prototype.stub =  __name(function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      }, "stub");
      FFTM.prototype.mulp =  __name(function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      }, "mulp");
      BN3.prototype.mul =  __name(function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }, "mul");
      BN3.prototype.mulf =  __name(function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }, "mulf");
      BN3.prototype.imul =  __name(function imul(num) {
        return this.clone().mulTo(num, this);
      }, "imul");
      BN3.prototype.imuln =  __name(function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      }, "imuln");
      BN3.prototype.muln =  __name(function muln(num) {
        return this.clone().imuln(num);
      }, "muln");
      BN3.prototype.sqr =  __name(function sqr() {
        return this.mul(this);
      }, "sqr");
      BN3.prototype.isqr =  __name(function isqr() {
        return this.imul(this.clone());
      }, "isqr");
      BN3.prototype.pow =  __name(function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      }, "pow");
      BN3.prototype.iushln =  __name(function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      }, "iushln");
      BN3.prototype.ishln =  __name(function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      }, "ishln");
      BN3.prototype.iushrn =  __name(function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) ; else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      }, "iushrn");
      BN3.prototype.ishrn =  __name(function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }, "ishrn");
      BN3.prototype.shln =  __name(function shln(bits) {
        return this.clone().ishln(bits);
      }, "shln");
      BN3.prototype.ushln =  __name(function ushln(bits) {
        return this.clone().iushln(bits);
      }, "ushln");
      BN3.prototype.shrn =  __name(function shrn(bits) {
        return this.clone().ishrn(bits);
      }, "shrn");
      BN3.prototype.ushrn =  __name(function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, "ushrn");
      BN3.prototype.testn =  __name(function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      }, "testn");
      BN3.prototype.imaskn =  __name(function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, "imaskn");
      BN3.prototype.maskn =  __name(function maskn(bits) {
        return this.clone().imaskn(bits);
      }, "maskn");
      BN3.prototype.iaddn =  __name(function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      }, "iaddn");
      BN3.prototype._iaddn =  __name(function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      }, "_iaddn");
      BN3.prototype.isubn =  __name(function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      }, "isubn");
      BN3.prototype.addn =  __name(function addn(num) {
        return this.clone().iaddn(num);
      }, "addn");
      BN3.prototype.subn =  __name(function subn(num) {
        return this.clone().isubn(num);
      }, "subn");
      BN3.prototype.iabs =  __name(function iabs() {
        this.negative = 0;
        return this;
      }, "iabs");
      BN3.prototype.abs =  __name(function abs() {
        return this.clone().iabs();
      }, "abs");
      BN3.prototype._ishlnsubmul =  __name(function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul3;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      }, "_ishlnsubmul");
      BN3.prototype._wordDiv =  __name(function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      }, "_wordDiv");
      BN3.prototype.divmod =  __name(function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      }, "divmod");
      BN3.prototype.div =  __name(function div(num) {
        return this.divmod(num, "div", false).div;
      }, "div");
      BN3.prototype.mod =  __name(function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      }, "mod");
      BN3.prototype.umod =  __name(function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, "umod");
      BN3.prototype.divRound =  __name(function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, "divRound");
      BN3.prototype.modn =  __name(function modn(num) {
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      }, "modn");
      BN3.prototype.idivn =  __name(function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      }, "idivn");
      BN3.prototype.divn =  __name(function divn(num) {
        return this.clone().idivn(num);
      }, "divn");
      BN3.prototype.egcd =  __name(function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      }, "egcd");
      BN3.prototype._invmp =  __name(function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      }, "_invmp");
      BN3.prototype.gcd =  __name(function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, "gcd");
      BN3.prototype.invm =  __name(function invm(num) {
        return this.egcd(num).a.umod(num);
      }, "invm");
      BN3.prototype.isEven =  __name(function isEven() {
        return (this.words[0] & 1) === 0;
      }, "isEven");
      BN3.prototype.isOdd =  __name(function isOdd() {
        return (this.words[0] & 1) === 1;
      }, "isOdd");
      BN3.prototype.andln =  __name(function andln(num) {
        return this.words[0] & num;
      }, "andln");
      BN3.prototype.bincn =  __name(function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      }, "bincn");
      BN3.prototype.isZero =  __name(function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, "isZero");
      BN3.prototype.cmpn =  __name(function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmpn");
      BN3.prototype.cmp =  __name(function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmp");
      BN3.prototype.ucmp =  __name(function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      }, "ucmp");
      BN3.prototype.gtn =  __name(function gtn(num) {
        return this.cmpn(num) === 1;
      }, "gtn");
      BN3.prototype.gt =  __name(function gt(num) {
        return this.cmp(num) === 1;
      }, "gt");
      BN3.prototype.gten =  __name(function gten(num) {
        return this.cmpn(num) >= 0;
      }, "gten");
      BN3.prototype.gte =  __name(function gte(num) {
        return this.cmp(num) >= 0;
      }, "gte");
      BN3.prototype.ltn =  __name(function ltn(num) {
        return this.cmpn(num) === -1;
      }, "ltn");
      BN3.prototype.lt =  __name(function lt(num) {
        return this.cmp(num) === -1;
      }, "lt");
      BN3.prototype.lten =  __name(function lten(num) {
        return this.cmpn(num) <= 0;
      }, "lten");
      BN3.prototype.lte =  __name(function lte(num) {
        return this.cmp(num) <= 0;
      }, "lte");
      BN3.prototype.eqn =  __name(function eqn(num) {
        return this.cmpn(num) === 0;
      }, "eqn");
      BN3.prototype.eq =  __name(function eq4(num) {
        return this.cmp(num) === 0;
      }, "eq");
      BN3.red =  __name(function red(num) {
        return new Red(num);
      }, "red");
      BN3.prototype.toRed =  __name(function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      }, "toRed");
      BN3.prototype.fromRed =  __name(function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      }, "fromRed");
      BN3.prototype._forceRed =  __name(function _forceRed(ctx) {
        this.red = ctx;
        return this;
      }, "_forceRed");
      BN3.prototype.forceRed =  __name(function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      }, "forceRed");
      BN3.prototype.redAdd =  __name(function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      }, "redAdd");
      BN3.prototype.redIAdd =  __name(function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      }, "redIAdd");
      BN3.prototype.redSub =  __name(function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      }, "redSub");
      BN3.prototype.redISub =  __name(function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      }, "redISub");
      BN3.prototype.redShl =  __name(function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      }, "redShl");
      BN3.prototype.redMul =  __name(function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      }, "redMul");
      BN3.prototype.redIMul =  __name(function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      }, "redIMul");
      BN3.prototype.redSqr =  __name(function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      }, "redSqr");
      BN3.prototype.redISqr =  __name(function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      }, "redISqr");
      BN3.prototype.redSqrt =  __name(function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      }, "redSqrt");
      BN3.prototype.redInvm =  __name(function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      }, "redInvm");
      BN3.prototype.redNeg =  __name(function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      }, "redNeg");
      BN3.prototype.redPow =  __name(function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      }, "redPow");
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name5, p) {
        this.name = name5;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      __name(MPrime, "MPrime");
      MPrime.prototype._tmp =  __name(function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      }, "_tmp");
      MPrime.prototype.ireduce =  __name(function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      }, "ireduce");
      MPrime.prototype.split =  __name(function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, "split");
      MPrime.prototype.imulK =  __name(function imulK(num) {
        return num.imul(this.k);
      }, "imulK");
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      __name(K256, "K256");
      inherits(K256, MPrime);
      K256.prototype.split =  __name(function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      }, "split");
      K256.prototype.imulK =  __name(function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      }, "imulK");
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      __name(P224, "P224");
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      __name(P192, "P192");
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      __name(P25519, "P25519");
      inherits(P25519, MPrime);
      P25519.prototype.imulK =  __name(function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      }, "imulK");
      BN3._prime =  __name(function prime(name5) {
        if (primes[name5])
          return primes[name5];
        var prime2;
        if (name5 === "k256") {
          prime2 = new K256();
        } else if (name5 === "p224") {
          prime2 = new P224();
        } else if (name5 === "p192") {
          prime2 = new P192();
        } else if (name5 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name5);
        }
        primes[name5] = prime2;
        return prime2;
      }, "prime");
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      __name(Red, "Red");
      Red.prototype._verify1 =  __name(function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      }, "_verify1");
      Red.prototype._verify2 =  __name(function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(a.red && a.red === b.red, "red works only with red numbers");
      }, "_verify2");
      Red.prototype.imod =  __name(function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, "imod");
      Red.prototype.neg =  __name(function neg3(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      }, "neg");
      Red.prototype.add =  __name(function add3(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      }, "add");
      Red.prototype.iadd =  __name(function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      }, "iadd");
      Red.prototype.sub =  __name(function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      }, "sub");
      Red.prototype.isub =  __name(function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      }, "isub");
      Red.prototype.shl =  __name(function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      }, "shl");
      Red.prototype.imul =  __name(function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      }, "imul");
      Red.prototype.mul =  __name(function mul3(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      }, "mul");
      Red.prototype.isqr =  __name(function isqr(a) {
        return this.imul(a, a.clone());
      }, "isqr");
      Red.prototype.sqr =  __name(function sqr(a) {
        return this.mul(a, a);
      }, "sqr");
      Red.prototype.sqrt =  __name(function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN3(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      }, "sqrt");
      Red.prototype.invm =  __name(function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      }, "invm");
      Red.prototype.pow =  __name(function pow(a, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      }, "pow");
      Red.prototype.convertTo =  __name(function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, "convertTo");
      Red.prototype.convertFrom =  __name(function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }, "convertFrom");
      BN3.mont =  __name(function mont(num) {
        return new Mont(num);
      }, "mont");
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      __name(Mont, "Mont");
      inherits(Mont, Red);
      Mont.prototype.convertTo =  __name(function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, "convertTo");
      Mont.prototype.convertFrom =  __name(function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      }, "convertFrom");
      Mont.prototype.imul =  __name(function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      }, "imul");
      Mont.prototype.mul =  __name(function mul3(a, b) {
        if (a.isZero() || b.isZero())
          return new BN3(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      }, "mul");
      Mont.prototype.invm =  __name(function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      }, "invm");
    })(typeof module === "undefined" || module, exports);
  }
});
var require_minimalistic_assert = __commonJS({
  "../../node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert2;
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    __name(assert2, "assert");
    assert2.equal =  __name(function assertEqual2(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    }, "assertEqual");
  }
});
var require_utils = __commonJS({
  "../../node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    __name(toArray, "toArray");
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    __name(zero2, "zero2");
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    __name(toHex2, "toHex");
    utils.toHex = toHex2;
    utils.encode =  __name(function encode11(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    }, "encode");
  }
});
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    var utils = exports;
    var BN3 = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF2(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod2 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z = (ws >> 1) - mod2;
          else
            z = mod2;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    __name(getNAF2, "getNAF");
    utils.getNAF = getNAF2;
    function getJSF2(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    __name(getJSF2, "getJSF");
    utils.getJSF = getJSF2;
    function cachedProperty(obj, name5, computer) {
      var key2 = "_" + name5;
      obj.prototype[name5] =  __name(function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      }, "cachedProperty");
    }
    __name(cachedProperty, "cachedProperty");
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    __name(parseBytes, "parseBytes");
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN3(bytes, "hex", "le");
    }
    __name(intFromLE, "intFromLE");
    utils.intFromLE = intFromLE;
  }
});
var require_brorand = __commonJS({
  "../../node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js"(exports, module) {
    var r;
    module.exports =  __name(function rand2(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    }, "rand");
    function Rand(rand2) {
      this.rand = rand2;
    }
    __name(Rand, "Rand");
    module.exports.Rand = Rand;
    Rand.prototype.generate =  __name(function generate3(len) {
      return this._rand(len);
    }, "generate");
    Rand.prototype._rand =  __name(function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    }, "_rand");
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand =  __name(function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        }, "_rand");
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand =  __name(function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        }, "_rand");
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto3 = window.crypto;
        if (typeof crypto3.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand =  __name(function _rand(n) {
          return crypto3.randomBytes(n);
        }, "_rand");
      } catch (e) {
      }
    }
    var crypto3;
  }
});
var require_base = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    var BN3 = require_bn();
    var utils = require_utils2();
    var getNAF2 = utils.getNAF;
    var getJSF2 = utils.getJSF;
    var assert2 = utils.assert;
    function BaseCurve2(type, conf) {
      this.type = type;
      this.p = new BN3(conf.p, 16);
      this.red = conf.prime ? BN3.red(conf.prime) : BN3.mont(this.p);
      this.zero = new BN3(0).toRed(this.red);
      this.one = new BN3(1).toRed(this.red);
      this.two = new BN3(2).toRed(this.red);
      this.n = conf.n && new BN3(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    __name(BaseCurve2, "BaseCurve");
    module.exports = BaseCurve2;
    BaseCurve2.prototype.point =  __name(function point3() {
      throw new Error("Not implemented");
    }, "point");
    BaseCurve2.prototype.validate =  __name(function validate6() {
      throw new Error("Not implemented");
    }, "validate");
    BaseCurve2.prototype._fixedNafMul =  __name(function _fixedNafMul2(p, k) {
      assert2(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF2(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    }, "_fixedNafMul");
    BaseCurve2.prototype._wnafMul =  __name(function _wnafMul2(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF2(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert2(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    }, "_wnafMul");
    BaseCurve2.prototype._wnafMulAdd =  __name(function _wnafMulAdd2(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF2(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF2(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          null,
          null,
          points[b]
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF2(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    }, "_wnafMulAdd");
    function BasePoint2(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    __name(BasePoint2, "BasePoint");
    BaseCurve2.BasePoint = BasePoint2;
    BasePoint2.prototype.eq =  __name(function eq4() {
      throw new Error("Not implemented");
    }, "eq");
    BasePoint2.prototype.validate =  __name(function validate6() {
      return this.curve.validate(this);
    }, "validate");
    BaseCurve2.prototype.decodePoint =  __name(function decodePoint2(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert2(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert2(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    }, "decodePoint");
    BasePoint2.prototype.encodeCompressed =  __name(function encodeCompressed2(enc) {
      return this.encode(enc, true);
    }, "encodeCompressed");
    BasePoint2.prototype._encode =  __name(function _encode2(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    }, "_encode");
    BasePoint2.prototype.encode =  __name(function encode11(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    }, "encode");
    BasePoint2.prototype.precompute =  __name(function precompute2(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    }, "precompute");
    BasePoint2.prototype._hasDoubles =  __name(function _hasDoubles2(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    }, "_hasDoubles");
    BasePoint2.prototype._getDoubles =  __name(function _getDoubles2(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    }, "_getDoubles");
    BasePoint2.prototype._getNAFPoints =  __name(function _getNAFPoints2(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl3 = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl3);
      return {
        wnd,
        points: res
      };
    }, "_getNAFPoints");
    BasePoint2.prototype._getBeta =  __name(function _getBeta3() {
      return null;
    }, "_getBeta");
    BasePoint2.prototype.dblp =  __name(function dblp3(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    }, "dblp");
  }
});
var require_inherits_browser = __commonJS({
  "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports =  __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      }, "inherits");
    } else {
      module.exports =  __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor =  __name(function() {
          }, "TempCtor");
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      }, "inherits");
    }
  }
});
var require_short = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    var utils = require_utils2();
    var BN3 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert2 = utils.assert;
    function ShortCurve2(conf) {
      Base.call(this, "short", conf);
      this.a = new BN3(conf.a, 16).toRed(this.red);
      this.b = new BN3(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    __name(ShortCurve2, "ShortCurve");
    inherits(ShortCurve2, Base);
    module.exports = ShortCurve2;
    ShortCurve2.prototype._getEndomorphism =  __name(function _getEndomorphism2(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN3(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN3(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN3(vec.a, 16),
            b: new BN3(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    }, "_getEndomorphism");
    ShortCurve2.prototype._getEndoRoots =  __name(function _getEndoRoots2(num) {
      var red = num === this.p ? this.red : BN3.mont(num);
      var tinv = new BN3(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN3(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    }, "_getEndoRoots");
    ShortCurve2.prototype._getEndoBasis =  __name(function _getEndoBasis2(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN3(1);
      var y1 = new BN3(0);
      var x2 = new BN3(0);
      var y2 = new BN3(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    }, "_getEndoBasis");
    ShortCurve2.prototype._endoSplit =  __name(function _endoSplit2(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    }, "_endoSplit");
    ShortCurve2.prototype.pointFromX =  __name(function pointFromX2(x, odd) {
      x = new BN3(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    }, "pointFromX");
    ShortCurve2.prototype.validate =  __name(function validate6(point3) {
      if (point3.inf)
        return true;
      var x = point3.x;
      var y = point3.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    }, "validate");
    ShortCurve2.prototype._endoWnafMulAdd =  __name(function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    }, "_endoWnafMulAdd");
    function Point2(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN3(x, 16);
        this.y = new BN3(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    __name(Point2, "Point");
    inherits(Point2, Base.BasePoint);
    ShortCurve2.prototype.point =  __name(function point3(x, y, isRed) {
      return new Point2(this, x, y, isRed);
    }, "point");
    ShortCurve2.prototype.pointFromJSON =  __name(function pointFromJSON2(obj, red) {
      return Point2.fromJSON(this, obj, red);
    }, "pointFromJSON");
    Point2.prototype._getBeta =  __name(function _getBeta3() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul =  __name(function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        }, "endoMul");
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    }, "_getBeta");
    Point2.prototype.toJSON =  __name(function toJSON2() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    }, "toJSON");
    Point2.fromJSON =  __name(function fromJSON2(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      __name(obj2point, "obj2point");
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    }, "fromJSON");
    Point2.prototype.inspect =  __name(function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, "inspect");
    Point2.prototype.isInfinity =  __name(function isInfinity3() {
      return this.inf;
    }, "isInfinity");
    Point2.prototype.add =  __name(function add3(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }, "add");
    Point2.prototype.dbl =  __name(function dbl3() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }, "dbl");
    Point2.prototype.getX =  __name(function getX2() {
      return this.x.fromRed();
    }, "getX");
    Point2.prototype.getY =  __name(function getY2() {
      return this.y.fromRed();
    }, "getY");
    Point2.prototype.mul =  __name(function mul3(k) {
      k = new BN3(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    }, "mul");
    Point2.prototype.mulAdd =  __name(function mulAdd2(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    }, "mulAdd");
    Point2.prototype.jmulAdd =  __name(function jmulAdd2(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    }, "jmulAdd");
    Point2.prototype.eq =  __name(function eq4(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    }, "eq");
    Point2.prototype.neg =  __name(function neg3(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate =  __name(function(p) {
          return p.neg();
        }, "negate");
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    }, "neg");
    Point2.prototype.toJ =  __name(function toJ2() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    }, "toJ");
    function JPoint2(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN3(0);
      } else {
        this.x = new BN3(x, 16);
        this.y = new BN3(y, 16);
        this.z = new BN3(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    __name(JPoint2, "JPoint");
    inherits(JPoint2, Base.BasePoint);
    ShortCurve2.prototype.jpoint =  __name(function jpoint2(x, y, z) {
      return new JPoint2(this, x, y, z);
    }, "jpoint");
    JPoint2.prototype.toP =  __name(function toP2() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    }, "toP");
    JPoint2.prototype.neg =  __name(function neg3() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, "neg");
    JPoint2.prototype.add =  __name(function add3(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    }, "add");
    JPoint2.prototype.mixedAdd =  __name(function mixedAdd2(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    }, "mixedAdd");
    JPoint2.prototype.dblp =  __name(function dblp3(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    }, "dblp");
    JPoint2.prototype.dbl =  __name(function dbl3() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    }, "dbl");
    JPoint2.prototype._zeroDbl =  __name(function _zeroDbl2() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    }, "_zeroDbl");
    JPoint2.prototype._threeDbl =  __name(function _threeDbl2() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    }, "_threeDbl");
    JPoint2.prototype._dbl =  __name(function _dbl2() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    }, "_dbl");
    JPoint2.prototype.trpl =  __name(function trpl2() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    }, "trpl");
    JPoint2.prototype.mul =  __name(function mul3(k, kbase) {
      k = new BN3(k, kbase);
      return this.curve._wnafMul(this, k);
    }, "mul");
    JPoint2.prototype.eq =  __name(function eq4(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    }, "eq");
    JPoint2.prototype.eqXToP =  __name(function eqXToP2(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    }, "eqXToP");
    JPoint2.prototype.inspect =  __name(function inspect4() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, "inspect");
    JPoint2.prototype.isInfinity =  __name(function isInfinity3() {
      return this.z.cmpn(0) === 0;
    }, "isInfinity");
  }
});
var require_mont = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    var BN3 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN3(conf.a, 16).toRed(this.red);
      this.b = new BN3(conf.b, 16).toRed(this.red);
      this.i4 = new BN3(4).toRed(this.red).redInvm();
      this.two = new BN3(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    __name(MontCurve, "MontCurve");
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate =  __name(function validate6(point3) {
      var x = point3.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    }, "validate");
    function Point2(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN3(x, 16);
        this.z = new BN3(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    __name(Point2, "Point");
    inherits(Point2, Base.BasePoint);
    MontCurve.prototype.decodePoint =  __name(function decodePoint2(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    }, "decodePoint");
    MontCurve.prototype.point =  __name(function point3(x, z) {
      return new Point2(this, x, z);
    }, "point");
    MontCurve.prototype.pointFromJSON =  __name(function pointFromJSON2(obj) {
      return Point2.fromJSON(this, obj);
    }, "pointFromJSON");
    Point2.prototype.precompute =  __name(function precompute2() {
    }, "precompute");
    Point2.prototype._encode =  __name(function _encode2() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    }, "_encode");
    Point2.fromJSON =  __name(function fromJSON2(curve, obj) {
      return new Point2(curve, obj[0], obj[1] || curve.one);
    }, "fromJSON");
    Point2.prototype.inspect =  __name(function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, "inspect");
    Point2.prototype.isInfinity =  __name(function isInfinity3() {
      return this.z.cmpn(0) === 0;
    }, "isInfinity");
    Point2.prototype.dbl =  __name(function dbl3() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    }, "dbl");
    Point2.prototype.add =  __name(function add3() {
      throw new Error("Not supported on Montgomery curve");
    }, "add");
    Point2.prototype.diffAdd =  __name(function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    }, "diffAdd");
    Point2.prototype.mul =  __name(function mul3(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    }, "mul");
    Point2.prototype.mulAdd =  __name(function mulAdd2() {
      throw new Error("Not supported on Montgomery curve");
    }, "mulAdd");
    Point2.prototype.jumlAdd =  __name(function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    }, "jumlAdd");
    Point2.prototype.eq =  __name(function eq4(other) {
      return this.getX().cmp(other.getX()) === 0;
    }, "eq");
    Point2.prototype.normalize =  __name(function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    }, "normalize");
    Point2.prototype.getX =  __name(function getX2() {
      this.normalize();
      return this.x.fromRed();
    }, "getX");
  }
});
var require_edwards = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    var utils = require_utils2();
    var BN3 = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert2 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN3(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN3(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN3(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    __name(EdwardsCurve, "EdwardsCurve");
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA =  __name(function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    }, "_mulA");
    EdwardsCurve.prototype._mulC =  __name(function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    }, "_mulC");
    EdwardsCurve.prototype.jpoint =  __name(function jpoint2(x, y, z, t) {
      return this.point(x, y, z, t);
    }, "jpoint");
    EdwardsCurve.prototype.pointFromX =  __name(function pointFromX2(x, odd) {
      x = new BN3(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    }, "pointFromX");
    EdwardsCurve.prototype.pointFromY =  __name(function pointFromY(y, odd) {
      y = new BN3(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    }, "pointFromY");
    EdwardsCurve.prototype.validate =  __name(function validate6(point3) {
      if (point3.isInfinity())
        return true;
      point3.normalize();
      var x2 = point3.x.redSqr();
      var y2 = point3.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    }, "validate");
    function Point2(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN3(x, 16);
        this.y = new BN3(y, 16);
        this.z = z ? new BN3(z, 16) : this.curve.one;
        this.t = t && new BN3(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    __name(Point2, "Point");
    inherits(Point2, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON =  __name(function pointFromJSON2(obj) {
      return Point2.fromJSON(this, obj);
    }, "pointFromJSON");
    EdwardsCurve.prototype.point =  __name(function point3(x, y, z, t) {
      return new Point2(this, x, y, z, t);
    }, "point");
    Point2.fromJSON =  __name(function fromJSON2(curve, obj) {
      return new Point2(curve, obj[0], obj[1], obj[2]);
    }, "fromJSON");
    Point2.prototype.inspect =  __name(function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, "inspect");
    Point2.prototype.isInfinity =  __name(function isInfinity3() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, "isInfinity");
    Point2.prototype._extDbl =  __name(function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    }, "_extDbl");
    Point2.prototype._projDbl =  __name(function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    }, "_projDbl");
    Point2.prototype.dbl =  __name(function dbl3() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    }, "dbl");
    Point2.prototype._extAdd =  __name(function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    }, "_extAdd");
    Point2.prototype._projAdd =  __name(function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    }, "_projAdd");
    Point2.prototype.add =  __name(function add3(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    }, "add");
    Point2.prototype.mul =  __name(function mul3(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    }, "mul");
    Point2.prototype.mulAdd =  __name(function mulAdd2(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    }, "mulAdd");
    Point2.prototype.jmulAdd =  __name(function jmulAdd2(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    }, "jmulAdd");
    Point2.prototype.normalize =  __name(function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    }, "normalize");
    Point2.prototype.neg =  __name(function neg3() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, "neg");
    Point2.prototype.getX =  __name(function getX2() {
      this.normalize();
      return this.x.fromRed();
    }, "getX");
    Point2.prototype.getY =  __name(function getY2() {
      this.normalize();
      return this.y.fromRed();
    }, "getY");
    Point2.prototype.eq =  __name(function eq4(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    }, "eq");
    Point2.prototype.eqXToP =  __name(function eqXToP2(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    }, "eqXToP");
    Point2.prototype.toP = Point2.prototype.normalize;
    Point2.prototype.mixedAdd = Point2.prototype.add;
  }
});
var require_curve = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js"(exports) {
    var assert2 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    __name(isSurrogatePair, "isSurrogatePair");
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    __name(toArray, "toArray");
    exports.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    __name(toHex2, "toHex");
    exports.toHex = toHex2;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    __name(htonl, "htonl");
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    __name(toHex32, "toHex32");
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    __name(zero2, "zero2");
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    __name(zero8, "zero8");
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert2(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    __name(join32, "join32");
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    __name(split32, "split32");
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    __name(rotr32, "rotr32");
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    __name(rotl32, "rotl32");
    exports.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    __name(sum32, "sum32");
    exports.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    __name(sum32_3, "sum32_3");
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    __name(sum32_4, "sum32_4");
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    __name(sum32_5, "sum32_5");
    exports.sum32_5 = sum32_5;
    function sum64(buf2, pos, ah, al) {
      var bh = buf2[pos];
      var bl = buf2[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf2[pos] = hi >>> 0;
      buf2[pos + 1] = lo;
    }
    __name(sum64, "sum64");
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    __name(sum64_hi, "sum64_hi");
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    __name(sum64_lo, "sum64_lo");
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    __name(sum64_4_hi, "sum64_4_hi");
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    __name(sum64_4_lo, "sum64_4_lo");
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    __name(sum64_5_hi, "sum64_5_hi");
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    __name(sum64_5_lo, "sum64_5_lo");
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    __name(rotr64_hi, "rotr64_hi");
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    __name(rotr64_lo, "rotr64_lo");
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    __name(shr64_hi, "shr64_hi");
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    __name(shr64_lo, "shr64_lo");
    exports.shr64_lo = shr64_lo;
  }
});
var require_common = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js"(exports) {
    var utils = require_utils3();
    var assert2 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    __name(BlockHash, "BlockHash");
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update =  __name(function update2(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    }, "update");
    BlockHash.prototype.digest =  __name(function digest2(enc) {
      this.update(this._pad());
      assert2(this.pending === null);
      return this._digest(enc);
    }, "digest");
    BlockHash.prototype._pad =  __name(function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    }, "pad");
  }
});
var require_common2 = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    __name(ft_1, "ft_1");
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    __name(ch32, "ch32");
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    __name(maj32, "maj32");
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    __name(p32, "p32");
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    __name(s0_256, "s0_256");
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    __name(s1_256, "s1_256");
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    __name(g0_256, "g0_256");
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    __name(g1_256, "g1_256");
    exports.g1_256 = g1_256;
  }
});
var require__ = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    __name(SHA1, "SHA1");
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update =  __name(function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    }, "_update");
    SHA1.prototype._digest =  __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest");
  }
});
var require__2 = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert2 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    __name(SHA256, "SHA256");
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update =  __name(function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert2(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    }, "_update");
    SHA256.prototype._digest =  __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest");
  }
});
var require__3 = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    __name(SHA224, "SHA224");
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest =  __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    }, "digest");
  }
});
var require__4 = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    var utils = require_utils3();
    var common = require_common();
    var assert2 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    __name(SHA512, "SHA512");
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock =  __name(function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      }
    }, "_prepareBlock");
    SHA512.prototype._update =  __name(function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert2(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    }, "_update");
    SHA512.prototype._digest =  __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    }, "digest");
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(ch64_hi, "ch64_hi");
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(ch64_lo, "ch64_lo");
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(maj64_hi, "maj64_hi");
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(maj64_lo, "maj64_lo");
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(s0_512_hi, "s0_512_hi");
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(s0_512_lo, "s0_512_lo");
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(s1_512_hi, "s1_512_hi");
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(s1_512_lo, "s1_512_lo");
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(g0_512_hi, "g0_512_hi");
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(g0_512_lo, "g0_512_lo");
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(g1_512_hi, "g1_512_hi");
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    __name(g1_512_lo, "g1_512_lo");
  }
});
var require__5 = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    __name(SHA384, "SHA384");
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest =  __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    }, "digest");
  }
});
var require_sha = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js"(exports) {
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});
var require_ripemd = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    __name(RIPEMD160, "RIPEMD160");
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update =  __name(function update2(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    }, "update");
    RIPEMD160.prototype._digest =  __name(function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    }, "digest");
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    __name(f, "f");
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    __name(K, "K");
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    __name(Kh, "Kh");
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});
var require_hmac = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    var utils = require_utils3();
    var assert2 = require_minimalistic_assert();
    function Hmac(hash3, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key2, enc);
      this.Hash = hash3;
      this.blockSize = hash3.blockSize / 8;
      this.outSize = hash3.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    __name(Hmac, "Hmac");
    module.exports = Hmac;
    Hmac.prototype._init =  __name(function init4(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert2(key2.length <= this.blockSize);
      for (var i = key2.length; i < this.blockSize; i++)
        key2.push(0);
      for (i = 0; i < key2.length; i++)
        key2[i] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i = 0; i < key2.length; i++)
        key2[i] ^= 106;
      this.outer = new this.Hash().update(key2);
    }, "init");
    Hmac.prototype.update =  __name(function update2(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    }, "update");
    Hmac.prototype.digest =  __name(function digest2(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    }, "digest");
  }
});
var require_hash = __commonJS({
  "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js"(exports) {
    var hash3 = exports;
    hash3.utils = require_utils3();
    hash3.common = require_common();
    hash3.sha = require_sha();
    hash3.ripemd = require_ripemd();
    hash3.hmac = require_hmac();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  }
});
var require_secp256k1 = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});
var require_curves = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    var curves = exports;
    var hash3 = require_hash();
    var curve = require_curve();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    __name(PresetCurve, "PresetCurve");
    curves.PresetCurve = PresetCurve;
    function defineCurve(name5, options) {
      Object.defineProperty(curves, name5, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name5, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    __name(defineCurve, "defineCurve");
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash3.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash3.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash3.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});
var require_hmac_drbg = __commonJS({
  "../../node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    var hash3 = require_hash();
    var utils = require_utils();
    var assert2 = require_minimalistic_assert();
    function HmacDRBG2(options) {
      if (!(this instanceof HmacDRBG2))
        return new HmacDRBG2(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._init(entropy, nonce, pers);
    }
    __name(HmacDRBG2, "HmacDRBG");
    module.exports = HmacDRBG2;
    HmacDRBG2.prototype._init =  __name(function init4(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    }, "init");
    HmacDRBG2.prototype._hmac =  __name(function hmac2() {
      return new hash3.hmac(this.hash, this.K);
    }, "hmac");
    HmacDRBG2.prototype._update =  __name(function update2(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    }, "update");
    HmacDRBG2.prototype.reseed =  __name(function reseed2(entropy, entropyEnc, add3, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add3;
        add3 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add3 = utils.toArray(add3, addEnc);
      assert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._update(entropy.concat(add3 || []));
      this._reseed = 1;
    }, "reseed");
    HmacDRBG2.prototype.generate =  __name(function generate3(len, enc, add3, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add3;
        add3 = enc;
        enc = null;
      }
      if (add3) {
        add3 = utils.toArray(add3, addEnc || "hex");
        this._update(add3);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add3);
      this._reseed++;
      return utils.encode(res, enc);
    }, "generate");
  }
});
var require_key = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    var BN3 = require_bn();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function KeyPair2(ec3, options) {
      this.ec = ec3;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    __name(KeyPair2, "KeyPair");
    module.exports = KeyPair2;
    KeyPair2.fromPublic =  __name(function fromPublic2(ec3, pub, enc) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(ec3, {
        pub,
        pubEnc: enc
      });
    }, "fromPublic");
    KeyPair2.fromPrivate =  __name(function fromPrivate2(ec3, priv, enc) {
      if (priv instanceof KeyPair2)
        return priv;
      return new KeyPair2(ec3, {
        priv,
        privEnc: enc
      });
    }, "fromPrivate");
    KeyPair2.prototype.validate =  __name(function validate6() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    }, "validate");
    KeyPair2.prototype.getPublic =  __name(function getPublic2(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    }, "getPublic");
    KeyPair2.prototype.getPrivate =  __name(function getPrivate2(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    }, "getPrivate");
    KeyPair2.prototype._importPrivate =  __name(function _importPrivate2(key2, enc) {
      this.priv = new BN3(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    }, "_importPrivate");
    KeyPair2.prototype._importPublic =  __name(function _importPublic2(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert2(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert2(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    }, "_importPublic");
    KeyPair2.prototype.derive =  __name(function derive2(pub) {
      if (!pub.validate()) {
        assert2(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    }, "derive");
    KeyPair2.prototype.sign =  __name(function sign5(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    }, "sign");
    KeyPair2.prototype.verify =  __name(function verify4(msg, signature2) {
      return this.ec.verify(msg, signature2, this);
    }, "verify");
    KeyPair2.prototype.inspect =  __name(function inspect4() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    }, "inspect");
  }
});
var require_signature = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    var BN3 = require_bn();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function Signature2(options, enc) {
      if (options instanceof Signature2)
        return options;
      if (this._importDER(options, enc))
        return;
      assert2(options.r && options.s, "Signature without r or s");
      this.r = new BN3(options.r, 16);
      this.s = new BN3(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    __name(Signature2, "Signature");
    module.exports = Signature2;
    function Position2() {
      this.place = 0;
    }
    __name(Position2, "Position");
    function getLength2(buf2, p) {
      var initial = buf2[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf2[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    __name(getLength2, "getLength");
    function rmPadding2(buf2) {
      var i = 0;
      var len = buf2.length - 1;
      while (!buf2[i] && !(buf2[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf2;
      }
      return buf2.slice(i);
    }
    __name(rmPadding2, "rmPadding");
    Signature2.prototype._importDER =  __name(function _importDER2(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position2();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength2(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength2(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength2(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN3(r);
      this.s = new BN3(s);
      this.recoveryParam = null;
      return true;
    }, "_importDER");
    function constructLength2(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    __name(constructLength2, "constructLength");
    Signature2.prototype.toDER =  __name(function toDER2(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding2(r);
      s = rmPadding2(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength2(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength2(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength2(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    }, "toDER");
  }
});
var require_ec = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    var BN3 = require_bn();
    var HmacDRBG2 = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand2 = require_brorand();
    var assert2 = utils.assert;
    var KeyPair2 = require_key();
    var Signature2 = require_signature();
    function EC2(options) {
      if (!(this instanceof EC2))
        return new EC2(options);
      if (typeof options === "string") {
        assert2(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    __name(EC2, "EC");
    module.exports = EC2;
    EC2.prototype.keyPair =  __name(function keyPair2(options) {
      return new KeyPair2(this, options);
    }, "keyPair");
    EC2.prototype.keyFromPrivate =  __name(function keyFromPrivate2(priv, enc) {
      return KeyPair2.fromPrivate(this, priv, enc);
    }, "keyFromPrivate");
    EC2.prototype.keyFromPublic =  __name(function keyFromPublic2(pub, enc) {
      return KeyPair2.fromPublic(this, pub, enc);
    }, "keyFromPublic");
    EC2.prototype.genKeyPair =  __name(function genKeyPair2(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG2({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand2(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN3(2));
      for (; ; ) {
        var priv = new BN3(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    }, "genKeyPair");
    EC2.prototype._truncateToN =  __name(function _truncateToN2(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    }, "_truncateToN");
    EC2.prototype.sign =  __name(function sign5(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new BN3(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG2({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN3(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN3(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key2.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature2({ r, s, recoveryParam });
      }
    }, "sign");
    EC2.prototype.verify =  __name(function verify4(msg, signature2, key2, enc) {
      msg = this._truncateToN(new BN3(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature2 = new Signature2(signature2, "hex");
      var r = signature2.r;
      var s = signature2.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key2.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key2.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    }, "verify");
    EC2.prototype.recoverPubKey = function(msg, signature2, j, enc) {
      assert2((3 & j) === j, "The recovery param is more than two bits");
      signature2 = new Signature2(signature2, enc);
      var n = this.n;
      var e = new BN3(msg);
      var r = signature2.r;
      var s = signature2.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature2.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC2.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
      signature2 = new Signature2(signature2, enc);
      if (signature2.recoveryParam !== null)
        return signature2.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature2, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});
var require_key2 = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    var utils = require_utils2();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair2(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    __name(KeyPair2, "KeyPair");
    KeyPair2.fromPublic =  __name(function fromPublic2(eddsa, pub) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(eddsa, { pub });
    }, "fromPublic");
    KeyPair2.fromSecret =  __name(function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair2)
        return secret;
      return new KeyPair2(eddsa, { secret });
    }, "fromSecret");
    KeyPair2.prototype.secret =  __name(function secret() {
      return this._secret;
    }, "secret");
    cachedProperty(KeyPair2, "pubBytes",  __name(function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    }, "pubBytes"));
    cachedProperty(KeyPair2, "pub",  __name(function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    }, "pub"));
    cachedProperty(KeyPair2, "privBytes",  __name(function privBytes() {
      var eddsa = this.eddsa;
      var hash3 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash3.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    }, "privBytes"));
    cachedProperty(KeyPair2, "priv",  __name(function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    }, "priv"));
    cachedProperty(KeyPair2, "hash",  __name(function hash3() {
      return this.eddsa.hash().update(this.secret()).digest();
    }, "hash"));
    cachedProperty(KeyPair2, "messagePrefix",  __name(function messagePrefix2() {
      return this.hash().slice(this.eddsa.encodingLength);
    }, "messagePrefix"));
    KeyPair2.prototype.sign =  __name(function sign5(message) {
      assert2(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    }, "sign");
    KeyPair2.prototype.verify =  __name(function verify4(message, sig) {
      return this.eddsa.verify(message, sig, this);
    }, "verify");
    KeyPair2.prototype.getSecret =  __name(function getSecret(enc) {
      assert2(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    }, "getSecret");
    KeyPair2.prototype.getPublic =  __name(function getPublic2(enc) {
      return utils.encode(this.pubBytes(), enc);
    }, "getPublic");
    module.exports = KeyPair2;
  }
});
var require_signature2 = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    var BN3 = require_bn();
    var utils = require_utils2();
    var assert2 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature2(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert2(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN3)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    __name(Signature2, "Signature");
    cachedProperty(Signature2, "S",  __name(function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    }, "S"));
    cachedProperty(Signature2, "R",  __name(function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    }, "R"));
    cachedProperty(Signature2, "Rencoded",  __name(function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    }, "Rencoded"));
    cachedProperty(Signature2, "Sencoded",  __name(function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    }, "Sencoded"));
    Signature2.prototype.toBytes =  __name(function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    }, "toBytes");
    Signature2.prototype.toHex =  __name(function toHex2() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    }, "toHex");
    module.exports = Signature2;
  }
});
var require_eddsa = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    var hash3 = require_hash();
    var curves = require_curves();
    var utils = require_utils2();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair2 = require_key2();
    var Signature2 = require_signature2();
    function EDDSA(curve) {
      assert2(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash3.sha512;
    }
    __name(EDDSA, "EDDSA");
    module.exports = EDDSA;
    EDDSA.prototype.sign =  __name(function sign5(message, secret) {
      message = parseBytes(message);
      var key2 = this.keyFromSecret(secret);
      var r = this.hashInt(key2.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    }, "sign");
    EDDSA.prototype.verify =  __name(function verify4(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key2 = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key2.pub().mul(h));
      return RplusAh.eq(SG);
    }, "verify");
    EDDSA.prototype.hashInt =  __name(function hashInt() {
      var hash4 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash4.update(arguments[i]);
      return utils.intFromLE(hash4.digest()).umod(this.curve.n);
    }, "hashInt");
    EDDSA.prototype.keyFromPublic =  __name(function keyFromPublic2(pub) {
      return KeyPair2.fromPublic(this, pub);
    }, "keyFromPublic");
    EDDSA.prototype.keyFromSecret =  __name(function keyFromSecret(secret) {
      return KeyPair2.fromSecret(this, secret);
    }, "keyFromSecret");
    EDDSA.prototype.makeSignature =  __name(function makeSignature(sig) {
      if (sig instanceof Signature2)
        return sig;
      return new Signature2(this, sig);
    }, "makeSignature");
    EDDSA.prototype.encodePoint =  __name(function encodePoint(point3) {
      var enc = point3.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point3.getX().isOdd() ? 128 : 0;
      return enc;
    }, "encodePoint");
    EDDSA.prototype.decodePoint =  __name(function decodePoint2(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    }, "decodePoint");
    EDDSA.prototype.encodeInt =  __name(function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    }, "encodeInt");
    EDDSA.prototype.decodeInt =  __name(function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    }, "decodeInt");
    EDDSA.prototype.isPoint =  __name(function isPoint(val) {
      return val instanceof this.pointClass;
    }, "isPoint");
  }
});
var require_elliptic = __commonJS({
  "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic.js"(exports) {
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});
var require_browser = __commonJS({
  "../../node_modules/.pnpm/@stablelib+random@1.0.1/node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var QUOTA = 65536;
    var BrowserRandomSource = function() {
      function BrowserRandomSource2() {
        this.isAvailable = false;
        this.isInstantiated = false;
        var browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      __name(BrowserRandomSource2, "BrowserRandomSource");
      BrowserRandomSource2.prototype.randomBytes = function(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        var out = new Uint8Array(length2);
        for (var i = 0; i < out.length; i += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
      };
      return BrowserRandomSource2;
    }();
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});
var require_node = __commonJS({
  "../../node_modules/.pnpm/@stablelib+random@1.0.1/node_modules/@stablelib/random/lib/source/node.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var wipe_1 = require_wipe();
    var NodeRandomSource = function() {
      function NodeRandomSource2() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          var nodeCrypto = window.crypto;
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      __name(NodeRandomSource2, "NodeRandomSource");
      NodeRandomSource2.prototype.randomBytes = function(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        var buffer2 = this._crypto.randomBytes(length2);
        if (buffer2.length !== length2) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        var out = new Uint8Array(length2);
        for (var i = 0; i < out.length; i++) {
          out[i] = buffer2[i];
        }
        wipe_1.wipe(buffer2);
        return out;
      };
      return NodeRandomSource2;
    }();
    exports.NodeRandomSource = NodeRandomSource;
  }
});
var require_system = __commonJS({
  "../../node_modules/.pnpm/@stablelib+random@1.0.1/node_modules/@stablelib/random/lib/source/system.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = function() {
      function SystemRandomSource2() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      __name(SystemRandomSource2, "SystemRandomSource");
      SystemRandomSource2.prototype.randomBytes = function(length2) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length2);
      };
      return SystemRandomSource2;
    }();
    exports.SystemRandomSource = SystemRandomSource;
  }
});
var require_random = __commonJS({
  "../../node_modules/.pnpm/@stablelib+random@1.0.1/node_modules/@stablelib/random/lib/random.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes6(length2, prng) {
      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      }
      return prng.randomBytes(length2);
    }
    __name(randomBytes6, "randomBytes");
    exports.randomBytes = randomBytes6;
    function randomUint32(prng) {
      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      }
      var buf2 = randomBytes6(4, prng);
      var result = binary_1.readUint32LE(buf2);
      wipe_1.wipe(buf2);
      return result;
    }
    __name(randomUint32, "randomUint32");
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString2(length2, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }
      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      }
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      var out = "";
      var charsLen = charset.length;
      var maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        var buf2 = randomBytes6(Math.ceil(length2 * 256 / maxByte), prng);
        for (var i = 0; i < buf2.length && length2 > 0; i++) {
          var randomByte = buf2[i];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        wipe_1.wipe(buf2);
      }
      return out;
    }
    __name(randomString2, "randomString");
    exports.randomString = randomString2;
    function randomStringForEntropy(bits, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }
      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      }
      var length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString2(length2, charset, prng);
    }
    __name(randomStringForEntropy, "randomStringForEntropy");
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});
var require_sha512 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+sha512@1.0.1/node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = function() {
      function SHA5122() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._stateHi = new Int32Array(8);
        this._stateLo = new Int32Array(8);
        this._tempHi = new Int32Array(16);
        this._tempLo = new Int32Array(16);
        this._buffer = new Uint8Array(256);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      __name(SHA5122, "SHA512");
      SHA5122.prototype._initState = function() {
        this._stateHi[0] = 1779033703;
        this._stateHi[1] = 3144134277;
        this._stateHi[2] = 1013904242;
        this._stateHi[3] = 2773480762;
        this._stateHi[4] = 1359893119;
        this._stateHi[5] = 2600822924;
        this._stateHi[6] = 528734635;
        this._stateHi[7] = 1541459225;
        this._stateLo[0] = 4089235720;
        this._stateLo[1] = 2227873595;
        this._stateLo[2] = 4271175723;
        this._stateLo[3] = 1595750129;
        this._stateLo[4] = 2917565137;
        this._stateLo[5] = 725511199;
        this._stateLo[6] = 4215389547;
        this._stateLo[7] = 327033209;
      };
      SHA5122.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA5122.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._tempHi);
        wipe_1.wipe(this._tempLo);
        this.reset();
      };
      SHA5122.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA512: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA5122.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 128 < 112 ? 128 : 256;
          this._buffer[left] = 128;
          for (var i = left + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 8; i++) {
          binary_1.writeUint32BE(this._stateHi[i], out, i * 8);
          binary_1.writeUint32BE(this._stateLo[i], out, i * 8 + 4);
        }
        return this;
      };
      SHA5122.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA5122.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA5122.prototype.restoreState = function(savedState) {
        this._stateHi.set(savedState.stateHi);
        this._stateLo.set(savedState.stateLo);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA5122.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.stateHi);
        wipe_1.wipe(savedState.stateLo);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA5122;
    }();
    exports.SHA512 = SHA512;
    var K = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h, l;
      var th, tl;
      var a, b, c, d;
      while (len >= 128) {
        for (var i = 0; i < 16; i++) {
          var j = 8 * i + pos;
          wh[i] = binary_1.readUint32BE(m, j);
          wl[i] = binary_1.readUint32BE(m, j + 4);
        }
        for (var i = 0; i < 80; i++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (var j = 0; j < 16; j++) {
              h = wh[j];
              l = wl[j];
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    __name(hashBlocks, "hashBlocks");
    function hash3(data) {
      var h = new SHA512();
      h.update(data);
      var digest2 = h.digest();
      h.clean();
      return digest2;
    }
    __name(hash3, "hash");
    exports.hash = hash3;
  }
});
var require_ed25519 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+ed25519@1.0.2/node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init4) {
      var r = new Float64Array(16);
      if (init4) {
        for (var i = 0; i < init4.length; i++) {
          r[i] = init4[i];
        }
      }
      return r;
    }
    __name(gf, "gf");
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r, a) {
      for (var i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
      }
    }
    __name(set25519, "set25519");
    function car25519(o) {
      var c = 1;
      for (var i = 0; i < 16; i++) {
        var v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    __name(car25519, "car25519");
    function sel25519(p, q, b) {
      var c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        var t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    __name(sel25519, "sel25519");
    function pack25519(o, n) {
      var m = gf();
      var t = gf();
      for (var i = 0; i < 16; i++) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (var j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (var i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        var b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (var i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    __name(pack25519, "pack25519");
    function verify32(x, y) {
      var d = 0;
      for (var i = 0; i < 32; i++) {
        d |= x[i] ^ y[i];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    __name(verify32, "verify32");
    function neq25519(a, b) {
      var c = new Uint8Array(32);
      var d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return verify32(c, d);
    }
    __name(neq25519, "neq25519");
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    __name(par25519, "par25519");
    function unpack25519(o, n) {
      for (var i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    __name(unpack25519, "unpack25519");
    function add3(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }
    __name(add3, "add");
    function sub(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }
    __name(sub, "sub");
    function mul3(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    __name(mul3, "mul");
    function square(o, a) {
      mul3(o, a, a);
    }
    __name(square, "square");
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }
      for (a = 253; a >= 0; a--) {
        square(c, c);
        if (a !== 2 && a !== 4) {
          mul3(c, c, i);
        }
      }
      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }
    __name(inv25519, "inv25519");
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }
      for (a = 250; a >= 0; a--) {
        square(c, c);
        if (a !== 1) {
          mul3(c, c, i);
        }
      }
      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }
    __name(pow2523, "pow2523");
    function edadd(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      sub(a, p[1], p[0]);
      sub(t, q[1], q[0]);
      mul3(a, a, t);
      add3(b, p[0], p[1]);
      add3(t, q[0], q[1]);
      mul3(b, b, t);
      mul3(c, p[3], q[3]);
      mul3(c, c, D2);
      mul3(d, p[2], q[2]);
      add3(d, d, d);
      sub(e, b, a);
      sub(f, d, c);
      add3(g, d, c);
      add3(h, b, a);
      mul3(p[0], e, f);
      mul3(p[1], h, g);
      mul3(p[2], g, f);
      mul3(p[3], e, h);
    }
    __name(edadd, "edadd");
    function cswap(p, q, b) {
      for (var i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    __name(cswap, "cswap");
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      mul3(tx, p[0], zi);
      mul3(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    __name(pack, "pack");
    function scalarmult(p, q, s) {
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (var i = 255; i >= 0; --i) {
        var b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        edadd(q, p);
        edadd(p, p);
        cswap(p, q, b);
      }
    }
    __name(scalarmult, "scalarmult");
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      mul3(q[3], X, Y);
      scalarmult(p, q, s);
    }
    __name(scalarbase, "scalarbase");
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error("ed25519: seed must be " + exports.SEED_LENGTH + " bytes");
      }
      var d = sha512_1.hash(seed);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var publicKey = new Uint8Array(32);
      var p = [gf(), gf(), gf(), gf()];
      scalarbase(p, d);
      pack(publicKey, p);
      var secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    __name(generateKeyPairFromSeed2, "generateKeyPairFromSeed");
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair2(prng) {
      var seed = random_1.randomBytes(32, prng);
      var result = generateKeyPairFromSeed2(seed);
      wipe_1.wipe(seed);
      return result;
    }
    __name(generateKeyPair2, "generateKeyPair");
    exports.generateKeyPair = generateKeyPair2;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error("ed25519: secret key must be " + exports.SECRET_KEY_LENGTH + " bytes");
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    __name(extractPublicKeyFromSecretKey, "extractPublicKeyFromSecretKey");
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r, x) {
      var carry;
      var i;
      var j;
      var k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) {
        x[j] -= carry * L[j];
      }
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    __name(modL, "modL");
    function reduce(r) {
      var x = new Float64Array(64);
      for (var i = 0; i < 64; i++) {
        x[i] = r[i];
      }
      for (var i = 0; i < 64; i++) {
        r[i] = 0;
      }
      modL(r, x);
    }
    __name(reduce, "reduce");
    function sign5(secretKey, message) {
      var x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var d = sha512_1.hash(secretKey.subarray(0, 32));
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var signature2 = new Uint8Array(64);
      signature2.set(d.subarray(32), 32);
      var hs = new sha512_1.SHA512();
      hs.update(signature2.subarray(32));
      hs.update(message);
      var r = hs.digest();
      hs.clean();
      reduce(r);
      scalarbase(p, r);
      pack(signature2, p);
      hs.reset();
      hs.update(signature2.subarray(0, 32));
      hs.update(secretKey.subarray(32));
      hs.update(message);
      var h = hs.digest();
      reduce(h);
      for (var i = 0; i < 32; i++) {
        x[i] = r[i];
      }
      for (var i = 0; i < 32; i++) {
        for (var j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(signature2.subarray(32), x);
      return signature2;
    }
    __name(sign5, "sign");
    exports.sign = sign5;
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      square(num, r[1]);
      mul3(den, num, D);
      sub(num, num, r[2]);
      add3(den, r[2], den);
      square(den2, den);
      square(den4, den2);
      mul3(den6, den4, den2);
      mul3(t, den6, num);
      mul3(t, t, den);
      pow2523(t, t);
      mul3(t, t, num);
      mul3(t, t, den);
      mul3(t, t, den);
      mul3(r[0], t, den);
      square(chk, r[0]);
      mul3(chk, chk, den);
      if (neq25519(chk, num)) {
        mul3(r[0], r[0], I);
      }
      square(chk, r[0]);
      mul3(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p[31] >> 7) {
        sub(r[0], gf0, r[0]);
      }
      mul3(r[3], r[0], r[1]);
      return 0;
    }
    __name(unpackneg, "unpackneg");
    function verify4(publicKey, message, signature2) {
      var t = new Uint8Array(32);
      var p = [gf(), gf(), gf(), gf()];
      var q = [gf(), gf(), gf(), gf()];
      if (signature2.length !== exports.SIGNATURE_LENGTH) {
        throw new Error("ed25519: signature must be " + exports.SIGNATURE_LENGTH + " bytes");
      }
      if (unpackneg(q, publicKey)) {
        return false;
      }
      var hs = new sha512_1.SHA512();
      hs.update(signature2.subarray(0, 32));
      hs.update(publicKey);
      hs.update(message);
      var h = hs.digest();
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, signature2.subarray(32));
      edadd(p, q);
      pack(t, p);
      if (verify32(signature2, t)) {
        return false;
      }
      return true;
    }
    __name(verify4, "verify");
    exports.verify = verify4;
    function convertPublicKeyToX25519(publicKey) {
      var q = [gf(), gf(), gf(), gf()];
      if (unpackneg(q, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      var a = gf();
      var b = gf();
      var y = q[1];
      add3(a, gf1, y);
      sub(b, gf1, y);
      inv25519(b, b);
      mul3(a, a, b);
      var z = new Uint8Array(32);
      pack25519(z, a);
      return z;
    }
    __name(convertPublicKeyToX25519, "convertPublicKeyToX25519");
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX255192(secretKey) {
      var d = sha512_1.hash(secretKey.subarray(0, 32));
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var o = new Uint8Array(d.subarray(0, 32));
      wipe_1.wipe(d);
      return o;
    }
    __name(convertSecretKeyToX255192, "convertSecretKeyToX25519");
    exports.convertSecretKeyToX25519 = convertSecretKeyToX255192;
  }
});
var require_canonicalize = __commonJS({
  "../../node_modules/.pnpm/canonicalize@1.0.8/node_modules/canonicalize/lib/canonicalize.js"(exports, module) {
    module.exports =  __name(function serialize2(object) {
      if (object === null || typeof object !== "object" || object.toJSON != null) {
        return JSON.stringify(object);
      }
      if (Array.isArray(object)) {
        return "[" + object.reduce((t, cv, ci) => {
          const comma = ci === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return t + comma + serialize2(value);
        }, "") + "]";
      }
      return "{" + Object.keys(object).sort().reduce((t, cv, ci) => {
        if (object[cv] === void 0 || typeof object[cv] === "symbol") {
          return t;
        }
        const comma = t.length === 0 ? "" : ",";
        return t + comma + serialize2(cv) + ":" + serialize2(object[cv]);
      }, "") + "}";
    }, "serialize");
  }
});
var require_x25519 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+x25519@1.0.2/node_modules/@stablelib/x25519/lib/x25519.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var random_1 = require_random();
    var wipe_1 = require_wipe();
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32;
    function gf(init4) {
      var r = new Float64Array(16);
      if (init4) {
        for (var i = 0; i < init4.length; i++) {
          r[i] = init4[i];
        }
      }
      return r;
    }
    __name(gf, "gf");
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      var c = 1;
      for (var i = 0; i < 16; i++) {
        var v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    __name(car25519, "car25519");
    function sel25519(p, q, b) {
      var c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        var t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    __name(sel25519, "sel25519");
    function pack25519(o, n) {
      var m = gf();
      var t = gf();
      for (var i = 0; i < 16; i++) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (var j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (var i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        var b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (var i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    __name(pack25519, "pack25519");
    function unpack25519(o, n) {
      for (var i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    __name(unpack25519, "unpack25519");
    function add3(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }
    __name(add3, "add");
    function sub(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }
    __name(sub, "sub");
    function mul3(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    __name(mul3, "mul");
    function square(o, a) {
      mul3(o, a, a);
    }
    __name(square, "square");
    function inv25519(o, inp) {
      var c = gf();
      for (var i = 0; i < 16; i++) {
        c[i] = inp[i];
      }
      for (var i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
          mul3(c, c, inp);
        }
      }
      for (var i = 0; i < 16; i++) {
        o[i] = c[i];
      }
    }
    __name(inv25519, "inv25519");
    function scalarMult(n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80);
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (var i = 0; i < 31; i++) {
        z[i] = n[i];
      }
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (var i = 0; i < 16; i++) {
        b[i] = x[i];
      }
      a[0] = d[0] = 1;
      for (var i = 254; i >= 0; --i) {
        var r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add3(e, a, c);
        sub(a, a, c);
        add3(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul3(a, c, a);
        mul3(c, b, e);
        add3(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul3(a, c, _121665);
        add3(a, a, d);
        mul3(c, c, a);
        mul3(a, d, f);
        mul3(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (var i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      mul3(x16, x16, x32);
      var q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }
    __name(scalarMult, "scalarMult");
    exports.scalarMult = scalarMult;
    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }
    __name(scalarMultBase, "scalarMultBase");
    exports.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error("x25519: seed must be " + exports.SECRET_KEY_LENGTH + " bytes");
      }
      var secretKey = new Uint8Array(seed);
      var publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    __name(generateKeyPairFromSeed2, "generateKeyPairFromSeed");
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair2(prng) {
      var seed = random_1.randomBytes(32, prng);
      var result = generateKeyPairFromSeed2(seed);
      wipe_1.wipe(seed);
      return result;
    }
    __name(generateKeyPair2, "generateKeyPair");
    exports.generateKeyPair = generateKeyPair2;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero) {
      if (rejectZero === void 0) {
        rejectZero = false;
      }
      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      var result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        var zeros = 0;
        for (var i = 0; i < result.length; i++) {
          zeros |= result[i];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    __name(sharedKey2, "sharedKey");
    exports.sharedKey = sharedKey2;
  }
});
var require_chacha = __commonJS({
  "../../node_modules/.pnpm/@stablelib+chacha@1.0.1/node_modules/@stablelib/chacha/lib/chacha.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key2) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key2[3] << 24 | key2[2] << 16 | key2[1] << 8 | key2[0];
      var j5 = key2[7] << 24 | key2[6] << 16 | key2[5] << 8 | key2[4];
      var j6 = key2[11] << 24 | key2[10] << 16 | key2[9] << 8 | key2[8];
      var j7 = key2[15] << 24 | key2[14] << 16 | key2[13] << 8 | key2[12];
      var j8 = key2[19] << 24 | key2[18] << 16 | key2[17] << 8 | key2[16];
      var j9 = key2[23] << 24 | key2[22] << 16 | key2[21] << 8 | key2[20];
      var j10 = key2[27] << 24 | key2[26] << 16 | key2[25] << 8 | key2[24];
      var j11 = key2[31] << 24 | key2[30] << 16 | key2[29] << 8 | key2[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    __name(core, "core");
    function streamXOR(key2, nonce, src2, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key2.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src2.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i = 0; i < src2.length; i += 64) {
        core(block, nc, key2);
        for (var j = i; j < i + 64 && j < src2.length; j++) {
          dst[j] = src2[j] ^ block[j - i];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    __name(streamXOR, "streamXOR");
    exports.streamXOR = streamXOR;
    function stream(key2, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key2, nonce, dst, dst, nonceInplaceCounterLength);
    }
    __name(stream, "stream");
    exports.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
    __name(incrementCounter, "incrementCounter");
  }
});
var require_xchacha20 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+xchacha20@1.0.1/node_modules/@stablelib/xchacha20/lib/xchacha20.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var chacha_1 = require_chacha();
    var ROUNDS = 20;
    function streamXOR(key2, nonce, src2, dst) {
      if (nonce.length !== 24) {
        throw new Error("XChaCha20 nonce must be 24 bytes");
      }
      var subkey = hchacha(key2, nonce.subarray(0, 16), new Uint8Array(32));
      var modifiedNonce = new Uint8Array(12);
      modifiedNonce.set(nonce.subarray(16), 4);
      var result = chacha_1.streamXOR(subkey, modifiedNonce, src2, dst);
      wipe_1.wipe(subkey);
      return result;
    }
    __name(streamXOR, "streamXOR");
    exports.streamXOR = streamXOR;
    function stream(key2, nonce, dst) {
      wipe_1.wipe(dst);
      return streamXOR(key2, nonce, dst, dst);
    }
    __name(stream, "stream");
    exports.stream = stream;
    function hchacha(key2, src2, dst) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key2[3] << 24 | key2[2] << 16 | key2[1] << 8 | key2[0];
      var j5 = key2[7] << 24 | key2[6] << 16 | key2[5] << 8 | key2[4];
      var j6 = key2[11] << 24 | key2[10] << 16 | key2[9] << 8 | key2[8];
      var j7 = key2[15] << 24 | key2[14] << 16 | key2[13] << 8 | key2[12];
      var j8 = key2[19] << 24 | key2[18] << 16 | key2[17] << 8 | key2[16];
      var j9 = key2[23] << 24 | key2[22] << 16 | key2[21] << 8 | key2[20];
      var j10 = key2[27] << 24 | key2[26] << 16 | key2[25] << 8 | key2[24];
      var j11 = key2[31] << 24 | key2[30] << 16 | key2[29] << 8 | key2[28];
      var j12 = src2[3] << 24 | src2[2] << 16 | src2[1] << 8 | src2[0];
      var j13 = src2[7] << 24 | src2[6] << 16 | src2[5] << 8 | src2[4];
      var j14 = src2[11] << 24 | src2[10] << 16 | src2[9] << 8 | src2[8];
      var j15 = src2[15] << 24 | src2[14] << 16 | src2[13] << 8 | src2[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0, dst, 0);
      binary_1.writeUint32LE(x1, dst, 4);
      binary_1.writeUint32LE(x2, dst, 8);
      binary_1.writeUint32LE(x3, dst, 12);
      binary_1.writeUint32LE(x12, dst, 16);
      binary_1.writeUint32LE(x13, dst, 20);
      binary_1.writeUint32LE(x14, dst, 24);
      binary_1.writeUint32LE(x15, dst, 28);
      return dst;
    }
    __name(hchacha, "hchacha");
    exports.hchacha = hchacha;
  }
});
var require_constant_time = __commonJS({
  "../../node_modules/.pnpm/@stablelib+constant-time@1.0.1/node_modules/@stablelib/constant-time/lib/constant-time.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    __name(select, "select");
    exports.select = select;
    function lessOrEqual(a, b) {
      return (a | 0) - (b | 0) - 1 >>> 31 & 1;
    }
    __name(lessOrEqual, "lessOrEqual");
    exports.lessOrEqual = lessOrEqual;
    function compare4(a, b) {
      if (a.length !== b.length) {
        return 0;
      }
      var result = 0;
      for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
      }
      return 1 & result - 1 >>> 8;
    }
    __name(compare4, "compare");
    exports.compare = compare4;
    function equal(a, b) {
      if (a.length === 0 || b.length === 0) {
        return false;
      }
      return compare4(a, b) !== 0;
    }
    __name(equal, "equal");
    exports.equal = equal;
  }
});
var require_poly1305 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+poly1305@1.0.1/node_modules/@stablelib/poly1305/lib/poly1305.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 16;
    var Poly1305 = function() {
      function Poly13052(key2) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key2[0] | key2[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key2[2] | key2[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key2[4] | key2[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key2[6] | key2[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key2[8] | key2[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key2[10] | key2[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key2[12] | key2[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key2[14] | key2[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key2[16] | key2[17] << 8;
        this._pad[1] = key2[18] | key2[19] << 8;
        this._pad[2] = key2[20] | key2[21] << 8;
        this._pad[3] = key2[22] | key2[23] << 8;
        this._pad[4] = key2[24] | key2[25] << 8;
        this._pad[5] = key2[26] | key2[27] << 8;
        this._pad[6] = key2[28] | key2[29] << 8;
        this._pad[7] = key2[30] | key2[31] << 8;
      }
      __name(Poly13052, "Poly1305");
      Poly13052.prototype._blocks = function(m, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
          var t0 = m[mpos + 0] | m[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m[mpos + 2] | m[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m[mpos + 4] | m[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m[mpos + 6] | m[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m[mpos + 8] | m[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m[mpos + 10] | m[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m[mpos + 12] | m[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m[mpos + 14] | m[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c = 0;
          var d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          var d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          var d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          var d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          var d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          var d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          var d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          var d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          var d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          var d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
          i = this._leftover;
          this._buffer[i++] = 1;
          for (; i < 16; i++) {
            this._buffer[i] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this._h[i] += c;
          c = this._h[i] >>> 13;
          this._h[i] &= 8191;
        }
        this._h[0] += c * 5;
        c = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this._h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
          g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
          this._h[i] = this._h[i] & mask | g[i];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this._h[i] + this._pad[i] | 0) + (f >>> 16) | 0;
          this._h[i] = f & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m) {
        var mpos = 0;
        var bytes = m.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes) {
            want = bytes;
          }
          for (var i = 0; i < want; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          bytes -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this._blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (var i = 0; i < bytes; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          this._leftover += bytes;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }();
    exports.Poly1305 = Poly1305;
    function oneTimeAuth(key2, data) {
      var h = new Poly1305(key2);
      h.update(data);
      var digest2 = h.digest();
      h.clean();
      return digest2;
    }
    __name(oneTimeAuth, "oneTimeAuth");
    exports.oneTimeAuth = oneTimeAuth;
    function equal(a, b) {
      if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a, b);
    }
    __name(equal, "equal");
    exports.equal = equal;
  }
});
var require_chacha20poly1305 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+chacha20poly1305@1.0.1/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = function() {
      function ChaCha20Poly13052(key2) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key2.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key2);
      }
      __name(ChaCha20Poly13052, "ChaCha20Poly1305");
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length2 = new Uint8Array(8);
        if (associatedData) {
          binary_1.writeUint64LE(associatedData.length, length2);
        }
        h.update(length2);
        binary_1.writeUint64LE(ciphertext.length, length2);
        h.update(length2);
        var tag = h.digest();
        for (var i = 0; i < tag.length; i++) {
          tagOut[i] = tag[i];
        }
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length2);
      };
      return ChaCha20Poly13052;
    }();
    exports.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});
var require_xchacha20poly1305 = __commonJS({
  "../../node_modules/.pnpm/@stablelib+xchacha20poly1305@1.0.1/node_modules/@stablelib/xchacha20poly1305/lib/xchacha20poly1305.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var xchacha20_1 = require_xchacha20();
    var chacha20poly1305_1 = require_chacha20poly1305();
    var wipe_1 = require_wipe();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 24;
    exports.TAG_LENGTH = 16;
    var XChaCha20Poly13052 = function() {
      function XChaCha20Poly13053(key2) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key2.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key2);
      }
      __name(XChaCha20Poly13053, "XChaCha20Poly1305");
      XChaCha20Poly13053.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length !== 24) {
          throw new Error("XChaCha20Poly1305: incorrect nonce length");
        }
        var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
        var modifiedNonce = new Uint8Array(12);
        modifiedNonce.set(nonce.subarray(16), 4);
        var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
        var result = chaChaPoly.seal(modifiedNonce, plaintext, associatedData, dst);
        wipe_1.wipe(subKey);
        wipe_1.wipe(modifiedNonce);
        chaChaPoly.clean();
        return result;
      };
      XChaCha20Poly13053.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length !== 24) {
          throw new Error("XChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
        var modifiedNonce = new Uint8Array(12);
        modifiedNonce.set(nonce.subarray(16), 4);
        var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
        var result = chaChaPoly.open(modifiedNonce, sealed, associatedData, dst);
        wipe_1.wipe(subKey);
        wipe_1.wipe(modifiedNonce);
        chaChaPoly.clean();
        return result;
      };
      XChaCha20Poly13053.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      return XChaCha20Poly13053;
    }();
    exports.XChaCha20Poly1305 = XChaCha20Poly13052;
  }
});
var require_identifiers = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/identifiers.js"(exports, module) {
    module.exports = {
      ALT: 1,
      CAT: 2,
      REP: 3,
      RNM: 4,
      TRG: 5,
      TBS: 6,
      TLS: 7,
      UDT: 11,
      AND: 12,
      NOT: 13,
      BKR: 14,
      BKA: 15,
      BKN: 16,
      ABG: 17,
      AEN: 18,
      ACTIVE: 100,
      MATCH: 101,
      EMPTY: 102,
      NOMATCH: 103,
      SEM_PRE: 200,
      SEM_POST: 201,
      SEM_OK: 300,
      SEM_SKIP: 301,
      ATTR_N: 400,
      ATTR_R: 401,
      ATTR_MR: 402,
      LOOKAROUND_NONE: 500,
      LOOKAROUND_AHEAD: 501,
      LOOKAROUND_BEHIND: 502,
      BKR_MODE_UM: 601,
      BKR_MODE_PM: 602,
      BKR_MODE_CS: 603,
      BKR_MODE_CI: 604
    };
  }
});
var require_style = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/style.js"(exports, module) {
    module.exports = {
      CLASS_MONOSPACE: "apg-mono",
      CLASS_ACTIVE: "apg-active",
      CLASS_EMPTY: "apg-empty",
      CLASS_MATCH: "apg-match",
      CLASS_NOMATCH: "apg-nomatch",
      CLASS_LOOKAHEAD: "apg-lh-match",
      CLASS_LOOKBEHIND: "apg-lb-match",
      CLASS_REMAINDER: "apg-remainder",
      CLASS_CTRLCHAR: "apg-ctrl-char",
      CLASS_LINEEND: "apg-line-end",
      CLASS_ERROR: "apg-error",
      CLASS_PHRASE: "apg-phrase",
      CLASS_EMPTYPHRASE: "apg-empty-phrase",
      CLASS_STATE: "apg-state",
      CLASS_STATS: "apg-stats",
      CLASS_TRACE: "apg-trace",
      CLASS_GRAMMAR: "apg-grammar",
      CLASS_RULES: "apg-rules",
      CLASS_RULESLINK: "apg-rules-link",
      CLASS_ATTRIBUTES: "apg-attrs"
    };
  }
});
var require_transformers = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-conv-api/transformers.js"(exports) {
    "use strict;";
    var thisThis = exports;
    var NON_SHORTEST = 4294967292;
    var TRAILING = 4294967293;
    var RANGE = 4294967294;
    var ILL_FORMED = 4294967295;
    var mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];
    var ascii2 = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0A",
      "0B",
      "0C",
      "0D",
      "0E",
      "0F",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1A",
      "1B",
      "1C",
      "1D",
      "1E",
      "1F",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2A",
      "2B",
      "2C",
      "2D",
      "2E",
      "2F",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3A",
      "3B",
      "3C",
      "3D",
      "3E",
      "3F",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4A",
      "4B",
      "4C",
      "4D",
      "4E",
      "4F",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5A",
      "5B",
      "5C",
      "5D",
      "5E",
      "5F",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6A",
      "6B",
      "6C",
      "6D",
      "6E",
      "6F",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7A",
      "7B",
      "7C",
      "7D",
      "7E",
      "7F",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8A",
      "8B",
      "8C",
      "8D",
      "8E",
      "8F",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9A",
      "9B",
      "9C",
      "9D",
      "9E",
      "9F",
      "A0",
      "A1",
      "A2",
      "A3",
      "A4",
      "A5",
      "A6",
      "A7",
      "A8",
      "A9",
      "AA",
      "AB",
      "AC",
      "AD",
      "AE",
      "AF",
      "B0",
      "B1",
      "B2",
      "B3",
      "B4",
      "B5",
      "B6",
      "B7",
      "B8",
      "B9",
      "BA",
      "BB",
      "BC",
      "BD",
      "BE",
      "BF",
      "C0",
      "C1",
      "C2",
      "C3",
      "C4",
      "C5",
      "C6",
      "C7",
      "C8",
      "C9",
      "CA",
      "CB",
      "CC",
      "CD",
      "CE",
      "CF",
      "D0",
      "D1",
      "D2",
      "D3",
      "D4",
      "D5",
      "D6",
      "D7",
      "D8",
      "D9",
      "DA",
      "DB",
      "DC",
      "DD",
      "DE",
      "DF",
      "E0",
      "E1",
      "E2",
      "E3",
      "E4",
      "E5",
      "E6",
      "E7",
      "E8",
      "E9",
      "EA",
      "EB",
      "EC",
      "ED",
      "EE",
      "EF",
      "F0",
      "F1",
      "F2",
      "F3",
      "F4",
      "F5",
      "F6",
      "F7",
      "F8",
      "F9",
      "FA",
      "FB",
      "FC",
      "FD",
      "FE",
      "FF"
    ];
    var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("");
    var base64codes = [];
    base64chars.forEach((char) => {
      base64codes.push(char.charCodeAt(0));
    });
    exports.utf8 = {
      encode(chars) {
        const bytes = [];
        chars.forEach((char) => {
          if (char >= 0 && char <= 127) {
            bytes.push(char);
          } else if (char <= 2047) {
            bytes.push(192 + (char >> 6 & mask[5]));
            bytes.push(128 + (char & mask[6]));
          } else if (char < 55296 || char > 57343 && char <= 65535) {
            bytes.push(224 + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else if (char >= 65536 && char <= 1114111) {
            const u = char >> 16 & mask[5];
            bytes.push(240 + (u >> 2));
            bytes.push(128 + ((u & mask[2]) << 4) + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else {
            throw new RangeError(`utf8.encode: character out of range: char: ${char}`);
          }
        });
        return Buffer.from(bytes);
      },
      decode(buf2, bom) {
        function bytes2(b12, b2) {
          if ((b2 & 192) !== 128) {
            return TRAILING;
          }
          const x = ((b12 & mask[5]) << 6) + (b2 & mask[6]);
          if (x < 128) {
            return NON_SHORTEST;
          }
          return x;
        }
        __name(bytes2, "bytes2");
        function bytes3(b12, b2, b3) {
          if ((b3 & 192) !== 128 || (b2 & 192) !== 128) {
            return TRAILING;
          }
          const x = ((b12 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);
          if (x < 2048) {
            return NON_SHORTEST;
          }
          if (x >= 55296 && x <= 57343) {
            return RANGE;
          }
          return x;
        }
        __name(bytes3, "bytes3");
        function bytes4(b12, b2, b3, b4) {
          if ((b4 & 192) !== 128 || (b3 & 192) !== 128 || (b2 & 192) !== 128) {
            return TRAILING;
          }
          const x = (((b12 & mask[3]) << 2) + (b2 >> 4 & mask[2]) << 16) + ((b2 & mask[4]) << 12) + ((b3 & mask[6]) << 6) + (b4 & mask[6]);
          if (x < 65536) {
            return NON_SHORTEST;
          }
          if (x > 1114111) {
            return RANGE;
          }
          return x;
        }
        __name(bytes4, "bytes4");
        let c;
        let b1;
        let i1;
        let i2;
        let i3;
        let inc;
        const len = buf2.length;
        let i = bom ? 3 : 0;
        const chars = [];
        while (i < len) {
          b1 = buf2[i];
          c = ILL_FORMED;
          const TRUE = true;
          while (TRUE) {
            if (b1 >= 0 && b1 <= 127) {
              c = b1;
              inc = 1;
              break;
            }
            i1 = i + 1;
            if (i1 < len && b1 >= 194 && b1 <= 223) {
              c = bytes2(b1, buf2[i1]);
              inc = 2;
              break;
            }
            i2 = i + 2;
            if (i2 < len && b1 >= 224 && b1 <= 239) {
              c = bytes3(b1, buf2[i1], buf2[i2]);
              inc = 3;
              break;
            }
            i3 = i + 3;
            if (i3 < len && b1 >= 240 && b1 <= 244) {
              c = bytes4(b1, buf2[i1], buf2[i2], buf2[i3]);
              inc = 4;
              break;
            }
            break;
          }
          if (c > 1114111) {
            const at = `byte[${i}]`;
            if (c === ILL_FORMED) {
              throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);
            }
            if (c === TRAILING) {
              throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);
            }
            if (c === RANGE) {
              throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);
            }
            if (c === NON_SHORTEST) {
              throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);
            }
            throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);
          }
          chars.push(c);
          i += inc;
        }
        return chars;
      }
    };
    exports.utf16be = {
      encode(chars) {
        const bytes = [];
        let char;
        let h;
        let l;
        for (let i = 0; i < chars.length; i += 1) {
          char = chars[i];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char >> 8 & mask[8]);
            bytes.push(char & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l = char - 65536;
            h = 55296 + (l >> 10);
            l = 56320 + (l & mask[10]);
            bytes.push(h >> 8 & mask[8]);
            bytes.push(h & mask[8]);
            bytes.push(l >> 8 & mask[8]);
            bytes.push(l & mask[8]);
          } else {
            throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf2, bom) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        const len = buf2.length;
        let i = bom ? 2 : 0;
        let j = 0;
        let c;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i + 1;
            if (i1 < len) {
              high = (buf2[i] << 8) + buf2[i1];
              if (high < 55296 || high > 57343) {
                c = high;
                inc = 2;
                break;
              }
              i3 = i + 3;
              if (i3 < len) {
                low = (buf2[i + 2] << 8) + buf2[i3];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);
          }
          chars[j++] = c;
          i += inc;
        }
        return chars;
      }
    };
    exports.utf16le = {
      encode(chars) {
        const bytes = [];
        let char;
        let h;
        let l;
        for (let i = 0; i < chars.length; i += 1) {
          char = chars[i];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char & mask[8]);
            bytes.push(char >> 8 & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l = char - 65536;
            h = 55296 + (l >> 10);
            l = 56320 + (l & mask[10]);
            bytes.push(h & mask[8]);
            bytes.push(h >> 8 & mask[8]);
            bytes.push(l & mask[8]);
            bytes.push(l >> 8 & mask[8]);
          } else {
            throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf2, bom) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        const len = buf2.length;
        let i = bom ? 2 : 0;
        let j = 0;
        let c;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i + 1;
            if (i1 < len) {
              high = (buf2[i1] << 8) + buf2[i];
              if (high < 55296 || high > 57343) {
                c = high;
                inc = 2;
                break;
              }
              i3 = i + 3;
              if (i3 < len) {
                low = (buf2[i3] << 8) + buf2[i + 2];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);
          }
          chars[j++] = c;
          i += inc;
        }
        return chars;
      }
    };
    exports.utf32be = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);
          }
          buf2[i++] = char >> 24 & mask[8];
          buf2[i++] = char >> 16 & mask[8];
          buf2[i++] = char >> 8 & mask[8];
          buf2[i++] = char & mask[8];
        });
        return buf2;
      },
      decode(buf2, bom) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        let i = bom ? 4 : 0;
        for (; i < buf2.length; i += 4) {
          const char = (buf2[i] << 24) + (buf2[i + 1] << 16) + (buf2[i + 2] << 8) + buf2[i + 3];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.utf32le = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);
          }
          buf2[i++] = char & mask[8];
          buf2[i++] = char >> 8 & mask[8];
          buf2[i++] = char >> 16 & mask[8];
          buf2[i++] = char >> 24 & mask[8];
        });
        return buf2;
      },
      decode(buf2, bom) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        let i = bom ? 4 : 0;
        for (; i < buf2.length; i += 4) {
          const char = (buf2[i + 3] << 24) + (buf2[i + 2] << 16) + (buf2[i + 1] << 8) + buf2[i];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.uint7 = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length);
        for (let i = 0; i < chars.length; i += 1) {
          if (chars[i] > 127) {
            throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);
          }
          buf2[i] = chars[i];
        }
        return buf2;
      },
      decode(buf2) {
        const chars = [];
        for (let i = 0; i < buf2.length; i += 1) {
          if (buf2[i] > 127) {
            throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf2[i]}`);
          }
          chars[i] = buf2[i];
        }
        return chars;
      }
    };
    exports.uint8 = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length);
        for (let i = 0; i < chars.length; i += 1) {
          if (chars[i] > 255) {
            throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);
          }
          buf2[i] = chars[i];
        }
        return buf2;
      },
      decode(buf2) {
        const chars = [];
        for (let i = 0; i < buf2.length; i += 1) {
          chars[i] = buf2[i];
        }
        return chars;
      }
    };
    exports.uint16be = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 2);
        let i = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);
          }
          buf2[i++] = char >> 8 & mask[8];
          buf2[i++] = char & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf2.length; i += 2) {
          chars.push((buf2[i] << 8) + buf2[i + 1]);
        }
        return chars;
      }
    };
    exports.uint16le = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 2);
        let i = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);
          }
          buf2[i++] = char & mask[8];
          buf2[i++] = char >> 8 & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 2 > 0) {
          throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf2.length; i += 2) {
          chars.push((buf2[i + 1] << 8) + buf2[i]);
        }
        return chars;
      }
    };
    exports.uint32be = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          buf2[i++] = char >> 24 & mask[8];
          buf2[i++] = char >> 16 & mask[8];
          buf2[i++] = char >> 8 & mask[8];
          buf2[i++] = char & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf2.length; i += 4) {
          chars.push((buf2[i] << 24) + (buf2[i + 1] << 16) + (buf2[i + 2] << 8) + buf2[i + 3]);
        }
        return chars;
      }
    };
    exports.uint32le = {
      encode(chars) {
        const buf2 = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          buf2[i++] = char & mask[8];
          buf2[i++] = char >> 8 & mask[8];
          buf2[i++] = char >> 16 & mask[8];
          buf2[i++] = char >> 24 & mask[8];
        });
        return buf2;
      },
      decode(buf2) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf2.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf2.length; i += 4) {
          chars.push((buf2[i + 3] << 24) + (buf2[i + 2] << 16) + (buf2[i + 1] << 8) + buf2[i]);
        }
        return chars;
      }
    };
    exports.string = {
      encode(chars) {
        return thisThis.utf16le.encode(chars).toString("utf16le");
      },
      decode(str) {
        return thisThis.utf16le.decode(Buffer.from(str, "utf16le"), 0);
      }
    };
    exports.escaped = {
      encode(chars) {
        const bytes = [];
        for (let i = 0; i < chars.length; i += 1) {
          const char = chars[i];
          if (char === 96) {
            bytes.push(char);
            bytes.push(char);
          } else if (char === 10) {
            bytes.push(char);
          } else if (char >= 32 && char <= 126) {
            bytes.push(char);
          } else {
            let str = "";
            if (char >= 0 && char <= 31) {
              str += `\`x${ascii2[char]}`;
            } else if (char >= 127 && char <= 255) {
              str += `\`x${ascii2[char]}`;
            } else if (char >= 256 && char <= 65535) {
              str += `\`u${ascii2[char >> 8 & mask[8]]}${ascii2[char & mask[8]]}`;
            } else if (char >= 65536 && char <= 4294967295) {
              str += "`u{";
              const digit = char >> 24 & mask[8];
              if (digit > 0) {
                str += ascii2[digit];
              }
              str += `${ascii2[char >> 16 & mask[8]] + ascii2[char >> 8 & mask[8]] + ascii2[char & mask[8]]}}`;
            } else {
              throw new Error("escape.encode(char): char > 0xffffffff not allowed");
            }
            const buf2 = Buffer.from(str);
            buf2.forEach((b) => {
              bytes.push(b);
            });
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf2) {
        function isHex2(hex) {
          if (hex >= 48 && hex <= 57 || hex >= 65 && hex <= 70 || hex >= 97 && hex <= 102) {
            return true;
          }
          return false;
        }
        __name(isHex2, "isHex");
        function getx(i2, len2, bufArg) {
          const ret2 = { char: null, nexti: i2 + 2, error: true };
          if (i2 + 1 < len2) {
            if (isHex2(bufArg[i2]) && isHex2(bufArg[i2 + 1])) {
              const str = String.fromCodePoint(bufArg[i2], bufArg[i2 + 1]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        __name(getx, "getx");
        function getu(i2, len2, bufArg) {
          const ret2 = { char: null, nexti: i2 + 4, error: true };
          if (i2 + 3 < len2) {
            if (isHex2(bufArg[i2]) && isHex2(bufArg[i2 + 1]) && isHex2(bufArg[i2 + 2]) && isHex2(bufArg[i2 + 3])) {
              const str = String.fromCodePoint(bufArg[i2], bufArg[i2 + 1], bufArg[i2 + 2], bufArg[i2 + 3]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        __name(getu, "getu");
        function getU(i2, len2, bufArg) {
          const ret2 = { char: null, nexti: i2 + 4, error: true };
          let str = "";
          while (i2 < len2 && isHex2(bufArg[i2])) {
            str += String.fromCodePoint(bufArg[i2]);
            i2 += 1;
          }
          ret2.char = parseInt(str, 16);
          if (bufArg[i2] === 125 && !Number.isNaN(ret2.char)) {
            ret2.error = false;
          }
          ret2.nexti = i2 + 1;
          return ret2;
        }
        __name(getU, "getU");
        const chars = [];
        const len = buf2.length;
        let i1;
        let ret;
        let error;
        let i = 0;
        while (i < len) {
          const TRUE = true;
          while (TRUE) {
            error = true;
            if (buf2[i] !== 96) {
              chars.push(buf2[i]);
              i += 1;
              error = false;
              break;
            }
            i1 = i + 1;
            if (i1 >= len) {
              break;
            }
            if (buf2[i1] === 96) {
              chars.push(96);
              i += 2;
              error = false;
              break;
            }
            if (buf2[i1] === 120) {
              ret = getx(i1 + 1, len, buf2);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i = ret.nexti;
              error = false;
              break;
            }
            if (buf2[i1] === 117) {
              if (buf2[i1 + 1] === 123) {
                ret = getU(i1 + 2, len, buf2);
                if (ret.error) {
                  break;
                }
                chars.push(ret.char);
                i = ret.nexti;
                error = false;
                break;
              }
              ret = getu(i1 + 1, len, buf2);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i = ret.nexti;
              error = false;
              break;
            }
            break;
          }
          if (error) {
            throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);
          }
        }
        return chars;
      }
    };
    var CR = 13;
    var LF = 10;
    exports.lineEnds = {
      crlf(chars) {
        const lfchars = [];
        let i = 0;
        while (i < chars.length) {
          switch (chars[i]) {
            case CR:
              if (i + 1 < chars.length && chars[i + 1] === LF) {
                i += 2;
              } else {
                i += 1;
              }
              lfchars.push(CR);
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(CR);
              lfchars.push(LF);
              i += 1;
              break;
            default:
              lfchars.push(chars[i]);
              i += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(CR);
          lfchars.push(LF);
        }
        return lfchars;
      },
      lf(chars) {
        const lfchars = [];
        let i = 0;
        while (i < chars.length) {
          switch (chars[i]) {
            case CR:
              if (i + 1 < chars.length && chars[i + 1] === LF) {
                i += 2;
              } else {
                i += 1;
              }
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(LF);
              i += 1;
              break;
            default:
              lfchars.push(chars[i]);
              i += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(LF);
        }
        return lfchars;
      }
    };
    exports.base64 = {
      encode(buf2) {
        if (buf2.length === 0) {
          return Buffer.alloc(0);
        }
        let i;
        let j;
        let n;
        let tail = buf2.length % 3;
        tail = tail > 0 ? 3 - tail : 0;
        let units = (buf2.length + tail) / 3;
        const base642 = Buffer.alloc(units * 4);
        if (tail > 0) {
          units -= 1;
        }
        i = 0;
        j = 0;
        for (let u = 0; u < units; u += 1) {
          n = buf2[i++] << 16;
          n += buf2[i++] << 8;
          n += buf2[i++];
          base642[j++] = base64codes[n >> 18 & mask[6]];
          base642[j++] = base64codes[n >> 12 & mask[6]];
          base642[j++] = base64codes[n >> 6 & mask[6]];
          base642[j++] = base64codes[n & mask[6]];
        }
        if (tail === 0) {
          return base642;
        }
        if (tail === 1) {
          n = buf2[i++] << 16;
          n += buf2[i] << 8;
          base642[j++] = base64codes[n >> 18 & mask[6]];
          base642[j++] = base64codes[n >> 12 & mask[6]];
          base642[j++] = base64codes[n >> 6 & mask[6]];
          base642[j] = base64codes[64];
          return base642;
        }
        if (tail === 2) {
          n = buf2[i] << 16;
          base642[j++] = base64codes[n >> 18 & mask[6]];
          base642[j++] = base64codes[n >> 12 & mask[6]];
          base642[j++] = base64codes[64];
          base642[j] = base64codes[64];
          return base642;
        }
        return void 0;
      },
      decode(codes) {
        function validate6(buf3) {
          const chars = [];
          let tail2 = 0;
          for (let i2 = 0; i2 < buf3.length; i2 += 1) {
            const char = buf3[i2];
            const TRUE = true;
            while (TRUE) {
              if (char === 32 || char === 9 || char === 10 || char === 13) {
                break;
              }
              if (char >= 65 && char <= 90) {
                chars.push(char - 65);
                break;
              }
              if (char >= 97 && char <= 122) {
                chars.push(char - 71);
                break;
              }
              if (char >= 48 && char <= 57) {
                chars.push(char + 4);
                break;
              }
              if (char === 43) {
                chars.push(62);
                break;
              }
              if (char === 47) {
                chars.push(63);
                break;
              }
              if (char === 61) {
                chars.push(64);
                tail2 += 1;
                break;
              }
              throw new RangeError(`base64.decode: invalid character buf[${i2}]: ${char}`);
            }
          }
          if (chars.length % 4 > 0) {
            throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);
          }
          switch (tail2) {
            case 0:
              break;
            case 1:
              if (chars[chars.length - 1] !== 64) {
                throw new RangeError("base64.decode: one tail character found: not last character");
              }
              break;
            case 2:
              if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {
                throw new RangeError("base64.decode: two tail characters found: not last characters");
              }
              break;
            default:
              throw new RangeError(`base64.decode: more than two tail characters found: ${tail2}`);
          }
          return { tail: tail2, buf: Buffer.from(chars) };
        }
        __name(validate6, "validate");
        if (codes.length === 0) {
          return Buffer.alloc(0);
        }
        const val = validate6(codes);
        const { tail } = val;
        const base642 = val.buf;
        let i;
        let j;
        let n;
        let units = base642.length / 4;
        const buf2 = Buffer.alloc(units * 3 - tail);
        if (tail > 0) {
          units -= 1;
        }
        j = 0;
        i = 0;
        for (let u = 0; u < units; u += 1) {
          n = base642[i++] << 18;
          n += base642[i++] << 12;
          n += base642[i++] << 6;
          n += base642[i++];
          buf2[j++] = n >> 16 & mask[8];
          buf2[j++] = n >> 8 & mask[8];
          buf2[j++] = n & mask[8];
        }
        if (tail === 1) {
          n = base642[i++] << 18;
          n += base642[i++] << 12;
          n += base642[i] << 6;
          buf2[j++] = n >> 16 & mask[8];
          buf2[j] = n >> 8 & mask[8];
        }
        if (tail === 2) {
          n = base642[i++] << 18;
          n += base642[i++] << 12;
          buf2[j] = n >> 16 & mask[8];
        }
        return buf2;
      },
      toString(buf2) {
        if (buf2.length % 4 > 0) {
          throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf2.length}`);
        }
        let str = "";
        let lineLen = 0;
        function buildLine(c1, c2, c3, c4) {
          switch (lineLen) {
            case 76:
              str += `\r
${c1}${c2}${c3}${c4}`;
              lineLen = 4;
              break;
            case 75:
              str += `${c1}\r
${c2}${c3}${c4}`;
              lineLen = 3;
              break;
            case 74:
              str += `${c1 + c2}\r
${c3}${c4}`;
              lineLen = 2;
              break;
            case 73:
              str += `${c1 + c2 + c3}\r
${c4}`;
              lineLen = 1;
              break;
            default:
              str += c1 + c2 + c3 + c4;
              lineLen += 4;
              break;
          }
        }
        __name(buildLine, "buildLine");
        function validate6(c) {
          if (c >= 65 && c <= 90) {
            return true;
          }
          if (c >= 97 && c <= 122) {
            return true;
          }
          if (c >= 48 && c <= 57) {
            return true;
          }
          if (c === 43) {
            return true;
          }
          if (c === 47) {
            return true;
          }
          if (c === 61) {
            return true;
          }
          return false;
        }
        __name(validate6, "validate");
        for (let i = 0; i < buf2.length; i += 4) {
          for (let j = i; j < i + 4; j += 1) {
            if (!validate6(buf2[j])) {
              throw new RangeError(`base64.toString: buf[${j}]: ${buf2[j]} : not valid base64 character code`);
            }
          }
          buildLine(String.fromCharCode(buf2[i]), String.fromCharCode(buf2[i + 1]), String.fromCharCode(buf2[i + 2]), String.fromCharCode(buf2[i + 3]));
        }
        return str;
      }
    };
  }
});
var require_converter = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-conv-api/converter.js"(exports) {
    "use strict;";
    var thisThis = exports;
    var trans = require_transformers();
    var UTF8 = "UTF8";
    var UTF16 = "UTF16";
    var UTF16BE = "UTF16BE";
    var UTF16LE = "UTF16LE";
    var UTF32 = "UTF32";
    var UTF32BE = "UTF32BE";
    var UTF32LE = "UTF32LE";
    var UINT7 = "UINT7";
    var ASCII = "ASCII";
    var BINARY = "BINARY";
    var UINT8 = "UINT8";
    var UINT16 = "UINT16";
    var UINT16LE = "UINT16LE";
    var UINT16BE = "UINT16BE";
    var UINT32 = "UINT32";
    var UINT32LE = "UINT32LE";
    var UINT32BE = "UINT32BE";
    var ESCAPED = "ESCAPED";
    var STRING = "STRING";
    var bom8 =  __name(function bom82(src2) {
      src2.type = UTF8;
      const buf2 = src2.data;
      src2.bom = 0;
      if (buf2.length >= 3) {
        if (buf2[0] === 239 && buf2[1] === 187 && buf2[2] === 191) {
          src2.bom = 3;
        }
      }
    }, "bom8");
    var bom16 =  __name(function bom162(src2) {
      const buf2 = src2.data;
      src2.bom = 0;
      switch (src2.type) {
        case UTF16:
          src2.type = UTF16BE;
          if (buf2.length >= 2) {
            if (buf2[0] === 254 && buf2[1] === 255) {
              src2.bom = 2;
            } else if (buf2[0] === 255 && buf2[1] === 254) {
              src2.type = UTF16LE;
              src2.bom = 2;
            }
          }
          break;
        case UTF16BE:
          src2.type = UTF16BE;
          if (buf2.length >= 2) {
            if (buf2[0] === 254 && buf2[1] === 255) {
              src2.bom = 2;
            } else if (buf2[0] === 255 && buf2[1] === 254) {
              throw new TypeError(`src type: "${UTF16BE}" specified but BOM is for "${UTF16LE}"`);
            }
          }
          break;
        case UTF16LE:
          src2.type = UTF16LE;
          if (buf2.length >= 0) {
            if (buf2[0] === 254 && buf2[1] === 255) {
              throw new TypeError(`src type: "${UTF16LE}" specified but BOM is for "${UTF16BE}"`);
            } else if (buf2[0] === 255 && buf2[1] === 254) {
              src2.bom = 2;
            }
          }
          break;
        default:
          throw new TypeError(`UTF16 BOM: src type "${src2.type}" unrecognized`);
      }
    }, "bom16");
    var bom32 =  __name(function bom322(src2) {
      const buf2 = src2.data;
      src2.bom = 0;
      switch (src2.type) {
        case UTF32:
          src2.type = UTF32BE;
          if (buf2.length >= 4) {
            if (buf2[0] === 0 && buf2[1] === 0 && buf2[2] === 254 && buf2[3] === 255) {
              src2.bom = 4;
            }
            if (buf2[0] === 255 && buf2[1] === 254 && buf2[2] === 0 && buf2[3] === 0) {
              src2.type = UTF32LE;
              src2.bom = 4;
            }
          }
          break;
        case UTF32BE:
          src2.type = UTF32BE;
          if (buf2.length >= 4) {
            if (buf2[0] === 0 && buf2[1] === 0 && buf2[2] === 254 && buf2[3] === 255) {
              src2.bom = 4;
            }
            if (buf2[0] === 255 && buf2[1] === 254 && buf2[2] === 0 && buf2[3] === 0) {
              throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}"`);
            }
          }
          break;
        case UTF32LE:
          src2.type = UTF32LE;
          if (buf2.length >= 4) {
            if (buf2[0] === 0 && buf2[1] === 0 && buf2[2] === 254 && buf2[3] === 255) {
              throw new TypeError(`src type: "${UTF32LE}" specified but BOM is for "${UTF32BE}"`);
            }
            if (buf2[0] === 255 && buf2[1] === 254 && buf2[2] === 0 && buf2[3] === 0) {
              src2.bom = 4;
            }
          }
          break;
        default:
          throw new TypeError(`UTF32 BOM: src type "${src2.type}" unrecognized`);
      }
    }, "bom32");
    var validateSrc =  __name(function validateSrc2(type, data) {
      function getType(typeArg) {
        const ret2 = {
          type: "",
          base64: false
        };
        const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;
        const result = rx.exec(typeArg);
        if (result) {
          if (result[2]) {
            ret2.type = result[2].toUpperCase();
          }
          if (result[1]) {
            ret2.base64 = true;
          }
        }
        return ret2;
      }
      __name(getType, "getType");
      if (typeof type !== "string" || type === "") {
        throw new TypeError(`type: "${type}" not recognized`);
      }
      const ret = getType(type.toUpperCase());
      if (ret.base64) {
        if (ret.type === STRING) {
          throw new TypeError(`type: "${type} "BASE64:" prefix not allowed with type ${STRING}`);
        }
        if (Buffer.isBuffer(data)) {
          ret.data = trans.base64.decode(data);
        } else if (typeof data === "string") {
          const buf2 = Buffer.from(data, "ascii");
          ret.data = trans.base64.decode(buf2);
        } else {
          throw new TypeError(`type: "${type} unrecognized data type: typeof(data): ${typeof data}`);
        }
      } else {
        ret.data = data;
      }
      switch (ret.type) {
        case UTF8:
          bom8(ret);
          break;
        case UTF16:
        case UTF16BE:
        case UTF16LE:
          bom16(ret);
          break;
        case UTF32:
        case UTF32BE:
        case UTF32LE:
          bom32(ret);
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case STRING:
        case ESCAPED:
          break;
        default:
          throw new TypeError(`type: "${type}" not recognized`);
      }
      if (ret.type === STRING) {
        if (typeof ret.data !== "string") {
          throw new TypeError(`type: "${type}" but data is not a string`);
        }
      } else if (!Buffer.isBuffer(ret.data)) {
        throw new TypeError(`type: "${type}" but data is not a Buffer`);
      }
      return ret;
    }, "validateSrc");
    var validateDst =  __name(function validateDst2(type, chars) {
      function getType(typeArg) {
        let fix;
        let rem;
        const ret2 = {
          crlf: false,
          lf: false,
          base64: false,
          type: ""
        };
        const TRUE = true;
        while (TRUE) {
          rem = typeArg;
          fix = typeArg.slice(0, 5);
          if (fix === "CRLF:") {
            ret2.crlf = true;
            rem = typeArg.slice(5);
            break;
          }
          fix = typeArg.slice(0, 3);
          if (fix === "LF:") {
            ret2.lf = true;
            rem = typeArg.slice(3);
            break;
          }
          break;
        }
        fix = rem.split(":");
        if (fix.length === 1) {
          ret2.type = fix[0];
        } else if (fix.length === 2 && fix[1] === "BASE64") {
          ret2.base64 = true;
          ret2.type = fix[0];
        }
        return ret2;
      }
      __name(getType, "getType");
      if (!Array.isArray(chars)) {
        throw new TypeError(`dst chars: not array: "${typeof chars}`);
      }
      if (typeof type !== "string") {
        throw new TypeError(`dst type: not string: "${typeof type}`);
      }
      const ret = getType(type.toUpperCase());
      switch (ret.type) {
        case UTF8:
        case UTF16BE:
        case UTF16LE:
        case UTF32BE:
        case UTF32LE:
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case ESCAPED:
          break;
        case STRING:
          if (ret.base64) {
            throw new TypeError(`":BASE64" suffix not allowed with type ${STRING}`);
          }
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UTF16:
          ret.type = UTF16BE;
          break;
        case UTF32:
          ret.type = UTF32BE;
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        default:
          throw new TypeError(`dst type unrecognized: "${type}" : must have form [crlf:|lf:]type[:base64]`);
      }
      return ret;
    }, "validateDst");
    var encode11 =  __name(function encode12(type, chars) {
      switch (type) {
        case UTF8:
          return trans.utf8.encode(chars);
        case UTF16BE:
          return trans.utf16be.encode(chars);
        case UTF16LE:
          return trans.utf16le.encode(chars);
        case UTF32BE:
          return trans.utf32be.encode(chars);
        case UTF32LE:
          return trans.utf32le.encode(chars);
        case UINT7:
          return trans.uint7.encode(chars);
        case UINT8:
          return trans.uint8.encode(chars);
        case UINT16BE:
          return trans.uint16be.encode(chars);
        case UINT16LE:
          return trans.uint16le.encode(chars);
        case UINT32BE:
          return trans.uint32be.encode(chars);
        case UINT32LE:
          return trans.uint32le.encode(chars);
        case STRING:
          return trans.string.encode(chars);
        case ESCAPED:
          return trans.escaped.encode(chars);
        default:
          throw new TypeError(`encode type "${type}" not recognized`);
      }
    }, "encode");
    var decode10 =  __name(function decode11(src2) {
      switch (src2.type) {
        case UTF8:
          return trans.utf8.decode(src2.data, src2.bom);
        case UTF16LE:
          return trans.utf16le.decode(src2.data, src2.bom);
        case UTF16BE:
          return trans.utf16be.decode(src2.data, src2.bom);
        case UTF32BE:
          return trans.utf32be.decode(src2.data, src2.bom);
        case UTF32LE:
          return trans.utf32le.decode(src2.data, src2.bom);
        case UINT7:
          return trans.uint7.decode(src2.data);
        case UINT8:
          return trans.uint8.decode(src2.data);
        case UINT16BE:
          return trans.uint16be.decode(src2.data);
        case UINT16LE:
          return trans.uint16le.decode(src2.data);
        case UINT32BE:
          return trans.uint32be.decode(src2.data);
        case UINT32LE:
          return trans.uint32le.decode(src2.data);
        case STRING:
          return trans.string.decode(src2.data);
        case ESCAPED:
          return trans.escaped.decode(src2.data);
        default:
          throw new TypeError(`decode type "${src2.type}" not recognized`);
      }
    }, "decode");
    exports.decode =  __name(function exportsDecode(type, data) {
      const src2 = validateSrc(type, data);
      return decode10(src2);
    }, "exportsDecode");
    exports.encode =  __name(function exportsEncode(type, chars) {
      let c;
      let buf2;
      const dst = validateDst(type, chars);
      if (dst.crlf) {
        c = trans.lineEnds.crlf(chars);
        buf2 = encode11(dst.type, c);
      } else if (dst.lf) {
        c = trans.lineEnds.lf(chars);
        buf2 = encode11(dst.type, c);
      } else {
        buf2 = encode11(dst.type, chars);
      }
      if (dst.base64) {
        buf2 = trans.base64.encode(buf2);
      }
      return buf2;
    }, "exportsEncode");
    exports.convert =  __name(function convert(srcType, srcData, dstType) {
      return thisThis.encode(dstType, thisThis.decode(srcType, srcData));
    }, "convert");
  }
});
var require_emitcss = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/emitcss.js"(exports, module) {
    module.exports =  __name(function emittcss() {
      return "/* This file automatically generated by jsonToless() and LESS. */\n.apg-mono {\n  font-family: monospace;\n}\n.apg-active {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-match {\n  font-weight: bold;\n  color: #264BFF;\n}\n.apg-empty {\n  font-weight: bold;\n  color: #0fbd0f;\n}\n.apg-nomatch {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-lh-match {\n  font-weight: bold;\n  color: #1A97BA;\n}\n.apg-lb-match {\n  font-weight: bold;\n  color: #5F1687;\n}\n.apg-remainder {\n  font-weight: bold;\n  color: #999999;\n}\n.apg-ctrl-char {\n  font-weight: bolder;\n  font-style: italic;\n  font-size: 0.6em;\n}\n.apg-line-end {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-error {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-phrase {\n  color: #000000;\n  background-color: #8caae6;\n}\n.apg-empty-phrase {\n  color: #0fbd0f;\n}\ntable.apg-state {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th,\ntable.apg-state td {\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th:nth-last-child(2),\ntable.apg-state td:nth-last-child(2) {\n  text-align: right;\n}\ntable.apg-state caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-stats {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats th,\ntable.apg-stats td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace th,\ntable.apg-trace td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace th:last-child,\ntable.apg-trace th:nth-last-child(2),\ntable.apg-trace td:last-child,\ntable.apg-trace td:nth-last-child(2) {\n  text-align: left;\n}\ntable.apg-grammar {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-grammar th,\ntable.apg-grammar td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar th:last-child,\ntable.apg-grammar td:last-child {\n  text-align: left;\n}\ntable.apg-rules {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-rules th,\ntable.apg-rules td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules a {\n  color: #003399 !important;\n}\ntable.apg-rules a:hover {\n  color: #8caae6 !important;\n}\ntable.apg-attrs {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-attrs th,\ntable.apg-attrs td {\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs th:nth-child(1),\ntable.apg-attrs th:nth-child(2),\ntable.apg-attrs th:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs td:nth-child(1),\ntable.apg-attrs td:nth-child(2),\ntable.apg-attrs td:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs a {\n  color: #003399 !important;\n}\ntable.apg-attrs a:hover {\n  color: #8caae6 !important;\n}\n";
    }, "emittcss");
  }
});
var require_utilities = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/utilities.js"(exports) {
    var style = require_style();
    var converter = require_converter();
    var emitCss = require_emitcss();
    var id = require_identifiers();
    var thisFileName = "utilities.js: ";
    var thisThis = exports;
    var getBounds =  __name(function(length2, begArg, len) {
      let end;
      let beg = begArg;
      const TRUE = true;
      while (TRUE) {
        if (length2 <= 0) {
          beg = 0;
          end = 0;
          break;
        }
        if (typeof beg !== "number") {
          beg = 0;
          end = length2;
          break;
        }
        if (beg >= length2) {
          beg = length2;
          end = length2;
          break;
        }
        if (typeof len !== "number") {
          end = length2;
          break;
        }
        end = beg + len;
        if (end > length2) {
          end = length2;
          break;
        }
        break;
      }
      return {
        beg,
        end
      };
    }, "getBounds");
    exports.htmlToPage = function(html, titleArg) {
      let title;
      if (typeof html !== "string") {
        throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);
      }
      if (typeof titleArg !== "string") {
        title = "htmlToPage";
      } else {
        title = titleArg;
      }
      let page = "";
      page += "<!DOCTYPE html>\n";
      page += '<html lang="en">\n';
      page += "<head>\n";
      page += '<meta charset="utf-8">\n';
      page += `<title>${title}</title>
`;
      page += "<style>\n";
      page += emitCss();
      page += "</style>\n";
      page += "</head>\n<body>\n";
      page += `<p>${new Date()}</p>
`;
      page += html;
      page += "</body>\n</html>\n";
      return page;
    };
    exports.parserResultToHtml = function(result, caption) {
      let cap = null;
      if (typeof caption === "string" && caption !== "") {
        cap = caption;
      }
      let success;
      let state;
      if (result.success === true) {
        success = `<span class="${style.CLASS_MATCH}">true</span>`;
      } else {
        success = `<span class="${style.CLASS_NOMATCH}">false</span>`;
      }
      if (result.state === id.EMPTY) {
        state = `<span class="${style.CLASS_EMPTY}">EMPTY</span>`;
      } else if (result.state === id.MATCH) {
        state = `<span class="${style.CLASS_MATCH}">MATCH</span>`;
      } else if (result.state === id.NOMATCH) {
        state = `<span class="${style.CLASS_NOMATCH}">NOMATCH</span>`;
      } else {
        state = `<span class="${style.CLASS_NOMATCH}">unrecognized</span>`;
      }
      let html = "";
      html += `<table class="${style.CLASS_STATE}">
`;
      if (cap) {
        html += `<caption>${cap}</caption>
`;
      }
      html += "<tr><th>state item</th><th>value</th><th>description</th></tr>\n";
      html += `<tr><td>parser success</td><td>${success}</td>
`;
      html += `<td><span class="${style.CLASS_MATCH}">true</span> if the parse succeeded,
`;
      html += ` <span class="${style.CLASS_NOMATCH}">false</span> otherwise`;
      html += "<br><i>NOTE: for success, entire string must be matched</i></td></tr>\n";
      html += `<tr><td>parser state</td><td>${state}</td>
`;
      html += `<td><span class="${style.CLASS_EMPTY}">EMPTY</span>, `;
      html += `<span class="${style.CLASS_MATCH}">MATCH</span> or 
`;
      html += `<span class="${style.CLASS_NOMATCH}">NOMATCH</span></td></tr>
`;
      html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>
`;
      html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>
`;
      html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>
`;
      html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>
`;
      html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>
`;
      html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>
`;
      html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>
`;
      html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>
`;
      html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>
`;
      html += "</table>\n";
      return html;
    };
    exports.charsToString = function(chars, phraseIndex, phraseLength) {
      let beg;
      let end;
      if (typeof phraseIndex === "number") {
        if (phraseIndex >= chars.length) {
          return "";
        }
        beg = phraseIndex < 0 ? 0 : phraseIndex;
      } else {
        beg = 0;
      }
      if (typeof phraseLength === "number") {
        if (phraseLength <= 0) {
          return "";
        }
        end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;
      } else {
        end = chars.length;
      }
      if (beg < end) {
        return converter.encode("UTF16LE", chars.slice(beg, end)).toString("utf16le");
      }
      return "";
    };
    exports.stringToChars = function(string2) {
      return converter.decode("STRING", string2);
    };
    exports.opcodeToString = function(type) {
      let ret = "unknown";
      switch (type) {
        case id.ALT:
          ret = "ALT";
          break;
        case id.CAT:
          ret = "CAT";
          break;
        case id.RNM:
          ret = "RNM";
          break;
        case id.UDT:
          ret = "UDT";
          break;
        case id.AND:
          ret = "AND";
          break;
        case id.NOT:
          ret = "NOT";
          break;
        case id.REP:
          ret = "REP";
          break;
        case id.TRG:
          ret = "TRG";
          break;
        case id.TBS:
          ret = "TBS";
          break;
        case id.TLS:
          ret = "TLS";
          break;
        case id.BKR:
          ret = "BKR";
          break;
        case id.BKA:
          ret = "BKA";
          break;
        case id.BKN:
          ret = "BKN";
          break;
        case id.ABG:
          ret = "ABG";
          break;
        case id.AEN:
          ret = "AEN";
          break;
        default:
          throw new Error("unrecognized opcode");
      }
      return ret;
    };
    exports.stateToString = function(state) {
      let ret = "unknown";
      switch (state) {
        case id.ACTIVE:
          ret = "ACTIVE";
          break;
        case id.MATCH:
          ret = "MATCH";
          break;
        case id.EMPTY:
          ret = "EMPTY";
          break;
        case id.NOMATCH:
          ret = "NOMATCH";
          break;
        default:
          throw new Error("unrecognized state");
      }
      return ret;
    };
    exports.asciiChars = [
      "NUL",
      "SOH",
      "STX",
      "ETX",
      "EOT",
      "ENQ",
      "ACK",
      "BEL",
      "BS",
      "TAB",
      "LF",
      "VT",
      "FF",
      "CR",
      "SO",
      "SI",
      "DLE",
      "DC1",
      "DC2",
      "DC3",
      "DC4",
      "NAK",
      "SYN",
      "ETB",
      "CAN",
      "EM",
      "SUB",
      "ESC",
      "FS",
      "GS",
      "RS",
      "US",
      "&nbsp;",
      "!",
      "&#34;",
      "#",
      "$",
      "%",
      "&#38;",
      "&#39;",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ":",
      ";",
      "&#60;",
      "=",
      "&#62;",
      "?",
      "@",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "[",
      "&#92;",
      "]",
      "^",
      "_",
      "`",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "{",
      "|",
      "}",
      "~",
      "DEL"
    ];
    exports.charToHex = function(char) {
      let ch = char.toString(16).toUpperCase();
      switch (ch.length) {
        case 1:
        case 3:
        case 7:
          ch = `0${ch}`;
          break;
        case 2:
        case 6:
          ch = `00${ch}`;
          break;
        case 4:
          break;
        case 5:
          ch = `000${ch}`;
          break;
        default:
          throw new Error("unrecognized option");
      }
      return ch;
    };
    exports.charsToDec = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += chars[bounds.beg];
        for (let i = bounds.beg + 1; i < bounds.end; i += 1) {
          ret += `,${chars[i]}`;
        }
      }
      return ret;
    };
    exports.charsToHex = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\x${thisThis.charToHex(chars[bounds.beg])}`;
        for (let i = bounds.beg + 1; i < bounds.end; i += 1) {
          ret += `,\\x${thisThis.charToHex(chars[i])}`;
        }
      }
      return ret;
    };
    exports.charsToHtmlEntities = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i = bounds.beg; i < bounds.end; i += 1) {
          ret += `&#x${chars[i].toString(16)};`;
        }
      }
      return ret;
    };
    function isUnicode(char) {
      if (char >= 55296 && char <= 57343) {
        return false;
      }
      if (char > 1114111) {
        return false;
      }
      return true;
    }
    __name(isUnicode, "isUnicode");
    exports.charsToUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i = bounds.beg; i < bounds.end; i += 1) {
          if (isUnicode(chars[i])) {
            ret += `&#${chars[i]};`;
          } else {
            ret += ` U+${thisThis.charToHex(chars[i])}`;
          }
        }
      }
      return ret;
    };
    exports.charsToJsUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\u${thisThis.charToHex(chars[bounds.beg])}`;
        for (let i = bounds.beg + 1; i < bounds.end; i += 1) {
          ret += `,\\u${thisThis.charToHex(chars[i])}`;
        }
      }
      return ret;
    };
    exports.charsToAscii = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      for (let i = bounds.beg; i < bounds.end; i += 1) {
        const char = chars[i];
        if (char >= 32 && char <= 126) {
          ret += String.fromCharCode(char);
        } else {
          ret += `\\x${thisThis.charToHex(char)}`;
        }
      }
      return ret;
    };
    exports.charsToAsciiHtml = function(chars, beg, len) {
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);
      }
      let html = "";
      let char;
      const bounds = getBounds(chars.length, beg, len);
      for (let i = bounds.beg; i < bounds.end; i += 1) {
        char = chars[i];
        if (char < 32 || char === 127) {
          html += `<span class="${style.CLASS_CTRLCHAR}">${thisThis.asciiChars[char]}</span>`;
        } else if (char > 127) {
          html += `<span class="${style.CLASS_CTRLCHAR}">U+${thisThis.charToHex(char)}</span>`;
        } else {
          html += thisThis.asciiChars[char];
        }
      }
      return html;
    };
    exports.stringToAsciiHtml = function(str) {
      const chars = converter.decode("STRING", str);
      return this.charsToAsciiHtml(chars);
    };
  }
});
var require_ast = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/ast.js"(exports, module) {
    module.exports =  __name(function exportsAst() {
      const id = require_identifiers();
      const utils = require_utilities();
      const thisFileName = "ast.js: ";
      const that = this;
      let rules = null;
      let udts = null;
      let chars = null;
      let nodeCount = 0;
      const nodesDefined = [];
      const nodeCallbacks = [];
      const stack = [];
      const records = [];
      this.callbacks = [];
      this.astObject = "astObject";
      this.init =  __name(function init4(rulesIn, udtsIn, charsIn) {
        stack.length = 0;
        records.length = 0;
        nodesDefined.length = 0;
        nodeCount = 0;
        rules = rulesIn;
        udts = udtsIn;
        chars = charsIn;
        let i;
        const list = [];
        for (i = 0; i < rules.length; i += 1) {
          list.push(rules[i].lower);
        }
        for (i = 0; i < udts.length; i += 1) {
          list.push(udts[i].lower);
        }
        nodeCount = rules.length + udts.length;
        for (i = 0; i < nodeCount; i += 1) {
          nodesDefined[i] = false;
          nodeCallbacks[i] = null;
        }
        for (const index in that.callbacks) {
          const lower = index.toLowerCase();
          i = list.indexOf(lower);
          if (i < 0) {
            throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);
          }
          if (typeof that.callbacks[index] === "function") {
            nodesDefined[i] = true;
            nodeCallbacks[i] = that.callbacks[index];
          }
          if (that.callbacks[index] === true) {
            nodesDefined[i] = true;
          }
        }
      }, "init");
      this.ruleDefined =  __name(function ruleDefined(index) {
        return nodesDefined[index] !== false;
      }, "ruleDefined");
      this.udtDefined =  __name(function udtDefined(index) {
        return nodesDefined[rules.length + index] !== false;
      }, "udtDefined");
      this.down =  __name(function down(callbackIndex, name5) {
        const thisIndex = records.length;
        stack.push(thisIndex);
        records.push({
          name: name5,
          thisIndex,
          thatIndex: null,
          state: id.SEM_PRE,
          callbackIndex,
          phraseIndex: null,
          phraseLength: null,
          stack: stack.length
        });
        return thisIndex;
      }, "down");
      this.up =  __name(function up(callbackIndex, name5, phraseIndex, phraseLength) {
        const thisIndex = records.length;
        const thatIndex = stack.pop();
        records.push({
          name: name5,
          thisIndex,
          thatIndex,
          state: id.SEM_POST,
          callbackIndex,
          phraseIndex,
          phraseLength,
          stack: stack.length
        });
        records[thatIndex].thatIndex = thisIndex;
        records[thatIndex].phraseIndex = phraseIndex;
        records[thatIndex].phraseLength = phraseLength;
        return thisIndex;
      }, "up");
      this.translate =  __name(function translate(data) {
        let ret;
        let callback;
        let record;
        for (let i = 0; i < records.length; i += 1) {
          record = records[i];
          callback = nodeCallbacks[record.callbackIndex];
          if (record.state === id.SEM_PRE) {
            if (callback !== null) {
              ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);
              if (ret === id.SEM_SKIP) {
                i = record.thatIndex;
              }
            }
          } else if (callback !== null) {
            callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);
          }
        }
      }, "translate");
      this.setLength =  __name(function setLength(length2) {
        records.length = length2;
        if (length2 > 0) {
          stack.length = records[length2 - 1].stack;
        } else {
          stack.length = 0;
        }
      }, "setLength");
      this.getLength =  __name(function getLength2() {
        return records.length;
      }, "getLength");
      function indent(n) {
        let ret = "";
        for (let i = 0; i < n; i += 1) {
          ret += " ";
        }
        return ret;
      }
      __name(indent, "indent");
      this.toXml =  __name(function toSml(modeArg) {
        let display = utils.charsToDec;
        let caption = "decimal integer character codes";
        if (typeof modeArg === "string" && modeArg.length >= 3) {
          const mode = modeArg.slice(0, 3).toLowerCase();
          if (mode === "asc") {
            display = utils.charsToAscii;
            caption = "ASCII for printing characters, hex for non-printing";
          } else if (mode === "hex") {
            display = utils.charsToHex;
            caption = "hexadecimal integer character codes";
          } else if (mode === "uni") {
            display = utils.charsToUnicode;
            caption = "Unicode UTF-32 integer character codes";
          }
        }
        let xml = "";
        let depth = 0;
        xml += '<?xml version="1.0" encoding="utf-8"?>\n';
        xml += `<root nodes="${records.length / 2}" characters="${chars.length}">
`;
        xml += `< !-- input string, ${caption} -- >
`;
        xml += indent(depth + 2);
        xml += display(chars);
        xml += "\n";
        records.forEach((rec) => {
          if (rec.state === id.SEM_PRE) {
            depth += 1;
            xml += indent(depth);
            xml += `<node name="${rec.name}" index="${rec.phraseIndex}" length="${rec.phraseLength}">
`;
            xml += indent(depth + 2);
            xml += display(chars, rec.phraseIndex, rec.phraseLength);
            xml += "\n";
          } else {
            xml += indent(depth);
            xml += `</node>< !-- name="${rec.name}" -- >
`;
            depth -= 1;
          }
        });
        xml += "</root>\n";
        return xml;
      }, "toSml");
      this.phrases =  __name(function phrases() {
        const obj = {};
        let i;
        let record;
        for (i = 0; i < records.length; i += 1) {
          record = records[i];
          if (record.state === id.SEM_PRE) {
            if (!Array.isArray(obj[record.name])) {
              obj[record.name] = [];
            }
            obj[record.name].push({
              index: record.phraseIndex,
              length: record.phraseLength
            });
          }
        }
        return obj;
      }, "phrases");
    }, "exportsAst");
  }
});
var require_circular_buffer = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/circular-buffer.js"(exports, module) {
    module.exports =  __name(function exportsCircularBuffer() {
      "use strict;";
      const thisFileName = "circular-buffer.js: ";
      let itemIndex = -1;
      let maxListSize = 0;
      this.init =  __name(function init4(size) {
        if (typeof size !== "number" || size <= 0) {
          throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);
        }
        maxListSize = Math.ceil(size);
        itemIndex = -1;
      }, "init");
      this.increment =  __name(function increment() {
        itemIndex += 1;
        return (itemIndex + maxListSize) % maxListSize;
      }, "increment");
      this.maxSize =  __name(function maxSize() {
        return maxListSize;
      }, "maxSize");
      this.items =  __name(function items() {
        return itemIndex + 1;
      }, "items");
      this.getListIndex =  __name(function getListIndex(item) {
        if (itemIndex === -1) {
          return -1;
        }
        if (item < 0 || item > itemIndex) {
          return -1;
        }
        if (itemIndex - item >= maxListSize) {
          return -1;
        }
        return (item + maxListSize) % maxListSize;
      }, "getListIndex");
      this.forEach =  __name(function forEach(fn) {
        if (itemIndex === -1) {
          return;
        }
        if (itemIndex < maxListSize) {
          for (let i = 0; i <= itemIndex; i += 1) {
            fn(i, i);
          }
          return;
        }
        for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {
          const listIndex = (i + maxListSize) % maxListSize;
          fn(listIndex, i);
        }
      }, "forEach");
    }, "exportsCircularBuffer");
  }
});
var require_parser = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/parser.js"(exports, module) {
    module.exports =  __name(function parser() {
      const id = require_identifiers();
      const utils = require_utilities();
      const thisFileName = "parser.js: ";
      const thisThis = this;
      let opExecute;
      this.ast = null;
      this.stats = null;
      this.trace = null;
      this.callbacks = [];
      let opcodes = null;
      let chars = null;
      let charsBegin;
      let charsLength;
      let charsEnd;
      let lookAround;
      let treeDepth = 0;
      let maxTreeDepth = 0;
      let nodeHits = 0;
      let ruleCallbacks = null;
      let udtCallbacks = null;
      let rules = null;
      let udts = null;
      let syntaxData = null;
      let maxMatched = 0;
      let limitTreeDepth = Infinity;
      let limitNodeHits = Infinity;
      const evaluateRule =  __name(function evaluateRule2(ruleIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateRule(): `;
        if (ruleIndex >= rules.length) {
          throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length: length2 } = opcodes;
        opcodes.push({
          type: id.RNM,
          index: ruleIndex
        });
        opExecute(length2, phraseIndex, sysData);
        opcodes.pop();
      }, "evaluateRule");
      const evaluateUdt =  __name(function(udtIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateUdt(): `;
        if (udtIndex >= udts.length) {
          throw new Error(`${functionName}udt index: ${udtIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length: length2 } = opcodes;
        opcodes.push({
          type: id.UDT,
          empty: udts[udtIndex].empty,
          index: udtIndex
        });
        opExecute(length2, phraseIndex, sysData);
        opcodes.pop();
      }, "evaluateUdt");
      const clear =  __name(function() {
        treeDepth = 0;
        maxTreeDepth = 0;
        nodeHits = 0;
        maxMatched = 0;
        lookAround = [
          {
            lookAround: id.LOOKAROUND_NONE,
            anchor: 0,
            charsEnd: 0,
            charsLength: 0
          }
        ];
        rules = null;
        udts = null;
        chars = null;
        charsBegin = 0;
        charsLength = 0;
        charsEnd = 0;
        ruleCallbacks = null;
        udtCallbacks = null;
        syntaxData = null;
        opcodes = null;
      }, "clear");
      const backRef =  __name(function() {
        const stack = [];
        const init4 =  __name(function() {
          const obj = {};
          rules.forEach((rule) => {
            if (rule.isBkr) {
              obj[rule.lower] = null;
            }
          });
          if (udts.length > 0) {
            udts.forEach((udt) => {
              if (udt.isBkr) {
                obj[udt.lower] = null;
              }
            });
          }
          stack.push(obj);
        }, "init");
        const copy =  __name(function() {
          const top = stack[stack.length - 1];
          const obj = {};
          for (const name5 in top) {
            obj[name5] = top[name5];
          }
          return obj;
        }, "copy");
        this.push =  __name(function push() {
          stack.push(copy());
        }, "push");
        this.pop =  __name(function pop(lengthArg) {
          let length2 = lengthArg;
          if (!length2) {
            length2 = stack.length - 1;
          }
          if (length2 < 1 || length2 > stack.length) {
            throw new Error(`${thisFileName}backRef.pop(): bad length: ${length2}`);
          }
          stack.length = length2;
          return stack[stack.length - 1];
        }, "pop");
        this.length =  __name(function length2() {
          return stack.length;
        }, "length");
        this.savePhrase =  __name(function savePhrase(name5, index, length2) {
          stack[stack.length - 1][name5] = {
            phraseIndex: index,
            phraseLength: length2
          };
        }, "savePhrase");
        this.getPhrase = function(name5) {
          return stack[stack.length - 1][name5];
        };
        init4();
      }, "backRef");
      const systemData =  __name(function systemData2() {
        const thisData = this;
        this.state = id.ACTIVE;
        this.phraseLength = 0;
        this.ruleIndex = 0;
        this.udtIndex = 0;
        this.lookAround = lookAround[lookAround.length - 1];
        this.uFrame = new backRef();
        this.pFrame = new backRef();
        this.evaluateRule = evaluateRule;
        this.evaluateUdt = evaluateUdt;
        this.refresh =  __name(function refresh() {
          thisData.state = id.ACTIVE;
          thisData.phraseLength = 0;
          thisData.lookAround = lookAround[lookAround.length - 1];
        }, "refresh");
      }, "systemData");
      const lookAroundValue =  __name(function lookAroundValue2() {
        return lookAround[lookAround.length - 1];
      }, "lookAroundValue");
      const inLookAround =  __name(function inLookAround2() {
        return lookAround.length > 1;
      }, "inLookAround");
      const inLookBehind =  __name(function() {
        return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;
      }, "inLookBehind");
      const initializeAst =  __name(function() {
        const functionName = `${thisFileName}initializeAst(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.ast === void 0) {
            thisThis.ast = null;
            break;
          }
          if (thisThis.ast === null) {
            break;
          }
          if (thisThis.ast.astObject !== "astObject") {
            throw new Error(`${functionName}ast object not recognized`);
          }
          break;
        }
        if (thisThis.ast !== null) {
          thisThis.ast.init(rules, udts, chars);
        }
      }, "initializeAst");
      const initializeTrace =  __name(function() {
        const functionName = `${thisFileName}initializeTrace(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.trace === void 0) {
            thisThis.trace = null;
            break;
          }
          if (thisThis.trace === null) {
            break;
          }
          if (thisThis.trace.traceObject !== "traceObject") {
            throw new Error(`${functionName}trace object not recognized`);
          }
          break;
        }
        if (thisThis.trace !== null) {
          thisThis.trace.init(rules, udts, chars);
        }
      }, "initializeTrace");
      const initializeStats =  __name(function() {
        const functionName = `${thisFileName}initializeStats(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.stats === void 0) {
            thisThis.stats = null;
            break;
          }
          if (thisThis.stats === null) {
            break;
          }
          if (thisThis.stats.statsObject !== "statsObject") {
            throw new Error(`${functionName}stats object not recognized`);
          }
          break;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.init(rules, udts);
        }
      }, "initializeStats");
      const initializeGrammar =  __name(function(grammar) {
        const functionName = `${thisFileName}initializeGrammar(): `;
        if (!grammar) {
          throw new Error(`${functionName}grammar object undefined`);
        }
        if (grammar.grammarObject !== "grammarObject") {
          throw new Error(`${functionName}bad grammar object`);
        }
        rules = grammar.rules;
        udts = grammar.udts;
      }, "initializeGrammar");
      const initializeStartRule =  __name(function(startRule) {
        const functionName = `${thisFileName}initializeStartRule(): `;
        let start = null;
        if (typeof startRule === "number") {
          if (startRule >= rules.length) {
            throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);
          }
          start = startRule;
        } else if (typeof startRule === "string") {
          const lower = startRule.toLowerCase();
          for (let i = 0; i < rules.length; i += 1) {
            if (lower === rules[i].lower) {
              start = rules[i].index;
              break;
            }
          }
          if (start === null) {
            throw new Error(`${functionName}start rule name '${startRule}' not recognized`);
          }
        } else {
          throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);
        }
        return start;
      }, "initializeStartRule");
      const initializeInputChars =  __name(function initializeInputChars2(inputArg, begArg, lenArg) {
        const functionName = `${thisFileName}initializeInputChars(): `;
        let input = inputArg;
        let beg = begArg;
        let len = lenArg;
        if (input === void 0) {
          throw new Error(`${functionName}input string is undefined`);
        }
        if (input === null) {
          throw new Error(`${functionName}input string is null`);
        }
        if (typeof input === "string") {
          input = utils.stringToChars(input);
        } else if (!Array.isArray(input)) {
          throw new Error(`${functionName}input string is not a string or array`);
        }
        if (input.length > 0) {
          if (typeof input[0] !== "number") {
            throw new Error(`${functionName}input string not an array of integers`);
          }
        }
        if (typeof beg !== "number") {
          beg = 0;
        } else {
          beg = Math.floor(beg);
          if (beg < 0 || beg > input.length) {
            throw new Error(`${functionName}input beginning index out of range: ${beg}`);
          }
        }
        if (typeof len !== "number") {
          len = input.length - beg;
        } else {
          len = Math.floor(len);
          if (len < 0 || len > input.length - beg) {
            throw new Error(`${functionName}input length out of range: ${len}`);
          }
        }
        chars = input;
        charsBegin = beg;
        charsLength = len;
        charsEnd = charsBegin + charsLength;
      }, "initializeInputChars");
      const initializeCallbacks =  __name(function() {
        const functionName = `${thisFileName}initializeCallbacks(): `;
        let i;
        ruleCallbacks = [];
        udtCallbacks = [];
        for (i = 0; i < rules.length; i += 1) {
          ruleCallbacks[i] = null;
        }
        for (i = 0; i < udts.length; i += 1) {
          udtCallbacks[i] = null;
        }
        let func;
        const list = [];
        for (i = 0; i < rules.length; i += 1) {
          list.push(rules[i].lower);
        }
        for (i = 0; i < udts.length; i += 1) {
          list.push(udts[i].lower);
        }
        for (const index in thisThis.callbacks) {
          i = list.indexOf(index.toLowerCase());
          if (i < 0) {
            throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);
          }
          func = thisThis.callbacks[index];
          if (!func) {
            func = null;
          }
          if (typeof func === "function" || func === null) {
            if (i < rules.length) {
              ruleCallbacks[i] = func;
            } else {
              udtCallbacks[i - rules.length] = func;
            }
          } else {
            throw new Error(`${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`);
          }
        }
        for (i = 0; i < udts.length; i += 1) {
          if (udtCallbacks[i] === null) {
            throw new Error(`${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`);
          }
        }
      }, "initializeCallbacks");
      this.setMaxTreeDepth = function(depth) {
        if (typeof depth !== "number") {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
        limitTreeDepth = Math.floor(depth);
        if (limitTreeDepth <= 0) {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
      };
      this.setMaxNodeHits = function(hits) {
        if (typeof hits !== "number") {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
        limitNodeHits = Math.floor(hits);
        if (limitNodeHits <= 0) {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
      };
      const privateParse =  __name(function(grammar, startRuleArg, callbackData) {
        let success;
        const functionName = `${thisFileName}parse(): `;
        initializeGrammar(grammar);
        const startRule = initializeStartRule(startRuleArg);
        initializeCallbacks();
        initializeTrace();
        initializeStats();
        initializeAst();
        const sysData = new systemData();
        if (!(callbackData === void 0 || callbackData === null)) {
          syntaxData = callbackData;
        }
        opcodes = [
          {
            type: id.RNM,
            index: startRule
          }
        ];
        opExecute(0, charsBegin, sysData);
        opcodes = null;
        switch (sysData.state) {
          case id.ACTIVE:
            throw new Error(`${functionName}final state should never be 'ACTIVE'`);
          case id.NOMATCH:
            success = false;
            break;
          case id.EMPTY:
          case id.MATCH:
            if (sysData.phraseLength === charsLength) {
              success = true;
            } else {
              success = false;
            }
            break;
          default:
            throw new Error("unrecognized state");
        }
        return {
          success,
          state: sysData.state,
          length: charsLength,
          matched: sysData.phraseLength,
          maxMatched,
          maxTreeDepth,
          nodeHits,
          inputLength: chars.length,
          subBegin: charsBegin,
          subEnd: charsEnd,
          subLength: charsLength
        };
      }, "privateParse");
      this.parseSubstring =  __name(function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {
        clear();
        initializeInputChars(inputChars, inputIndex, inputLength);
        return privateParse(grammar, startRule, callbackData);
      }, "parseSubstring");
      this.parse =  __name(function parse2(grammar, startRule, inputChars, callbackData) {
        clear();
        initializeInputChars(inputChars, 0, inputChars.length);
        return privateParse(grammar, startRule, callbackData);
      }, "parse");
      const opALT =  __name(function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        for (let i = 0; i < op.children.length; i += 1) {
          opExecute(op.children[i], phraseIndex, sysData);
          if (sysData.state !== id.NOMATCH) {
            break;
          }
        }
      }, "opALT");
      const opCAT =  __name(function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catPhrase;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catPhrase = 0;
        for (let i = 0; i < op.children.length; i += 1) {
          opExecute(op.children[i], catCharIndex, sysData);
          if (sysData.state === id.NOMATCH) {
            success = false;
            break;
          } else {
            catCharIndex += sysData.phraseLength;
            catPhrase += sysData.phraseLength;
          }
        }
        if (success) {
          sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = catPhrase;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opCAT");
      const opREP =  __name(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex >= charsEnd) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id.NOMATCH) {
            break;
          }
          if (sysData.state === id.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex += sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id.EMPTY) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opREP");
      const validateRnmCallbackResult =  __name(function(rule, sysData, charsLeft, down) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id.ACTIVE:
            if (down !== true) {
              throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`);
            }
            break;
          case id.EMPTY:
            sysData.phraseLength = 0;
            break;
          case id.MATCH:
            if (sysData.phraseLength === 0) {
              sysData.state = id.EMPTY;
            }
            break;
          case id.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`);
        }
      }, "validateRnmCallbackResult");
      const opRNM =  __name(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astDefined;
        let savedOpcodes;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const rule = rules[op.index];
        const callback = ruleCallbacks[rule.index];
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);
          if (astDefined) {
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(op.index, rules[op.index].name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        if (callback === null) {
          savedOpcodes = opcodes;
          opcodes = rule.opcodes;
          opExecute(0, phraseIndex, sysData);
          opcodes = savedOpcodes;
        } else {
          const charsLeft = charsEnd - phraseIndex;
          sysData.ruleIndex = rule.index;
          callback(sysData, chars, phraseIndex, syntaxData);
          validateRnmCallbackResult(rule, sysData, charsLeft, true);
          if (sysData.state === id.ACTIVE) {
            savedOpcodes = opcodes;
            opcodes = rule.opcodes;
            opExecute(0, phraseIndex, sysData);
            opcodes = savedOpcodes;
            sysData.ruleIndex = rule.index;
            callback(sysData, chars, phraseIndex, syntaxData);
            validateRnmCallbackResult(rule, sysData, charsLeft, false);
          }
        }
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (rule.isBkr) {
            sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
          }
        }
      }, "opRNM");
      const validateUdtCallbackResult =  __name(function(udt, sysData, charsLeft) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id.ACTIVE:
            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);
          case id.EMPTY:
            if (udt.empty === false) {
              throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
            } else {
              sysData.phraseLength = 0;
            }
            break;
          case id.MATCH:
            if (sysData.phraseLength === 0) {
              if (udt.empty === false) {
                throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
              } else {
                sysData.state = id.EMPTY;
              }
            }
            break;
          case id.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`);
        }
      }, "validateUdtCallbackResult");
      const opUDT =  __name(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astIndex;
        let astDefined;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const udt = udts[op.index];
        sysData.UdtIndex = udt.index;
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);
          if (astDefined) {
            astIndex = rules.length + op.index;
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(astIndex, udt.name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        const charsLeft = charsEnd - phraseIndex;
        udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);
        validateUdtCallbackResult(udt, sysData, charsLeft);
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (udt.isBkr) {
            sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
          }
        }
      }, "opUDT");
      const opAND =  __name(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
            sysData.state = id.EMPTY;
            break;
          case id.MATCH:
            sysData.state = id.EMPTY;
            break;
          case id.NOMATCH:
            sysData.state = id.NOMATCH;
            break;
          default:
            throw new Error(`opAND: invalid state ${sysData.state}`);
        }
      }, "opAND");
      const opNOT =  __name(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
          case id.MATCH:
            sysData.state = id.NOMATCH;
            break;
          case id.NOMATCH:
            sysData.state = id.EMPTY;
            break;
          default:
            throw new Error(`opNOT: invalid state ${sysData.state}`);
        }
      }, "opNOT");
      const opTRG =  __name(function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        if (phraseIndex < charsEnd) {
          if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {
            sysData.state = id.MATCH;
            sysData.phraseLength = 1;
          }
        }
      }, "opTRG");
      const opTBS =  __name(function(opIndex, phraseIndex, sysData) {
        let i;
        const op = opcodes[opIndex];
        const len = op.string.length;
        sysData.state = id.NOMATCH;
        if (phraseIndex + len <= charsEnd) {
          for (i = 0; i < len; i += 1) {
            if (chars[phraseIndex + i] !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTBS");
      const opTLS =  __name(function(opIndex, phraseIndex, sysData) {
        let i;
        let code5;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          for (i = 0; i < len; i += 1) {
            code5 = chars[phraseIndex + i];
            if (code5 >= 65 && code5 <= 90) {
              code5 += 32;
            }
            if (code5 !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTLS");
      const opABG =  __name(function(opIndex, phraseIndex, sysData) {
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;
      }, "opABG");
      const opAEN =  __name(function(opIndex, phraseIndex, sysData) {
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;
      }, "opAEN");
      const opBKR =  __name(function(opIndex, phraseIndex, sysData) {
        let i;
        let code5;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id.BKR_MODE_CI;
        if (frame === null) {
          return;
        }
        const lmIndex = frame.phraseIndex;
        const len = frame.phraseLength;
        if (len === 0) {
          sysData.state = id.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          if (insensitive) {
            for (i = 0; i < len; i += 1) {
              code5 = chars[phraseIndex + i];
              lmcode = chars[lmIndex + i];
              if (code5 >= 65 && code5 <= 90) {
                code5 += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code5 !== lmcode) {
                return;
              }
            }
            sysData.state = id.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i = 0; i < len; i += 1) {
              code5 = chars[phraseIndex + i];
              lmcode = chars[lmIndex + i];
              if (code5 !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      }, "opBKR");
      const opBKA =  __name(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
            sysData.state = id.EMPTY;
            break;
          case id.MATCH:
            sysData.state = id.EMPTY;
            break;
          case id.NOMATCH:
            sysData.state = id.NOMATCH;
            break;
          default:
            throw new Error(`opBKA: invalid state ${sysData.state}`);
        }
      }, "opBKA");
      const opBKN =  __name(function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
          case id.MATCH:
            sysData.state = id.NOMATCH;
            break;
          case id.NOMATCH:
            sysData.state = id.EMPTY;
            break;
          default:
            throw new Error(`opBKN: invalid state ${sysData.state}`);
        }
      }, "opBKN");
      const opCATBehind =  __name(function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catMatched;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catMatched = 0;
        for (let i = op.children.length - 1; i >= 0; i -= 1) {
          opExecute(op.children[i], catCharIndex, sysData);
          catCharIndex -= sysData.phraseLength;
          catMatched += sysData.phraseLength;
          if (sysData.state === id.NOMATCH) {
            success = false;
            break;
          }
        }
        if (success) {
          sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = catMatched;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opCATBehind");
      const opREPBehind =  __name(function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex <= 0) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id.NOMATCH) {
            break;
          }
          if (sysData.state === id.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex -= sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id.EMPTY) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      }, "opREPBehind");
      const opTRGBehind =  __name(function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        if (phraseIndex > 0) {
          const char = chars[phraseIndex - 1];
          if (op.min <= char && char <= op.max) {
            sysData.state = id.MATCH;
            sysData.phraseLength = 1;
          }
        }
      }, "opTRGBehind");
      const opTBSBehind =  __name(function(opIndex, phraseIndex, sysData) {
        let i;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        const len = op.string.length;
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (i = 0; i < len; i += 1) {
            if (chars[beg + i] !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTBSBehind");
      const opTLSBehind =  __name(function(opIndex, phraseIndex, sysData) {
        let char;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id.EMPTY;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (let i = 0; i < len; i += 1) {
            char = chars[beg + i];
            if (char >= 65 && char <= 90) {
              char += 32;
            }
            if (char !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      }, "opTLSBehind");
      const opBKRBehind =  __name(function(opIndex, phraseIndex, sysData) {
        let i;
        let code5;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id.BKR_MODE_CI;
        if (frame === null) {
          return;
        }
        const lmIndex = frame.phraseIndex;
        const len = frame.phraseLength;
        if (len === 0) {
          sysData.state = id.EMPTY;
          sysData.phraseLength = 0;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          if (insensitive) {
            for (i = 0; i < len; i += 1) {
              code5 = chars[beg + i];
              lmcode = chars[lmIndex + i];
              if (code5 >= 65 && code5 <= 90) {
                code5 += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code5 !== lmcode) {
                return;
              }
            }
            sysData.state = id.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i = 0; i < len; i += 1) {
              code5 = chars[beg + i];
              lmcode = chars[lmIndex + i];
              if (code5 !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      }, "opBKRBehind");
      opExecute =  __name(function opExecuteFunc(opIndex, phraseIndex, sysData) {
        let ret = true;
        const op = opcodes[opIndex];
        nodeHits += 1;
        if (nodeHits > limitNodeHits) {
          throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);
        }
        treeDepth += 1;
        if (treeDepth > maxTreeDepth) {
          maxTreeDepth = treeDepth;
          if (maxTreeDepth > limitTreeDepth) {
            throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);
          }
        }
        sysData.refresh();
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        if (inLookBehind()) {
          switch (op.type) {
            case id.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id.CAT:
              opCATBehind(opIndex, phraseIndex, sysData);
              break;
            case id.REP:
              opREPBehind(opIndex, phraseIndex, sysData);
              break;
            case id.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id.TRG:
              opTRGBehind(opIndex, phraseIndex, sysData);
              break;
            case id.TBS:
              opTBSBehind(opIndex, phraseIndex, sysData);
              break;
            case id.TLS:
              opTLSBehind(opIndex, phraseIndex, sysData);
              break;
            case id.BKR:
              opBKRBehind(opIndex, phraseIndex, sysData);
              break;
            case id.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        } else {
          switch (op.type) {
            case id.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id.CAT:
              opCAT(opIndex, phraseIndex, sysData);
              break;
            case id.REP:
              opREP(opIndex, phraseIndex, sysData);
              break;
            case id.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id.TRG:
              opTRG(opIndex, phraseIndex, sysData);
              break;
            case id.TBS:
              opTBS(opIndex, phraseIndex, sysData);
              break;
            case id.TLS:
              opTLS(opIndex, phraseIndex, sysData);
              break;
            case id.BKR:
              opBKR(opIndex, phraseIndex, sysData);
              break;
            case id.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        }
        if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {
          maxMatched = phraseIndex + sysData.phraseLength;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.collect(op, sysData);
        }
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        treeDepth -= 1;
        return ret;
      }, "opExecuteFunc");
    }, "parser");
  }
});
var require_stats = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/stats.js"(exports, module) {
    module.exports =  __name(function statsFunc() {
      const id = require_identifiers();
      const utils = require_utilities();
      const style = require_style();
      const thisFileName = "stats.js: ";
      let rules = [];
      let udts = [];
      const stats = [];
      let totals;
      const ruleStats = [];
      const udtStats = [];
      this.statsObject = "statsObject";
      const nameId = "stats";
      const sortAlpha =  __name(function sortAlpha2(lhs, rhs) {
        if (lhs.lower < rhs.lower) {
          return -1;
        }
        if (lhs.lower > rhs.lower) {
          return 1;
        }
        return 0;
      }, "sortAlpha");
      const sortHits =  __name(function sortHits2(lhs, rhs) {
        if (lhs.total < rhs.total) {
          return 1;
        }
        if (lhs.total > rhs.total) {
          return -1;
        }
        return sortAlpha(lhs, rhs);
      }, "sortHits");
      const sortIndex =  __name(function sortIndex2(lhs, rhs) {
        if (lhs.index < rhs.index) {
          return -1;
        }
        if (lhs.index > rhs.index) {
          return 1;
        }
        return 0;
      }, "sortIndex");
      const EmptyStat =  __name(function EmptyStat2() {
        this.empty = 0;
        this.match = 0;
        this.nomatch = 0;
        this.total = 0;
      }, "EmptyStat");
      const clear =  __name(function clear2() {
        stats.length = 0;
        totals = new EmptyStat();
        stats[id.ALT] = new EmptyStat();
        stats[id.CAT] = new EmptyStat();
        stats[id.REP] = new EmptyStat();
        stats[id.RNM] = new EmptyStat();
        stats[id.TRG] = new EmptyStat();
        stats[id.TBS] = new EmptyStat();
        stats[id.TLS] = new EmptyStat();
        stats[id.UDT] = new EmptyStat();
        stats[id.AND] = new EmptyStat();
        stats[id.NOT] = new EmptyStat();
        stats[id.BKR] = new EmptyStat();
        stats[id.BKA] = new EmptyStat();
        stats[id.BKN] = new EmptyStat();
        stats[id.ABG] = new EmptyStat();
        stats[id.AEN] = new EmptyStat();
        ruleStats.length = 0;
        for (let i = 0; i < rules.length; i += 1) {
          ruleStats.push({
            empty: 0,
            match: 0,
            nomatch: 0,
            total: 0,
            name: rules[i].name,
            lower: rules[i].lower,
            index: rules[i].index
          });
        }
        if (udts.length > 0) {
          udtStats.length = 0;
          for (let i = 0; i < udts.length; i += 1) {
            udtStats.push({
              empty: 0,
              match: 0,
              nomatch: 0,
              total: 0,
              name: udts[i].name,
              lower: udts[i].lower,
              index: udts[i].index
            });
          }
        }
      }, "clear");
      const incStat =  __name(function incStat2(stat, state) {
        stat.total += 1;
        switch (state) {
          case id.EMPTY:
            stat.empty += 1;
            break;
          case id.MATCH:
            stat.match += 1;
            break;
          case id.NOMATCH:
            stat.nomatch += 1;
            break;
          default:
            throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);
        }
      }, "incStat");
      const displayRow =  __name(function displayRow2(name5, stat) {
        let html = "";
        html += "<tr>";
        html += `<td class="${style.CLASS_ACTIVE}">${name5}</td>`;
        html += `<td class="${style.CLASS_EMPTY}">${stat.empty}</td>`;
        html += `<td class="${style.CLASS_MATCH}">${stat.match}</td>`;
        html += `<td class="${style.CLASS_NOMATCH}">${stat.nomatch}</td>`;
        html += `<td class="${style.CLASS_ACTIVE}">${stat.total}</td>`;
        html += "</tr>\n";
        return html;
      }, "displayRow");
      const displayOpsOnly =  __name(function displayOpsOnly2() {
        let html = "";
        html += displayRow("ALT", stats[id.ALT]);
        html += displayRow("CAT", stats[id.CAT]);
        html += displayRow("REP", stats[id.REP]);
        html += displayRow("RNM", stats[id.RNM]);
        html += displayRow("TRG", stats[id.TRG]);
        html += displayRow("TBS", stats[id.TBS]);
        html += displayRow("TLS", stats[id.TLS]);
        html += displayRow("UDT", stats[id.UDT]);
        html += displayRow("AND", stats[id.AND]);
        html += displayRow("NOT", stats[id.NOT]);
        html += displayRow("BKR", stats[id.BKR]);
        html += displayRow("BKA", stats[id.BKA]);
        html += displayRow("BKN", stats[id.BKN]);
        html += displayRow("ABG", stats[id.ABG]);
        html += displayRow("AEN", stats[id.AEN]);
        html += displayRow("totals", totals);
        return html;
      }, "displayOpsOnly");
      const displayRules =  __name(function displayRules2() {
        let html = "";
        html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
        html += "<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\n";
        for (let i = 0; i < rules.length; i += 1) {
          if (ruleStats[i].total > 0) {
            html += "<tr>";
            html += `<td class="${style.CLASS_ACTIVE}">${ruleStats[i].name}</td>`;
            html += `<td class="${style.CLASS_EMPTY}">${ruleStats[i].empty}</td>`;
            html += `<td class="${style.CLASS_MATCH}">${ruleStats[i].match}</td>`;
            html += `<td class="${style.CLASS_NOMATCH}">${ruleStats[i].nomatch}</td>`;
            html += `<td class="${style.CLASS_ACTIVE}">${ruleStats[i].total}</td>`;
            html += "</tr>\n";
          }
        }
        if (udts.length > 0) {
          html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
          html += "<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\n";
          for (let i = 0; i < udts.length; i += 1) {
            if (udtStats[i].total > 0) {
              html += "<tr>";
              html += `<td class="${style.CLASS_ACTIVE}">${udtStats[i].name}</td>`;
              html += `<td class="${style.CLASS_EMPTY}">${udtStats[i].empty}</td>`;
              html += `<td class="${style.CLASS_MATCH}">${udtStats[i].match}</td>`;
              html += `<td class="${style.CLASS_NOMATCH}">${udtStats[i].nomatch}</td>`;
              html += `<td class="${style.CLASS_ACTIVE}">${udtStats[i].total}</td>`;
              html += "</tr>\n";
            }
          }
        }
        return html;
      }, "displayRules");
      this.validate =  __name(function validate6(name5) {
        let ret = false;
        if (typeof name5 === "string" && nameId === name5) {
          ret = true;
        }
        return ret;
      }, "validate");
      this.init =  __name(function init4(inputRules, inputUdts) {
        rules = inputRules;
        udts = inputUdts;
        clear();
      }, "init");
      this.collect =  __name(function collect(op, result) {
        incStat(totals, result.state, result.phraseLength);
        incStat(stats[op.type], result.state, result.phraseLength);
        if (op.type === id.RNM) {
          incStat(ruleStats[op.index], result.state, result.phraseLength);
        }
        if (op.type === id.UDT) {
          incStat(udtStats[op.index], result.state, result.phraseLength);
        }
      }, "collect");
      this.toHtml =  __name(function toHtml(type, caption) {
        let html = "";
        html += `<table class="${style.CLASS_STATS}">
`;
        if (typeof caption === "string") {
          html += `<caption>${caption}</caption>
`;
        }
        html += `<tr><th class="${style.CLASS_ACTIVE}">ops</th>
`;
        html += `<th class="${style.CLASS_EMPTY}">EMPTY</th>
`;
        html += `<th class="${style.CLASS_MATCH}">MATCH</th>
`;
        html += `<th class="${style.CLASS_NOMATCH}">NOMATCH</th>
`;
        html += `<th class="${style.CLASS_ACTIVE}">totals</th></tr>
`;
        const test = true;
        while (test) {
          if (type === void 0) {
            html += displayOpsOnly();
            break;
          }
          if (type === null) {
            html += displayOpsOnly();
            break;
          }
          if (type === "ops") {
            html += displayOpsOnly();
            break;
          }
          if (type === "index") {
            ruleStats.sort(sortIndex);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type === "hits") {
            ruleStats.sort(sortHits);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type === "alpha") {
            ruleStats.sort(sortAlpha);
            if (udtStats.length > 0) {
              udtStats.sort(sortAlpha);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          break;
        }
        html += "</table>\n";
        return html;
      }, "toHtml");
      this.toHtmlPage =  __name(function toHtmlPage(type, caption, title) {
        return utils.htmlToPage(this.toHtml(type, caption), title);
      }, "toHtmlPage");
    }, "statsFunc");
  }
});
var require_trace = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/trace.js"(exports, module) {
    module.exports =  __name(function exportTrace() {
      const utils = require_utilities();
      const style = require_style();
      const circular = new (require_circular_buffer())();
      const id = require_identifiers();
      const thisFileName = "trace.js: ";
      const that = this;
      const MODE_HEX = 16;
      const MODE_DEC = 10;
      const MODE_ASCII = 8;
      const MODE_UNICODE = 32;
      const MAX_PHRASE = 80;
      const MAX_TLS = 5;
      const records = [];
      let maxRecords = 5e3;
      let lastRecord = -1;
      let filteredRecords = 0;
      let treeDepth = 0;
      const recordStack = [];
      let chars = null;
      let rules = null;
      let udts = null;
      const operatorFilter = [];
      const ruleFilter = [];
      const PHRASE_END = `<span class="${style.CLASS_LINEEND}">&bull;</span>`;
      const PHRASE_CONTINUE = `<span class="${style.CLASS_LINEEND}">&hellip;</span>`;
      const PHRASE_EMPTY = `<span class="${style.CLASS_EMPTY}">&#120634;</span>`;
      const initOperatorFilter =  __name(function() {
        const setOperators =  __name(function(set) {
          operatorFilter[id.ALT] = set;
          operatorFilter[id.CAT] = set;
          operatorFilter[id.REP] = set;
          operatorFilter[id.TLS] = set;
          operatorFilter[id.TBS] = set;
          operatorFilter[id.TRG] = set;
          operatorFilter[id.AND] = set;
          operatorFilter[id.NOT] = set;
          operatorFilter[id.BKR] = set;
          operatorFilter[id.BKA] = set;
          operatorFilter[id.BKN] = set;
          operatorFilter[id.ABG] = set;
          operatorFilter[id.AEN] = set;
        }, "setOperators");
        let items = 0;
        for (const name5 in that.filter.operators) {
          items += 1;
        }
        if (items === 0) {
          setOperators(false);
          return;
        }
        for (const name5 in that.filter.operators) {
          const upper = name5.toUpperCase();
          if (upper === "<ALL>") {
            setOperators(true);
            return;
          }
          if (upper === "<NONE>") {
            setOperators(false);
            return;
          }
        }
        setOperators(false);
        for (const name5 in that.filter.operators) {
          const upper = name5.toUpperCase();
          if (upper === "ALT") {
            operatorFilter[id.ALT] = that.filter.operators[name5] === true;
          } else if (upper === "CAT") {
            operatorFilter[id.CAT] = that.filter.operators[name5] === true;
          } else if (upper === "REP") {
            operatorFilter[id.REP] = that.filter.operators[name5] === true;
          } else if (upper === "AND") {
            operatorFilter[id.AND] = that.filter.operators[name5] === true;
          } else if (upper === "NOT") {
            operatorFilter[id.NOT] = that.filter.operators[name5] === true;
          } else if (upper === "TLS") {
            operatorFilter[id.TLS] = that.filter.operators[name5] === true;
          } else if (upper === "TBS") {
            operatorFilter[id.TBS] = that.filter.operators[name5] === true;
          } else if (upper === "TRG") {
            operatorFilter[id.TRG] = that.filter.operators[name5] === true;
          } else if (upper === "BKR") {
            operatorFilter[id.BKR] = that.filter.operators[name5] === true;
          } else if (upper === "BKA") {
            operatorFilter[id.BKA] = that.filter.operators[name5] === true;
          } else if (upper === "BKN") {
            operatorFilter[id.BKN] = that.filter.operators[name5] === true;
          } else if (upper === "ABG") {
            operatorFilter[id.ABG] = that.filter.operators[name5] === true;
          } else if (upper === "AEN") {
            operatorFilter[id.AEN] = that.filter.operators[name5] === true;
          } else {
            throw new Error(`${thisFileName}initOpratorFilter: '${name5}' not a valid operator name. Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`);
          }
        }
      }, "initOperatorFilter");
      const initRuleFilter =  __name(function() {
        const setRules =  __name(function(set) {
          operatorFilter[id.RNM] = set;
          operatorFilter[id.UDT] = set;
          const count = rules.length + udts.length;
          ruleFilter.length = 0;
          for (let i2 = 0; i2 < count; i2 += 1) {
            ruleFilter.push(set);
          }
        }, "setRules");
        let items;
        let i;
        const list = [];
        for (i = 0; i < rules.length; i += 1) {
          list.push(rules[i].lower);
        }
        for (i = 0; i < udts.length; i += 1) {
          list.push(udts[i].lower);
        }
        ruleFilter.length = 0;
        items = 0;
        for (const name5 in that.filter.rules) {
          items += 1;
        }
        if (items === 0) {
          setRules(true);
          return;
        }
        for (const name5 in that.filter.rules) {
          const lower = name5.toLowerCase();
          if (lower === "<all>") {
            setRules(true);
            return;
          }
          if (lower === "<none>") {
            setRules(false);
            return;
          }
        }
        setRules(false);
        operatorFilter[id.RNM] = true;
        operatorFilter[id.UDT] = true;
        for (const name5 in that.filter.rules) {
          const lower = name5.toLowerCase();
          i = list.indexOf(lower);
          if (i < 0) {
            throw new Error(`${thisFileName}initRuleFilter: '${name5}' not a valid rule or udt name`);
          }
          ruleFilter[i] = that.filter.rules[name5] === true;
        }
      }, "initRuleFilter");
      this.traceObject = "traceObject";
      this.filter = {
        operators: [],
        rules: []
      };
      this.setMaxRecords = function(max, last2) {
        lastRecord = -1;
        if (typeof max === "number" && max > 0) {
          maxRecords = Math.ceil(max);
        } else {
          maxRecords = 0;
          return;
        }
        if (typeof last2 === "number") {
          lastRecord = Math.floor(last2);
          if (lastRecord < 0) {
            lastRecord = -1;
          }
        }
      };
      this.getMaxRecords = function() {
        return maxRecords;
      };
      this.getLastRecord = function() {
        return lastRecord;
      };
      this.init = function(rulesIn, udtsIn, charsIn) {
        records.length = 0;
        recordStack.length = 0;
        filteredRecords = 0;
        treeDepth = 0;
        chars = charsIn;
        rules = rulesIn;
        udts = udtsIn;
        initOperatorFilter();
        initRuleFilter();
        circular.init(maxRecords);
      };
      const filterOps =  __name(function(op) {
        let ret = false;
        if (op.type === id.RNM) {
          if (operatorFilter[op.type] && ruleFilter[op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else if (op.type === id.UDT) {
          if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else {
          ret = operatorFilter[op.type];
        }
        return ret;
      }, "filterOps");
      const filterRecords =  __name(function(record) {
        if (lastRecord === -1) {
          return true;
        }
        if (record <= lastRecord) {
          return true;
        }
        return false;
      }, "filterRecords");
      this.down = function(op, state, offset, length2, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          recordStack.push(filteredRecords);
          records[circular.increment()] = {
            dirUp: false,
            depth: treeDepth,
            thisLine: filteredRecords,
            thatLine: void 0,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length2,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
          treeDepth += 1;
        }
      };
      this.up = function(op, state, offset, length2, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          const thisLine = filteredRecords;
          const thatLine = recordStack.pop();
          const thatRecord = circular.getListIndex(thatLine);
          if (thatRecord !== -1) {
            records[thatRecord].thatLine = thisLine;
          }
          treeDepth -= 1;
          records[circular.increment()] = {
            dirUp: true,
            depth: treeDepth,
            thisLine,
            thatLine,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length2,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
        }
      };
      const toTreeObj =  __name(function() {
        function nodeOpcode(node2, opcode) {
          let name5;
          let casetype;
          let modetype;
          if (opcode) {
            node2.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };
            node2.opData = void 0;
            switch (opcode.type) {
              case id.RNM:
                node2.opData = rules[opcode.index].name;
                break;
              case id.UDT:
                node2.opData = udts[opcode.index].name;
                break;
              case id.BKR:
                if (opcode.index < rules.length) {
                  name5 = rules[opcode.index].name;
                } else {
                  name5 = udts[opcode.index - rules.length].name;
                }
                casetype = opcode.bkrCase === id.BKR_MODE_CI ? "%i" : "%s";
                modetype = opcode.bkrMode === id.BKR_MODE_UM ? "%u" : "%p";
                node2.opData = `\\\\${casetype}${modetype}${name5}`;
                break;
              case id.TLS:
                node2.opData = [];
                for (let i = 0; i < opcode.string.length; i += 1) {
                  node2.opData.push(opcode.string[i]);
                }
                break;
              case id.TBS:
                node2.opData = [];
                for (let i = 0; i < opcode.string.length; i += 1) {
                  node2.opData.push(opcode.string[i]);
                }
                break;
              case id.TRG:
                node2.opData = [opcode.min, opcode.max];
                break;
              case id.REP:
                node2.opData = [opcode.min, opcode.max];
                break;
              default:
                throw new Error("unrecognized opcode");
            }
          } else {
            node2.op = { id: void 0, name: void 0 };
            node2.opData = void 0;
          }
        }
        __name(nodeOpcode, "nodeOpcode");
        function nodePhrase(state, index, length2) {
          if (state === id.MATCH) {
            return {
              index,
              length: length2
            };
          }
          if (state === id.NOMATCH) {
            return {
              index,
              length: 0
            };
          }
          if (state === id.EMPTY) {
            return {
              index,
              length: 0
            };
          }
          return null;
        }
        __name(nodePhrase, "nodePhrase");
        let nodeId = -1;
        function nodeDown(parent2, record2, depth2) {
          const node2 = {
            id: nodeId++,
            branch: -1,
            parent: parent2,
            up: false,
            down: false,
            depth: depth2,
            children: []
          };
          if (record2) {
            node2.down = true;
            node2.state = { id: record2.state, name: utils.stateToString(record2.state) };
            node2.phrase = null;
            nodeOpcode(node2, record2.opcode);
          } else {
            node2.state = { id: void 0, name: void 0 };
            node2.phrase = nodePhrase();
            nodeOpcode(node2, void 0);
          }
          return node2;
        }
        __name(nodeDown, "nodeDown");
        function nodeUp(node2, record2) {
          if (record2) {
            node2.up = true;
            node2.state = { id: record2.state, name: utils.stateToString(record2.state) };
            node2.phrase = nodePhrase(record2.state, record2.phraseIndex, record2.phraseLength);
            if (!node2.down) {
              nodeOpcode(node2, record2.opcode);
            }
          }
        }
        __name(nodeUp, "nodeUp");
        let leafNodes = 0;
        let depth = -1;
        let branchCount = 1;
        function walk(node2) {
          depth += 1;
          node2.branch = branchCount;
          if (depth > treeDepth) {
            treeDepth = depth;
          }
          if (node2.children.length === 0) {
            leafNodes += 1;
          } else {
            for (let i = 0; i < node2.children.length; i += 1) {
              if (i > 0) {
                branchCount += 1;
              }
              node2.children[i].leftMost = false;
              node2.children[i].rightMost = false;
              if (node2.leftMost) {
                node2.children[i].leftMost = i === 0;
              }
              if (node2.rightMost) {
                node2.children[i].rightMost = i === node2.children.length - 1;
              }
              walk(node2.children[i]);
            }
          }
          depth -= 1;
        }
        __name(walk, "walk");
        function display(node2, offset) {
          let name5;
          const obj2 = {};
          obj2.id = node2.id;
          obj2.branch = node2.branch;
          obj2.leftMost = node2.leftMost;
          obj2.rightMost = node2.rightMost;
          name5 = node2.state.name ? node2.state.name : "ACTIVE";
          obj2.state = { id: node2.state.id, name: name5 };
          name5 = node2.op.name ? node2.op.name : "?";
          obj2.op = { id: node2.op.id, name: name5 };
          if (typeof node2.opData === "string") {
            obj2.opData = node2.opData;
          } else if (Array.isArray(node2.opData)) {
            obj2.opData = [];
            for (let i = 0; i < node2.opData.length; i += 1) {
              obj2.opData[i] = node2.opData[i];
            }
          } else {
            obj2.opData = void 0;
          }
          if (node2.phrase) {
            obj2.phrase = { index: node2.phrase.index, length: node2.phrase.length };
          } else {
            obj2.phrase = null;
          }
          obj2.depth = node2.depth;
          obj2.children = [];
          for (let i = 0; i < node2.children.length; i += 1) {
            i !== node2.children.length - 1;
            obj2.children[i] = display(node2.children[i]);
          }
          return obj2;
        }
        __name(display, "display");
        const branch = [];
        let root;
        let node;
        let parent;
        let record;
        let firstRecord = true;
        const dummy = nodeDown(null, null, -1);
        branch.push(dummy);
        node = dummy;
        circular.forEach((lineIndex) => {
          record = records[lineIndex];
          if (firstRecord) {
            firstRecord = false;
            if (record.depth > 0) {
              const num = record.dirUp ? record.depth + 1 : record.depth;
              for (let i = 0; i < num; i += 1) {
                parent = node;
                node = nodeDown(node, null, i);
                branch.push(node);
                parent.children.push(node);
              }
            }
          }
          if (record.dirUp) {
            node = branch.pop();
            nodeUp(node, record);
            node = branch[branch.length - 1];
          } else {
            parent = node;
            node = nodeDown(node, record, record.depth);
            branch.push(node);
            parent.children.push(node);
          }
        });
        while (branch.length > 1) {
          node = branch.pop();
          nodeUp(node, null);
        }
        if (dummy.children.length === 0) {
          throw new Error("trace.toTree(): parse tree has no nodes");
        }
        if (branch.length === 0) {
          throw new Error("trace.toTree(): integrity check: dummy root node disappeared?");
        }
        root = dummy.children[0];
        let prev = root;
        while (root && !root.down && !root.up) {
          prev = root;
          root = root.children[0];
        }
        root = prev;
        root.leftMost = true;
        root.rightMost = true;
        walk(root);
        root.branch = 0;
        const obj = {};
        obj.string = [];
        for (let i = 0; i < chars.length; i += 1) {
          obj.string[i] = chars[i];
        }
        obj.rules = [];
        for (let i = 0; i < rules.length; i += 1) {
          obj.rules[i] = rules[i].name;
        }
        obj.udts = [];
        for (let i = 0; i < udts.length; i += 1) {
          obj.udts[i] = udts[i].name;
        }
        obj.id = {};
        obj.id.ALT = { id: id.ALT, name: "ALT" };
        obj.id.CAT = { id: id.CAT, name: "CAT" };
        obj.id.REP = { id: id.REP, name: "REP" };
        obj.id.RNM = { id: id.RNM, name: "RNM" };
        obj.id.TLS = { id: id.TLS, name: "TLS" };
        obj.id.TBS = { id: id.TBS, name: "TBS" };
        obj.id.TRG = { id: id.TRG, name: "TRG" };
        obj.id.UDT = { id: id.UDT, name: "UDT" };
        obj.id.AND = { id: id.AND, name: "AND" };
        obj.id.NOT = { id: id.NOT, name: "NOT" };
        obj.id.BKR = { id: id.BKR, name: "BKR" };
        obj.id.BKA = { id: id.BKA, name: "BKA" };
        obj.id.BKN = { id: id.BKN, name: "BKN" };
        obj.id.ABG = { id: id.ABG, name: "ABG" };
        obj.id.AEN = { id: id.AEN, name: "AEN" };
        obj.id.ACTIVE = { id: id.ACTIVE, name: "ACTIVE" };
        obj.id.MATCH = { id: id.MATCH, name: "MATCH" };
        obj.id.EMPTY = { id: id.EMPTY, name: "EMPTY" };
        obj.id.NOMATCH = { id: id.NOMATCH, name: "NOMATCH" };
        obj.treeDepth = treeDepth;
        obj.leafNodes = leafNodes;
        let branchesIncomplete;
        if (root.down) {
          if (root.up) {
            branchesIncomplete = "none";
          } else {
            branchesIncomplete = "right";
          }
        } else if (root.up) {
          branchesIncomplete = "left";
        } else {
          branchesIncomplete = "both";
        }
        obj.branchesIncomplete = branchesIncomplete;
        obj.tree = display(root, root.depth);
        return obj;
      }, "toTreeObj");
      this.toTree = function(stringify2) {
        const obj = toTreeObj();
        if (stringify2) {
          return JSON.stringify(obj);
        }
        return obj;
      };
      this.toHtmlPage = function(mode, caption, title) {
        return utils.htmlToPage(this.toHtml(mode, caption), title);
      };
      const htmlHeader =  __name(function(mode, caption) {
        let modeName;
        switch (mode) {
          case MODE_HEX:
            modeName = "hexadecimal";
            break;
          case MODE_DEC:
            modeName = "decimal";
            break;
          case MODE_ASCII:
            modeName = "ASCII";
            break;
          case MODE_UNICODE:
            modeName = "UNICODE";
            break;
          default:
            throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);
        }
        let header = "";
        header += `<p>display mode: ${modeName}</p>
`;
        header += `<table class="${style.CLASS_TRACE}">
`;
        if (typeof caption === "string") {
          header += `<caption>${caption}</caption>`;
        }
        return header;
      }, "htmlHeader");
      const htmlFooter =  __name(function() {
        let footer = "";
        footer += "</table>\n";
        footer += `<p class="${style.CLASS_MONOSPACE}">legend:<br>
`;
        footer += "(a)&nbsp;-&nbsp;line number<br>\n";
        footer += "(b)&nbsp;-&nbsp;matching line number<br>\n";
        footer += "(c)&nbsp;-&nbsp;phrase offset<br>\n";
        footer += "(d)&nbsp;-&nbsp;phrase length<br>\n";
        footer += "(e)&nbsp;-&nbsp;tree depth<br>\n";
        footer += "(f)&nbsp;-&nbsp;operator state<br>\n";
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_ACTIVE}">&darr;</span>&nbsp;&nbsp;phrase opened<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_MATCH}">&uarr;M</span> phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_EMPTY}">&uarr;E</span> empty phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_NOMATCH}">&uarr;N</span> phrase not matched<br>
`;
        footer += "operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\n";
        footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_MATCH}">matched characters</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_LOOKAHEAD}">matched characters in look ahead mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_LOOKBEHIND}">matched characters in look behind mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_REMAINDER}">remainder characters(not yet examined by parser)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_CTRLCHAR}">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>
`;
        footer += "</p>\n";
        footer += `<p class="${style.CLASS_MONOSPACE}">
`;
        footer += "<sup>&dagger;</sup>original ABNF operators:<br>\n";
        footer += "ALT - alternation<br>\n";
        footer += "CAT - concatenation<br>\n";
        footer += "REP - repetition<br>\n";
        footer += "RNM - rule name<br>\n";
        footer += "TRG - terminal range<br>\n";
        footer += "TLS - terminal literal string (case insensitive)<br>\n";
        footer += "TBS - terminal binary string (case sensitive)<br>\n";
        footer += "<br>\n";
        footer += "<sup>&Dagger;</sup>super set SABNF operators:<br>\n";
        footer += "UDT - user-defined terminal<br>\n";
        footer += "AND - positive look ahead<br>\n";
        footer += "NOT - negative look ahead<br>\n";
        footer += "BKA - positive look behind<br>\n";
        footer += "BKN - negative look behind<br>\n";
        footer += "BKR - back reference<br>\n";
        footer += "ABG - anchor - begin of input string<br>\n";
        footer += "AEN - anchor - end of input string<br>\n";
        footer += "</p>\n";
        return footer;
      }, "htmlFooter");
      this.indent = function(depth) {
        let html = "";
        for (let i = 0; i < depth; i += 1) {
          html += ".";
        }
        return html;
      };
      const displayTrg =  __name(function(mode, op) {
        let html = "";
        if (op.type === id.TRG) {
          if (mode === MODE_HEX || mode === MODE_UNICODE) {
            let hex = op.min.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html += mode === MODE_HEX ? "%x" : "U+";
            html += hex;
            hex = op.max.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html += `&ndash;${hex}`;
          } else {
            html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          }
        }
        return html;
      }, "displayTrg");
      const displayRep =  __name(function(mode, op) {
        let html = "";
        if (op.type === id.REP) {
          if (mode === MODE_HEX) {
            let hex = op.min.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html = `x${hex}`;
            if (op.max < Infinity) {
              hex = op.max.toString(16).toUpperCase();
              if (hex.length % 2 !== 0) {
                hex = `0${hex}`;
              }
            } else {
              hex = "inf";
            }
            html += `&ndash;${hex}`;
          } else if (op.max < Infinity) {
            html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          } else {
            html = `${op.min.toString(10)}&ndash;inf`;
          }
        }
        return html;
      }, "displayRep");
      const displayTbs =  __name(function(mode, op) {
        let html = "";
        if (op.type === id.TBS) {
          const len = Math.min(op.string.length, MAX_TLS * 2);
          if (mode === MODE_HEX || mode === MODE_UNICODE) {
            html += mode === MODE_HEX ? "%x" : "U+";
            for (let i = 0; i < len; i += 1) {
              let hex;
              if (i > 0) {
                html += ".";
              }
              hex = op.string[i].toString(16).toUpperCase();
              if (hex.length % 2 !== 0) {
                hex = `0${hex}`;
              }
              html += hex;
            }
          } else {
            html = "%d";
            for (let i = 0; i < len; i += 1) {
              if (i > 0) {
                html += ".";
              }
              html += op.string[i].toString(10);
            }
          }
          if (len < op.string.length) {
            html += PHRASE_CONTINUE;
          }
        }
        return html;
      }, "displayTbs");
      const displayTls =  __name(function(mode, op) {
        let html = "";
        if (op.type === id.TLS) {
          const len = Math.min(op.string.length, MAX_TLS);
          if (mode === MODE_HEX || mode === MODE_DEC) {
            let charu;
            let charl;
            let base4;
            if (mode === MODE_HEX) {
              html = "%x";
              base4 = 16;
            } else {
              html = "%d";
              base4 = 10;
            }
            for (let i = 0; i < len; i += 1) {
              if (i > 0) {
                html += ".";
              }
              charl = op.string[i];
              if (charl >= 97 && charl <= 122) {
                charu = charl - 32;
                html += `${charu.toString(base4)}/${charl.toString(base4)}`.toUpperCase();
              } else if (charl >= 65 && charl <= 90) {
                charu = charl;
                charl += 32;
                html += `${charu.toString(base4)}/${charl.toString(base4)}`.toUpperCase();
              } else {
                html += charl.toString(base4).toUpperCase();
              }
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
          } else {
            html = '"';
            for (let i = 0; i < len; i += 1) {
              html += utils.asciiChars[op.string[i]];
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
            html += '"';
          }
        }
        return html;
      }, "displayTls");
      const subPhrase =  __name(function(mode, charsArg, index, length2, prev) {
        if (length2 === 0) {
          return "";
        }
        let phrase = "";
        const comma = prev ? "," : "";
        switch (mode) {
          case MODE_HEX:
            phrase = comma + utils.charsToHex(charsArg, index, length2);
            break;
          case MODE_DEC:
            if (prev) {
              return `,${utils.charsToDec(charsArg, index, length2)}`;
            }
            phrase = comma + utils.charsToDec(charsArg, index, length2);
            break;
          case MODE_UNICODE:
            phrase = utils.charsToUnicode(charsArg, index, length2);
            break;
          case MODE_ASCII:
          default:
            phrase = utils.charsToAsciiHtml(charsArg, index, length2);
            break;
        }
        return phrase;
      }, "subPhrase");
      const displayBehind =  __name(function(mode, charsArg, state, index, length2, anchor) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanBehind = `<span class="${style.CLASS_LOOKBEHIND}">`;
        const spanRemainder = `<span class="${style.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id.EMPTY:
            html += PHRASE_EMPTY;
          case id.NOMATCH:
          case id.MATCH:
          case id.ACTIVE:
            beg1 = index - length2;
            len1 = anchor - beg1;
            beg2 = anchor;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanBehind;
          html += subPhrase(mode, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      }, "displayBehind");
      const displayForward =  __name(function(mode, charsArg, state, index, length2, spanAhead) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanRemainder = `<span class="${style.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id.EMPTY:
            html += PHRASE_EMPTY;
          case id.NOMATCH:
          case id.ACTIVE:
            beg1 = index;
            len1 = 0;
            beg2 = index;
            len2 = charsArg.length - beg2;
            break;
          case id.MATCH:
            beg1 = index;
            len1 = length2;
            beg2 = index + len1;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanAhead;
          html += subPhrase(mode, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      }, "displayForward");
      const displayAhead =  __name(function(mode, charsArg, state, index, length2) {
        const spanAhead = `<span class="${style.CLASS_LOOKAHEAD}">`;
        return displayForward(mode, charsArg, state, index, length2, spanAhead);
      }, "displayAhead");
      const displayNone =  __name(function(mode, charsArg, state, index, length2) {
        const spanAhead = `<span class="${style.CLASS_MATCH}">`;
        return displayForward(mode, charsArg, state, index, length2, spanAhead);
      }, "displayNone");
      const htmlTable =  __name(function(mode) {
        if (rules === null) {
          return "";
        }
        let html = "";
        let thisLine;
        let thatLine;
        let lookAhead;
        let lookBehind;
        let lookAround;
        let anchor;
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        circular.forEach((lineIndex) => {
          const line = records[lineIndex];
          thisLine = line.thisLine;
          thatLine = line.thatLine !== void 0 ? line.thatLine : "--";
          lookAhead = false;
          lookBehind = false;
          lookAround = false;
          if (line.lookAround === id.LOOKAROUND_AHEAD) {
            lookAhead = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {
            lookAhead = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          if (line.lookAround === id.LOOKAROUND_BEHIND) {
            lookBehind = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {
            lookBehind = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          html += "<tr>";
          html += `<td>${thisLine}</td><td>${thatLine}</td>`;
          html += `<td>${line.phraseIndex}</td>`;
          html += `<td>${line.phraseLength}</td>`;
          html += `<td>${line.depth}</td>`;
          html += "<td>";
          switch (line.state) {
            case id.ACTIVE:
              html += `<span class="${style.CLASS_ACTIVE}">&darr;&nbsp;</span>`;
              break;
            case id.MATCH:
              html += `<span class="${style.CLASS_MATCH}">&uarr;M</span>`;
              break;
            case id.NOMATCH:
              html += `<span class="${style.CLASS_NOMATCH}">&uarr;N</span>`;
              break;
            case id.EMPTY:
              html += `<span class="${style.CLASS_EMPTY}">&uarr;E</span>`;
              break;
            default:
              html += `<span class="${style.CLASS_ACTIVE}">--</span>`;
              break;
          }
          html += "</td>";
          html += "<td>";
          html += that.indent(line.depth);
          if (lookAhead) {
            html += `<span class="${style.CLASS_LOOKAHEAD}">`;
          } else if (lookBehind) {
            html += `<span class="${style.CLASS_LOOKBEHIND}">`;
          }
          html += utils.opcodeToString(line.opcode.type);
          if (line.opcode.type === id.RNM) {
            html += `(${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id.BKR) {
            const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? "%i" : "%s";
            const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? "%u" : "%p";
            html += `(\\${casetype}${modetype}${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id.UDT) {
            html += `(${udts[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id.TRG) {
            html += `(${displayTrg(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id.TBS) {
            html += `(${displayTbs(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id.TLS) {
            html += `(${displayTls(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id.REP) {
            html += `(${displayRep(mode, line.opcode)}) `;
          }
          if (lookAround) {
            html += "</span>";
          }
          html += "</td>";
          html += "<td>";
          if (lookBehind) {
            html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);
          } else if (lookAhead) {
            html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);
          } else {
            html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);
          }
          html += "</td></tr>\n";
        });
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        html += "</table>\n";
        return html;
      }, "htmlTable");
      this.toHtml = function(modearg, caption) {
        let mode = MODE_ASCII;
        if (typeof modearg === "string" && modearg.length >= 3) {
          const modein = modearg.toLowerCase().slice(0, 3);
          if (modein === "hex") {
            mode = MODE_HEX;
          } else if (modein === "dec") {
            mode = MODE_DEC;
          } else if (modein === "uni") {
            mode = MODE_UNICODE;
          }
        }
        let html = "";
        html += htmlHeader(mode, caption);
        html += htmlTable(mode);
        html += htmlFooter();
        return html;
      };
    }, "exportTrace");
  }
});
var require_node_exports = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-lib/node-exports.js"(exports, module) {
    module.exports = {
      ast: require_ast(),
      circular: require_circular_buffer(),
      ids: require_identifiers(),
      parser: require_parser(),
      stats: require_stats(),
      trace: require_trace(),
      utils: require_utilities(),
      emitcss: require_emitcss(),
      style: require_style()
    };
  }
});
var require_scanner_grammar = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/scanner-grammar.js"(exports, module) {
    module.exports =  __name(function grammar() {
      this.grammarObject = "grammarObject";
      this.rules = [];
      this.rules[0] = { name: "file", lower: "file", index: 0, isBkr: false };
      this.rules[1] = { name: "line", lower: "line", index: 1, isBkr: false };
      this.rules[2] = { name: "line-text", lower: "line-text", index: 2, isBkr: false };
      this.rules[3] = { name: "last-line", lower: "last-line", index: 3, isBkr: false };
      this.rules[4] = { name: "valid", lower: "valid", index: 4, isBkr: false };
      this.rules[5] = { name: "invalid", lower: "invalid", index: 5, isBkr: false };
      this.rules[6] = { name: "end", lower: "end", index: 6, isBkr: false };
      this.rules[7] = { name: "CRLF", lower: "crlf", index: 7, isBkr: false };
      this.rules[8] = { name: "LF", lower: "lf", index: 8, isBkr: false };
      this.rules[9] = { name: "CR", lower: "cr", index: 9, isBkr: false };
      this.udts = [];
      this.rules[0].opcodes = [];
      this.rules[0].opcodes[0] = { type: 2, children: [1, 3] };
      this.rules[0].opcodes[1] = { type: 3, min: 0, max: Infinity };
      this.rules[0].opcodes[2] = { type: 4, index: 1 };
      this.rules[0].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[0].opcodes[4] = { type: 4, index: 3 };
      this.rules[1].opcodes = [];
      this.rules[1].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[1].opcodes[1] = { type: 4, index: 2 };
      this.rules[1].opcodes[2] = { type: 4, index: 6 };
      this.rules[2].opcodes = [];
      this.rules[2].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[2].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[2].opcodes[2] = { type: 4, index: 4 };
      this.rules[2].opcodes[3] = { type: 4, index: 5 };
      this.rules[3].opcodes = [];
      this.rules[3].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[3].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[3].opcodes[2] = { type: 4, index: 4 };
      this.rules[3].opcodes[3] = { type: 4, index: 5 };
      this.rules[4].opcodes = [];
      this.rules[4].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[4].opcodes[1] = { type: 5, min: 32, max: 126 };
      this.rules[4].opcodes[2] = { type: 6, string: [9] };
      this.rules[5].opcodes = [];
      this.rules[5].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[5].opcodes[1] = { type: 5, min: 0, max: 8 };
      this.rules[5].opcodes[2] = { type: 5, min: 11, max: 12 };
      this.rules[5].opcodes[3] = { type: 5, min: 14, max: 31 };
      this.rules[5].opcodes[4] = { type: 5, min: 127, max: 4294967295 };
      this.rules[6].opcodes = [];
      this.rules[6].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[6].opcodes[1] = { type: 4, index: 7 };
      this.rules[6].opcodes[2] = { type: 4, index: 8 };
      this.rules[6].opcodes[3] = { type: 4, index: 9 };
      this.rules[7].opcodes = [];
      this.rules[7].opcodes[0] = { type: 6, string: [13, 10] };
      this.rules[8].opcodes = [];
      this.rules[8].opcodes[0] = { type: 6, string: [10] };
      this.rules[9].opcodes = [];
      this.rules[9].opcodes[0] = { type: 6, string: [13] };
      this.toString =  __name(function toString5() {
        let str = "";
        str += "file = *line [last-line]\n";
        str += "line = line-text end\n";
        str += "line-text = *(valid/invalid)\n";
        str += "last-line = 1*(valid/invalid)\n";
        str += "valid = %d32-126 / %d9\n";
        str += "invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\n";
        str += "end = CRLF / LF / CR\n";
        str += "CRLF = %d13.10\n";
        str += "LF = %d10\n";
        str += "CR = %d13\n";
        return str;
      }, "toString");
    }, "grammar");
  }
});
var require_scanner_callbacks = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/scanner-callbacks.js"(exports) {
    var ids = require_identifiers();
    var utils = require_utilities();
    function semLine(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endLength = 0;
        data.textLength = 0;
        data.invalidCount = 0;
      } else {
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount,
          textLength: data.textLength,
          endType: data.endType,
          invalidChars: data.invalidCount
        });
      }
      return ids.SEM_OK;
    }
    __name(semLine, "semLine");
    function semLineText(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.textLength = phraseCount;
      }
      return ids.SEM_OK;
    }
    __name(semLineText, "semLineText");
    function semLastLine(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endLength = 0;
        data.textLength = 0;
        data.invalidCount = 0;
      } else if (data.strict) {
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount,
          textLength: phraseCount,
          endType: "none",
          invalidChars: data.invalidCount
        });
        data.errors.push({
          line: data.lineNo,
          char: phraseIndex + phraseCount,
          msg: "no line end on last line - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
        });
      } else {
        chars.push(10);
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount + 1,
          textLength: phraseCount,
          endType: "LF",
          invalidChars: data.invalidCount
        });
      }
      return ids.SEM_OK;
    }
    __name(semLastLine, "semLastLine");
    function semInvalid(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.errors.push({
          line: data.lineNo,
          char: phraseIndex,
          msg: `invalid character found '\\x${utils.charToHex(chars[phraseIndex])}'`
        });
      }
      return ids.SEM_OK;
    }
    __name(semInvalid, "semInvalid");
    function semEnd(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_POST) {
        data.lineNo += 1;
      }
      return ids.SEM_OK;
    }
    __name(semEnd, "semEnd");
    function semLF(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "LF";
        if (data.strict) {
          data.errors.push({
            line: data.lineNo,
            char: phraseIndex,
            msg: "line end character LF(\\n, \\x0A) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
          });
        }
      }
      return ids.SEM_OK;
    }
    __name(semLF, "semLF");
    function semCR(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "CR";
        if (data.strict) {
          data.errors.push({
            line: data.lineNo,
            char: phraseIndex,
            msg: "line end character CR(\\r, \\x0D) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
          });
        }
      }
      return ids.SEM_OK;
    }
    __name(semCR, "semCR");
    function semCRLF(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "CRLF";
      }
      return ids.SEM_OK;
    }
    __name(semCRLF, "semCRLF");
    var callbacks = [];
    callbacks.line = semLine;
    callbacks["line-text"] = semLineText;
    callbacks["last-line"] = semLastLine;
    callbacks.invalid = semInvalid;
    callbacks.end = semEnd;
    callbacks.lf = semLF;
    callbacks.cr = semCR;
    callbacks.crlf = semCRLF;
    exports.callbacks = callbacks;
  }
});
var require_scanner = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/scanner.js"(exports, module) {
    module.exports =  __name(function exfn(chars, errors, strict, trace) {
      const thisFileName = "scanner.js: ";
      const apglib = require_node_exports();
      const grammar = new (require_scanner_grammar())();
      const { callbacks } = require_scanner_callbacks();
      const lines = [];
      const parser = new apglib.parser();
      parser.ast = new apglib.ast();
      parser.ast.callbacks = callbacks;
      if (trace) {
        if (trace.traceObject !== "traceObject") {
          throw new TypeError(`${thisFileName}trace argument is not a trace object`);
        }
        parser.trace = trace;
      }
      const test = parser.parse(grammar, "file", chars);
      if (test.success !== true) {
        errors.push({
          line: 0,
          char: 0,
          msg: "syntax analysis error analyzing input SABNF grammar"
        });
        return;
      }
      const data = {
        lines,
        lineNo: 0,
        errors,
        strict: !!strict
      };
      parser.ast.translate(data);
      return lines;
    }, "exfn");
  }
});
var require_syntax_callbacks = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/syntax-callbacks.js"(exports, module) {
    module.exports =  __name(function exfn() {
      const thisFileName = "syntax-callbacks.js: ";
      const apglib = require_node_exports();
      const id = apglib.ids;
      let topAlt;
      const synFile =  __name(function synFile2(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.altStack = [];
            data.repCount = 0;
            break;
          case id.EMPTY:
            data.errors.push({
              line: 0,
              char: 0,
              msg: "grammar file is empty"
            });
            break;
          case id.MATCH:
            if (data.ruleCount === 0) {
              data.errors.push({
                line: 0,
                char: 0,
                msg: "no rules defined"
              });
            }
            break;
          case id.NOMATCH:
            throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synFile");
      const synRule =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.altStack.length = 0;
            topAlt = {
              groupOpen: null,
              groupError: false,
              optionOpen: null,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          case id.EMPTY:
            throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);
          case id.NOMATCH:
            break;
          case id.MATCH:
            data.ruleCount += 1;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRule");
      const synRuleError =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Unrecognized SABNF line. Invalid rule, comment or blank line."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRuleError");
      const synRuleNameError =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Rule names must be alphanum and begin with alphabetic character."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRuleNameError");
      const synDefinedAsError =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Expected '=' or '=/'. Not found."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synDefinedAsError");
      const synAndOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "AND operator(&) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synAndOp");
      const synNotOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "NOT operator(!) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synNotOp");
      const synBkaOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Positive look-behind operator(&&) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBkaOp");
      const synBknOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Negative look-behind operator(!!) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBknOp");
      const synAbgOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Beginning of string anchor(%^) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synAbgOp");
      const synAenOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "End of string anchor(%$) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synAenOp");
      const synBkrOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              const name5 = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Back reference operator(${name5}) found - strict ABNF specified.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBkrOp");
      const synUdtOp =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.strict) {
              const name5 = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `UDT operator found(${name5}) - strict ABNF specified.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synUdtOp");
      const synTlsOpen =  __name(function(result, chars, phraseIndex) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            topAlt.tlsOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synTlsOpen");
      const synTlsString =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.stringTabChar = false;
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)"
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synTlsString");
      const synStringTab =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            data.stringTabChar = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synStringTab");
      const synTlsClose =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.tlsOpen),
              char: topAlt.tlsOpen,
              msg: 'Case-insensitive literal string("...") opened but not closed.'
            });
            topAlt.basicError = true;
            topAlt.tlsOpen = null;
            break;
          case id.MATCH:
            topAlt.tlsOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synTlsClose");
      const synClsOpen =  __name(function(result, chars, phraseIndex) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            topAlt.clsOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synClsOpen");
      const synClsString =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.stringTabChar = false;
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in literal string."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synClsString");
      const synClsClose =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.clsOpen),
              char: topAlt.clsOpen,
              msg: "Case-sensitive literal string('...') opened but not closed."
            });
            topAlt.clsOpen = null;
            topAlt.basicError = true;
            break;
          case id.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, topAlt.clsOpen),
                char: topAlt.clsOpen,
                msg: "Case-sensitive string operator('...') found - strict ABNF specified."
              });
            }
            topAlt.clsOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synClsClose");
      const synProsValOpen =  __name(function(result, chars, phraseIndex) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            topAlt.prosValOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synProsValOpen");
      const synProsValString =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.stringTabChar = false;
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in prose value string."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synProsValString");
      const synProsValClose =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.prosValOpen),
              char: topAlt.prosValOpen,
              msg: "Prose value operator(<...>) opened but not closed."
            });
            topAlt.basicError = true;
            topAlt.prosValOpen = null;
            break;
          case id.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.prosValOpen),
              char: topAlt.prosValOpen,
              msg: "Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar."
            });
            topAlt.prosValOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synProsValClose");
      const synGroupOpen =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            topAlt = {
              groupOpen: phraseIndex,
              groupError: false,
              optionOpen: null,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synGroupOpen");
      const synGroupClose =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.groupOpen),
              char: topAlt.groupOpen,
              msg: 'Group "(...)" opened but not closed.'
            });
            topAlt = data.altStack.pop();
            topAlt.groupError = true;
            break;
          case id.MATCH:
            topAlt = data.altStack.pop();
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synGroupClose");
      const synOptionOpen =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            topAlt = {
              groupOpen: null,
              groupError: false,
              optionOpen: phraseIndex,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synOptionOpen");
      const synOptionClose =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.optionOpen),
              char: topAlt.optionOpen,
              msg: 'Option "[...]" opened but not closed.'
            });
            topAlt = data.altStack.pop();
            topAlt.optionError = true;
            break;
          case id.MATCH:
            topAlt = data.altStack.pop();
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synOptionClose");
      const synBasicElementError =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (topAlt.basicError === false) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Unrecognized SABNF element."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synBasicElementError");
      const synLineEnd =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            if (result.phraseLength === 1 && data.strict) {
              const end = chars[phraseIndex] === 13 ? "CR" : "LF";
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synLineEnd");
      const synLineEndError =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            break;
          case id.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Unrecognized grammar element or characters."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synLineEndError");
      const synRepetition =  __name(function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            break;
          case id.EMPTY:
            break;
          case id.NOMATCH:
            data.repCount += 1;
            break;
          case id.MATCH:
            data.repCount += 1;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      }, "synRepetition");
      this.callbacks = [];
      this.callbacks.andop = synAndOp;
      this.callbacks.basicelementerr = synBasicElementError;
      this.callbacks.clsclose = synClsClose;
      this.callbacks.clsopen = synClsOpen;
      this.callbacks.clsstring = synClsString;
      this.callbacks.definedaserror = synDefinedAsError;
      this.callbacks.file = synFile;
      this.callbacks.groupclose = synGroupClose;
      this.callbacks.groupopen = synGroupOpen;
      this.callbacks.lineenderror = synLineEndError;
      this.callbacks.lineend = synLineEnd;
      this.callbacks.notop = synNotOp;
      this.callbacks.optionclose = synOptionClose;
      this.callbacks.optionopen = synOptionOpen;
      this.callbacks.prosvalclose = synProsValClose;
      this.callbacks.prosvalopen = synProsValOpen;
      this.callbacks.prosvalstring = synProsValString;
      this.callbacks.repetition = synRepetition;
      this.callbacks.rule = synRule;
      this.callbacks.ruleerror = synRuleError;
      this.callbacks.rulenameerror = synRuleNameError;
      this.callbacks.stringtab = synStringTab;
      this.callbacks.tlsclose = synTlsClose;
      this.callbacks.tlsopen = synTlsOpen;
      this.callbacks.tlsstring = synTlsString;
      this.callbacks.udtop = synUdtOp;
      this.callbacks.bkaop = synBkaOp;
      this.callbacks.bknop = synBknOp;
      this.callbacks.bkrop = synBkrOp;
      this.callbacks.abgop = synAbgOp;
      this.callbacks.aenop = synAenOp;
    }, "exfn");
  }
});
var require_semantic_callbacks = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/semantic-callbacks.js"(exports, module) {
    module.exports =  __name(function exfn() {
      const apglib = require_node_exports();
      const id = apglib.ids;
      const NameList =  __name(function NameList2() {
        this.names = [];
        this.add =  __name(function add3(name5) {
          let ret = -1;
          const find = this.get(name5);
          if (find === -1) {
            ret = {
              name: name5,
              lower: name5.toLowerCase(),
              index: this.names.length
            };
            this.names.push(ret);
          }
          return ret;
        }, "add");
        this.get =  __name(function get2(name5) {
          let ret = -1;
          const lower = name5.toLowerCase();
          for (let i = 0; i < this.names.length; i += 1) {
            if (this.names[i].lower === lower) {
              ret = this.names[i];
              break;
            }
          }
          return ret;
        }, "get");
      }, "NameList");
      const decnum =  __name(function decnum2(chars, beg, len) {
        let num = 0;
        for (let i = beg; i < beg + len; i += 1) {
          num = 10 * num + chars[i] - 48;
        }
        return num;
      }, "decnum");
      const binnum =  __name(function binnum2(chars, beg, len) {
        let num = 0;
        for (let i = beg; i < beg + len; i += 1) {
          num = 2 * num + chars[i] - 48;
        }
        return num;
      }, "binnum");
      const hexnum =  __name(function hexnum2(chars, beg, len) {
        let num = 0;
        for (let i = beg; i < beg + len; i += 1) {
          let digit = chars[i];
          if (digit >= 48 && digit <= 57) {
            digit -= 48;
          } else if (digit >= 65 && digit <= 70) {
            digit -= 55;
          } else if (digit >= 97 && digit <= 102) {
            digit -= 87;
          } else {
            throw new Error("hexnum out of range");
          }
          num = 16 * num + digit;
        }
        return num;
      }, "hexnum");
      function semFile(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.ruleNames = new NameList();
          data.udtNames = new NameList();
          data.rules = [];
          data.udts = [];
          data.rulesLineMap = [];
          data.opcodes = [];
          data.altStack = [];
          data.topStack = null;
          data.topRule = null;
        } else if (state === id.SEM_POST) {
          let nameObj;
          data.rules.forEach((rule) => {
            rule.isBkr = false;
            rule.opcodes.forEach((op) => {
              if (op.type === id.RNM) {
                nameObj = data.ruleNames.get(op.index.name);
                if (nameObj === -1) {
                  data.errors.push({
                    line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),
                    char: op.index.phraseIndex,
                    msg: `Rule name '${op.index.name}' used but not defined.`
                  });
                  op.index = -1;
                } else {
                  op.index = nameObj.index;
                }
              }
            });
          });
          data.udts.forEach((udt) => {
            udt.isBkr = false;
          });
          data.rules.forEach((rule) => {
            rule.opcodes.forEach((op) => {
              if (op.type === id.BKR) {
                rule.hasBkr = true;
                nameObj = data.ruleNames.get(op.index.name);
                if (nameObj !== -1) {
                  data.rules[nameObj.index].isBkr = true;
                  op.index = nameObj.index;
                } else {
                  nameObj = data.udtNames.get(op.index.name);
                  if (nameObj !== -1) {
                    data.udts[nameObj.index].isBkr = true;
                    op.index = data.rules.length + nameObj.index;
                  } else {
                    data.errors.push({
                      line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),
                      char: op.index.phraseIndex,
                      msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`
                    });
                    op.index = -1;
                  }
                }
              }
            });
          });
        }
        return ret;
      }
      __name(semFile, "semFile");
      function semRule(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.altStack.length = 0;
          data.topStack = null;
          data.rulesLineMap.push({
            line: data.findLine(data.lines, phraseIndex, data.charsLength),
            char: phraseIndex
          });
        }
        return ret;
      }
      __name(semRule, "semRule");
      function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.ruleName = "";
          data.definedas = "";
        } else if (state === id.SEM_POST) {
          let ruleName;
          if (data.definedas === "=") {
            ruleName = data.ruleNames.add(data.ruleName);
            if (ruleName === -1) {
              data.definedas = null;
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Rule name '${data.ruleName}' previously defined.`
              });
            } else {
              data.topRule = {
                name: ruleName.name,
                lower: ruleName.lower,
                opcodes: [],
                index: ruleName.index
              };
              data.rules.push(data.topRule);
              data.opcodes = data.topRule.opcodes;
            }
          } else {
            ruleName = data.ruleNames.get(data.ruleName);
            if (ruleName === -1) {
              data.definedas = null;
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`
              });
            } else {
              data.topRule = data.rules[ruleName.index];
              data.opcodes = data.topRule.opcodes;
            }
          }
        }
        return ret;
      }
      __name(semRuleLookup, "semRuleLookup");
      function semAlternation(state, chars, phraseIndex, phraseCount, data) {
        let ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          const TRUE = true;
          while (TRUE) {
            if (data.definedas === null) {
              ret = id.SEM_SKIP;
              break;
            }
            if (data.topStack === null) {
              if (data.definedas === "=") {
                data.topStack = {
                  alt: {
                    type: id.ALT,
                    children: []
                  },
                  cat: null
                };
                data.altStack.push(data.topStack);
                data.opcodes.push(data.topStack.alt);
                break;
              }
              data.topStack = {
                alt: data.opcodes[0],
                cat: null
              };
              data.altStack.push(data.topStack);
              break;
            }
            data.topStack = {
              alt: {
                type: id.ALT,
                children: []
              },
              cat: null
            };
            data.altStack.push(data.topStack);
            data.opcodes.push(data.topStack.alt);
            break;
          }
        } else if (state === id.SEM_POST) {
          data.altStack.pop();
          if (data.altStack.length > 0) {
            data.topStack = data.altStack[data.altStack.length - 1];
          } else {
            data.topStack = null;
          }
        }
        return ret;
      }
      __name(semAlternation, "semAlternation");
      function semConcatenation(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.topStack.alt.children.push(data.opcodes.length);
          data.topStack.cat = {
            type: id.CAT,
            children: []
          };
          data.opcodes.push(data.topStack.cat);
        } else if (state === id.SEM_POST) {
          data.topStack.cat = null;
        }
        return ret;
      }
      __name(semConcatenation, "semConcatenation");
      function semRepetition(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.topStack.cat.children.push(data.opcodes.length);
        }
        return ret;
      }
      __name(semRepetition, "semRepetition");
      function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.REP,
            min: 0,
            max: 1,
            char: phraseIndex
          });
        }
        return ret;
      }
      __name(semOptionOpen, "semOptionOpen");
      function semRuleName(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semRuleName, "semRuleName");
      function semDefined(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.definedas = "=";
        }
        return ret;
      }
      __name(semDefined, "semDefined");
      function semIncAlt(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.definedas = "=/";
        }
        return ret;
      }
      __name(semIncAlt, "semIncAlt");
      function semRepOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.min = 0;
          data.max = Infinity;
          data.topRep = {
            type: id.REP,
            min: 0,
            max: Infinity
          };
          data.opcodes.push(data.topRep);
        } else if (state === id.SEM_POST) {
          if (data.min > data.max) {
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`
            });
          }
          data.topRep.min = data.min;
          data.topRep.max = data.max;
        }
        return ret;
      }
      __name(semRepOp, "semRepOp");
      function semRepMin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.min = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semRepMin, "semRepMin");
      function semRepMax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semRepMax, "semRepMax");
      function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
          data.min = data.max;
        }
        return ret;
      }
      __name(semRepMinMax, "semRepMinMax");
      function semAndOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.AND
          });
        }
        return ret;
      }
      __name(semAndOp, "semAndOp");
      function semNotOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.NOT
          });
        }
        return ret;
      }
      __name(semNotOp, "semNotOp");
      function semRnmOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.RNM,
            index: {
              phraseIndex,
              name: apglib.utils.charsToString(chars, phraseIndex, phraseCount)
            }
          });
        }
        return ret;
      }
      __name(semRnmOp, "semRnmOp");
      function semAbgOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.ABG
          });
        }
        return ret;
      }
      __name(semAbgOp, "semAbgOp");
      function semAenOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.AEN
          });
        }
        return ret;
      }
      __name(semAenOp, "semAenOp");
      function semBkaOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.BKA
          });
        }
        return ret;
      }
      __name(semBkaOp, "semBkaOp");
      function semBknOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.BKN
          });
        }
        return ret;
      }
      __name(semBknOp, "semBknOp");
      function semBkrOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.ci = true;
          data.cs = false;
          data.um = true;
          data.pm = false;
        } else if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.BKR,
            bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,
            bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,
            index: {
              phraseIndex: data.bkrname.phraseIndex,
              name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength)
            }
          });
        }
        return ret;
      }
      __name(semBkrOp, "semBkrOp");
      function semBkrCi(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.ci = true;
        }
        return ret;
      }
      __name(semBkrCi, "semBkrCi");
      function semBkrCs(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.cs = true;
        }
        return ret;
      }
      __name(semBkrCs, "semBkrCs");
      function semBkrUm(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.um = true;
        }
        return ret;
      }
      __name(semBkrUm, "semBkrUm");
      function semBkrPm(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.pm = true;
        }
        return ret;
      }
      __name(semBkrPm, "semBkrPm");
      function semBkrName(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.bkrname = {
            phraseIndex,
            phraseLength: phraseCount
          };
        }
        return ret;
      }
      __name(semBkrName, "semBkrName");
      function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          const name5 = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
          let udtName = data.udtNames.add(name5);
          if (udtName === -1) {
            udtName = data.udtNames.get(name5);
            if (udtName === -1) {
              throw new Error("semUdtEmpty: name look up error");
            }
          } else {
            data.udts.push({
              name: udtName.name,
              lower: udtName.lower,
              index: udtName.index,
              empty: true
            });
          }
          data.opcodes.push({
            type: id.UDT,
            empty: true,
            index: udtName.index
          });
        }
        return ret;
      }
      __name(semUdtEmpty, "semUdtEmpty");
      function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          const name5 = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
          let udtName = data.udtNames.add(name5);
          if (udtName === -1) {
            udtName = data.udtNames.get(name5);
            if (udtName === -1) {
              throw new Error("semUdtNonEmpty: name look up error");
            }
          } else {
            data.udts.push({
              name: udtName.name,
              lower: udtName.lower,
              index: udtName.index,
              empty: false
            });
          }
          data.opcodes.push({
            type: id.UDT,
            empty: false,
            index: udtName.index,
            syntax: null,
            semantic: null
          });
        }
        return ret;
      }
      __name(semUdtNonEmpty, "semUdtNonEmpty");
      function semTlsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.tlscase = true;
        }
        return ret;
      }
      __name(semTlsOp, "semTlsOp");
      function semTlsCase(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {
            data.tlscase = false;
          }
        }
        return ret;
      }
      __name(semTlsCase, "semTlsCase");
      function semTlsString(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          if (data.tlscase) {
            const str = chars.slice(phraseIndex, phraseIndex + phraseCount);
            for (let i = 0; i < str.length; i += 1) {
              if (str[i] >= 65 && str[i] <= 90) {
                str[i] += 32;
              }
            }
            data.opcodes.push({
              type: id.TLS,
              string: str
            });
          } else {
            data.opcodes.push({
              type: id.TBS,
              string: chars.slice(phraseIndex, phraseIndex + phraseCount)
            });
          }
        }
        return ret;
      }
      __name(semTlsString, "semTlsString");
      function semClsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          if (phraseCount <= 2) {
            data.opcodes.push({
              type: id.TLS,
              string: []
            });
          } else {
            data.opcodes.push({
              type: id.TBS,
              string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1)
            });
          }
        }
        return ret;
      }
      __name(semClsOp, "semClsOp");
      function semTbsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.tbsstr = [];
        } else if (state === id.SEM_POST) {
          data.opcodes.push({
            type: id.TBS,
            string: data.tbsstr
          });
        }
        return ret;
      }
      __name(semTbsOp, "semTbsOp");
      function semTrgOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_PRE) {
          data.min = 0;
          data.max = 0;
        } else if (state === id.SEM_POST) {
          if (data.min > data.max) {
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`
            });
          }
          data.opcodes.push({
            type: id.TRG,
            min: data.min,
            max: data.max
          });
        }
        return ret;
      }
      __name(semTrgOp, "semTrgOp");
      function semDmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.min = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semDmin, "semDmin");
      function semDmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semDmax, "semDmax");
      function semBmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.min = binnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semBmin, "semBmin");
      function semBmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.max = binnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semBmax, "semBmax");
      function semXmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.min = hexnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semXmin, "semXmin");
      function semXmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.max = hexnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      __name(semXmax, "semXmax");
      function semDstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      __name(semDstring, "semDstring");
      function semBstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      __name(semBstring, "semBstring");
      function semXstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id.SEM_OK;
        if (state === id.SEM_POST) {
          data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      __name(semXstring, "semXstring");
      this.callbacks = [];
      this.callbacks.abgop = semAbgOp;
      this.callbacks.aenop = semAenOp;
      this.callbacks.alternation = semAlternation;
      this.callbacks.andop = semAndOp;
      this.callbacks.bmax = semBmax;
      this.callbacks.bmin = semBmin;
      this.callbacks.bkaop = semBkaOp;
      this.callbacks.bknop = semBknOp;
      this.callbacks.bkrop = semBkrOp;
      this.callbacks["bkr-name"] = semBkrName;
      this.callbacks.bstring = semBstring;
      this.callbacks.clsop = semClsOp;
      this.callbacks.ci = semBkrCi;
      this.callbacks.cs = semBkrCs;
      this.callbacks.um = semBkrUm;
      this.callbacks.pm = semBkrPm;
      this.callbacks.concatenation = semConcatenation;
      this.callbacks.defined = semDefined;
      this.callbacks.dmax = semDmax;
      this.callbacks.dmin = semDmin;
      this.callbacks.dstring = semDstring;
      this.callbacks.file = semFile;
      this.callbacks.incalt = semIncAlt;
      this.callbacks.notop = semNotOp;
      this.callbacks.optionopen = semOptionOpen;
      this.callbacks["rep-max"] = semRepMax;
      this.callbacks["rep-min"] = semRepMin;
      this.callbacks["rep-min-max"] = semRepMinMax;
      this.callbacks.repetition = semRepetition;
      this.callbacks.repop = semRepOp;
      this.callbacks.rnmop = semRnmOp;
      this.callbacks.rule = semRule;
      this.callbacks.rulelookup = semRuleLookup;
      this.callbacks.rulename = semRuleName;
      this.callbacks.tbsop = semTbsOp;
      this.callbacks.tlscase = semTlsCase;
      this.callbacks.tlsstring = semTlsString;
      this.callbacks.tlsop = semTlsOp;
      this.callbacks.trgop = semTrgOp;
      this.callbacks["udt-empty"] = semUdtEmpty;
      this.callbacks["udt-non-empty"] = semUdtNonEmpty;
      this.callbacks.xmax = semXmax;
      this.callbacks.xmin = semXmin;
      this.callbacks.xstring = semXstring;
    }, "exfn");
  }
});
var require_sabnf_grammar = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/sabnf-grammar.js"(exports, module) {
    module.exports =  __name(function grammar() {
      this.grammarObject = "grammarObject";
      this.rules = [];
      this.rules[0] = { name: "File", lower: "file", index: 0, isBkr: false };
      this.rules[1] = { name: "BlankLine", lower: "blankline", index: 1, isBkr: false };
      this.rules[2] = { name: "Rule", lower: "rule", index: 2, isBkr: false };
      this.rules[3] = { name: "RuleLookup", lower: "rulelookup", index: 3, isBkr: false };
      this.rules[4] = { name: "RuleNameTest", lower: "rulenametest", index: 4, isBkr: false };
      this.rules[5] = { name: "RuleName", lower: "rulename", index: 5, isBkr: false };
      this.rules[6] = { name: "RuleNameError", lower: "rulenameerror", index: 6, isBkr: false };
      this.rules[7] = { name: "DefinedAsTest", lower: "definedastest", index: 7, isBkr: false };
      this.rules[8] = { name: "DefinedAsError", lower: "definedaserror", index: 8, isBkr: false };
      this.rules[9] = { name: "DefinedAs", lower: "definedas", index: 9, isBkr: false };
      this.rules[10] = { name: "Defined", lower: "defined", index: 10, isBkr: false };
      this.rules[11] = { name: "IncAlt", lower: "incalt", index: 11, isBkr: false };
      this.rules[12] = { name: "RuleError", lower: "ruleerror", index: 12, isBkr: false };
      this.rules[13] = { name: "LineEndError", lower: "lineenderror", index: 13, isBkr: false };
      this.rules[14] = { name: "Alternation", lower: "alternation", index: 14, isBkr: false };
      this.rules[15] = { name: "Concatenation", lower: "concatenation", index: 15, isBkr: false };
      this.rules[16] = { name: "Repetition", lower: "repetition", index: 16, isBkr: false };
      this.rules[17] = { name: "Modifier", lower: "modifier", index: 17, isBkr: false };
      this.rules[18] = { name: "Predicate", lower: "predicate", index: 18, isBkr: false };
      this.rules[19] = { name: "BasicElement", lower: "basicelement", index: 19, isBkr: false };
      this.rules[20] = { name: "BasicElementErr", lower: "basicelementerr", index: 20, isBkr: false };
      this.rules[21] = { name: "Group", lower: "group", index: 21, isBkr: false };
      this.rules[22] = { name: "GroupError", lower: "grouperror", index: 22, isBkr: false };
      this.rules[23] = { name: "GroupOpen", lower: "groupopen", index: 23, isBkr: false };
      this.rules[24] = { name: "GroupClose", lower: "groupclose", index: 24, isBkr: false };
      this.rules[25] = { name: "Option", lower: "option", index: 25, isBkr: false };
      this.rules[26] = { name: "OptionError", lower: "optionerror", index: 26, isBkr: false };
      this.rules[27] = { name: "OptionOpen", lower: "optionopen", index: 27, isBkr: false };
      this.rules[28] = { name: "OptionClose", lower: "optionclose", index: 28, isBkr: false };
      this.rules[29] = { name: "RnmOp", lower: "rnmop", index: 29, isBkr: false };
      this.rules[30] = { name: "BkrOp", lower: "bkrop", index: 30, isBkr: false };
      this.rules[31] = { name: "bkrModifier", lower: "bkrmodifier", index: 31, isBkr: false };
      this.rules[32] = { name: "cs", lower: "cs", index: 32, isBkr: false };
      this.rules[33] = { name: "ci", lower: "ci", index: 33, isBkr: false };
      this.rules[34] = { name: "um", lower: "um", index: 34, isBkr: false };
      this.rules[35] = { name: "pm", lower: "pm", index: 35, isBkr: false };
      this.rules[36] = { name: "bkr-name", lower: "bkr-name", index: 36, isBkr: false };
      this.rules[37] = { name: "rname", lower: "rname", index: 37, isBkr: false };
      this.rules[38] = { name: "uname", lower: "uname", index: 38, isBkr: false };
      this.rules[39] = { name: "ename", lower: "ename", index: 39, isBkr: false };
      this.rules[40] = { name: "UdtOp", lower: "udtop", index: 40, isBkr: false };
      this.rules[41] = { name: "udt-non-empty", lower: "udt-non-empty", index: 41, isBkr: false };
      this.rules[42] = { name: "udt-empty", lower: "udt-empty", index: 42, isBkr: false };
      this.rules[43] = { name: "RepOp", lower: "repop", index: 43, isBkr: false };
      this.rules[44] = { name: "AltOp", lower: "altop", index: 44, isBkr: false };
      this.rules[45] = { name: "CatOp", lower: "catop", index: 45, isBkr: false };
      this.rules[46] = { name: "StarOp", lower: "starop", index: 46, isBkr: false };
      this.rules[47] = { name: "AndOp", lower: "andop", index: 47, isBkr: false };
      this.rules[48] = { name: "NotOp", lower: "notop", index: 48, isBkr: false };
      this.rules[49] = { name: "BkaOp", lower: "bkaop", index: 49, isBkr: false };
      this.rules[50] = { name: "BknOp", lower: "bknop", index: 50, isBkr: false };
      this.rules[51] = { name: "AbgOp", lower: "abgop", index: 51, isBkr: false };
      this.rules[52] = { name: "AenOp", lower: "aenop", index: 52, isBkr: false };
      this.rules[53] = { name: "TrgOp", lower: "trgop", index: 53, isBkr: false };
      this.rules[54] = { name: "TbsOp", lower: "tbsop", index: 54, isBkr: false };
      this.rules[55] = { name: "TlsOp", lower: "tlsop", index: 55, isBkr: false };
      this.rules[56] = { name: "TlsCase", lower: "tlscase", index: 56, isBkr: false };
      this.rules[57] = { name: "TlsOpen", lower: "tlsopen", index: 57, isBkr: false };
      this.rules[58] = { name: "TlsClose", lower: "tlsclose", index: 58, isBkr: false };
      this.rules[59] = { name: "TlsString", lower: "tlsstring", index: 59, isBkr: false };
      this.rules[60] = { name: "StringTab", lower: "stringtab", index: 60, isBkr: false };
      this.rules[61] = { name: "ClsOp", lower: "clsop", index: 61, isBkr: false };
      this.rules[62] = { name: "ClsOpen", lower: "clsopen", index: 62, isBkr: false };
      this.rules[63] = { name: "ClsClose", lower: "clsclose", index: 63, isBkr: false };
      this.rules[64] = { name: "ClsString", lower: "clsstring", index: 64, isBkr: false };
      this.rules[65] = { name: "ProsVal", lower: "prosval", index: 65, isBkr: false };
      this.rules[66] = { name: "ProsValOpen", lower: "prosvalopen", index: 66, isBkr: false };
      this.rules[67] = { name: "ProsValString", lower: "prosvalstring", index: 67, isBkr: false };
      this.rules[68] = { name: "ProsValClose", lower: "prosvalclose", index: 68, isBkr: false };
      this.rules[69] = { name: "rep-min", lower: "rep-min", index: 69, isBkr: false };
      this.rules[70] = { name: "rep-min-max", lower: "rep-min-max", index: 70, isBkr: false };
      this.rules[71] = { name: "rep-max", lower: "rep-max", index: 71, isBkr: false };
      this.rules[72] = { name: "rep-num", lower: "rep-num", index: 72, isBkr: false };
      this.rules[73] = { name: "dString", lower: "dstring", index: 73, isBkr: false };
      this.rules[74] = { name: "xString", lower: "xstring", index: 74, isBkr: false };
      this.rules[75] = { name: "bString", lower: "bstring", index: 75, isBkr: false };
      this.rules[76] = { name: "Dec", lower: "dec", index: 76, isBkr: false };
      this.rules[77] = { name: "Hex", lower: "hex", index: 77, isBkr: false };
      this.rules[78] = { name: "Bin", lower: "bin", index: 78, isBkr: false };
      this.rules[79] = { name: "dmin", lower: "dmin", index: 79, isBkr: false };
      this.rules[80] = { name: "dmax", lower: "dmax", index: 80, isBkr: false };
      this.rules[81] = { name: "bmin", lower: "bmin", index: 81, isBkr: false };
      this.rules[82] = { name: "bmax", lower: "bmax", index: 82, isBkr: false };
      this.rules[83] = { name: "xmin", lower: "xmin", index: 83, isBkr: false };
      this.rules[84] = { name: "xmax", lower: "xmax", index: 84, isBkr: false };
      this.rules[85] = { name: "dnum", lower: "dnum", index: 85, isBkr: false };
      this.rules[86] = { name: "bnum", lower: "bnum", index: 86, isBkr: false };
      this.rules[87] = { name: "xnum", lower: "xnum", index: 87, isBkr: false };
      this.rules[88] = { name: "alphanum", lower: "alphanum", index: 88, isBkr: false };
      this.rules[89] = { name: "owsp", lower: "owsp", index: 89, isBkr: false };
      this.rules[90] = { name: "wsp", lower: "wsp", index: 90, isBkr: false };
      this.rules[91] = { name: "space", lower: "space", index: 91, isBkr: false };
      this.rules[92] = { name: "comment", lower: "comment", index: 92, isBkr: false };
      this.rules[93] = { name: "LineEnd", lower: "lineend", index: 93, isBkr: false };
      this.rules[94] = { name: "LineContinue", lower: "linecontinue", index: 94, isBkr: false };
      this.udts = [];
      this.rules[0].opcodes = [];
      this.rules[0].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[0].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[0].opcodes[2] = { type: 4, index: 1 };
      this.rules[0].opcodes[3] = { type: 4, index: 2 };
      this.rules[0].opcodes[4] = { type: 4, index: 12 };
      this.rules[1].opcodes = [];
      this.rules[1].opcodes[0] = { type: 2, children: [1, 5, 7] };
      this.rules[1].opcodes[1] = { type: 3, min: 0, max: Infinity };
      this.rules[1].opcodes[2] = { type: 1, children: [3, 4] };
      this.rules[1].opcodes[3] = { type: 6, string: [32] };
      this.rules[1].opcodes[4] = { type: 6, string: [9] };
      this.rules[1].opcodes[5] = { type: 3, min: 0, max: 1 };
      this.rules[1].opcodes[6] = { type: 4, index: 92 };
      this.rules[1].opcodes[7] = { type: 4, index: 93 };
      this.rules[2].opcodes = [];
      this.rules[2].opcodes[0] = { type: 2, children: [1, 2, 3, 4] };
      this.rules[2].opcodes[1] = { type: 4, index: 3 };
      this.rules[2].opcodes[2] = { type: 4, index: 89 };
      this.rules[2].opcodes[3] = { type: 4, index: 14 };
      this.rules[2].opcodes[4] = { type: 1, children: [5, 8] };
      this.rules[2].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[2].opcodes[6] = { type: 4, index: 89 };
      this.rules[2].opcodes[7] = { type: 4, index: 93 };
      this.rules[2].opcodes[8] = { type: 2, children: [9, 10] };
      this.rules[2].opcodes[9] = { type: 4, index: 13 };
      this.rules[2].opcodes[10] = { type: 4, index: 93 };
      this.rules[3].opcodes = [];
      this.rules[3].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[3].opcodes[1] = { type: 4, index: 4 };
      this.rules[3].opcodes[2] = { type: 4, index: 89 };
      this.rules[3].opcodes[3] = { type: 4, index: 7 };
      this.rules[4].opcodes = [];
      this.rules[4].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[4].opcodes[1] = { type: 4, index: 5 };
      this.rules[4].opcodes[2] = { type: 4, index: 6 };
      this.rules[5].opcodes = [];
      this.rules[5].opcodes[0] = { type: 4, index: 88 };
      this.rules[6].opcodes = [];
      this.rules[6].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[6].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[6].opcodes[2] = { type: 5, min: 33, max: 60 };
      this.rules[6].opcodes[3] = { type: 5, min: 62, max: 126 };
      this.rules[7].opcodes = [];
      this.rules[7].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[7].opcodes[1] = { type: 4, index: 9 };
      this.rules[7].opcodes[2] = { type: 4, index: 8 };
      this.rules[8].opcodes = [];
      this.rules[8].opcodes[0] = { type: 3, min: 1, max: 2 };
      this.rules[8].opcodes[1] = { type: 5, min: 33, max: 126 };
      this.rules[9].opcodes = [];
      this.rules[9].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[9].opcodes[1] = { type: 4, index: 11 };
      this.rules[9].opcodes[2] = { type: 4, index: 10 };
      this.rules[10].opcodes = [];
      this.rules[10].opcodes[0] = { type: 6, string: [61] };
      this.rules[11].opcodes = [];
      this.rules[11].opcodes[0] = { type: 6, string: [61, 47] };
      this.rules[12].opcodes = [];
      this.rules[12].opcodes[0] = { type: 2, children: [1, 6] };
      this.rules[12].opcodes[1] = { type: 3, min: 1, max: Infinity };
      this.rules[12].opcodes[2] = { type: 1, children: [3, 4, 5] };
      this.rules[12].opcodes[3] = { type: 5, min: 32, max: 126 };
      this.rules[12].opcodes[4] = { type: 6, string: [9] };
      this.rules[12].opcodes[5] = { type: 4, index: 94 };
      this.rules[12].opcodes[6] = { type: 4, index: 93 };
      this.rules[13].opcodes = [];
      this.rules[13].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[13].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[13].opcodes[2] = { type: 5, min: 32, max: 126 };
      this.rules[13].opcodes[3] = { type: 6, string: [9] };
      this.rules[13].opcodes[4] = { type: 4, index: 94 };
      this.rules[14].opcodes = [];
      this.rules[14].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[14].opcodes[1] = { type: 4, index: 15 };
      this.rules[14].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[14].opcodes[3] = { type: 2, children: [4, 5, 6] };
      this.rules[14].opcodes[4] = { type: 4, index: 89 };
      this.rules[14].opcodes[5] = { type: 4, index: 44 };
      this.rules[14].opcodes[6] = { type: 4, index: 15 };
      this.rules[15].opcodes = [];
      this.rules[15].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[15].opcodes[1] = { type: 4, index: 16 };
      this.rules[15].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[15].opcodes[3] = { type: 2, children: [4, 5] };
      this.rules[15].opcodes[4] = { type: 4, index: 45 };
      this.rules[15].opcodes[5] = { type: 4, index: 16 };
      this.rules[16].opcodes = [];
      this.rules[16].opcodes[0] = { type: 2, children: [1, 3] };
      this.rules[16].opcodes[1] = { type: 3, min: 0, max: 1 };
      this.rules[16].opcodes[2] = { type: 4, index: 17 };
      this.rules[16].opcodes[3] = { type: 1, children: [4, 5, 6, 7] };
      this.rules[16].opcodes[4] = { type: 4, index: 21 };
      this.rules[16].opcodes[5] = { type: 4, index: 25 };
      this.rules[16].opcodes[6] = { type: 4, index: 19 };
      this.rules[16].opcodes[7] = { type: 4, index: 20 };
      this.rules[17].opcodes = [];
      this.rules[17].opcodes[0] = { type: 1, children: [1, 5] };
      this.rules[17].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[17].opcodes[2] = { type: 4, index: 18 };
      this.rules[17].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[17].opcodes[4] = { type: 4, index: 43 };
      this.rules[17].opcodes[5] = { type: 4, index: 43 };
      this.rules[18].opcodes = [];
      this.rules[18].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[18].opcodes[1] = { type: 4, index: 49 };
      this.rules[18].opcodes[2] = { type: 4, index: 50 };
      this.rules[18].opcodes[3] = { type: 4, index: 47 };
      this.rules[18].opcodes[4] = { type: 4, index: 48 };
      this.rules[19].opcodes = [];
      this.rules[19].opcodes[0] = { type: 1, children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] };
      this.rules[19].opcodes[1] = { type: 4, index: 40 };
      this.rules[19].opcodes[2] = { type: 4, index: 29 };
      this.rules[19].opcodes[3] = { type: 4, index: 53 };
      this.rules[19].opcodes[4] = { type: 4, index: 54 };
      this.rules[19].opcodes[5] = { type: 4, index: 55 };
      this.rules[19].opcodes[6] = { type: 4, index: 61 };
      this.rules[19].opcodes[7] = { type: 4, index: 30 };
      this.rules[19].opcodes[8] = { type: 4, index: 51 };
      this.rules[19].opcodes[9] = { type: 4, index: 52 };
      this.rules[19].opcodes[10] = { type: 4, index: 65 };
      this.rules[20].opcodes = [];
      this.rules[20].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[20].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[20].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[20].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[20].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[20].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[21].opcodes = [];
      this.rules[21].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[21].opcodes[1] = { type: 4, index: 23 };
      this.rules[21].opcodes[2] = { type: 4, index: 14 };
      this.rules[21].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[21].opcodes[4] = { type: 4, index: 24 };
      this.rules[21].opcodes[5] = { type: 4, index: 22 };
      this.rules[22].opcodes = [];
      this.rules[22].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[22].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[22].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[22].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[22].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[22].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[23].opcodes = [];
      this.rules[23].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[23].opcodes[1] = { type: 6, string: [40] };
      this.rules[23].opcodes[2] = { type: 4, index: 89 };
      this.rules[24].opcodes = [];
      this.rules[24].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[24].opcodes[1] = { type: 4, index: 89 };
      this.rules[24].opcodes[2] = { type: 6, string: [41] };
      this.rules[25].opcodes = [];
      this.rules[25].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[25].opcodes[1] = { type: 4, index: 27 };
      this.rules[25].opcodes[2] = { type: 4, index: 14 };
      this.rules[25].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[25].opcodes[4] = { type: 4, index: 28 };
      this.rules[25].opcodes[5] = { type: 4, index: 26 };
      this.rules[26].opcodes = [];
      this.rules[26].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[26].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[26].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[26].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[26].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[26].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[27].opcodes = [];
      this.rules[27].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[27].opcodes[1] = { type: 6, string: [91] };
      this.rules[27].opcodes[2] = { type: 4, index: 89 };
      this.rules[28].opcodes = [];
      this.rules[28].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[28].opcodes[1] = { type: 4, index: 89 };
      this.rules[28].opcodes[2] = { type: 6, string: [93] };
      this.rules[29].opcodes = [];
      this.rules[29].opcodes[0] = { type: 4, index: 88 };
      this.rules[30].opcodes = [];
      this.rules[30].opcodes[0] = { type: 2, children: [1, 2, 4] };
      this.rules[30].opcodes[1] = { type: 6, string: [92] };
      this.rules[30].opcodes[2] = { type: 3, min: 0, max: 1 };
      this.rules[30].opcodes[3] = { type: 4, index: 31 };
      this.rules[30].opcodes[4] = { type: 4, index: 36 };
      this.rules[31].opcodes = [];
      this.rules[31].opcodes[0] = { type: 1, children: [1, 7, 13, 19] };
      this.rules[31].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[31].opcodes[2] = { type: 4, index: 32 };
      this.rules[31].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[4] = { type: 1, children: [5, 6] };
      this.rules[31].opcodes[5] = { type: 4, index: 34 };
      this.rules[31].opcodes[6] = { type: 4, index: 35 };
      this.rules[31].opcodes[7] = { type: 2, children: [8, 9] };
      this.rules[31].opcodes[8] = { type: 4, index: 33 };
      this.rules[31].opcodes[9] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[10] = { type: 1, children: [11, 12] };
      this.rules[31].opcodes[11] = { type: 4, index: 34 };
      this.rules[31].opcodes[12] = { type: 4, index: 35 };
      this.rules[31].opcodes[13] = { type: 2, children: [14, 15] };
      this.rules[31].opcodes[14] = { type: 4, index: 34 };
      this.rules[31].opcodes[15] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[16] = { type: 1, children: [17, 18] };
      this.rules[31].opcodes[17] = { type: 4, index: 32 };
      this.rules[31].opcodes[18] = { type: 4, index: 33 };
      this.rules[31].opcodes[19] = { type: 2, children: [20, 21] };
      this.rules[31].opcodes[20] = { type: 4, index: 35 };
      this.rules[31].opcodes[21] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[22] = { type: 1, children: [23, 24] };
      this.rules[31].opcodes[23] = { type: 4, index: 32 };
      this.rules[31].opcodes[24] = { type: 4, index: 33 };
      this.rules[32].opcodes = [];
      this.rules[32].opcodes[0] = { type: 6, string: [37, 115] };
      this.rules[33].opcodes = [];
      this.rules[33].opcodes[0] = { type: 6, string: [37, 105] };
      this.rules[34].opcodes = [];
      this.rules[34].opcodes[0] = { type: 6, string: [37, 117] };
      this.rules[35].opcodes = [];
      this.rules[35].opcodes[0] = { type: 6, string: [37, 112] };
      this.rules[36].opcodes = [];
      this.rules[36].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[36].opcodes[1] = { type: 4, index: 38 };
      this.rules[36].opcodes[2] = { type: 4, index: 39 };
      this.rules[36].opcodes[3] = { type: 4, index: 37 };
      this.rules[37].opcodes = [];
      this.rules[37].opcodes[0] = { type: 4, index: 88 };
      this.rules[38].opcodes = [];
      this.rules[38].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[38].opcodes[1] = { type: 6, string: [117, 95] };
      this.rules[38].opcodes[2] = { type: 4, index: 88 };
      this.rules[39].opcodes = [];
      this.rules[39].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[39].opcodes[1] = { type: 6, string: [101, 95] };
      this.rules[39].opcodes[2] = { type: 4, index: 88 };
      this.rules[40].opcodes = [];
      this.rules[40].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[40].opcodes[1] = { type: 4, index: 42 };
      this.rules[40].opcodes[2] = { type: 4, index: 41 };
      this.rules[41].opcodes = [];
      this.rules[41].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[41].opcodes[1] = { type: 6, string: [117, 95] };
      this.rules[41].opcodes[2] = { type: 4, index: 88 };
      this.rules[42].opcodes = [];
      this.rules[42].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[42].opcodes[1] = { type: 6, string: [101, 95] };
      this.rules[42].opcodes[2] = { type: 4, index: 88 };
      this.rules[43].opcodes = [];
      this.rules[43].opcodes[0] = { type: 1, children: [1, 5, 8, 11, 12] };
      this.rules[43].opcodes[1] = { type: 2, children: [2, 3, 4] };
      this.rules[43].opcodes[2] = { type: 4, index: 69 };
      this.rules[43].opcodes[3] = { type: 4, index: 46 };
      this.rules[43].opcodes[4] = { type: 4, index: 71 };
      this.rules[43].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[43].opcodes[6] = { type: 4, index: 69 };
      this.rules[43].opcodes[7] = { type: 4, index: 46 };
      this.rules[43].opcodes[8] = { type: 2, children: [9, 10] };
      this.rules[43].opcodes[9] = { type: 4, index: 46 };
      this.rules[43].opcodes[10] = { type: 4, index: 71 };
      this.rules[43].opcodes[11] = { type: 4, index: 46 };
      this.rules[43].opcodes[12] = { type: 4, index: 70 };
      this.rules[44].opcodes = [];
      this.rules[44].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[44].opcodes[1] = { type: 6, string: [47] };
      this.rules[44].opcodes[2] = { type: 4, index: 89 };
      this.rules[45].opcodes = [];
      this.rules[45].opcodes[0] = { type: 4, index: 90 };
      this.rules[46].opcodes = [];
      this.rules[46].opcodes[0] = { type: 6, string: [42] };
      this.rules[47].opcodes = [];
      this.rules[47].opcodes[0] = { type: 6, string: [38] };
      this.rules[48].opcodes = [];
      this.rules[48].opcodes[0] = { type: 6, string: [33] };
      this.rules[49].opcodes = [];
      this.rules[49].opcodes[0] = { type: 6, string: [38, 38] };
      this.rules[50].opcodes = [];
      this.rules[50].opcodes[0] = { type: 6, string: [33, 33] };
      this.rules[51].opcodes = [];
      this.rules[51].opcodes[0] = { type: 6, string: [37, 94] };
      this.rules[52].opcodes = [];
      this.rules[52].opcodes[0] = { type: 6, string: [37, 36] };
      this.rules[53].opcodes = [];
      this.rules[53].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[53].opcodes[1] = { type: 6, string: [37] };
      this.rules[53].opcodes[2] = { type: 1, children: [3, 8, 13] };
      this.rules[53].opcodes[3] = { type: 2, children: [4, 5, 6, 7] };
      this.rules[53].opcodes[4] = { type: 4, index: 76 };
      this.rules[53].opcodes[5] = { type: 4, index: 79 };
      this.rules[53].opcodes[6] = { type: 6, string: [45] };
      this.rules[53].opcodes[7] = { type: 4, index: 80 };
      this.rules[53].opcodes[8] = { type: 2, children: [9, 10, 11, 12] };
      this.rules[53].opcodes[9] = { type: 4, index: 77 };
      this.rules[53].opcodes[10] = { type: 4, index: 83 };
      this.rules[53].opcodes[11] = { type: 6, string: [45] };
      this.rules[53].opcodes[12] = { type: 4, index: 84 };
      this.rules[53].opcodes[13] = { type: 2, children: [14, 15, 16, 17] };
      this.rules[53].opcodes[14] = { type: 4, index: 78 };
      this.rules[53].opcodes[15] = { type: 4, index: 81 };
      this.rules[53].opcodes[16] = { type: 6, string: [45] };
      this.rules[53].opcodes[17] = { type: 4, index: 82 };
      this.rules[54].opcodes = [];
      this.rules[54].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[54].opcodes[1] = { type: 6, string: [37] };
      this.rules[54].opcodes[2] = { type: 1, children: [3, 10, 17] };
      this.rules[54].opcodes[3] = { type: 2, children: [4, 5, 6] };
      this.rules[54].opcodes[4] = { type: 4, index: 76 };
      this.rules[54].opcodes[5] = { type: 4, index: 73 };
      this.rules[54].opcodes[6] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[7] = { type: 2, children: [8, 9] };
      this.rules[54].opcodes[8] = { type: 6, string: [46] };
      this.rules[54].opcodes[9] = { type: 4, index: 73 };
      this.rules[54].opcodes[10] = { type: 2, children: [11, 12, 13] };
      this.rules[54].opcodes[11] = { type: 4, index: 77 };
      this.rules[54].opcodes[12] = { type: 4, index: 74 };
      this.rules[54].opcodes[13] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[14] = { type: 2, children: [15, 16] };
      this.rules[54].opcodes[15] = { type: 6, string: [46] };
      this.rules[54].opcodes[16] = { type: 4, index: 74 };
      this.rules[54].opcodes[17] = { type: 2, children: [18, 19, 20] };
      this.rules[54].opcodes[18] = { type: 4, index: 78 };
      this.rules[54].opcodes[19] = { type: 4, index: 75 };
      this.rules[54].opcodes[20] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[21] = { type: 2, children: [22, 23] };
      this.rules[54].opcodes[22] = { type: 6, string: [46] };
      this.rules[54].opcodes[23] = { type: 4, index: 75 };
      this.rules[55].opcodes = [];
      this.rules[55].opcodes[0] = { type: 2, children: [1, 2, 3, 4] };
      this.rules[55].opcodes[1] = { type: 4, index: 56 };
      this.rules[55].opcodes[2] = { type: 4, index: 57 };
      this.rules[55].opcodes[3] = { type: 4, index: 59 };
      this.rules[55].opcodes[4] = { type: 4, index: 58 };
      this.rules[56].opcodes = [];
      this.rules[56].opcodes[0] = { type: 3, min: 0, max: 1 };
      this.rules[56].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[56].opcodes[2] = { type: 7, string: [37, 105] };
      this.rules[56].opcodes[3] = { type: 7, string: [37, 115] };
      this.rules[57].opcodes = [];
      this.rules[57].opcodes[0] = { type: 6, string: [34] };
      this.rules[58].opcodes = [];
      this.rules[58].opcodes[0] = { type: 6, string: [34] };
      this.rules[59].opcodes = [];
      this.rules[59].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[59].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[59].opcodes[2] = { type: 5, min: 32, max: 33 };
      this.rules[59].opcodes[3] = { type: 5, min: 35, max: 126 };
      this.rules[59].opcodes[4] = { type: 4, index: 60 };
      this.rules[60].opcodes = [];
      this.rules[60].opcodes[0] = { type: 6, string: [9] };
      this.rules[61].opcodes = [];
      this.rules[61].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[61].opcodes[1] = { type: 4, index: 62 };
      this.rules[61].opcodes[2] = { type: 4, index: 64 };
      this.rules[61].opcodes[3] = { type: 4, index: 63 };
      this.rules[62].opcodes = [];
      this.rules[62].opcodes[0] = { type: 6, string: [39] };
      this.rules[63].opcodes = [];
      this.rules[63].opcodes[0] = { type: 6, string: [39] };
      this.rules[64].opcodes = [];
      this.rules[64].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[64].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[64].opcodes[2] = { type: 5, min: 32, max: 38 };
      this.rules[64].opcodes[3] = { type: 5, min: 40, max: 126 };
      this.rules[64].opcodes[4] = { type: 4, index: 60 };
      this.rules[65].opcodes = [];
      this.rules[65].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[65].opcodes[1] = { type: 4, index: 66 };
      this.rules[65].opcodes[2] = { type: 4, index: 67 };
      this.rules[65].opcodes[3] = { type: 4, index: 68 };
      this.rules[66].opcodes = [];
      this.rules[66].opcodes[0] = { type: 6, string: [60] };
      this.rules[67].opcodes = [];
      this.rules[67].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[67].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[67].opcodes[2] = { type: 5, min: 32, max: 61 };
      this.rules[67].opcodes[3] = { type: 5, min: 63, max: 126 };
      this.rules[67].opcodes[4] = { type: 4, index: 60 };
      this.rules[68].opcodes = [];
      this.rules[68].opcodes[0] = { type: 6, string: [62] };
      this.rules[69].opcodes = [];
      this.rules[69].opcodes[0] = { type: 4, index: 72 };
      this.rules[70].opcodes = [];
      this.rules[70].opcodes[0] = { type: 4, index: 72 };
      this.rules[71].opcodes = [];
      this.rules[71].opcodes[0] = { type: 4, index: 72 };
      this.rules[72].opcodes = [];
      this.rules[72].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[72].opcodes[1] = { type: 5, min: 48, max: 57 };
      this.rules[73].opcodes = [];
      this.rules[73].opcodes[0] = { type: 4, index: 85 };
      this.rules[74].opcodes = [];
      this.rules[74].opcodes[0] = { type: 4, index: 87 };
      this.rules[75].opcodes = [];
      this.rules[75].opcodes[0] = { type: 4, index: 86 };
      this.rules[76].opcodes = [];
      this.rules[76].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[76].opcodes[1] = { type: 6, string: [68] };
      this.rules[76].opcodes[2] = { type: 6, string: [100] };
      this.rules[77].opcodes = [];
      this.rules[77].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[77].opcodes[1] = { type: 6, string: [88] };
      this.rules[77].opcodes[2] = { type: 6, string: [120] };
      this.rules[78].opcodes = [];
      this.rules[78].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[78].opcodes[1] = { type: 6, string: [66] };
      this.rules[78].opcodes[2] = { type: 6, string: [98] };
      this.rules[79].opcodes = [];
      this.rules[79].opcodes[0] = { type: 4, index: 85 };
      this.rules[80].opcodes = [];
      this.rules[80].opcodes[0] = { type: 4, index: 85 };
      this.rules[81].opcodes = [];
      this.rules[81].opcodes[0] = { type: 4, index: 86 };
      this.rules[82].opcodes = [];
      this.rules[82].opcodes[0] = { type: 4, index: 86 };
      this.rules[83].opcodes = [];
      this.rules[83].opcodes[0] = { type: 4, index: 87 };
      this.rules[84].opcodes = [];
      this.rules[84].opcodes[0] = { type: 4, index: 87 };
      this.rules[85].opcodes = [];
      this.rules[85].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[85].opcodes[1] = { type: 5, min: 48, max: 57 };
      this.rules[86].opcodes = [];
      this.rules[86].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[86].opcodes[1] = { type: 5, min: 48, max: 49 };
      this.rules[87].opcodes = [];
      this.rules[87].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[87].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[87].opcodes[2] = { type: 5, min: 48, max: 57 };
      this.rules[87].opcodes[3] = { type: 5, min: 65, max: 70 };
      this.rules[87].opcodes[4] = { type: 5, min: 97, max: 102 };
      this.rules[88].opcodes = [];
      this.rules[88].opcodes[0] = { type: 2, children: [1, 4] };
      this.rules[88].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[88].opcodes[2] = { type: 5, min: 97, max: 122 };
      this.rules[88].opcodes[3] = { type: 5, min: 65, max: 90 };
      this.rules[88].opcodes[4] = { type: 3, min: 0, max: Infinity };
      this.rules[88].opcodes[5] = { type: 1, children: [6, 7, 8, 9] };
      this.rules[88].opcodes[6] = { type: 5, min: 97, max: 122 };
      this.rules[88].opcodes[7] = { type: 5, min: 65, max: 90 };
      this.rules[88].opcodes[8] = { type: 5, min: 48, max: 57 };
      this.rules[88].opcodes[9] = { type: 6, string: [45] };
      this.rules[89].opcodes = [];
      this.rules[89].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[89].opcodes[1] = { type: 4, index: 91 };
      this.rules[90].opcodes = [];
      this.rules[90].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[90].opcodes[1] = { type: 4, index: 91 };
      this.rules[91].opcodes = [];
      this.rules[91].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[91].opcodes[1] = { type: 6, string: [32] };
      this.rules[91].opcodes[2] = { type: 6, string: [9] };
      this.rules[91].opcodes[3] = { type: 4, index: 92 };
      this.rules[91].opcodes[4] = { type: 4, index: 94 };
      this.rules[92].opcodes = [];
      this.rules[92].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[92].opcodes[1] = { type: 6, string: [59] };
      this.rules[92].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[92].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[92].opcodes[4] = { type: 5, min: 32, max: 126 };
      this.rules[92].opcodes[5] = { type: 6, string: [9] };
      this.rules[93].opcodes = [];
      this.rules[93].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[93].opcodes[1] = { type: 6, string: [13, 10] };
      this.rules[93].opcodes[2] = { type: 6, string: [10] };
      this.rules[93].opcodes[3] = { type: 6, string: [13] };
      this.rules[94].opcodes = [];
      this.rules[94].opcodes[0] = { type: 2, children: [1, 5] };
      this.rules[94].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[94].opcodes[2] = { type: 6, string: [13, 10] };
      this.rules[94].opcodes[3] = { type: 6, string: [10] };
      this.rules[94].opcodes[4] = { type: 6, string: [13] };
      this.rules[94].opcodes[5] = { type: 1, children: [6, 7] };
      this.rules[94].opcodes[6] = { type: 6, string: [32] };
      this.rules[94].opcodes[7] = { type: 6, string: [9] };
      this.toString =  __name(function toString5() {
        let str = "";
        str += ";\n";
        str += "; ABNF for JavaScript APG 2.0 SABNF\n";
        str += "; RFC 5234 with some restrictions and additions.\n";
        str += "; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\n";
        str += ';  - accepts %s"string" as a case-sensitive string\n';
        str += ';  - accepts %i"string" as a case-insensitive string\n';
        str += ';  - accepts "string" as a case-insensitive string\n';
        str += ";\n";
        str += "; Some restrictions:\n";
        str += ";   1. Rules must begin at first character of each line.\n";
        str += ";      Indentations on first rule and rules thereafter are not allowed.\n";
        str += ";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\n";
        str += ";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\n";
        str += ";      However, a working parser cannot be generated from them.\n";
        str += ";\n";
        str += "; Super set (SABNF) additions:\n";
        str += ";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\n";
        str += ";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\n";
        str += ";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\n";
        str += ";      e.g. &%d13 or &rule or !(A / B)\n";
        str += ";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\n";
        str += ";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\n";
        str += ";      u_name may be used as an element but no rule definition is given.\n";
        str += ";      e.g. rule = A / u_myUdt\n";
        str += ';           A = "a"\n';
        str += ";      would be a valid grammar.\n";
        str += ";   3. Case-sensitive, single-quoted strings are accepted.\n";
        str += ";      e.g. 'abc' would be equivalent to %d97.98.99\n";
        str += ';      (kept for backward compatibility, but superseded by %s"abc")  \n';
        str += "; New 12/26/2015\n";
        str += ";   4. Look-behind operators are accepted as element prefixes.\n";
        str += ";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\n";
        str += ";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\n";
        str += ";      e.g. &&%d13 or &&rule or !!(A / B)\n";
        str += ";   5. Back reference operators, i.e. \\rulename, are accepted.\n";
        str += ";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\n";
        str += ";      to match is a phrase previously matched by the rule 'rulename'.\n";
        str += ";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\n";
        str += ";      In universal mode, \\rulename matches the last match to 'rulename' regardless of where it was found.\n";
        str += ";      In parent-frame mode, \\rulename matches only the last match found on the parent's frame or parse tree level.\n";
        str += ";      Back reference modifiers can be used to specify case and mode.\n";
        str += ";      \\A defaults to case-insensitive and universal mode, e.g. \\A === \\%i%uA\n";
        str += ";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\n";
        str += ";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\n";
        str += ";      Case and mode modifiers can appear in any order, e.g. \\%s%pA === \\%p%sA. \n";
        str += ";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\n";
        str += ";      Returns EMPTY or NOMATCH. Never consumes any characters.\n";
        str += ";   8. String end anchor, AEN(%$) matches the end of the input string location.\n";
        str += ";      Returns EMPTY or NOMATCH. Never consumes any characters.\n";
        str += ";\n";
        str += "File            = *(BlankLine / Rule / RuleError)\n";
        str += "BlankLine       = *(%d32/%d9) [comment] LineEnd\n";
        str += "Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\n";
        str += "                / (LineEndError LineEnd))\n";
        str += "RuleLookup      = RuleNameTest owsp DefinedAsTest\n";
        str += "RuleNameTest    = RuleName/RuleNameError\n";
        str += "RuleName        = alphanum\n";
        str += "RuleNameError   = 1*(%d33-60/%d62-126)\n";
        str += "DefinedAsTest   = DefinedAs / DefinedAsError\n";
        str += "DefinedAsError  = 1*2%d33-126\n";
        str += "DefinedAs       = IncAlt / Defined\n";
        str += "Defined         = %d61\n";
        str += "IncAlt          = %d61.47\n";
        str += "RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\n";
        str += "LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\n";
        str += "Alternation     = Concatenation *(owsp AltOp Concatenation)\n";
        str += "Concatenation   = Repetition *(CatOp Repetition)\n";
        str += "Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\n";
        str += "Modifier        = (Predicate [RepOp])\n";
        str += "                / RepOp\n";
        str += "Predicate       = BkaOp\n";
        str += "                / BknOp\n";
        str += "                / AndOp\n";
        str += "                / NotOp\n";
        str += "BasicElement    = UdtOp\n";
        str += "                / RnmOp\n";
        str += "                / TrgOp\n";
        str += "                / TbsOp\n";
        str += "                / TlsOp\n";
        str += "                / ClsOp\n";
        str += "                / BkrOp\n";
        str += "                / AbgOp\n";
        str += "                / AenOp\n";
        str += "                / ProsVal\n";
        str += "BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\n";
        str += "Group           = GroupOpen  Alternation (GroupClose / GroupError)\n";
        str += "GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\n";
        str += "GroupOpen       = %d40 owsp\n";
        str += "GroupClose      = owsp %d41\n";
        str += "Option          = OptionOpen Alternation (OptionClose / OptionError)\n";
        str += "OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\n";
        str += "OptionOpen      = %d91 owsp\n";
        str += "OptionClose     = owsp %d93\n";
        str += "RnmOp           = alphanum\n";
        str += "BkrOp           = %d92 [bkrModifier] bkr-name\n";
        str += "bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\n";
        str += "cs              = '%s'\n";
        str += "ci              = '%i'\n";
        str += "um              = '%u'\n";
        str += "pm              = '%p'\n";
        str += "bkr-name        = uname / ename / rname\n";
        str += "rname           = alphanum\n";
        str += "uname           = %d117.95 alphanum\n";
        str += "ename           = %d101.95 alphanum\n";
        str += "UdtOp           = udt-empty\n";
        str += "                / udt-non-empty\n";
        str += "udt-non-empty   = %d117.95 alphanum\n";
        str += "udt-empty       = %d101.95 alphanum\n";
        str += "RepOp           = (rep-min StarOp rep-max)\n";
        str += "                / (rep-min StarOp)\n";
        str += "                / (StarOp rep-max)\n";
        str += "                / StarOp\n";
        str += "                / rep-min-max\n";
        str += "AltOp           = %d47 owsp\n";
        str += "CatOp           = wsp\n";
        str += "StarOp          = %d42\n";
        str += "AndOp           = %d38\n";
        str += "NotOp           = %d33\n";
        str += "BkaOp           = %d38.38\n";
        str += "BknOp           = %d33.33\n";
        str += "AbgOp           = %d37.94\n";
        str += "AenOp           = %d37.36\n";
        str += "TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\n";
        str += "TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\n";
        str += "TlsOp           = TlsCase TlsOpen TlsString TlsClose\n";
        str += 'TlsCase         = ["%i" / "%s"]\n';
        str += "TlsOpen         = %d34\n";
        str += "TlsClose        = %d34\n";
        str += "TlsString       = *(%d32-33/%d35-126/StringTab)\n";
        str += "StringTab       = %d9\n";
        str += "ClsOp           = ClsOpen ClsString ClsClose\n";
        str += "ClsOpen         = %d39\n";
        str += "ClsClose        = %d39\n";
        str += "ClsString       = *(%d32-38/%d40-126/StringTab)\n";
        str += "ProsVal         = ProsValOpen ProsValString ProsValClose\n";
        str += "ProsValOpen     = %d60\n";
        str += "ProsValString   = *(%d32-61/%d63-126/StringTab)\n";
        str += "ProsValClose    = %d62\n";
        str += "rep-min         = rep-num\n";
        str += "rep-min-max     = rep-num\n";
        str += "rep-max         = rep-num\n";
        str += "rep-num         = 1*(%d48-57)\n";
        str += "dString         = dnum\n";
        str += "xString         = xnum\n";
        str += "bString         = bnum\n";
        str += "Dec             = (%d68/%d100)\n";
        str += "Hex             = (%d88/%d120)\n";
        str += "Bin             = (%d66/%d98)\n";
        str += "dmin            = dnum\n";
        str += "dmax            = dnum\n";
        str += "bmin            = bnum\n";
        str += "bmax            = bnum\n";
        str += "xmin            = xnum\n";
        str += "xmax            = xnum\n";
        str += "dnum            = 1*(%d48-57)\n";
        str += "bnum            = 1*%d48-49\n";
        str += "xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\n";
        str += ";\n";
        str += "; Basics\n";
        str += "alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\n";
        str += "owsp            = *space\n";
        str += "wsp             = 1*space\n";
        str += "space           = %d32\n";
        str += "                / %d9\n";
        str += "                / comment\n";
        str += "                / LineContinue\n";
        str += "comment         = %d59 *(%d32-126 / %d9)\n";
        str += "LineEnd         = %d13.10\n";
        str += "                / %d10\n";
        str += "                / %d13\n";
        str += "LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\n";
        return str;
      }, "toString");
    }, "grammar");
  }
});
var require_parser2 = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/parser.js"(exports, module) {
    module.exports =  __name(function exportParser() {
      const thisFileName = "parser: ";
      const ApgLib = require_node_exports();
      const id = ApgLib.ids;
      const syn = new (require_syntax_callbacks())();
      const sem = new (require_semantic_callbacks())();
      const sabnfGrammar = new (require_sabnf_grammar())();
      const parser = new ApgLib.parser();
      parser.ast = new ApgLib.ast();
      parser.callbacks = syn.callbacks;
      parser.ast.callbacks = sem.callbacks;
      const findLine =  __name(function findLine2(lines, charIndex, charLength) {
        if (charIndex < 0 || charIndex >= charLength) {
          return -1;
        }
        for (let i = 0; i < lines.length; i += 1) {
          if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {
            return i;
          }
        }
        return -1;
      }, "findLine");
      const translateIndex =  __name(function translateIndex2(map2, index) {
        let ret = -1;
        if (index < map2.length) {
          for (let i = index; i < map2.length; i += 1) {
            if (map2[i] !== null) {
              ret = map2[i];
              break;
            }
          }
        }
        return ret;
      }, "translateIndex");
      const reduceOpcodes =  __name(function reduceOpcodes2(rules) {
        rules.forEach((rule) => {
          const opcodes = [];
          const map2 = [];
          let reducedIndex = 0;
          rule.opcodes.forEach((op) => {
            if (op.type === id.ALT && op.children.length === 1) {
              map2.push(null);
            } else if (op.type === id.CAT && op.children.length === 1) {
              map2.push(null);
            } else if (op.type === id.REP && op.min === 1 && op.max === 1) {
              map2.push(null);
            } else {
              map2.push(reducedIndex);
              opcodes.push(op);
              reducedIndex += 1;
            }
          });
          map2.push(reducedIndex);
          opcodes.forEach((op) => {
            if (op.type === id.ALT || op.type === id.CAT) {
              for (let i = 0; i < op.children.length; i += 1) {
                op.children[i] = translateIndex(map2, op.children[i]);
              }
            }
          });
          rule.opcodes = opcodes;
        });
      }, "reduceOpcodes");
      this.syntax =  __name(function syntax(chars, lines, errors, strict, trace) {
        if (trace) {
          if (trace.traceObject !== "traceObject") {
            throw new TypeError(`${thisFileName}trace argument is not a trace object`);
          }
          parser.trace = trace;
        }
        const data = {};
        data.errors = errors;
        data.strict = !!strict;
        data.lines = lines;
        data.findLine = findLine;
        data.charsLength = chars.length;
        data.ruleCount = 0;
        const result = parser.parse(sabnfGrammar, "file", chars, data);
        if (!result.success) {
          errors.push({
            line: 0,
            char: 0,
            msg: "syntax analysis of input grammar failed"
          });
        }
      }, "syntax");
      this.semantic =  __name(function semantic(chars, lines, errors) {
        const data = {};
        data.errors = errors;
        data.lines = lines;
        data.findLine = findLine;
        data.charsLength = chars.length;
        parser.ast.translate(data);
        if (errors.length) {
          return null;
        }
        reduceOpcodes(data.rules);
        return {
          rules: data.rules,
          udts: data.udts,
          lineMap: data.rulesLineMap
        };
      }, "semantic");
      this.generateSource =  __name(function generateSource(chars, lines, rules, udts, name5) {
        let source = "";
        let i;
        let bkrname;
        let bkrlower;
        let opcodeCount = 0;
        let charCodeMin = Infinity;
        let charCodeMax = 0;
        const ruleNames = [];
        const udtNames = [];
        let alt = 0;
        let cat = 0;
        let rnm = 0;
        let udt = 0;
        let rep = 0;
        let and = 0;
        let not = 0;
        let tls = 0;
        let tbs = 0;
        let trg = 0;
        let bkr = 0;
        let bka = 0;
        let bkn = 0;
        let abg = 0;
        let aen = 0;
        rules.forEach((rule) => {
          ruleNames.push(rule.lower);
          opcodeCount += rule.opcodes.length;
          rule.opcodes.forEach((op) => {
            switch (op.type) {
              case id.ALT:
                alt += 1;
                break;
              case id.CAT:
                cat += 1;
                break;
              case id.RNM:
                rnm += 1;
                break;
              case id.UDT:
                udt += 1;
                break;
              case id.REP:
                rep += 1;
                break;
              case id.AND:
                and += 1;
                break;
              case id.NOT:
                not += 1;
                break;
              case id.BKA:
                bka += 1;
                break;
              case id.BKN:
                bkn += 1;
                break;
              case id.BKR:
                bkr += 1;
                break;
              case id.ABG:
                abg += 1;
                break;
              case id.AEN:
                aen += 1;
                break;
              case id.TLS:
                tls += 1;
                for (i = 0; i < op.string.length; i += 1) {
                  if (op.string[i] < charCodeMin) {
                    charCodeMin = op.string[i];
                  }
                  if (op.string[i] > charCodeMax) {
                    charCodeMax = op.string[i];
                  }
                }
                break;
              case id.TBS:
                tbs += 1;
                for (i = 0; i < op.string.length; i += 1) {
                  if (op.string[i] < charCodeMin) {
                    charCodeMin = op.string[i];
                  }
                  if (op.string[i] > charCodeMax) {
                    charCodeMax = op.string[i];
                  }
                }
                break;
              case id.TRG:
                trg += 1;
                if (op.min < charCodeMin) {
                  charCodeMin = op.min;
                }
                if (op.max > charCodeMax) {
                  charCodeMax = op.max;
                }
                break;
              default:
                throw new Error("generateSource: unrecognized opcode");
            }
          });
        });
        ruleNames.sort();
        if (udts.length > 0) {
          udts.forEach((udtFunc) => {
            udtNames.push(udtFunc.lower);
          });
          udtNames.sort();
        }
        let funcname = "module.exports";
        if (name5 && typeof name5 === "string") {
          funcname = `let ${name5}`;
        }
        source += "// copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved<br>\n";
        source += "//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n";
        source += "//\n";
        source += "// Generated by apg-js, Version 4.0.0 [apg-js](https://github.com/ldthomas/apg-js)\n";
        source += `${funcname} = function grammar(){
`;
        source += "  // ```\n";
        source += "  // SUMMARY\n";
        source += `  //      rules = ${rules.length}
`;
        source += `  //       udts = ${udts.length}
`;
        source += `  //    opcodes = ${opcodeCount}
`;
        source += "  //        ---   ABNF original opcodes\n";
        source += `  //        ALT = ${alt}
`;
        source += `  //        CAT = ${cat}
`;
        source += `  //        REP = ${rep}
`;
        source += `  //        RNM = ${rnm}
`;
        source += `  //        TLS = ${tls}
`;
        source += `  //        TBS = ${tbs}
`;
        source += `  //        TRG = ${trg}
`;
        source += "  //        ---   SABNF superset opcodes\n";
        source += `  //        UDT = ${udt}
`;
        source += `  //        AND = ${and}
`;
        source += `  //        NOT = ${not}
`;
        source += `  //        BKA = ${bka}
`;
        source += `  //        BKN = ${bkn}
`;
        source += `  //        BKR = ${bkr}
`;
        source += `  //        ABG = ${abg}
`;
        source += `  //        AEN = ${aen}
`;
        source += "  // characters = [";
        if (tls + tbs + trg === 0) {
          source += " none defined ]";
        } else {
          source += `${charCodeMin} - ${charCodeMax}]`;
        }
        if (udt > 0) {
          source += " + user defined";
        }
        source += "\n";
        source += "  // ```\n";
        source += "  /* OBJECT IDENTIFIER (for internal parser use) */\n";
        source += "  this.grammarObject = 'grammarObject';\n";
        source += "\n";
        source += "  /* RULES */\n";
        source += "  this.rules = [];\n";
        rules.forEach((rule, ii) => {
          let thisRule = "  this.rules[";
          thisRule += ii;
          thisRule += "] = {name: '";
          thisRule += rule.name;
          thisRule += "', lower: '";
          thisRule += rule.lower;
          thisRule += "', index: ";
          thisRule += rule.index;
          thisRule += ", isBkr: ";
          thisRule += rule.isBkr;
          thisRule += "};\n";
          source += thisRule;
        });
        source += "\n";
        source += "  /* UDTS */\n";
        source += "  this.udts = [];\n";
        if (udts.length > 0) {
          udts.forEach((udtFunc, ii) => {
            let thisUdt = "  this.udts[";
            thisUdt += ii;
            thisUdt += "] = {name: '";
            thisUdt += udtFunc.name;
            thisUdt += "', lower: '";
            thisUdt += udtFunc.lower;
            thisUdt += "', index: ";
            thisUdt += udtFunc.index;
            thisUdt += ", empty: ";
            thisUdt += udtFunc.empty;
            thisUdt += ", isBkr: ";
            thisUdt += udtFunc.isBkr;
            thisUdt += "};\n";
            source += thisUdt;
          });
        }
        source += "\n";
        source += "  /* OPCODES */\n";
        rules.forEach((rule, ruleIndex) => {
          if (ruleIndex > 0) {
            source += "\n";
          }
          source += `  /* ${rule.name} */
`;
          source += `  this.rules[${ruleIndex}].opcodes = [];
`;
          rule.opcodes.forEach((op, opIndex) => {
            let prefix;
            switch (op.type) {
              case id.ALT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, children: [${op.children.toString()}]};// ALT
`;
                break;
              case id.CAT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, children: [${op.children.toString()}]};// CAT
`;
                break;
              case id.RNM:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}};// RNM(${rules[op.index].name})
`;
                break;
              case id.BKR:
                if (op.index >= rules.length) {
                  bkrname = udts[op.index - rules.length].name;
                  bkrlower = udts[op.index - rules.length].lower;
                } else {
                  bkrname = rules[op.index].name;
                  bkrlower = rules[op.index].lower;
                }
                prefix = "%i";
                if (op.bkrCase === id.BKR_MODE_CS) {
                  prefix = "%s";
                }
                if (op.bkrMode === id.BKR_MODE_UM) {
                  prefix += "%u";
                } else {
                  prefix += "%p";
                }
                bkrname = prefix + bkrname;
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}, lower: '${bkrlower}', bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode}};// BKR(\\${bkrname})
`;
                break;
              case id.UDT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, empty: ${op.empty}, index: ${op.index}};// UDT(${udts[op.index].name})
`;
                break;
              case id.REP:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// REP
`;
                break;
              case id.AND:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AND
`;
                break;
              case id.NOT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// NOT
`;
                break;
              case id.ABG:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// ABG(%^)
`;
                break;
              case id.AEN:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AEN(%$)
`;
                break;
              case id.BKA:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKA
`;
                break;
              case id.BKN:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKN
`;
                break;
              case id.TLS:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, string: [${op.string.toString()}]};// TLS
`;
                break;
              case id.TBS:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, string: [${op.string.toString()}]};// TBS
`;
                break;
              case id.TRG:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// TRG
`;
                break;
              default:
                throw new Error("parser.js: ~143: unrecognized opcode");
            }
          });
        });
        source += "\n";
        source += "  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n";
        source += "  this.toString = function toString(){\n";
        source += '    let str = "";\n';
        let str;
        lines.forEach((line) => {
          const end = line.beginChar + line.length;
          str = "";
          source += '    str += "';
          for (let ii = line.beginChar; ii < end; ii += 1) {
            switch (chars[ii]) {
              case 9:
                str = " ";
                break;
              case 10:
                str = "\\n";
                break;
              case 13:
                str = "\\r";
                break;
              case 34:
                str = '\\"';
                break;
              case 92:
                str = "\\\\";
                break;
              default:
                str = String.fromCharCode(chars[ii]);
                break;
            }
            source += str;
          }
          source += '";\n';
        });
        source += "    return str;\n";
        source += "  }\n";
        source += "}\n";
        return source;
      }, "generateSource");
      this.generateObject =  __name(function generateObject(stringArg, rules, udts) {
        const obj = {};
        const ruleNames = [];
        const udtNames = [];
        const string2 = stringArg.slice(0);
        obj.grammarObject = "grammarObject";
        rules.forEach((rule) => {
          ruleNames.push(rule.lower);
        });
        ruleNames.sort();
        if (udts.length > 0) {
          udts.forEach((udtFunc) => {
            udtNames.push(udtFunc.lower);
          });
          udtNames.sort();
        }
        obj.callbacks = [];
        ruleNames.forEach((name5) => {
          obj.callbacks[name5] = false;
        });
        if (udts.length > 0) {
          udtNames.forEach((name5) => {
            obj.callbacks[name5] = false;
          });
        }
        obj.rules = rules;
        obj.udts = udts;
        obj.toString =  __name(function toStringFunc() {
          return string2;
        }, "toStringFunc");
        return obj;
      }, "generateObject");
    }, "exportParser");
  }
});
var require_rule_attributes = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/rule-attributes.js"(exports, module) {
    module.exports = ( __name(function exportRuleAttributes() {
      const id = require_identifiers();
      const thisFile = "rule-attributes.js";
      let state = null;
      function isEmptyOnly(attr) {
        if (attr.left || attr.nested || attr.right || attr.cyclic) {
          return false;
        }
        return attr.empty;
      }
      __name(isEmptyOnly, "isEmptyOnly");
      function isRecursive(attr) {
        if (attr.left || attr.nested || attr.right || attr.cyclic) {
          return true;
        }
        return false;
      }
      __name(isRecursive, "isRecursive");
      function isCatNested(attrs, count) {
        let i = 0;
        let j = 0;
        let k = 0;
        for (i = 0; i < count; i += 1) {
          if (attrs[i].nested) {
            return true;
          }
        }
        for (i = 0; i < count; i += 1) {
          if (attrs[i].right && !attrs[i].leaf) {
            for (j = i + 1; j < count; j += 1) {
              if (!isEmptyOnly(attrs[j])) {
                return true;
              }
            }
          }
        }
        for (i = count - 1; i >= 0; i -= 1) {
          if (attrs[i].left && !attrs[i].leaf) {
            for (j = i - 1; j >= 0; j -= 1) {
              if (!isEmptyOnly(attrs[j])) {
                return true;
              }
            }
          }
        }
        for (i = 0; i < count; i += 1) {
          if (!attrs[i].empty && !isRecursive(attrs[i])) {
            for (j = i + 1; j < count; j += 1) {
              if (isRecursive(attrs[j])) {
                for (k = j + 1; k < count; k += 1) {
                  if (!attrs[k].empty && !isRecursive(attrs[k])) {
                    return true;
                  }
                }
              }
            }
          }
        }
        return false;
      }
      __name(isCatNested, "isCatNested");
      function isCatCyclic(attrs, count) {
        for (let i = 0; i < count; i += 1) {
          if (!attrs[i].cyclic) {
            return false;
          }
        }
        return true;
      }
      __name(isCatCyclic, "isCatCyclic");
      function isCatLeft(attrs, count) {
        for (let i = 0; i < count; i += 1) {
          if (attrs[i].left) {
            return true;
          }
          if (!attrs[i].empty) {
            return false;
          }
        }
        return false;
      }
      __name(isCatLeft, "isCatLeft");
      function isCatRight(attrs, count) {
        for (let i = count - 1; i >= 0; i -= 1) {
          if (attrs[i].right) {
            return true;
          }
          if (!attrs[i].empty) {
            return false;
          }
        }
        return false;
      }
      __name(isCatRight, "isCatRight");
      function isCatEmpty(attrs, count) {
        for (let i = 0; i < count; i += 1) {
          if (!attrs[i].empty) {
            return false;
          }
        }
        return true;
      }
      __name(isCatEmpty, "isCatEmpty");
      function isCatFinite(attrs, count) {
        for (let i = 0; i < count; i += 1) {
          if (!attrs[i].finite) {
            return false;
          }
        }
        return true;
      }
      __name(isCatFinite, "isCatFinite");
      function cat(stateArg, opcodes, opIndex, iAttr) {
        let i = 0;
        const opCat = opcodes[opIndex];
        const count = opCat.children.length;
        const childAttrs = [];
        for (i = 0; i < count; i += 1) {
          childAttrs.push(stateArg.attrGen());
        }
        for (i = 0; i < count; i += 1) {
          opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);
        }
        iAttr.left = isCatLeft(childAttrs, count);
        iAttr.right = isCatRight(childAttrs, count);
        iAttr.nested = isCatNested(childAttrs, count);
        iAttr.empty = isCatEmpty(childAttrs, count);
        iAttr.finite = isCatFinite(childAttrs, count);
        iAttr.cyclic = isCatCyclic(childAttrs, count);
      }
      __name(cat, "cat");
      function alt(stateArg, opcodes, opIndex, iAttr) {
        let i = 0;
        const opAlt = opcodes[opIndex];
        const count = opAlt.children.length;
        const childAttrs = [];
        for (i = 0; i < count; i += 1) {
          childAttrs.push(stateArg.attrGen());
        }
        for (i = 0; i < count; i += 1) {
          opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);
        }
        iAttr.left = false;
        iAttr.right = false;
        iAttr.nested = false;
        iAttr.empty = false;
        iAttr.finite = false;
        iAttr.cyclic = false;
        for (i = 0; i < count; i += 1) {
          if (childAttrs[i].left) {
            iAttr.left = true;
          }
          if (childAttrs[i].nested) {
            iAttr.nested = true;
          }
          if (childAttrs[i].right) {
            iAttr.right = true;
          }
          if (childAttrs[i].empty) {
            iAttr.empty = true;
          }
          if (childAttrs[i].finite) {
            iAttr.finite = true;
          }
          if (childAttrs[i].cyclic) {
            iAttr.cyclic = true;
          }
        }
      }
      __name(alt, "alt");
      function bkr(stateArg, opcodes, opIndex, iAttr) {
        const opBkr = opcodes[opIndex];
        if (opBkr.index >= stateArg.ruleCount) {
          iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;
          iAttr.finite = true;
        } else {
          ruleAttrsEval(stateArg, opBkr.index, iAttr);
          iAttr.left = false;
          iAttr.nested = false;
          iAttr.right = false;
          iAttr.cyclic = false;
        }
      }
      __name(bkr, "bkr");
      function opEval(stateArg, opcodes, opIndex, iAttr) {
        stateArg.attrInit(iAttr);
        const opi = opcodes[opIndex];
        switch (opi.type) {
          case id.ALT:
            alt(stateArg, opcodes, opIndex, iAttr);
            break;
          case id.CAT:
            cat(stateArg, opcodes, opIndex, iAttr);
            break;
          case id.REP:
            opEval(stateArg, opcodes, opIndex + 1, iAttr);
            if (opi.min === 0) {
              iAttr.empty = true;
              iAttr.finite = true;
            }
            break;
          case id.RNM:
            ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);
            break;
          case id.BKR:
            bkr(stateArg, opcodes, opIndex, iAttr);
            break;
          case id.AND:
          case id.NOT:
          case id.BKA:
          case id.BKN:
            opEval(stateArg, opcodes, opIndex + 1, iAttr);
            iAttr.empty = true;
            break;
          case id.TLS:
            iAttr.empty = !opcodes[opIndex].string.length;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id.TBS:
          case id.TRG:
            iAttr.empty = false;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id.UDT:
            iAttr.empty = opi.empty;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id.ABG:
          case id.AEN:
            iAttr.empty = true;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          default:
            throw new Error(`unknown opcode type: ${opi}`);
        }
      }
      __name(opEval, "opEval");
      function ruleAttrsEval(stateArg, ruleIndex, iAttr) {
        const attri = stateArg.attrsWorking[ruleIndex];
        if (attri.isComplete) {
          stateArg.attrCopy(iAttr, attri);
        } else if (!attri.isOpen) {
          attri.isOpen = true;
          opEval(stateArg, attri.rule.opcodes, 0, iAttr);
          attri.left = iAttr.left;
          attri.right = iAttr.right;
          attri.nested = iAttr.nested;
          attri.empty = iAttr.empty;
          attri.finite = iAttr.finite;
          attri.cyclic = iAttr.cyclic;
          attri.leaf = false;
          attri.isOpen = false;
          attri.isComplete = true;
        } else if (ruleIndex === stateArg.startRule) {
          if (ruleIndex === stateArg.startRule) {
            iAttr.left = true;
            iAttr.right = true;
            iAttr.cyclic = true;
            iAttr.leaf = true;
          }
        } else {
          iAttr.finite = true;
        }
      }
      __name(ruleAttrsEval, "ruleAttrsEval");
      const ruleAttributes =  __name((stateArg) => {
        state = stateArg;
        let i = 0;
        let j = 0;
        const iAttr = state.attrGen();
        for (i = 0; i < state.ruleCount; i += 1) {
          for (j = 0; j < state.ruleCount; j += 1) {
            state.attrInit(state.attrsWorking[j]);
          }
          state.startRule = i;
          ruleAttrsEval(state, i, iAttr);
          state.attrCopy(state.attrs[i], state.attrsWorking[i]);
        }
        state.attributesComplete = true;
        let attri = null;
        for (i = 0; i < state.ruleCount; i += 1) {
          attri = state.attrs[i];
          if (attri.left || !attri.finite || attri.cyclic) {
            const temp = state.attrGen(attri.rule);
            state.attrCopy(temp, attri);
            state.attrsErrors.push(temp);
            state.attrsErrorCount += 1;
          }
        }
      }, "ruleAttributes");
      const truth =  __name((val) => val ? "t" : "f", "truth");
      const tError =  __name((val) => val ? "e" : "f", "tError");
      const fError =  __name((val) => val ? "t" : "e", "fError");
      const showAttr =  __name((seq, index, attr, dep) => {
        let str = `${seq}:${index}:`;
        str += `${tError(attr.left)} `;
        str += `${truth(attr.nested)} `;
        str += `${truth(attr.right)} `;
        str += `${tError(attr.cyclic)} `;
        str += `${fError(attr.finite)} `;
        str += `${truth(attr.empty)}:`;
        str += `${state.typeToString(dep.recursiveType)}:`;
        str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : "-";
        str += `:${attr.rule.name}
`;
        return str;
      }, "showAttr");
      const showLegend =  __name(() => {
        let str = "LEGEND - t=true, f=false, e=error\n";
        str += "sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\n";
        return str;
      }, "showLegend");
      const showAttributeErrors =  __name(() => {
        let attri = null;
        let depi = null;
        let str = "";
        str += "RULE ATTRIBUTES WITH ERRORS\n";
        str += showLegend();
        if (state.attrsErrorCount) {
          for (let i = 0; i < state.attrsErrorCount; i += 1) {
            attri = state.attrsErrors[i];
            depi = state.ruleDeps[attri.rule.index];
            str += showAttr(i, attri.rule.index, attri, depi);
          }
        } else {
          str += "<none>\n";
        }
        return str;
      }, "showAttributeErrors");
      const show =  __name((type) => {
        let i = 0;
        let ii = 0;
        let attri = null;
        let depi = null;
        let str = "";
        let { ruleIndexes } = state;
        if (type === 97) {
          ruleIndexes = state.ruleAlphaIndexes;
        } else if (type === 116) {
          ruleIndexes = state.ruleTypeIndexes;
        }
        for (i = 0; i < state.ruleCount; i += 1) {
          ii = ruleIndexes[i];
          attri = state.attrs[ii];
          depi = state.ruleDeps[ii];
          str += showAttr(i, ii, attri, depi);
        }
        return str;
      }, "show");
      const showAttributes =  __name((order = "index") => {
        if (!state.attributesComplete) {
          throw new Error(`${thisFile}:showAttributes: attributes not available`);
        }
        let str = "";
        const leader = "RULE ATTRIBUTES\n";
        if (order.charCodeAt(0) === 97) {
          str += "alphabetical by rule name\n";
          str += leader;
          str += showLegend();
          str += show(97);
        } else if (order.charCodeAt(0) === 116) {
          str += "ordered by rule type\n";
          str += leader;
          str += showLegend();
          str += show(116);
        } else {
          str += "ordered by rule index\n";
          str += leader;
          str += showLegend();
          str += show();
        }
        return str;
      }, "showAttributes");
      return { ruleAttributes, showAttributes, showAttributeErrors };
    }, "exportRuleAttributes"))();
  }
});
var require_rule_dependencies = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/rule-dependencies.js"(exports, module) {
    module.exports = (() => {
      const id = require_identifiers();
      let state = null;
      const scan =  __name((ruleCount, ruleDeps, index, isScanned) => {
        let i = 0;
        let j = 0;
        const rdi = ruleDeps[index];
        isScanned[index] = true;
        const op = rdi.rule.opcodes;
        for (i = 0; i < op.length; i += 1) {
          const opi = op[i];
          if (opi.type === id.RNM) {
            rdi.refersTo[opi.index] = true;
            if (!isScanned[opi.index]) {
              scan(ruleCount, ruleDeps, opi.index, isScanned);
            }
            for (j = 0; j < ruleCount; j += 1) {
              if (ruleDeps[opi.index].refersTo[j]) {
                rdi.refersTo[j] = true;
              }
            }
          } else if (opi.type === id.UDT) {
            rdi.refersToUdt[opi.index] = true;
          } else if (opi.type === id.BKR) {
            if (opi.index < ruleCount) {
              rdi.refersTo[opi.index] = true;
              if (!isScanned[opi.index]) {
                scan(ruleCount, ruleDeps, opi.index, isScanned);
              }
            } else {
              rdi.refersToUdt[ruleCount - opi.index] = true;
            }
          }
        }
      }, "scan");
      const ruleDependencies =  __name((stateArg) => {
        state = stateArg;
        let i = 0;
        let j = 0;
        let groupCount = 0;
        let rdi = null;
        let rdj = null;
        let newGroup = false;
        state.dependenciesComplete = false;
        const isScanned = state.falseArray(state.ruleCount);
        for (i = 0; i < state.ruleCount; i += 1) {
          state.falsifyArray(isScanned);
          scan(state.ruleCount, state.ruleDeps, i, isScanned);
        }
        for (i = 0; i < state.ruleCount; i += 1) {
          for (j = 0; j < state.ruleCount; j += 1) {
            if (i !== j) {
              if (state.ruleDeps[j].refersTo[i]) {
                state.ruleDeps[i].referencedBy[j] = true;
              }
            }
          }
        }
        for (i = 0; i < state.ruleCount; i += 1) {
          state.ruleDeps[i].recursiveType = id.ATTR_N;
          if (state.ruleDeps[i].refersTo[i]) {
            state.ruleDeps[i].recursiveType = id.ATTR_R;
          }
        }
        groupCount = -1;
        for (i = 0; i < state.ruleCount; i += 1) {
          rdi = state.ruleDeps[i];
          if (rdi.recursiveType === id.ATTR_R) {
            newGroup = true;
            for (j = 0; j < state.ruleCount; j += 1) {
              if (i !== j) {
                rdj = state.ruleDeps[j];
                if (rdj.recursiveType === id.ATTR_R) {
                  if (rdi.refersTo[j] && rdj.refersTo[i]) {
                    if (newGroup) {
                      groupCount += 1;
                      rdi.recursiveType = id.ATTR_MR;
                      rdi.groupNumber = groupCount;
                      newGroup = false;
                    }
                    rdj.recursiveType = id.ATTR_MR;
                    rdj.groupNumber = groupCount;
                  }
                }
              }
            }
          }
        }
        state.isMutuallyRecursive = groupCount > -1;
        state.ruleAlphaIndexes.sort(state.compRulesAlpha);
        state.ruleTypeIndexes.sort(state.compRulesAlpha);
        state.ruleTypeIndexes.sort(state.compRulesType);
        if (state.isMutuallyRecursive) {
          state.ruleTypeIndexes.sort(state.compRulesGroup);
        }
        if (state.udtCount) {
          state.udtAlphaIndexes.sort(state.compUdtsAlpha);
        }
        state.dependenciesComplete = true;
      }, "ruleDependencies");
      const show =  __name((type = null) => {
        let i = 0;
        let j = 0;
        let count = 0;
        let startSeg = 0;
        const maxRule = state.ruleCount - 1;
        const maxUdt = state.udtCount - 1;
        const lineLength = 100;
        let str = "";
        let pre = "";
        const toArrow = "=> ";
        const byArrow = "<= ";
        let first2 = false;
        let rdi = null;
        let { ruleIndexes } = state;
        let { udtIndexes } = state;
        if (type === 97) {
          ruleIndexes = state.ruleAlphaIndexes;
          udtIndexes = state.udtAlphaIndexes;
        } else if (type === 116) {
          ruleIndexes = state.ruleTypeIndexes;
          udtIndexes = state.udtAlphaIndexes;
        }
        for (i = 0; i < state.ruleCount; i += 1) {
          rdi = state.ruleDeps[ruleIndexes[i]];
          pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;
          if (state.isMutuallyRecursive) {
            pre += rdi.groupNumber > -1 ? rdi.groupNumber : "-";
            pre += ":";
          }
          pre += " ";
          str += `${pre + state.rules[ruleIndexes[i]].name}
`;
          first2 = true;
          count = 0;
          startSeg = str.length;
          str += pre;
          for (j = 0; j < state.ruleCount; j += 1) {
            if (rdi.refersTo[ruleIndexes[j]]) {
              if (first2) {
                str += toArrow;
                first2 = false;
                str += state.ruleDeps[ruleIndexes[j]].rule.name;
              } else {
                str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;
              }
              count += 1;
            }
            if (str.length - startSeg > lineLength && j !== maxRule) {
              str += `
${pre}${toArrow}`;
              startSeg = str.length;
            }
          }
          if (state.udtCount) {
            for (j = 0; j < state.udtCount; j += 1) {
              if (rdi.refersToUdt[udtIndexes[j]]) {
                if (first2) {
                  str += toArrow;
                  first2 = false;
                  str += state.udts[udtIndexes[j]].name;
                } else {
                  str += `, ${state.udts[udtIndexes[j]].name}`;
                }
                count += 1;
              }
              if (str.length - startSeg > lineLength && j !== maxUdt) {
                str += `
${pre}${toArrow}`;
                startSeg = str.length;
              }
            }
          }
          if (count === 0) {
            str += "=> <none>\n";
          }
          if (first2 === false) {
            str += "\n";
          }
          first2 = true;
          count = 0;
          startSeg = str.length;
          str += pre;
          for (j = 0; j < state.ruleCount; j += 1) {
            if (rdi.referencedBy[ruleIndexes[j]]) {
              if (first2) {
                str += byArrow;
                first2 = false;
                str += state.ruleDeps[ruleIndexes[j]].rule.name;
              } else {
                str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;
              }
              count += 1;
            }
            if (str.length - startSeg > lineLength && j !== maxRule) {
              str += `
${pre}${toArrow}`;
              startSeg = str.length;
            }
          }
          if (count === 0) {
            str += "<= <none>\n";
          }
          if (first2 === false) {
            str += "\n";
          }
          str += "\n";
        }
        return str;
      }, "show");
      const showRuleDependencies =  __name((order = "index") => {
        let str = "RULE DEPENDENCIES(index:type:[group number:])\n";
        str += "=> refers to rule names\n";
        str += "<= referenced by rule names\n";
        if (!state.dependenciesComplete) {
          return str;
        }
        if (order.charCodeAt(0) === 97) {
          str += "alphabetical by rule name\n";
          str += show(97);
        } else if (order.charCodeAt(0) === 116) {
          str += "ordered by rule type\n";
          str += show(116);
        } else {
          str += "ordered by rule index\n";
          str += show(null);
        }
        return str;
      }, "showRuleDependencies");
      return { ruleDependencies, showRuleDependencies };
    })();
  }
});
var require_attributes = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/attributes.js"(exports, module) {
    module.exports = ( __name(function exportAttributes() {
      const id = require_identifiers();
      const { ruleAttributes, showAttributes, showAttributeErrors } = require_rule_attributes();
      const { ruleDependencies, showRuleDependencies } = require_rule_dependencies();
      class State {
        constructor(rules, udts) {
          this.rules = rules;
          this.udts = udts;
          this.ruleCount = rules.length;
          this.udtCount = udts.length;
          this.startRule = 0;
          this.dependenciesComplete = false;
          this.attributesComplete = false;
          this.isMutuallyRecursive = false;
          this.ruleIndexes = this.indexArray(this.ruleCount);
          this.ruleAlphaIndexes = this.indexArray(this.ruleCount);
          this.ruleTypeIndexes = this.indexArray(this.ruleCount);
          this.udtIndexes = this.indexArray(this.udtCount);
          this.udtAlphaIndexes = this.indexArray(this.udtCount);
          this.attrsErrorCount = 0;
          this.attrs = [];
          this.attrsErrors = [];
          this.attrsWorking = [];
          this.ruleDeps = [];
          for (let i = 0; i < this.ruleCount; i += 1) {
            this.attrs.push(this.attrGen(this.rules[i]));
            this.attrsWorking.push(this.attrGen(this.rules[i]));
            this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));
          }
          this.compRulesAlpha = this.compRulesAlpha.bind(this);
          this.compUdtsAlpha = this.compUdtsAlpha.bind(this);
          this.compRulesType = this.compRulesType.bind(this);
          this.compRulesGroup = this.compRulesGroup.bind(this);
        }
        attrGen(rule) {
          return {
            left: false,
            nested: false,
            right: false,
            empty: false,
            finite: false,
            cyclic: false,
            leaf: false,
            isOpen: false,
            isComplete: false,
            rule
          };
        }
        attrInit(attr) {
          attr.left = false;
          attr.nested = false;
          attr.right = false;
          attr.empty = false;
          attr.finite = false;
          attr.cyclic = false;
          attr.leaf = false;
          attr.isOpen = false;
          attr.isComplete = false;
        }
        attrCopy(dst, src2) {
          dst.left = src2.left;
          dst.nested = src2.nested;
          dst.right = src2.right;
          dst.empty = src2.empty;
          dst.finite = src2.finite;
          dst.cyclic = src2.cyclic;
          dst.leaf = src2.leaf;
          dst.isOpen = src2.isOpen;
          dst.isComplete = src2.isComplete;
          dst.rule = src2.rule;
        }
        rdGen(rule, ruleCount, udtCount) {
          const ret = {
            rule,
            recursiveType: id.ATTR_N,
            groupNumber: -1,
            refersTo: this.falseArray(ruleCount),
            refersToUdt: this.falseArray(udtCount),
            referencedBy: this.falseArray(ruleCount)
          };
          return ret;
        }
        typeToString(recursiveType) {
          switch (recursiveType) {
            case id.ATTR_N:
              return " N";
            case id.ATTR_R:
              return " R";
            case id.ATTR_MR:
              return "MR";
            default:
              return "UNKNOWN";
          }
        }
        falseArray(length2) {
          const ret = [];
          if (length2 > 0) {
            for (let i = 0; i < length2; i += 1) {
              ret.push(false);
            }
          }
          return ret;
        }
        falsifyArray(a) {
          for (let i = 0; i < a.length; i += 1) {
            a[i] = false;
          }
        }
        indexArray(length2) {
          const ret = [];
          if (length2 > 0) {
            for (let i = 0; i < length2; i += 1) {
              ret.push(i);
            }
          }
          return ret;
        }
        compRulesAlpha(left, right) {
          if (this.rules[left].lower < this.rules[right].lower) {
            return -1;
          }
          if (this.rules[left].lower > this.rules[right].lower) {
            return 1;
          }
          return 0;
        }
        compUdtsAlpha(left, right) {
          if (this.udts[left].lower < this.udts[right].lower) {
            return -1;
          }
          if (this.udts[left].lower > this.udts[right].lower) {
            return 1;
          }
          return 0;
        }
        compRulesType(left, right) {
          if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {
            return -1;
          }
          if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {
            return 1;
          }
          return 0;
        }
        compRulesGroup(left, right) {
          if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {
            if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {
              return -1;
            }
            if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {
              return 1;
            }
          }
          return 0;
        }
      }
      __name(State, "State");
      const attributes =  __name(function attributes2(rules = [], udts = [], lineMap = [], errors = []) {
        const state = new State(rules, udts);
        ruleDependencies(state);
        ruleAttributes(state);
        if (state.attrsErrorCount) {
          errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });
        }
        return state.attrsErrorCount;
      }, "attributes");
      return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };
    }, "exportAttributes"))();
  }
});
var require_show_rules = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/show-rules.js"(exports, module) {
    module.exports = ( __name(function exfn() {
      const thisFileName = "show-rules.js";
      const showRules =  __name(function showRules2(rulesIn = [], udtsIn = [], order = "index") {
        const thisFuncName = "showRules";
        let alphaArray = [];
        let udtAlphaArray = [];
        const indexArray = [];
        const udtIndexArray = [];
        const rules = rulesIn;
        const udts = udtsIn;
        const ruleCount = rulesIn.length;
        const udtCount = udtsIn.length;
        let str = "RULE/UDT NAMES";
        let i;
        function compRulesAlpha(left, right) {
          if (rules[left].lower < rules[right].lower) {
            return -1;
          }
          if (rules[left].lower > rules[right].lower) {
            return 1;
          }
          return 0;
        }
        __name(compRulesAlpha, "compRulesAlpha");
        function compUdtsAlpha(left, right) {
          if (udts[left].lower < udts[right].lower) {
            return -1;
          }
          if (udts[left].lower > udts[right].lower) {
            return 1;
          }
          return 0;
        }
        __name(compUdtsAlpha, "compUdtsAlpha");
        if (!(Array.isArray(rulesIn) && rulesIn.length)) {
          throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);
        }
        if (!Array.isArray(udtsIn)) {
          throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);
        }
        for (i = 0; i < ruleCount; i += 1) {
          indexArray.push(i);
        }
        alphaArray = indexArray.slice(0);
        alphaArray.sort(compRulesAlpha);
        if (udtCount) {
          for (i = 0; i < udtCount; i += 1) {
            udtIndexArray.push(i);
          }
          udtAlphaArray = udtIndexArray.slice(0);
          udtAlphaArray.sort(compUdtsAlpha);
        }
        if (order.charCodeAt(0) === 97) {
          str += " - alphabetical by rule/UDT name\n";
          for (i = 0; i < ruleCount; i += 1) {
            str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}
`;
          }
          if (udtCount) {
            for (i = 0; i < udtCount; i += 1) {
              str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}
`;
            }
          }
        } else {
          str += " - ordered by rule/UDT index\n";
          for (i = 0; i < ruleCount; i += 1) {
            str += `${i}: ${rules[i].name}
`;
          }
          if (udtCount) {
            for (i = 0; i < udtCount; i += 1) {
              str += `${i}: ${udts[i].name}
`;
            }
          }
        }
        return str;
      }, "showRules");
      return showRules;
    }, "exfn"))();
  }
});
var require_api = __commonJS({
  "../../node_modules/.pnpm/apg-js@4.1.2/node_modules/apg-js/src/apg-api/api.js"(exports, module) {
    module.exports =  __name(function api(src2) {
      const thisFileName = "api.js: ";
      const thisObject = this;
      const apglib = require_node_exports();
      const converter = require_converter();
      const scanner = require_scanner();
      const parser = new (require_parser2())();
      const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = require_attributes();
      const showRules = require_show_rules();
      const abnfToHtml =  __name(function abnfToHtml2(chars, beg, len) {
        const NORMAL = 0;
        const CONTROL = 1;
        const INVALID2 = 2;
        const CONTROL_BEG = `<span class="${apglib.style.CLASS_CTRLCHAR}">`;
        const CONTROL_END = "</span>";
        const INVALID_BEG = `<span class="${apglib.style.CLASS_NOMATCH}">`;
        const INVALID_END = "</span>";
        let end;
        let html = "";
        const TRUE = true;
        while (TRUE) {
          if (!Array.isArray(chars) || chars.length === 0) {
            break;
          }
          if (typeof beg !== "number") {
            throw new Error("abnfToHtml: beg must be type number");
          }
          if (beg >= chars.length) {
            break;
          }
          if (typeof len !== "number" || beg + len >= chars.length) {
            end = chars.length;
          } else {
            end = beg + len;
          }
          let state = NORMAL;
          for (let i = beg; i < end; i += 1) {
            const ch = chars[i];
            if (ch >= 32 && ch <= 126) {
              if (state === CONTROL) {
                html += CONTROL_END;
                state = NORMAL;
              } else if (state === INVALID2) {
                html += INVALID_END;
                state = NORMAL;
              }
              switch (ch) {
                case 32:
                  html += "&nbsp;";
                  break;
                case 60:
                  html += "&lt;";
                  break;
                case 62:
                  html += "&gt;";
                  break;
                case 38:
                  html += "&amp;";
                  break;
                case 34:
                  html += "&quot;";
                  break;
                case 39:
                  html += "&#039;";
                  break;
                case 92:
                  html += "&#092;";
                  break;
                default:
                  html += String.fromCharCode(ch);
                  break;
              }
            } else if (ch === 9 || ch === 10 || ch === 13) {
              if (state === NORMAL) {
                html += CONTROL_BEG;
                state = CONTROL;
              } else if (state === INVALID2) {
                html += INVALID_END + CONTROL_BEG;
                state = CONTROL;
              }
              if (ch === 9) {
                html += "TAB";
              }
              if (ch === 10) {
                html += "LF";
              }
              if (ch === 13) {
                html += "CR";
              }
            } else {
              if (state === NORMAL) {
                html += INVALID_BEG;
                state = INVALID2;
              } else if (state === CONTROL) {
                html += CONTROL_END + INVALID_BEG;
                state = INVALID2;
              }
              html += `\\x${apglib.utils.charToHex(ch)}`;
            }
          }
          if (state === INVALID2) {
            html += INVALID_END;
          }
          if (state === CONTROL) {
            html += CONTROL_END;
          }
          break;
        }
        return html;
      }, "abnfToHtml");
      const abnfToAscii =  __name(function abnfToAscii2(chars, beg, len) {
        let str = "";
        for (let i = beg; i < beg + len; i += 1) {
          const ch = chars[i];
          if (ch >= 32 && ch <= 126) {
            str += String.fromCharCode(ch);
          } else {
            switch (ch) {
              case 9:
                str += "\\t";
                break;
              case 10:
                str += "\\n";
                break;
              case 13:
                str += "\\r";
                break;
              default:
                str += "\\unknown";
                break;
            }
          }
        }
        return str;
      }, "abnfToAscii");
      const linesToAscii =  __name(function linesToAscii2(lines) {
        let str = "Annotated Input Grammar";
        lines.forEach((val) => {
          str += "\n";
          str += `line no: ${val.lineNo}`;
          str += ` : char index: ${val.beginChar}`;
          str += ` : length: ${val.length}`;
          str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;
        });
        str += "\n";
        return str;
      }, "linesToAscii");
      const linesToHtml =  __name(function linesToHtml2(lines) {
        let html = "";
        html += `<table class="${apglib.style.CLASS_GRAMMAR}">
`;
        const title = "Annotated Input Grammar";
        html += `<caption>${title}</caption>
`;
        html += "<tr>";
        html += "<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>";
        html += "</tr>\n";
        lines.forEach((val) => {
          html += "<tr>";
          html += `<td>${val.lineNo}`;
          html += `</td><td>${val.beginChar}`;
          html += `</td><td>${val.length}`;
          html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;
          html += "</td>";
          html += "</tr>\n";
        });
        html += "</table>\n";
        return html;
      }, "linesToHtml");
      const errorsToHtml =  __name(function errorsToHtml2(errors, lines, chars, title) {
        const [style] = apglib;
        let html = "";
        const errorArrow = `<span class="${style.CLASS_NOMATCH}">&raquo;</span>`;
        html += `<p><table class="${style.CLASS_GRAMMAR}">
`;
        if (title && typeof title === "string") {
          html += `<caption>${title}</caption>
`;
        }
        html += "<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\n";
        errors.forEach((val) => {
          let line;
          let relchar;
          let beg;
          let end;
          let text;
          let prefix = "";
          let suffix = "";
          if (lines.length === 0) {
            text = errorArrow;
            relchar = 0;
          } else {
            line = lines[val.line];
            beg = line.beginChar;
            if (val.char > beg) {
              prefix = abnfToHtml(chars, beg, val.char - beg);
            }
            beg = val.char;
            end = line.beginChar + line.length;
            if (beg < end) {
              suffix = abnfToHtml(chars, beg, end - beg);
            }
            text = prefix + errorArrow + suffix;
            relchar = val.char - line.beginChar;
            html += "<tr>";
            html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;
            html += "</tr>\n";
            html += "<tr>";
            html += `<td colspan="3"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;
            html += "</tr>\n";
          }
        });
        html += "</table></p>\n";
        return html;
      }, "errorsToHtml");
      const errorsToAscii =  __name(function errorsToAscii2(errors, lines, chars) {
        let str;
        let line;
        let beg;
        let len;
        str = "";
        errors.forEach((error) => {
          line = lines[error.line];
          str += `${line.lineNo}: `;
          str += `${line.beginChar}: `;
          str += `${error.char - line.beginChar}: `;
          beg = line.beginChar;
          len = error.char - line.beginChar;
          str += abnfToAscii(chars, beg, len);
          str += " >> ";
          beg = error.char;
          len = line.beginChar + line.length - error.char;
          str += abnfToAscii(chars, beg, len);
          str += "\n";
          str += `${line.lineNo}: `;
          str += `${line.beginChar}: `;
          str += `${error.char - line.beginChar}: `;
          str += "error: ";
          str += error.msg;
          str += "\n";
        });
        return str;
      }, "errorsToAscii");
      let isScanned = false;
      let isParsed = false;
      let isTranslated = false;
      let haveAttributes = false;
      let attributeErrors = 0;
      let lineMap;
      this.errors = [];
      if (Buffer.isBuffer(src2)) {
        this.chars = converter.decode("BINARY", src2);
      } else if (Array.isArray(src2)) {
        this.chars = src2.slice();
      } else if (typeof src2 === "string") {
        this.chars = converter.decode("STRING", src2);
      } else {
        throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);
      }
      this.sabnf = converter.encode("STRING", this.chars);
      this.scan =  __name(function scan(strict, trace) {
        this.lines = scanner(this.chars, this.errors, strict, trace);
        isScanned = true;
      }, "scan");
      this.parse =  __name(function parse2(strict, trace) {
        if (!isScanned) {
          throw new Error(`${thisFileName}grammar not scanned`);
        }
        parser.syntax(this.chars, this.lines, this.errors, strict, trace);
        isParsed = true;
      }, "parse");
      this.translate =  __name(function translate() {
        if (!isParsed) {
          throw new Error(`${thisFileName}grammar not scanned and parsed`);
        }
        const ret = parser.semantic(this.chars, this.lines, this.errors);
        if (this.errors.length === 0) {
          this.rules = ret.rules;
          this.udts = ret.udts;
          lineMap = ret.lineMap;
          isTranslated = true;
        }
      }, "translate");
      this.attributes =  __name(function attrs() {
        if (!isTranslated) {
          throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);
        }
        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);
        haveAttributes = true;
        return attributeErrors;
      }, "attrs");
      this.generate =  __name(function generate3(strict) {
        this.lines = scanner(this.chars, this.errors, strict);
        if (this.errors.length) {
          return;
        }
        parser.syntax(this.chars, this.lines, this.errors, strict);
        if (this.errors.length) {
          return;
        }
        const ret = parser.semantic(this.chars, this.lines, this.errors);
        if (this.errors.length) {
          return;
        }
        this.rules = ret.rules;
        this.udts = ret.udts;
        lineMap = ret.lineMap;
        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);
        haveAttributes = true;
      }, "generate");
      this.displayRules =  __name(function displayRules(order = "index") {
        if (!isTranslated) {
          throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);
        }
        return showRules(this.rules, this.udts, order);
      }, "displayRules");
      this.displayRuleDependencies =  __name(function displayRuleDependencies(order = "index") {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        return showRuleDependencies(order);
      }, "displayRuleDependencies");
      this.displayAttributes =  __name(function displayAttributes(order = "index") {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          showAttributeErrors(order);
        }
        return showAttributes(order);
      }, "displayAttributes");
      this.displayAttributeErrors =  __name(function displayAttributeErrors() {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        return showAttributeErrors();
      }, "displayAttributeErrors");
      this.toSource =  __name(function toSource(name5) {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);
        }
        return parser.generateSource(this.chars, this.lines, this.rules, this.udts, name5);
      }, "toSource");
      this.toObject =  __name(function toObject() {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);
        }
        return parser.generateObject(this.sabnf, this.rules, this.udts);
      }, "toObject");
      this.errorsToAscii =  __name(function errorsToAsciiFunc() {
        return errorsToAscii(this.errors, this.lines, this.chars);
      }, "errorsToAsciiFunc");
      this.errorsToHtml =  __name(function errorsToHtmlFunc(title) {
        return errorsToHtml(this.errors, this.lines, this.chars, title);
      }, "errorsToHtmlFunc");
      this.linesToAscii =  __name(function linesToAsciiFunc() {
        return linesToAscii(this.lines);
      }, "linesToAsciiFunc");
      this.linesToHtml =  __name(function linesToHtmlFunc() {
        return linesToHtml(this.lines);
      }, "linesToHtmlFunc");
    }, "api");
  }
});
var require_bn2 = __commonJS({
  "../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      __name(assert2, "assert");
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor =  __name(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      __name(inherits, "inherits");
      function BN3(number, base4, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base4 === "le" || base4 === "be") {
            endian = base4;
            base4 = 10;
          }
          this._init(number || 0, base4 || 10, endian || "be");
        }
      }
      __name(BN3, "BN");
      if (typeof module2 === "object") {
        module2.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN =  __name(function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      }, "isBN");
      BN3.max =  __name(function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, "max");
      BN3.min =  __name(function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, "min");
      BN3.prototype._init =  __name(function init4(number, base4, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base4, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base4, endian);
        }
        if (base4 === "hex") {
          base4 = 16;
        }
        assert2(base4 === (base4 | 0) && base4 >= 2 && base4 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base4 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base4, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base4, endian);
            }
          }
        }
      }, "init");
      BN3.prototype._initNumber =  __name(function _initNumber(number, base4, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base4, endian);
      }, "_initNumber");
      BN3.prototype._initArray =  __name(function _initArray(number, base4, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      }, "_initArray");
      function parseHex4Bits(string2, index) {
        var c = string2.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string2);
        }
      }
      __name(parseHex4Bits, "parseHex4Bits");
      function parseHexByte(string2, lowerBound, index) {
        var r = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r;
      }
      __name(parseHexByte, "parseHexByte");
      BN3.prototype._parseHex =  __name(function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      }, "_parseHex");
      function parseBase(str, start, end, mul3) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul3;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert2(c >= 0 && b < mul3, "Invalid character");
          r += b;
        }
        return r;
      }
      __name(parseBase, "parseBase");
      BN3.prototype._parseBase =  __name(function _parseBase(number, base4, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base4) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base4 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base4);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base4);
          for (i = 0; i < mod2; i++) {
            pow *= base4;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      }, "_parseBase");
      BN3.prototype.copy =  __name(function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      }, "copy");
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      __name(move, "move");
      BN3.prototype._move =  __name(function _move(dest) {
        move(dest, this);
      }, "_move");
      BN3.prototype.clone =  __name(function clone() {
        var r = new BN3(null);
        this.copy(r);
        return r;
      }, "clone");
      BN3.prototype._expand =  __name(function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      }, "_expand");
      BN3.prototype._strip =  __name(function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      }, "strip");
      BN3.prototype._normSign =  __name(function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      }, "_normSign");
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e) {
          BN3.prototype.inspect = inspect4;
        }
      } else {
        BN3.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      __name(inspect4, "inspect");
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString =  __name(function toString5(base4, padding) {
        base4 = base4 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base4 === 16 || base4 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base4 === (base4 | 0) && base4 >= 2 && base4 <= 36) {
          var groupSize = groupSizes[base4];
          var groupBase = groupBases[base4];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base4);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      }, "toString");
      BN3.prototype.toNumber =  __name(function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      }, "toNumber");
      BN3.prototype.toJSON =  __name(function toJSON2() {
        return this.toString(16, 2);
      }, "toJSON");
      if (Buffer2) {
        BN3.prototype.toBuffer =  __name(function toBuffer(endian, length2) {
          return this.toArrayLike(Buffer2, endian, length2);
        }, "toBuffer");
      }
      BN3.prototype.toArray =  __name(function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      }, "toArray");
      var allocate =  __name(function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      }, "allocate");
      BN3.prototype.toArrayLike =  __name(function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      }, "toArrayLike");
      BN3.prototype._toArrayLikeLE =  __name(function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      }, "_toArrayLikeLE");
      BN3.prototype._toArrayLikeBE =  __name(function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      }, "_toArrayLikeBE");
      if (Math.clz32) {
        BN3.prototype._countBits =  __name(function _countBits(w) {
          return 32 - Math.clz32(w);
        }, "_countBits");
      } else {
        BN3.prototype._countBits =  __name(function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        }, "_countBits");
      }
      BN3.prototype._zeroBits =  __name(function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      }, "_zeroBits");
      BN3.prototype.bitLength =  __name(function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      }, "bitLength");
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      __name(toBitArray, "toBitArray");
      BN3.prototype.zeroBits =  __name(function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      }, "zeroBits");
      BN3.prototype.byteLength =  __name(function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, "byteLength");
      BN3.prototype.toTwos =  __name(function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      }, "toTwos");
      BN3.prototype.fromTwos =  __name(function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      }, "fromTwos");
      BN3.prototype.isNeg =  __name(function isNeg() {
        return this.negative !== 0;
      }, "isNeg");
      BN3.prototype.neg =  __name(function neg3() {
        return this.clone().ineg();
      }, "neg");
      BN3.prototype.ineg =  __name(function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      }, "ineg");
      BN3.prototype.iuor =  __name(function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      }, "iuor");
      BN3.prototype.ior =  __name(function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      }, "ior");
      BN3.prototype.or =  __name(function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, "or");
      BN3.prototype.uor =  __name(function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, "uor");
      BN3.prototype.iuand =  __name(function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      }, "iuand");
      BN3.prototype.iand =  __name(function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      }, "iand");
      BN3.prototype.and =  __name(function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, "and");
      BN3.prototype.uand =  __name(function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, "uand");
      BN3.prototype.iuxor =  __name(function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      }, "iuxor");
      BN3.prototype.ixor =  __name(function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }, "ixor");
      BN3.prototype.xor =  __name(function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, "xor");
      BN3.prototype.uxor =  __name(function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, "uxor");
      BN3.prototype.inotn =  __name(function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      }, "inotn");
      BN3.prototype.notn =  __name(function notn(width) {
        return this.clone().inotn(width);
      }, "notn");
      BN3.prototype.setn =  __name(function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      }, "setn");
      BN3.prototype.iadd =  __name(function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      }, "iadd");
      BN3.prototype.add =  __name(function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, "add");
      BN3.prototype.isub =  __name(function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      }, "isub");
      BN3.prototype.sub =  __name(function sub(num) {
        return this.clone().isub(num);
      }, "sub");
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      __name(smallMulTo, "smallMulTo");
      var comb10MulTo =  __name(function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      }, "comb10MulTo");
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      __name(bigMulTo, "bigMulTo");
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      __name(jumboMulTo, "jumboMulTo");
      BN3.prototype.mulTo =  __name(function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      }, "mulTo");
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      __name(FFTM, "FFTM");
      FFTM.prototype.makeRBT =  __name(function makeRBT(N) {
        var t = new Array(N);
        var l = BN3.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      }, "makeRBT");
      FFTM.prototype.revBin =  __name(function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      }, "revBin");
      FFTM.prototype.permute =  __name(function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      }, "permute");
      FFTM.prototype.transform =  __name(function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      }, "transform");
      FFTM.prototype.guessLen13b =  __name(function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      }, "guessLen13b");
      FFTM.prototype.conjugate =  __name(function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      }, "conjugate");
      FFTM.prototype.normalize13b =  __name(function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      }, "normalize13b");
      FFTM.prototype.convert13b =  __name(function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      }, "convert13b");
      FFTM.prototype.stub =  __name(function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      }, "stub");
      FFTM.prototype.mulp =  __name(function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      }, "mulp");
      BN3.prototype.mul =  __name(function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }, "mul");
      BN3.prototype.mulf =  __name(function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }, "mulf");
      BN3.prototype.imul =  __name(function imul(num) {
        return this.clone().mulTo(num, this);
      }, "imul");
      BN3.prototype.imuln =  __name(function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      }, "imuln");
      BN3.prototype.muln =  __name(function muln(num) {
        return this.clone().imuln(num);
      }, "muln");
      BN3.prototype.sqr =  __name(function sqr() {
        return this.mul(this);
      }, "sqr");
      BN3.prototype.isqr =  __name(function isqr() {
        return this.imul(this.clone());
      }, "isqr");
      BN3.prototype.pow =  __name(function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      }, "pow");
      BN3.prototype.iushln =  __name(function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      }, "iushln");
      BN3.prototype.ishln =  __name(function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      }, "ishln");
      BN3.prototype.iushrn =  __name(function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) ; else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      }, "iushrn");
      BN3.prototype.ishrn =  __name(function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }, "ishrn");
      BN3.prototype.shln =  __name(function shln(bits) {
        return this.clone().ishln(bits);
      }, "shln");
      BN3.prototype.ushln =  __name(function ushln(bits) {
        return this.clone().iushln(bits);
      }, "ushln");
      BN3.prototype.shrn =  __name(function shrn(bits) {
        return this.clone().ishrn(bits);
      }, "shrn");
      BN3.prototype.ushrn =  __name(function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, "ushrn");
      BN3.prototype.testn =  __name(function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      }, "testn");
      BN3.prototype.imaskn =  __name(function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      }, "imaskn");
      BN3.prototype.maskn =  __name(function maskn(bits) {
        return this.clone().imaskn(bits);
      }, "maskn");
      BN3.prototype.iaddn =  __name(function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      }, "iaddn");
      BN3.prototype._iaddn =  __name(function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      }, "_iaddn");
      BN3.prototype.isubn =  __name(function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      }, "isubn");
      BN3.prototype.addn =  __name(function addn(num) {
        return this.clone().iaddn(num);
      }, "addn");
      BN3.prototype.subn =  __name(function subn(num) {
        return this.clone().isubn(num);
      }, "subn");
      BN3.prototype.iabs =  __name(function iabs() {
        this.negative = 0;
        return this;
      }, "iabs");
      BN3.prototype.abs =  __name(function abs() {
        return this.clone().iabs();
      }, "abs");
      BN3.prototype._ishlnsubmul =  __name(function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul3;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      }, "_ishlnsubmul");
      BN3.prototype._wordDiv =  __name(function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      }, "_wordDiv");
      BN3.prototype.divmod =  __name(function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      }, "divmod");
      BN3.prototype.div =  __name(function div(num) {
        return this.divmod(num, "div", false).div;
      }, "div");
      BN3.prototype.mod =  __name(function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      }, "mod");
      BN3.prototype.umod =  __name(function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, "umod");
      BN3.prototype.divRound =  __name(function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, "divRound");
      BN3.prototype.modrn =  __name(function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      }, "modrn");
      BN3.prototype.modn =  __name(function modn(num) {
        return this.modrn(num);
      }, "modn");
      BN3.prototype.idivn =  __name(function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      }, "idivn");
      BN3.prototype.divn =  __name(function divn(num) {
        return this.clone().idivn(num);
      }, "divn");
      BN3.prototype.egcd =  __name(function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      }, "egcd");
      BN3.prototype._invmp =  __name(function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      }, "_invmp");
      BN3.prototype.gcd =  __name(function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, "gcd");
      BN3.prototype.invm =  __name(function invm(num) {
        return this.egcd(num).a.umod(num);
      }, "invm");
      BN3.prototype.isEven =  __name(function isEven() {
        return (this.words[0] & 1) === 0;
      }, "isEven");
      BN3.prototype.isOdd =  __name(function isOdd() {
        return (this.words[0] & 1) === 1;
      }, "isOdd");
      BN3.prototype.andln =  __name(function andln(num) {
        return this.words[0] & num;
      }, "andln");
      BN3.prototype.bincn =  __name(function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      }, "bincn");
      BN3.prototype.isZero =  __name(function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, "isZero");
      BN3.prototype.cmpn =  __name(function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmpn");
      BN3.prototype.cmp =  __name(function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, "cmp");
      BN3.prototype.ucmp =  __name(function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      }, "ucmp");
      BN3.prototype.gtn =  __name(function gtn(num) {
        return this.cmpn(num) === 1;
      }, "gtn");
      BN3.prototype.gt =  __name(function gt(num) {
        return this.cmp(num) === 1;
      }, "gt");
      BN3.prototype.gten =  __name(function gten(num) {
        return this.cmpn(num) >= 0;
      }, "gten");
      BN3.prototype.gte =  __name(function gte(num) {
        return this.cmp(num) >= 0;
      }, "gte");
      BN3.prototype.ltn =  __name(function ltn(num) {
        return this.cmpn(num) === -1;
      }, "ltn");
      BN3.prototype.lt =  __name(function lt(num) {
        return this.cmp(num) === -1;
      }, "lt");
      BN3.prototype.lten =  __name(function lten(num) {
        return this.cmpn(num) <= 0;
      }, "lten");
      BN3.prototype.lte =  __name(function lte(num) {
        return this.cmp(num) <= 0;
      }, "lte");
      BN3.prototype.eqn =  __name(function eqn(num) {
        return this.cmpn(num) === 0;
      }, "eqn");
      BN3.prototype.eq =  __name(function eq4(num) {
        return this.cmp(num) === 0;
      }, "eq");
      BN3.red =  __name(function red(num) {
        return new Red(num);
      }, "red");
      BN3.prototype.toRed =  __name(function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      }, "toRed");
      BN3.prototype.fromRed =  __name(function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      }, "fromRed");
      BN3.prototype._forceRed =  __name(function _forceRed(ctx) {
        this.red = ctx;
        return this;
      }, "_forceRed");
      BN3.prototype.forceRed =  __name(function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      }, "forceRed");
      BN3.prototype.redAdd =  __name(function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      }, "redAdd");
      BN3.prototype.redIAdd =  __name(function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      }, "redIAdd");
      BN3.prototype.redSub =  __name(function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      }, "redSub");
      BN3.prototype.redISub =  __name(function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      }, "redISub");
      BN3.prototype.redShl =  __name(function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      }, "redShl");
      BN3.prototype.redMul =  __name(function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      }, "redMul");
      BN3.prototype.redIMul =  __name(function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      }, "redIMul");
      BN3.prototype.redSqr =  __name(function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      }, "redSqr");
      BN3.prototype.redISqr =  __name(function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      }, "redISqr");
      BN3.prototype.redSqrt =  __name(function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      }, "redSqrt");
      BN3.prototype.redInvm =  __name(function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      }, "redInvm");
      BN3.prototype.redNeg =  __name(function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      }, "redNeg");
      BN3.prototype.redPow =  __name(function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      }, "redPow");
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name5, p) {
        this.name = name5;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      __name(MPrime, "MPrime");
      MPrime.prototype._tmp =  __name(function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      }, "_tmp");
      MPrime.prototype.ireduce =  __name(function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      }, "ireduce");
      MPrime.prototype.split =  __name(function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, "split");
      MPrime.prototype.imulK =  __name(function imulK(num) {
        return num.imul(this.k);
      }, "imulK");
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      __name(K256, "K256");
      inherits(K256, MPrime);
      K256.prototype.split =  __name(function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      }, "split");
      K256.prototype.imulK =  __name(function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      }, "imulK");
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      __name(P224, "P224");
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      __name(P192, "P192");
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      __name(P25519, "P25519");
      inherits(P25519, MPrime);
      P25519.prototype.imulK =  __name(function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      }, "imulK");
      BN3._prime =  __name(function prime(name5) {
        if (primes[name5])
          return primes[name5];
        var prime2;
        if (name5 === "k256") {
          prime2 = new K256();
        } else if (name5 === "p224") {
          prime2 = new P224();
        } else if (name5 === "p192") {
          prime2 = new P192();
        } else if (name5 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name5);
        }
        primes[name5] = prime2;
        return prime2;
      }, "prime");
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      __name(Red, "Red");
      Red.prototype._verify1 =  __name(function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      }, "_verify1");
      Red.prototype._verify2 =  __name(function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(a.red && a.red === b.red, "red works only with red numbers");
      }, "_verify2");
      Red.prototype.imod =  __name(function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      }, "imod");
      Red.prototype.neg =  __name(function neg3(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      }, "neg");
      Red.prototype.add =  __name(function add3(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      }, "add");
      Red.prototype.iadd =  __name(function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      }, "iadd");
      Red.prototype.sub =  __name(function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      }, "sub");
      Red.prototype.isub =  __name(function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      }, "isub");
      Red.prototype.shl =  __name(function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      }, "shl");
      Red.prototype.imul =  __name(function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      }, "imul");
      Red.prototype.mul =  __name(function mul3(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      }, "mul");
      Red.prototype.isqr =  __name(function isqr(a) {
        return this.imul(a, a.clone());
      }, "isqr");
      Red.prototype.sqr =  __name(function sqr(a) {
        return this.mul(a, a);
      }, "sqr");
      Red.prototype.sqrt =  __name(function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN3(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      }, "sqrt");
      Red.prototype.invm =  __name(function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      }, "invm");
      Red.prototype.pow =  __name(function pow(a, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      }, "pow");
      Red.prototype.convertTo =  __name(function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, "convertTo");
      Red.prototype.convertFrom =  __name(function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }, "convertFrom");
      BN3.mont =  __name(function mont(num) {
        return new Mont(num);
      }, "mont");
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      __name(Mont, "Mont");
      inherits(Mont, Red);
      Mont.prototype.convertTo =  __name(function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, "convertTo");
      Mont.prototype.convertFrom =  __name(function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      }, "convertFrom");
      Mont.prototype.imul =  __name(function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      }, "imul");
      Mont.prototype.mul =  __name(function mul3(a, b) {
        if (a.isZero() || b.isZero())
          return new BN3(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      }, "mul");
      Mont.prototype.invm =  __name(function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      }, "invm");
    })(typeof module === "undefined" || module, exports);
  }
});
var require_encode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode11;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode11(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode11.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode11.bytes = offset - oldOffset + 1;
      return out;
    }
    __name(encode11, "encode");
  }
});
var require_decode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports, module) {
    module.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
    __name(read2, "read");
  }
});
var require_length = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports, module) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});
var require_varint = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});
var require_src = __commonJS({
  "../../node_modules/.pnpm/@multiformats+base-x@4.0.1/node_modules/@multiformats/base-x/src/index.js"(exports, module) {
    function base4(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode11(source) {
        if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      __name(encode11, "encode");
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      __name(decodeUnsafe, "decodeUnsafe");
      function decode10(string2) {
        var buffer2 = decodeUnsafe(string2);
        if (buffer2) {
          return buffer2;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      __name(decode10, "decode");
      return {
        encode: encode11,
        decodeUnsafe,
        decode: decode10
      };
    }
    __name(base4, "base");
    module.exports = base4;
  }
});
var require_util = __commonJS({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/util.js"(exports, module) {
    var textDecoder3 = new TextDecoder();
    var decodeText =  __name((bytes) => textDecoder3.decode(bytes), "decodeText");
    var textEncoder3 = new TextEncoder();
    var encodeText =  __name((text) => textEncoder3.encode(text), "encodeText");
    function concat4(arrs, length2) {
      const output = new Uint8Array(length2);
      let offset = 0;
      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    __name(concat4, "concat");
    module.exports = { decodeText, encodeText, concat: concat4 };
  }
});
var require_base2 = __commonJS({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/base.js"(exports, module) {
    var { encodeText } = require_util();
    var Base = class {
      constructor(name5, code5, factory, alphabet2) {
        this.name = name5;
        this.code = code5;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet2;
        this.codec = factory(alphabet2);
      }
      encode(buf2) {
        return this.codec.encode(buf2);
      }
      decode(string2) {
        for (const char of string2) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string2}'`);
          }
        }
        return this.codec.decode(string2);
      }
    };
    __name(Base, "Base");
    module.exports = Base;
  }
});
var require_rfc4648 = __commonJS({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/rfc4648.js"(exports, module) {
    var decode10 =  __name((string2, alphabet2, bitsPerChar) => {
      const codes = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes[alphabet2[i]] = i;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string2[i]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string2[i]);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    }, "decode");
    var encode11 =  __name((data, alphabet2, bitsPerChar) => {
      const pad2 = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer2 = buffer2 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    }, "encode");
    var rfc46482 =  __name((bitsPerChar) => (alphabet2) => {
      return {
        encode(input) {
          return encode11(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode10(input, alphabet2, bitsPerChar);
        }
      };
    }, "rfc4648");
    module.exports = { rfc4648: rfc46482 };
  }
});
var require_constants = __commonJS({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/constants.js"(exports, module) {
    var baseX2 = require_src();
    var Base = require_base2();
    var { rfc4648: rfc46482 } = require_rfc4648();
    var { decodeText, encodeText } = require_util();
    var identity4 =  __name(() => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    }, "identity");
    var constants = [
      ["identity", "\0", identity4, ""],
      ["base2", "0", rfc46482(1), "01"],
      ["base8", "7", rfc46482(3), "01234567"],
      ["base10", "9", baseX2, "0123456789"],
      ["base16", "f", rfc46482(4), "0123456789abcdef"],
      ["base16upper", "F", rfc46482(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc46482(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc46482(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc46482(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX2, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX2, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX2, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX2, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce((prev, tupple) => {
      prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
      return prev;
    }, {});
    var codes = constants.reduce((prev, tupple) => {
      prev[tupple[1]] = names[tupple[0]];
      return prev;
    }, {});
    module.exports = {
      names,
      codes
    };
  }
});
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/index.js"(exports, module) {
    var constants = require_constants();
    var { encodeText, decodeText, concat: concat4 } = require_util();
    function multibase(nameOrCode, buf2) {
      if (!buf2) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name: name5, codeBuf } = encoding(nameOrCode);
      validEncode(name5, buf2);
      return concat4([codeBuf, buf2], codeBuf.length + buf2.length);
    }
    __name(multibase, "multibase");
    function encode11(nameOrCode, buf2) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf2));
      return concat4([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    __name(encode11, "encode");
    function decode10(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(data[0]);
      return enc.decode(data.substring(1));
    }
    __name(decode10, "decode");
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(data[0]);
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    __name(isEncoded, "isEncoded");
    function validEncode(name5, buf2) {
      const enc = encoding(name5);
      enc.decode(decodeText(buf2));
    }
    __name(validEncode, "validEncode");
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(constants.names, nameOrCode)) {
        return constants.names[nameOrCode];
      } else if (Object.prototype.hasOwnProperty.call(constants.codes, nameOrCode)) {
        return constants.codes[nameOrCode];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    __name(encoding, "encoding");
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(data[0]);
    }
    __name(encodingFromData, "encodingFromData");
    exports = module.exports = multibase;
    exports.encode = encode11;
    exports.decode = decode10;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    var names = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports.names = names;
    exports.codes = codes;
  }
});
var require_compare = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/compare.js"(exports, module) {
    function compare4(a, b) {
      for (let i = 0; i < a.byteLength; i++) {
        if (a[i] < b[i]) {
          return -1;
        }
        if (a[i] > b[i]) {
          return 1;
        }
      }
      if (a.byteLength > b.byteLength) {
        return 1;
      }
      if (a.byteLength < b.byteLength) {
        return -1;
      }
      return 0;
    }
    __name(compare4, "compare");
    module.exports = compare4;
  }
});
var require_concat = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/concat.js"(exports, module) {
    function concat4(arrays, length2) {
      if (!length2) {
        length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = new Uint8Array(length2);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    __name(concat4, "concat");
    module.exports = concat4;
  }
});
var require_equals = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/equals.js"(exports, module) {
    function equals4(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    __name(equals4, "equals");
    module.exports = equals4;
  }
});
var require_bases = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/util/bases.js"(exports, module) {
    var { bases: bases2 } = (init_basics(), __toCommonJS(basics_exports));
    function createCodec2(name5, prefix, encode11, decode10) {
      return {
        name: name5,
        prefix,
        encoder: {
          name: name5,
          prefix,
          encode: encode11
        },
        decoder: {
          decode: decode10
        }
      };
    }
    __name(createCodec2, "createCodec");
    var string2 = createCodec2("utf8", "u", (buf2) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf2);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii2 = createCodec2("ascii", "a", (buf2) => {
      let string3 = "a";
      for (let i = 0; i < buf2.length; i++) {
        string3 += String.fromCharCode(buf2[i]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf2 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf2[i] = str.charCodeAt(i);
      }
      return buf2;
    });
    var BASES2 = __spreadValues({
      "utf8": string2,
      "utf-8": string2,
      "hex": bases2.base16,
      "latin1": ascii2,
      "ascii": ascii2,
      "binary": ascii2
    }, bases2);
    module.exports = BASES2;
  }
});
var require_from_string = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/from-string.js"(exports, module) {
    var bases2 = require_bases();
    function fromString6(string2, encoding = "utf8") {
      const base4 = bases2[encoding];
      if (!base4) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base4.decoder.decode(`${base4.prefix}${string2}`);
    }
    __name(fromString6, "fromString");
    module.exports = fromString6;
  }
});
var require_to_string = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/to-string.js"(exports, module) {
    var bases2 = require_bases();
    function toString5(array, encoding = "utf8") {
      const base4 = bases2[encoding];
      if (!base4) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base4.encoder.encode(array).substring(1);
    }
    __name(toString5, "toString");
    module.exports = toString5;
  }
});
var require_xor = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/xor.js"(exports, module) {
    function xor2(a, b) {
      if (a.length !== b.length) {
        throw new Error("Inputs should have the same length");
      }
      const result = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        result[i] = a[i] ^ b[i];
      }
      return result;
    }
    __name(xor2, "xor");
    module.exports = xor2;
  }
});
var require_uint8arrays = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@2.1.10/node_modules/uint8arrays/index.js"(exports, module) {
    var compare4 = require_compare();
    var concat4 = require_concat();
    var equals4 = require_equals();
    var fromString6 = require_from_string();
    var toString5 = require_to_string();
    var xor2 = require_xor();
    module.exports = {
      compare: compare4,
      concat: concat4,
      equals: equals4,
      fromString: fromString6,
      toString: toString5,
      xor: xor2
    };
  }
});
var require_secp256k12 = __commonJS({
  "../../node_modules/.pnpm/key-did-resolver@1.4.4/node_modules/key-did-resolver/lib/secp256k1.js"(exports) {
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding2(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyToDidDoc = void 0;
    var u8a = __importStar2(require_uint8arrays());
    function keyToDidDoc(pubKeyBytes, fingerprint) {
      const did = `did:key:${fingerprint}`;
      const keyId = `${did}#${fingerprint}`;
      return {
        id: did,
        verificationMethod: [
          {
            id: keyId,
            type: "Secp256k1VerificationKey2018",
            controller: did,
            publicKeyBase58: u8a.toString(pubKeyBytes, "base58btc")
          }
        ],
        authentication: [keyId],
        assertionMethod: [keyId],
        capabilityDelegation: [keyId],
        capabilityInvocation: [keyId]
      };
    }
    __name(keyToDidDoc, "keyToDidDoc");
    exports.keyToDidDoc = keyToDidDoc;
  }
});
var require_ed255192 = __commonJS({
  "../../node_modules/.pnpm/key-did-resolver@1.4.4/node_modules/key-did-resolver/lib/ed25519.js"(exports) {
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding2(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyToDidDoc = void 0;
    var u8a = __importStar2(require_uint8arrays());
    var ed25519_1 = require_ed25519();
    function encodeKey(key2) {
      const bytes = new Uint8Array(key2.length + 2);
      bytes[0] = 236;
      bytes[1] = 1;
      bytes.set(key2, 2);
      return `z${u8a.toString(bytes, "base58btc")}`;
    }
    __name(encodeKey, "encodeKey");
    function keyToDidDoc(pubKeyBytes, fingerprint) {
      const did = `did:key:${fingerprint}`;
      const keyId = `${did}#${fingerprint}`;
      const x25519PubBytes = ed25519_1.convertPublicKeyToX25519(pubKeyBytes);
      const x25519KeyId = `${did}#${encodeKey(x25519PubBytes)}`;
      return {
        id: did,
        verificationMethod: [
          {
            id: keyId,
            type: "Ed25519VerificationKey2018",
            controller: did,
            publicKeyBase58: u8a.toString(pubKeyBytes, "base58btc")
          }
        ],
        authentication: [keyId],
        assertionMethod: [keyId],
        capabilityDelegation: [keyId],
        capabilityInvocation: [keyId],
        keyAgreement: [
          {
            id: x25519KeyId,
            type: "X25519KeyAgreementKey2019",
            controller: did,
            publicKeyBase58: u8a.toString(x25519PubBytes, "base58btc")
          }
        ]
      };
    }
    __name(keyToDidDoc, "keyToDidDoc");
    exports.keyToDidDoc = keyToDidDoc;
  }
});
var require_lib = __commonJS({
  "../../node_modules/.pnpm/key-did-resolver@1.4.4/node_modules/key-did-resolver/lib/index.js"(exports) {
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding2(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getResolver = void 0;
    var varint_1 = __importDefault2(require_varint());
    var multibase_1 = __importDefault2(require_src2());
    var secp256k12 = __importStar2(require_secp256k12());
    var ed25519 = __importStar2(require_ed255192());
    var DID_LD_JSON = "application/did+ld+json";
    var DID_JSON = "application/did+json";
    var prefixToDriverMap = {
      231: secp256k12,
      237: ed25519
    };
    function getResolver() {
      return {
        key: (did, parsed, r, options) => __async(this, null, function* () {
          const contentType = options.accept || DID_JSON;
          const response = {
            didResolutionMetadata: { contentType },
            didDocument: null,
            didDocumentMetadata: {}
          };
          try {
            const multicodecPubKey = multibase_1.default.decode(parsed.id);
            const keyType = varint_1.default.decode(multicodecPubKey);
            const pubKeyBytes = multicodecPubKey.slice(varint_1.default.decode.bytes);
            const doc = yield prefixToDriverMap[keyType].keyToDidDoc(pubKeyBytes, parsed.id);
            if (contentType === DID_LD_JSON) {
              doc["@context"] = "https://w3id.org/did/v1";
              response.didDocument = doc;
            } else if (contentType === DID_JSON) {
              response.didDocument = doc;
            } else {
              delete response.didResolutionMetadata.contentType;
              response.didResolutionMetadata.error = "representationNotSupported";
            }
          } catch (e) {
            response.didResolutionMetadata.error = "invalidDid";
            response.didResolutionMetadata.message = e.toString();
          }
          return response;
        })
      };
    }
    __name(getResolver, "getResolver");
    exports.getResolver = getResolver;
    exports.default = { getResolver };
  }
});
var require_fast_json_stable_stringify = __commonJS({
  "../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return ( __name(function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key2 = keys[i];
          var value = stringify2(node[key2]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key2) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }, "stringify"))(data);
    };
  }
});
var require_lodash = __commonJS({
  "../../node_modules/.pnpm/lodash.clonedeep@4.5.0/node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map2, pair) {
      map2.set(pair[0], pair[1]);
      return map2;
    }
    __name(addMapEntry, "addMapEntry");
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    __name(addSetEntry, "addSetEntry");
    function arrayEach(array, iteratee) {
      var index = -1, length2 = array ? array.length : 0;
      while (++index < length2) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    function arrayPush(array, values) {
      var index = -1, length2 = values.length, offset = array.length;
      while (++index < length2) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length2 = array ? array.length : 0;
      if (initAccum && length2) {
        accumulator = array[++index];
      }
      while (++index < length2) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    __name(getValue, "getValue");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    root = root || {};
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root && root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash, "Hash");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    __name(hashClear, "hashClear");
    function hashDelete(key2) {
      return this.has(key2) && delete this.__data__[key2];
    }
    __name(hashDelete, "hashDelete");
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key2) ? data[key2] : void 0;
    }
    __name(hashGet, "hashGet");
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty2.call(data, key2);
    }
    __name(hashHas, "hashHas");
    function hashSet(key2, value) {
      var data = this.__data__;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    function listCacheClear() {
      this.__data__ = [];
    }
    __name(listCacheClear, "listCacheClear");
    function listCacheDelete(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    function listCacheGet(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    function listCacheSet(key2, value) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        data.push([key2, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    function mapCacheDelete(key2) {
      return getMapData(this, key2)["delete"](key2);
    }
    __name(mapCacheDelete, "mapCacheDelete");
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    __name(mapCacheGet, "mapCacheGet");
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    __name(mapCacheHas, "mapCacheHas");
    function mapCacheSet(key2, value) {
      getMapData(this, key2).set(key2, value);
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    __name(Stack, "Stack");
    function stackClear() {
      this.__data__ = new ListCache();
    }
    __name(stackClear, "stackClear");
    function stackDelete(key2) {
      return this.__data__["delete"](key2);
    }
    __name(stackDelete, "stackDelete");
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    __name(stackGet, "stackGet");
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    __name(stackHas, "stackHas");
    function stackSet(key2, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key2, value);
      return this;
    }
    __name(stackSet, "stackSet");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length2 = result.length, skipIndexes = !!length2;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && (key2 == "length" || isIndex(key2, length2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty2.call(object, key2) && eq4(objValue, value)) || value === void 0 && !(key2 in object)) {
        object[key2] = value;
      }
    }
    __name(assignValue, "assignValue");
    function assocIndexOf(array, key2) {
      var length2 = array.length;
      while (length2--) {
        if (eq4(array[length2][0], key2)) {
          return length2;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    __name(baseAssign, "baseAssign");
    function baseClone(value, isDeep, isFull, customizer, key2, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key2, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer3(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, isDeep, isFull, customizer, key3, value, stack));
      });
      return result;
    }
    __name(baseClone, "baseClone");
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    __name(baseCreate, "baseCreate");
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    __name(baseGetAllKeys, "baseGetAllKeys");
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    __name(baseGetTag, "baseGetTag");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var result = new buffer2.constructor(buffer2.length);
      buffer2.copy(result);
      return result;
    }
    __name(cloneBuffer, "cloneBuffer");
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    __name(cloneArrayBuffer, "cloneArrayBuffer");
    function cloneDataView(dataView2, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(dataView2.buffer) : dataView2.buffer;
      return new dataView2.constructor(buffer2, dataView2.byteOffset, dataView2.byteLength);
    }
    __name(cloneDataView, "cloneDataView");
    function cloneMap(map2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
      return arrayReduce(array, addMapEntry, new map2.constructor());
    }
    __name(cloneMap, "cloneMap");
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    __name(cloneRegExp, "cloneRegExp");
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    __name(cloneSet, "cloneSet");
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    __name(cloneSymbol, "cloneSymbol");
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    __name(cloneTypedArray, "cloneTypedArray");
    function copyArray(source, array) {
      var index = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index < length2) {
        array[index] = source[index];
      }
      return array;
    }
    __name(copyArray, "copyArray");
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length2 = props.length;
      while (++index < length2) {
        var key2 = props[index];
        var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
        assignValue(object, key2, newValue === void 0 ? source[key2] : newValue);
      }
      return object;
    }
    __name(copyObject, "copyObject");
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    __name(copySymbols, "copySymbols");
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    __name(getAllKeys, "getAllKeys");
    function getMapData(map2, key2) {
      var data = map2.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag =  __name(function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    function initCloneArray(array) {
      var length2 = array.length, result = array.constructor(length2);
      if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    __name(initCloneArray, "initCloneArray");
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    __name(initCloneObject, "initCloneObject");
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    __name(initCloneByTag, "initCloneByTag");
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    __name(isIndex, "isIndex");
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    function cloneDeep5(value) {
      return baseClone(value, true, true);
    }
    __name(cloneDeep5, "cloneDeep");
    function eq4(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq4, "eq");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike2, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    var isBuffer3 = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    __name(isLength, "isLength");
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function keys(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    function stubArray() {
      return [];
    }
    __name(stubArray, "stubArray");
    function stubFalse() {
      return false;
    }
    __name(stubFalse, "stubFalse");
    module.exports = cloneDeep5;
  }
});
var require_tslib = __commonJS({
  "../../node_modules/.pnpm/tslib@2.4.0/node_modules/tslib/tslib.js"(exports, module) {
    var __extends3;
    var __assign2;
    var __rest2;
    var __decorate8;
    var __param2;
    var __metadata4;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
      __name(createExporter, "createExporter");
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends3 =  __name(function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }, "__extends");
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 =  __name(function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      }, "__rest");
      __decorate8 =  __name(function(decorators, target, key2, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
        return c > 3 && r && Object.defineProperty(target, key2, r), r;
      }, "__decorate");
      __param2 =  __name(function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      }, "__param");
      __metadata4 =  __name(function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      }, "__metadata");
      __awaiter2 =  __name(function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        __name(adopt, "adopt");
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          __name(fulfilled, "fulfilled");
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          __name(rejected, "rejected");
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          __name(step, "step");
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }, "__awaiter");
      __generator2 =  __name(function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }, "__generator");
      __exportStar2 =  __name(function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      }, "__exportStar");
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 =  __name(function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, "__values");
      __read2 =  __name(function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      }, "__read");
      __spread2 =  __name(function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      }, "__spread");
      __spreadArrays2 =  __name(function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      }, "__spreadArrays");
      __spreadArray2 =  __name(function(to, from4, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from4.length, ar; i < l; i++) {
            if (ar || !(i in from4)) {
              if (!ar)
                ar = Array.prototype.slice.call(from4, 0, i);
              ar[i] = from4[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from4));
      }, "__spreadArray");
      __await2 =  __name(function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      }, "__await");
      __asyncGenerator2 =  __name(function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      }, "__asyncGenerator");
      __asyncDelegator2 =  __name(function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      }, "__asyncDelegator");
      __asyncValues2 =  __name(function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      }, "__asyncValues");
      __makeTemplateObject2 =  __name(function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }, "__makeTemplateObject");
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 =  __name(function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding2(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      }, "__importStar");
      __importDefault2 =  __name(function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      }, "__importDefault");
      __classPrivateFieldGet3 =  __name(function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      }, "__classPrivateFieldGet");
      __classPrivateFieldSet3 =  __name(function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      }, "__classPrivateFieldSet");
      __classPrivateFieldIn2 =  __name(function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      }, "__classPrivateFieldIn");
      exporter("__extends", __extends3);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate8);
      exporter("__param", __param2);
      exporter("__metadata", __metadata4);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});
var require_browser_ponyfill = __commonJS({
  "../../node_modules/.pnpm/cross-fetch@3.1.5/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      __name(F, "F");
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      (function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        __name(isDataView, "isDataView");
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name5) {
          if (typeof name5 !== "string") {
            name5 = String(name5);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name5)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name5.toLowerCase();
        }
        __name(normalizeName, "normalizeName");
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        __name(normalizeValue, "normalizeValue");
        function iteratorFor(items) {
          var iterator2 = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator2[Symbol.iterator] = function() {
              return iterator2;
            };
          }
          return iterator2;
        }
        __name(iteratorFor, "iteratorFor");
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name5) {
              this.append(name5, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name5) {
              this.append(name5, headers[name5]);
            }, this);
          }
        }
        __name(Headers2, "Headers");
        Headers2.prototype.append = function(name5, value) {
          name5 = normalizeName(name5);
          value = normalizeValue(value);
          var oldValue = this.map[name5];
          this.map[name5] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name5) {
          delete this.map[normalizeName(name5)];
        };
        Headers2.prototype.get = function(name5) {
          name5 = normalizeName(name5);
          return this.has(name5) ? this.map[name5] : null;
        };
        Headers2.prototype.has = function(name5) {
          return this.map.hasOwnProperty(normalizeName(name5));
        };
        Headers2.prototype.set = function(name5, value) {
          this.map[normalizeName(name5)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name5 in this.map) {
            if (this.map.hasOwnProperty(name5)) {
              callback.call(thisArg, this.map[name5], name5, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name5) {
            items.push(name5);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name5) {
            items.push([name5, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        __name(consumed, "consumed");
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        __name(fileReaderReady, "fileReaderReady");
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        __name(readBlobAsArrayBuffer, "readBlobAsArrayBuffer");
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        __name(readBlobAsText, "readBlobAsText");
        function readArrayBufferAsText(buf2) {
          var view = new Uint8Array(buf2);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        __name(readArrayBufferAsText, "readArrayBufferAsText");
        function bufferClone(buf2) {
          if (buf2.slice) {
            return buf2.slice(0);
          } else {
            var view = new Uint8Array(buf2.byteLength);
            view.set(new Uint8Array(buf2));
            return view.buffer;
          }
        }
        __name(bufferClone, "bufferClone");
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode10);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        __name(Body, "Body");
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        __name(normalizeMethod, "normalizeMethod");
        function Request2(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        __name(Request2, "Request");
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode10(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name5 = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name5), decodeURIComponent(value));
            }
          });
          return form;
        }
        __name(decode10, "decode");
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key2 = parts.shift().trim();
            if (key2) {
              var value = parts.join(":").trim();
              headers.append(key2, value);
            }
          });
          return headers;
        }
        __name(parseHeaders, "parseHeaders");
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        __name(Response2, "Response");
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name5) {
            this.message = message;
            this.name = name5;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init4) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init4);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            __name(abortXhr, "abortXhr");
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response2(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name5) {
              xhr.setRequestHeader(name5, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        __name(fetch3, "fetch");
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers2;
          self2.Request = Request2;
          self2.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});
var require_dataloader = __commonJS({
  "../../node_modules/.pnpm/dataloader@2.1.0/node_modules/dataloader/index.js"(exports, module) {
    var DataLoader2 = /* @__PURE__ */ function() {
      function DataLoader3(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
      }
      __name(DataLoader3, "DataLoader");
      var _proto = DataLoader3.prototype;
      _proto.load = /* @__PURE__ */ __name(function load2(key2) {
        if (key2 === null || key2 === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key2) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key2);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key2);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      }, "load");
      _proto.loadMany = /* @__PURE__ */ __name(function loadMany(keys) {
        if (!isArrayLike2(keys)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
        }
        var loadPromises = [];
        for (var i = 0; i < keys.length; i++) {
          loadPromises.push(this.load(keys[i])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      }, "loadMany");
      _proto.clear = /* @__PURE__ */ __name(function clear(key2) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key2);
          cacheMap["delete"](cacheKey);
        }
        return this;
      }, "clear");
      _proto.clearAll = /* @__PURE__ */ __name(function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      }, "clearAll");
      _proto.prime = /* @__PURE__ */ __name(function prime(key2, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key2);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      }, "prime");
      return DataLoader3;
    }();
    var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        process.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    __name(getCurrentBatch, "getCurrentBatch");
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise = loader._batchLoadFn(batch.keys);
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike2(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i = 0; i < batch.callbacks.length; i++) {
          var value = values[i];
          if (value instanceof Error) {
            batch.callbacks[i].reject(value);
          } else {
            batch.callbacks[i].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    __name(dispatchBatch, "dispatchBatch");
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i = 0; i < batch.keys.length; i++) {
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
      }
    }
    __name(failedDispatch, "failedDispatch");
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i = 0; i < batch.cacheHits.length; i++) {
          batch.cacheHits[i]();
        }
      }
    }
    __name(resolveCacheHits, "resolveCacheHits");
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    __name(getValidMaxBatchSize, "getValidMaxBatchSize");
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    __name(getValidBatchScheduleFn, "getValidBatchScheduleFn");
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key2) {
          return key2;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    __name(getValidCacheKeyFn, "getValidCacheKeyFn");
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    __name(getValidCacheMap, "getValidCacheMap");
    function isArrayLike2(x) {
      return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
    }
    __name(isArrayLike2, "isArrayLike");
    module.exports = DataLoader2;
  }
});
var require_encode2 = __commonJS({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode11;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode11(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode11.bytes = offset - oldOffset + 1;
      return out;
    }
    __name(encode11, "encode");
  }
});
var require_decode2 = __commonJS({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js"(exports, module) {
    module.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
    __name(read2, "read");
  }
});
var require_length2 = __commonJS({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js"(exports, module) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});
var require_varint2 = __commonJS({
  "../../node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/constants.js"(exports, module) {
    var names = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module.exports = { names };
  }
});
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/index.js"(exports, module) {
    var multibase = require_src2();
    var varint5 = require_varint2();
    var { names } = require_constants2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var codes = {};
    for (const key2 in names) {
      const name5 = key2;
      codes[names[name5]] = name5;
    }
    Object.freeze(codes);
    function toHexString(hash3) {
      if (!(hash3 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash3, "base16");
    }
    __name(toHexString, "toHexString");
    function fromHexString(hash3) {
      return uint8ArrayFromString(hash3, "base16");
    }
    __name(fromHexString, "fromHexString");
    function toB58String(hash3) {
      if (!(hash3 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash3)).slice(1);
    }
    __name(toB58String, "toB58String");
    function fromB58String(hash3) {
      const encoded = hash3 instanceof Uint8Array ? uint8ArrayToString(hash3) : hash3;
      return multibase.decode("z" + encoded);
    }
    __name(fromB58String, "fromB58String");
    function decode10(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code5 = varint5.decode(bytes);
      if (!isValidCode(code5)) {
        throw new Error(`multihash unknown function code: 0x${code5.toString(16)}`);
      }
      bytes = bytes.slice(varint5.decode.bytes);
      const len = varint5.decode(bytes);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes = bytes.slice(varint5.decode.bytes);
      if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
      }
      return {
        code: code5,
        name: codes[code5],
        length: len,
        digest: bytes
      };
    }
    __name(decode10, "decode");
    function encode11(digest2, code5, length2) {
      if (!digest2 || code5 === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code5);
      if (!(digest2 instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length2 == null) {
        length2 = digest2.length;
      }
      if (length2 && digest2.length !== length2) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash3 = varint5.encode(hashfn);
      const len = varint5.encode(length2);
      return uint8ArrayConcat([hash3, len, digest2], hash3.length + len.length + digest2.length);
    }
    __name(encode11, "encode");
    function coerceCode(name5) {
      let code5 = name5;
      if (typeof name5 === "string") {
        if (names[name5] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name5}`);
        }
        code5 = names[name5];
      }
      if (typeof code5 !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code5}`);
      }
      if (codes[code5] === void 0 && !isAppCode(code5)) {
        throw new Error(`Unrecognized function code: ${code5}`);
      }
      return code5;
    }
    __name(coerceCode, "coerceCode");
    function isAppCode(code5) {
      return code5 > 0 && code5 < 16;
    }
    __name(isAppCode, "isAppCode");
    function isValidCode(code5) {
      if (isAppCode(code5)) {
        return true;
      }
      if (codes[code5]) {
        return true;
      }
      return false;
    }
    __name(isValidCode, "isValidCode");
    function validate6(multihash) {
      decode10(multihash);
    }
    __name(validate6, "validate");
    function prefix(multihash) {
      validate6(multihash);
      return multihash.subarray(0, 2);
    }
    __name(prefix, "prefix");
    module.exports = {
      names,
      codes,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode: decode10,
      encode: encode11,
      coerceCode,
      isAppCode,
      validate: validate6,
      prefix,
      isValidCode
    };
  }
});
if (typeof window === "undefined")
  globalThis.crypto = crypto2;
var addPluginToWallet = /* @__PURE__ */ __name((wallet, plugin) => __async(void 0, null, function* () {
  return generateWallet(wallet.contents, {
    plugins: [...wallet.plugins, plugin]
  });
}), "addPluginToWallet");
var addToWallet = /* @__PURE__ */ __name((wallet, content) => __async(void 0, null, function* () {
  return generateWallet([...wallet.contents, content], wallet);
}), "addToWallet");
var removeFromWallet = /* @__PURE__ */ __name((wallet, contentId) => __async(void 0, null, function* () {
  const clonedContents = JSON.parse(JSON.stringify(wallet.contents));
  const content = clonedContents.find((c) => c.id === contentId);
  return generateWallet(clonedContents.filter((i) => i.id !== content.id), wallet);
}), "removeFromWallet");
var bindMethods = /* @__PURE__ */ __name((wallet, pluginMethods) => Object.fromEntries(Object.entries(pluginMethods).map(([key2, method]) => [key2, method.bind(wallet, wallet)])), "bindMethods");
var generateWallet = /* @__PURE__ */ __name((..._0) => __async(void 0, [..._0], function* (contents = [], _wallet = {}) {
  const { plugins = [] } = _wallet;
  const pluginMethods = plugins.reduce((cumulativePluginMethods, plugin) => {
    const newPluginMethods = __spreadValues(__spreadValues({}, cumulativePluginMethods), plugin.pluginMethods);
    return newPluginMethods;
  }, {});
  const wallet = {
    contents: [...contents],
    add: function(content) {
      return addToWallet(this, content);
    },
    remove: function(contentId) {
      return removeFromWallet(this, contentId);
    },
    status: "UNLOCKED",
    plugins,
    pluginMethods,
    addPlugin: function(plugin) {
      return addPluginToWallet(this, plugin);
    }
  };
  if (pluginMethods)
    wallet.pluginMethods = bindMethods(wallet, pluginMethods);
  return wallet;
}), "generateWallet");
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
__name(_catch, "_catch");
function inMemoryCache() {
  const cache = /* @__PURE__ */ new Map();
  return function(parsed, resolve) {
    try {
      let _temp2 = function(_result) {
        if (_exit)
          return _result;
        const cached = cache.get(parsed.didUrl);
        return cached !== void 0 ? cached : Promise.resolve(resolve()).then(function(result) {
          var _result$didResolution;
          if (((_result$didResolution = result.didResolutionMetadata) == null ? void 0 : _result$didResolution.error) !== "notFound") {
            cache.set(parsed.didUrl, result);
          }
          return result;
        });
      };
      __name(_temp2, "_temp2");
      let _exit;
      const _temp = function() {
        if (parsed.params && parsed.params["no-cache"] === "true") {
          return Promise.resolve(resolve()).then(function(_await$resolve) {
            _exit = 1;
            return _await$resolve;
          });
        }
      }();
      return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
__name(inMemoryCache, "inMemoryCache");
function noCache(parsed, resolve) {
  return resolve();
}
__name(noCache, "noCache");
var PCT_ENCODED = "(?:%[0-9a-fA-F]{2})";
var ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`;
var METHOD = "([a-z0-9]+)";
var METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`;
var PARAM_CHAR = "[a-zA-Z0-9_.:%-]";
var PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`;
var PARAMS = `((${PARAM})*)`;
var PATH = `(/[^#?]*)?`;
var QUERY = `([?][^#]*)?`;
var FRAGMENT = `(#.*)?`;
var DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
function parse(didUrl) {
  if (didUrl === "" || !didUrl)
    return null;
  const sections = didUrl.match(DID_MATCHER);
  if (sections) {
    const parts = {
      did: `did:${sections[1]}:${sections[2]}`,
      method: sections[1],
      id: sections[2],
      didUrl
    };
    if (sections[4]) {
      const params = sections[4].slice(1).split(";");
      parts.params = {};
      for (const p of params) {
        const kv = p.split("=");
        parts.params[kv[0]] = kv[1];
      }
    }
    if (sections[6])
      parts.path = sections[6];
    if (sections[7])
      parts.query = sections[7].slice(1);
    if (sections[8])
      parts.fragment = sections[8].slice(1);
    return parts;
  }
  return null;
}
__name(parse, "parse");
var EMPTY_RESULT = {
  didResolutionMetadata: {},
  didDocument: null,
  didDocumentMetadata: {}
};
function wrapLegacyResolver(resolve) {
  return function(did, parsed, resolver) {
    try {
      return Promise.resolve(_catch(function() {
        return Promise.resolve(resolve(did, parsed, resolver)).then(function(doc) {
          return __spreadProps(__spreadValues({}, EMPTY_RESULT), {
            didResolutionMetadata: {
              contentType: "application/did+ld+json"
            },
            didDocument: doc
          });
        });
      }, function(e) {
        return __spreadProps(__spreadValues({}, EMPTY_RESULT), {
          didResolutionMetadata: {
            error: "notFound",
            message: e.toString()
          }
        });
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
__name(wrapLegacyResolver, "wrapLegacyResolver");
var Resolver = class {
  constructor(registry2 = {}, options = {}) {
    this.registry = void 0;
    this.cache = void 0;
    this.registry = registry2;
    this.cache = options.cache === true ? inMemoryCache() : options.cache || noCache;
    if (options.legacyResolvers) {
      Object.keys(options.legacyResolvers).map((methodName) => {
        if (!this.registry[methodName]) {
          this.registry[methodName] = wrapLegacyResolver(options.legacyResolvers[methodName]);
        }
      });
    }
  }
  resolve(didUrl, options = {}) {
    try {
      const _this = this;
      const parsed = parse(didUrl);
      if (parsed === null) {
        return Promise.resolve(__spreadProps(__spreadValues({}, EMPTY_RESULT), {
          didResolutionMetadata: {
            error: "invalidDid"
          }
        }));
      }
      const resolver = _this.registry[parsed.method];
      if (!resolver) {
        return Promise.resolve(__spreadProps(__spreadValues({}, EMPTY_RESULT), {
          didResolutionMetadata: {
            error: "unsupportedDidMethod"
          }
        }));
      }
      return Promise.resolve(_this.cache(parsed, () => resolver(parsed.did, parsed, _this, options)));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
__name(Resolver, "Resolver");
init_concat();
init_from_string();
init_to_string();
init_basics();
var import_sha256 = __toESM(require_sha256());
var import_js_sha3 = __toESM(require_sha3());
var import_elliptic = __toESM(require_elliptic());
var import_ed25519 = __toESM(require_ed25519());
var import_canonicalize = __toESM(require_canonicalize());
var import_x25519 = __toESM(require_x25519());
var import_xchacha20poly1305 = __toESM(require_xchacha20poly1305());
var import_random = __toESM(require_random());
function bytesToBase64url(b) {
  return toString3(b, "base64url");
}
__name(bytesToBase64url, "bytesToBase64url");
function base64ToBytes(s) {
  const inputBase64Url = s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return fromString2(inputBase64Url, "base64url");
}
__name(base64ToBytes, "base64ToBytes");
function base58ToBytes(s) {
  return fromString2(s, "base58btc");
}
__name(base58ToBytes, "base58ToBytes");
function hexToBytes(s) {
  const input = s.startsWith("0x") ? s.substring(2) : s;
  return fromString2(input.toLowerCase(), "base16");
}
__name(hexToBytes, "hexToBytes");
function encodeBase64url(s) {
  return bytesToBase64url(fromString2(s));
}
__name(encodeBase64url, "encodeBase64url");
function decodeBase64url(s) {
  return toString3(base64ToBytes(s));
}
__name(decodeBase64url, "decodeBase64url");
function bytesToHex(b) {
  return toString3(b, "base16");
}
__name(bytesToHex, "bytesToHex");
function stringToBytes(s) {
  return fromString2(s);
}
__name(stringToBytes, "stringToBytes");
function toJose({
  r,
  s,
  recoveryParam
}, recoverable) {
  const jose = new Uint8Array(recoverable ? 65 : 64);
  jose.set(fromString2(r, "base16"), 0);
  jose.set(fromString2(s, "base16"), 32);
  if (recoverable) {
    if (typeof recoveryParam === "undefined") {
      throw new Error("Signer did not return a recoveryParam");
    }
    jose[64] = recoveryParam;
  }
  return bytesToBase64url(jose);
}
__name(toJose, "toJose");
function fromJose(signature2) {
  const signatureBytes = base64ToBytes(signature2);
  if (signatureBytes.length < 64 || signatureBytes.length > 65) {
    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`);
  }
  const r = bytesToHex(signatureBytes.slice(0, 32));
  const s = bytesToHex(signatureBytes.slice(32, 64));
  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : void 0;
  return {
    r,
    s,
    recoveryParam
  };
}
__name(fromJose, "fromJose");
function toSealed(ciphertext, tag) {
  return concat([base64ToBytes(ciphertext), base64ToBytes(tag)]);
}
__name(toSealed, "toSealed");
var hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/;
var base58Matcher = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/;
var base64Matcher = /^([0-9a-zA-Z=\-_+/]{43}|[0-9a-zA-Z=\-_+/]{86})(={0,2})$/;
function parseKey(input) {
  if (typeof input === "string") {
    if (hexMatcher.test(input)) {
      return hexToBytes(input);
    } else if (base58Matcher.test(input)) {
      return base58ToBytes(input);
    } else if (base64Matcher.test(input)) {
      return base64ToBytes(input);
    } else {
      throw TypeError("bad_key: Invalid private key format");
    }
  } else if (input instanceof Uint8Array) {
    return input;
  } else {
    throw TypeError("bad_key: Invalid private key format");
  }
}
__name(parseKey, "parseKey");
function sha2562(payload) {
  const data = typeof payload === "string" ? fromString2(payload) : payload;
  return (0, import_sha256.hash)(data);
}
__name(sha2562, "sha256");
function keccak(data) {
  return new Uint8Array(import_js_sha3.keccak_256.arrayBuffer(data));
}
__name(keccak, "keccak");
function toEthereumAddress(hexPublicKey) {
  const hashInput = fromString2(hexPublicKey.slice(2), "base16");
  return `0x${toString3(keccak(hashInput).slice(-20), "base16")}`;
}
__name(toEthereumAddress, "toEthereumAddress");
function writeUint32BE(value, array = new Uint8Array(4)) {
  const encoded = fromString2(value.toString(), "base10");
  array.set(encoded, 4 - encoded.length);
  return array;
}
__name(writeUint32BE, "writeUint32BE");
var lengthAndInput = /* @__PURE__ */ __name((input) => concat([writeUint32BE(input.length), input]), "lengthAndInput");
function concatKDF(secret, keyLen, alg, producerInfo, consumerInfo) {
  if (keyLen !== 256)
    throw new Error(`Unsupported key length: ${keyLen}`);
  const value = concat([lengthAndInput(fromString2(alg)), lengthAndInput(typeof producerInfo === "undefined" ? new Uint8Array(0) : producerInfo), lengthAndInput(typeof consumerInfo === "undefined" ? new Uint8Array(0) : consumerInfo), writeUint32BE(keyLen)]);
  const roundNumber = 1;
  return (0, import_sha256.hash)(concat([writeUint32BE(roundNumber), secret, value]));
}
__name(concatKDF, "concatKDF");
new import_elliptic.ec("secp256k1");
function EdDSASigner(secretKey) {
  const privateKeyBytes = parseKey(secretKey);
  if (privateKeyBytes.length !== 64) {
    throw new Error(`bad_key: Invalid private key format. Expecting 64 bytes, but got ${privateKeyBytes.length}`);
  }
  return function(data) {
    try {
      const dataBytes = typeof data === "string" ? stringToBytes(data) : data;
      const sig = (0, import_ed25519.sign)(privateKeyBytes, dataBytes);
      return Promise.resolve(bytesToBase64url(sig));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
__name(EdDSASigner, "EdDSASigner");
function instanceOfEcdsaSignature(object) {
  return typeof object === "object" && "r" in object && "s" in object;
}
__name(instanceOfEcdsaSignature, "instanceOfEcdsaSignature");
function ES256KSignerAlg(recoverable) {
  return /* @__PURE__ */ __name(function sign5(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature2) {
        if (instanceOfEcdsaSignature(signature2)) {
          return toJose(signature2, recoverable);
        } else {
          if (recoverable && typeof fromJose(signature2).recoveryParam === "undefined") {
            throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`);
          }
          return signature2;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }, "sign");
}
__name(ES256KSignerAlg, "ES256KSignerAlg");
function Ed25519SignerAlg() {
  return  __name(function sign5(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature2) {
        if (!instanceOfEcdsaSignature(signature2)) {
          return signature2;
        } else {
          throw new Error("invalid_config: expected a signer function that returns a string instead of signature object");
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }, "sign");
}
__name(Ed25519SignerAlg, "Ed25519SignerAlg");
var algorithms$1 = {
  ES256K: ES256KSignerAlg(),
  "ES256K-R": ES256KSignerAlg(true),
  Ed25519: Ed25519SignerAlg(),
  EdDSA: Ed25519SignerAlg()
};
function SignerAlg(alg) {
  const impl = algorithms$1[alg];
  if (!impl)
    throw new Error(`not_supported: Unsupported algorithm ${alg}`);
  return impl;
}
__name(SignerAlg, "SignerAlg");
var secp256k1 = new import_elliptic.ec("secp256k1");
function toSignatureObject(signature2, recoverable = false) {
  const rawSig = base64ToBytes(signature2);
  if (rawSig.length !== (recoverable ? 65 : 64)) {
    throw new Error("wrong signature length");
  }
  const r = bytesToHex(rawSig.slice(0, 32));
  const s = bytesToHex(rawSig.slice(32, 64));
  const sigObj = {
    r,
    s
  };
  if (recoverable) {
    sigObj.recoveryParam = rawSig[64];
  }
  return sigObj;
}
__name(toSignatureObject, "toSignatureObject");
function extractPublicKeyBytes(pk) {
  if (pk.publicKeyBase58) {
    return base58ToBytes(pk.publicKeyBase58);
  } else if (pk.publicKeyBase64) {
    return base64ToBytes(pk.publicKeyBase64);
  } else if (pk.publicKeyHex) {
    return hexToBytes(pk.publicKeyHex);
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "secp256k1" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
    return hexToBytes(secp256k1.keyFromPublic({
      x: bytesToHex(base64ToBytes(pk.publicKeyJwk.x)),
      y: bytesToHex(base64ToBytes(pk.publicKeyJwk.y))
    }).getPublic("hex"));
  } else if (pk.publicKeyMultibase) {
    const {
      base16: base162,
      base58btc: base58btc2,
      base64: base642,
      base64url: base64url2
    } = bases;
    const baseDecoder = base162.decoder.or(base58btc2.decoder.or(base642.decoder.or(base64url2.decoder)));
    return baseDecoder.decode(pk.publicKeyMultibase);
  }
  return new Uint8Array();
}
__name(extractPublicKeyBytes, "extractPublicKeyBytes");
function verifyES256K(data, signature2, authenticators) {
  const hash3 = sha2562(data);
  const sigObj = toSignatureObject(signature2);
  const fullPublicKeys = authenticators.filter(({
    ethereumAddress,
    blockchainAccountId
  }) => {
    return typeof ethereumAddress === "undefined" && typeof blockchainAccountId === "undefined";
  });
  const ethAddressKeys = authenticators.filter(({
    ethereumAddress,
    blockchainAccountId
  }) => {
    return typeof ethereumAddress !== "undefined" || typeof blockchainAccountId !== void 0;
  });
  let signer = fullPublicKeys.find((pk) => {
    try {
      const pubBytes = extractPublicKeyBytes(pk);
      return secp256k1.keyFromPublic(pubBytes).verify(hash3, sigObj);
    } catch (err) {
      return false;
    }
  });
  if (!signer && ethAddressKeys.length > 0) {
    signer = verifyRecoverableES256K(data, signature2, ethAddressKeys);
  }
  if (!signer)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
__name(verifyES256K, "verifyES256K");
function verifyRecoverableES256K(data, signature2, authenticators) {
  let signatures;
  if (signature2.length > 86) {
    signatures = [toSignatureObject(signature2, true)];
  } else {
    const so = toSignatureObject(signature2, false);
    signatures = [__spreadProps(__spreadValues({}, so), {
      recoveryParam: 0
    }), __spreadProps(__spreadValues({}, so), {
      recoveryParam: 1
    })];
  }
  const checkSignatureAgainstSigner =  __name((sigObj) => {
    const hash3 = sha2562(data);
    const recoveredKey = secp256k1.recoverPubKey(hash3, sigObj, sigObj.recoveryParam);
    const recoveredPublicKeyHex = recoveredKey.encode("hex");
    const recoveredCompressedPublicKeyHex = recoveredKey.encode("hex", true);
    const recoveredAddress = toEthereumAddress(recoveredPublicKeyHex);
    const signer2 = authenticators.find((pk) => {
      var _pk$ethereumAddress, _pk$blockchainAccount, _pk$blockchainAccount2;
      const keyHex = bytesToHex(extractPublicKeyBytes(pk));
      return keyHex === recoveredPublicKeyHex || keyHex === recoveredCompressedPublicKeyHex || ((_pk$ethereumAddress = pk.ethereumAddress) == null ? void 0 : _pk$ethereumAddress.toLowerCase()) === recoveredAddress || ((_pk$blockchainAccount = pk.blockchainAccountId) == null ? void 0 : (_pk$blockchainAccount2 = _pk$blockchainAccount.split("@eip155")) == null ? void 0 : _pk$blockchainAccount2[0].toLowerCase()) === recoveredAddress;
    });
    return signer2;
  }, "checkSignatureAgainstSigner");
  const signer = signatures.map(checkSignatureAgainstSigner).filter((key2) => typeof key2 !== "undefined");
  if (signer.length === 0)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer[0];
}
__name(verifyRecoverableES256K, "verifyRecoverableES256K");
function verifyEd25519(data, signature2, authenticators) {
  const clear = stringToBytes(data);
  const sig = base64ToBytes(signature2);
  const signer = authenticators.find((pk) => {
    return (0, import_ed25519.verify)(extractPublicKeyBytes(pk), clear, sig);
  });
  if (!signer)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
__name(verifyEd25519, "verifyEd25519");
var algorithms = {
  ES256K: verifyES256K,
  "ES256K-R": verifyRecoverableES256K,
  Ed25519: verifyEd25519,
  EdDSA: verifyEd25519
};
function VerifierAlgorithm(alg) {
  const impl = algorithms[alg];
  if (!impl)
    throw new Error(`not_supported: Unsupported algorithm ${alg}`);
  return impl;
}
__name(VerifierAlgorithm, "VerifierAlgorithm");
VerifierAlgorithm.toSignatureObject = toSignatureObject;
var createJWS =  __name(function(payload, signer, header = {}, options = {}) {
  try {
    if (!header.alg)
      header.alg = defaultAlg;
    const encodedPayload = typeof payload === "string" ? payload : encodeSection(payload, options.canonicalize);
    const signingInput = [encodeSection(header, options.canonicalize), encodedPayload].join(".");
    const jwtSigner = SignerAlg(header.alg);
    return Promise.resolve(jwtSigner(signingInput, signer)).then(function(signature2) {
      return [signingInput, signature2].join(".");
    });
  } catch (e) {
    return Promise.reject(e);
  }
}, "createJWS");
var defaultAlg = "ES256K";
function encodeSection(data, shouldCanonicalize = false) {
  if (shouldCanonicalize) {
    return encodeBase64url((0, import_canonicalize.default)(data));
  } else {
    return encodeBase64url(JSON.stringify(data));
  }
}
__name(encodeSection, "encodeSection");
function decodeJWS(jws) {
  const parts = jws.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
  if (parts) {
    return {
      header: JSON.parse(decodeBase64url(parts[1])),
      payload: parts[2],
      signature: parts[3],
      data: `${parts[1]}.${parts[2]}`
    };
  }
  throw new Error("invalid_argument: Incorrect format JWS");
}
__name(decodeJWS, "decodeJWS");
function verifyJWSDecoded({
  header,
  data,
  signature: signature2
}, pubKeys) {
  if (!Array.isArray(pubKeys))
    pubKeys = [pubKeys];
  const signer = VerifierAlgorithm(header.alg)(data, signature2, pubKeys);
  return signer;
}
__name(verifyJWSDecoded, "verifyJWSDecoded");
function verifyJWS(jws, pubKeys) {
  const jwsDecoded = decodeJWS(jws);
  return verifyJWSDecoded(jwsDecoded, pubKeys);
}
__name(verifyJWS, "verifyJWS");
function _for(test, update2, body) {
  var stage;
  for (; ; ) {
    var shouldContinue = test();
    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }
    if (!shouldContinue) {
      return result;
    }
    if (shouldContinue.then) {
      stage = 0;
      break;
    }
    var result = body();
    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }
    if (update2) {
      var updateValue = update2();
      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }
  var pact = new _Pact();
  var reject = _settle.bind(null, pact, 2);
  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;
  function _resumeAfterBody(value) {
    result = value;
    do {
      if (update2) {
        updateValue = update2();
        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }
      shouldContinue = test();
      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);
        return;
      }
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }
      result = body();
      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);
    result.then(_resumeAfterBody).then(void 0, reject);
  }
  function _resumeAfterTest(shouldContinue2) {
    if (shouldContinue2) {
      result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
}
__name(_for, "_for");
var decryptJWE =  __name(function(jwe, decrypter) {
  try {
    let _temp5 = function(_result) {
      if (_exit)
        ;
      if (cleartext === null)
        throw new Error("failure: Failed to decrypt");
      return cleartext;
    };
    __name(_temp5, "_temp5");
    let _exit;
    validateJWE(jwe);
    const protHeader = JSON.parse(decodeBase64url(jwe.protected));
    if (protHeader.enc !== decrypter.enc)
      throw new Error(`not_supported: Decrypter does not supported: '${protHeader.enc}'`);
    const sealed = toSealed(jwe.ciphertext, jwe.tag);
    const aad = new Uint8Array(Buffer.from(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected));
    let cleartext = null;
    const _temp4 = function() {
      if (protHeader.alg === "dir" && decrypter.alg === "dir") {
        return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)).then(function(_decrypter$decrypt) {
          cleartext = _decrypter$decrypt;
        });
      } else
        return function() {
          if (!jwe.recipients || jwe.recipients.length === 0) {
            throw new Error("bad_jwe: missing recipients");
          } else {
            let i = 0;
            return _for(function() {
              return !cleartext && i < jwe.recipients.length;
            }, function() {
              return i++;
            }, function() {
              const recipient = jwe.recipients[i];
              Object.assign(recipient.header, protHeader);
              const _temp3 = function() {
                if (recipient.header.alg === decrypter.alg) {
                  return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)).then(function(_decrypter$decrypt2) {
                    cleartext = _decrypter$decrypt2;
                  });
                }
              }();
              if (_temp3 && _temp3.then)
                return _temp3.then(function() {
                });
            });
          }
        }();
    }();
    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4));
  } catch (e) {
    return Promise.reject(e);
  }
}, "decryptJWE");
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    const observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
__name(_settle, "_settle");
var _Pact =  function() {
  function _Pact2() {
  }
  __name(_Pact2, "_Pact");
  _Pact2.prototype.then = function(onFulfilled, onRejected) {
    const result = new _Pact2();
    const state = this.s;
    if (state) {
      const callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function(_this) {
      try {
        const value = _this.v;
        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };
    return result;
  };
  return _Pact2;
}();
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}
__name(_isSettledPact, "_isSettledPact");
function _forTo(array, body, check) {
  var i = -1, pact, reject;
  function _cycle(result) {
    try {
      while (++i < array.length && (!check || !check())) {
        result = body(i);
        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }
      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle(pact || (pact = new _Pact()), 2, e);
    }
  }
  __name(_cycle, "_cycle");
  _cycle();
  return pact;
}
__name(_forTo, "_forTo");
function _forOf(target, body, check) {
  if (typeof target[_iteratorSymbol] === "function") {
    let _cycle = function(result) {
      try {
        while (!(step = iterator2.next()).done && (!check || !check())) {
          result = body(step.value);
          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }
        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle(pact || (pact = new _Pact()), 2, e);
      }
    };
    __name(_cycle, "_cycle");
    var iterator2 = target[_iteratorSymbol](), step, pact, reject;
    _cycle();
    if (iterator2.return) {
      var _fixup =  __name(function(value) {
        try {
          if (!step.done) {
            iterator2.return();
          }
        } catch (e) {
        }
        return value;
      }, "_fixup");
      if (pact && pact.then) {
        return pact.then(_fixup, function(e) {
          throw _fixup(e);
        });
      }
      _fixup();
    }
    return pact;
  }
  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  }
  var values = [];
  for (var i = 0; i < target.length; i++) {
    values.push(target[i]);
  }
  return _forTo(values, function(i2) {
    return body(values[i2]);
  }, check);
}
__name(_forOf, "_forOf");
function validateJWE(jwe) {
  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {
    throw new Error("bad_jwe: missing properties");
  }
  if (jwe.recipients) {
    jwe.recipients.map((rec) => {
      if (!(rec.header && rec.encrypted_key)) {
        throw new Error("bad_jwe: malformed recipients");
      }
    });
  }
}
__name(validateJWE, "validateJWE");
function encodeJWE({
  ciphertext,
  tag,
  iv,
  protectedHeader,
  recipient
}, aad) {
  const jwe = {
    protected: protectedHeader,
    iv: bytesToBase64url(iv),
    ciphertext: bytesToBase64url(ciphertext),
    tag: bytesToBase64url(tag)
  };
  if (aad)
    jwe.aad = bytesToBase64url(aad);
  if (recipient)
    jwe.recipients = [recipient];
  return jwe;
}
__name(encodeJWE, "encodeJWE");
var createJWE =  __name(function(cleartext, encrypters, protectedHeader = {}, aad) {
  try {
    if (encrypters[0].alg === "dir") {
      if (encrypters.length > 1)
        throw new Error('not_supported: Can only do "dir" encryption to one key.');
      return Promise.resolve(encrypters[0].encrypt(cleartext, protectedHeader, aad)).then(function(encryptionResult) {
        return encodeJWE(encryptionResult, aad);
      });
    } else {
      const tmpEnc = encrypters[0].enc;
      if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {
        throw new Error("invalid_argument: Incompatible encrypters passed");
      }
      let cek;
      let jwe;
      const _temp2 = _forOf(encrypters, function(encrypter) {
        const _temp = function() {
          if (!cek) {
            return Promise.resolve(encrypter.encrypt(cleartext, protectedHeader, aad)).then(function(encryptionResult) {
              cek = encryptionResult.cek;
              jwe = encodeJWE(encryptionResult, aad);
            });
          } else {
            return Promise.resolve(encrypter.encryptCek == null ? void 0 : encrypter.encryptCek(cek)).then(function(recipient) {
              if (recipient) {
                var _jwe, _jwe$recipients;
                (_jwe = jwe) == null ? void 0 : (_jwe$recipients = _jwe.recipients) == null ? void 0 : _jwe$recipients.push(recipient);
              }
            });
          }
        }();
        if (_temp && _temp.then)
          return _temp.then(function() {
          });
      });
      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function() {
        return jwe;
      }) : jwe);
    }
  } catch (e) {
    return Promise.reject(e);
  }
}, "createJWE");
var resolveX25519Encrypters =  __name(function(dids, resolver) {
  try {
    const encryptersForDID =  __name(function(did) {
      try {
        return Promise.resolve(resolver.resolve(did)).then(function({
          didResolutionMetadata,
          didDocument
        }) {
          var _didDocument$keyAgree;
          if (didResolutionMetadata != null && didResolutionMetadata.error || didDocument == null) {
            throw new Error(`resolver_error: Could not resolve ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`);
          }
          if (!didDocument.keyAgreement)
            throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`);
          const agreementKeys = (_didDocument$keyAgree = didDocument.keyAgreement) == null ? void 0 : _didDocument$keyAgree.map((key2) => {
            if (typeof key2 === "string") {
              return [...didDocument.publicKey || [], ...didDocument.verificationMethod || []].find((pk) => pk.id === key2);
            }
            return key2;
          }).filter((key2) => typeof key2 !== "undefined");
          const pks = agreementKeys.filter((key2) => {
            return key2.type === "X25519KeyAgreementKey2019" && Boolean(key2.publicKeyBase58);
          });
          if (!pks.length)
            throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`);
          return pks.map((pk) => x25519Encrypter(base58ToBytes(pk.publicKeyBase58), pk.id));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }, "encryptersForDID");
    const encrypterPromises = dids.map((did) => encryptersForDID(did));
    return Promise.resolve(Promise.all(encrypterPromises)).then(function(encrypterArrays) {
      const flattenedArray = [].concat(...encrypterArrays);
      return flattenedArray;
    });
  } catch (e) {
    return Promise.reject(e);
  }
}, "resolveX25519Encrypters");
function xc20pEncrypter(key2) {
  const cipher = new import_xchacha20poly1305.XChaCha20Poly1305(key2);
  return (cleartext, aad) => {
    const iv = (0, import_random.randomBytes)(cipher.nonceLength);
    const sealed = cipher.seal(iv, cleartext, aad);
    return {
      ciphertext: sealed.subarray(0, sealed.length - cipher.tagLength),
      tag: sealed.subarray(sealed.length - cipher.tagLength),
      iv
    };
  };
}
__name(xc20pEncrypter, "xc20pEncrypter");
function xc20pDirEncrypter(key2) {
  const encrypt =  __name(function(cleartext, protectedHeader = {}, aad) {
    try {
      const protHeader = encodeBase64url(JSON.stringify(Object.assign({
        alg
      }, protectedHeader, {
        enc
      })));
      const encodedAad = new Uint8Array(Buffer.from(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader));
      return Promise.resolve(__spreadProps(__spreadValues({}, xc20pEncrypt(cleartext, encodedAad)), {
        protectedHeader: protHeader
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }, "encrypt");
  const xc20pEncrypt = xc20pEncrypter(key2);
  const enc = "XC20P";
  const alg = "dir";
  return {
    alg,
    enc,
    encrypt
  };
}
__name(xc20pDirEncrypter, "xc20pDirEncrypter");
function xc20pDirDecrypter(key2) {
  const decrypt =  __name(function(sealed, iv, aad) {
    try {
      return Promise.resolve(cipher.open(iv, sealed, aad));
    } catch (e) {
      return Promise.reject(e);
    }
  }, "decrypt");
  const cipher = new import_xchacha20poly1305.XChaCha20Poly1305(key2);
  return {
    alg: "dir",
    enc: "XC20P",
    decrypt
  };
}
__name(xc20pDirDecrypter, "xc20pDirDecrypter");
function x25519Encrypter(publicKey, kid) {
  const encrypt =  __name(function(cleartext, protectedHeader = {}, aad) {
    try {
      Object.assign(protectedHeader, {
        alg: void 0
      });
      const cek = (0, import_random.randomBytes)(32);
      return Promise.resolve(xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)).then(function(_xc20pDirEncrypter$en) {
        return Promise.resolve(encryptCek(cek)).then(function(_encryptCek) {
          return __spreadProps(__spreadValues({}, _xc20pDirEncrypter$en), {
            recipient: _encryptCek,
            cek
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }, "encrypt");
  const encryptCek =  __name(function(cek) {
    try {
      const epk = (0, import_x25519.generateKeyPair)();
      const sharedSecret = (0, import_x25519.sharedKey)(epk.secretKey, publicKey);
      const kek = concatKDF(sharedSecret, keyLen, alg);
      const res = xc20pEncrypter(kek)(cek);
      const recipient = {
        encrypted_key: bytesToBase64url(res.ciphertext),
        header: {
          alg,
          iv: bytesToBase64url(res.iv),
          tag: bytesToBase64url(res.tag),
          epk: {
            kty: "OKP",
            crv,
            x: bytesToBase64url(epk.publicKey)
          }
        }
      };
      if (kid)
        recipient.header.kid = kid;
      return Promise.resolve(recipient);
    } catch (e) {
      return Promise.reject(e);
    }
  }, "encryptCek");
  const alg = "ECDH-ES+XC20PKW";
  const keyLen = 256;
  const crv = "X25519";
  return {
    alg,
    enc: "XC20P",
    encrypt,
    encryptCek
  };
}
__name(x25519Encrypter, "x25519Encrypter");
function validateHeader(header) {
  if (!(header && header.epk && header.iv && header.tag)) {
    throw new Error("bad_jwe: malformed header");
  }
}
__name(validateHeader, "validateHeader");
function x25519Decrypter(receiverSecret) {
  const decrypt =  __name(function(sealed, iv, aad, recipient) {
    try {
      let _temp4 = function() {
        const kek = concatKDF(sharedSecret, keyLen, alg);
        const sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag);
        return Promise.resolve(xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))).then(function(cek) {
          return cek === null ? null : xc20pDirDecrypter(cek).decrypt(sealed, iv, aad);
        });
      };
      __name(_temp4, "_temp4");
      var _recipient, _recipient$header$epk;
      validateHeader((_recipient = recipient) == null ? void 0 : _recipient.header);
      recipient = recipient;
      if (((_recipient$header$epk = recipient.header.epk) == null ? void 0 : _recipient$header$epk.crv) !== crv || typeof recipient.header.epk.x == "undefined")
        return Promise.resolve(null);
      const publicKey = base64ToBytes(recipient.header.epk.x);
      let sharedSecret;
      const _temp3 = function() {
        if (receiverSecret instanceof Uint8Array) {
          sharedSecret = (0, import_x25519.sharedKey)(receiverSecret, publicKey);
        } else {
          return Promise.resolve(receiverSecret(publicKey)).then(function(_receiverSecret) {
            sharedSecret = _receiverSecret;
          });
        }
      }();
      return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3));
    } catch (e) {
      return Promise.reject(e);
    }
  }, "decrypt");
  const alg = "ECDH-ES+XC20PKW";
  const keyLen = 256;
  const crv = "X25519";
  return {
    alg,
    enc: "XC20P",
    decrypt
  };
}
__name(x25519Decrypter, "x25519Decrypter");
init_src();
var readonly2 =  __name(({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
}), "readonly");
var links =  __name(function* (source, base4) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key2, value] of Object.entries(source)) {
    const path = [
      ...base4,
      key2
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
}, "links");
var tree =  __name(function* (source, base4) {
  if (source == null)
    return;
  for (const [key2, value] of Object.entries(source)) {
    const path = [
      ...base4,
      key2
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
  }
}, "tree");
var get =  __name((source, path) => {
  let node = source;
  for (const [index, key2] of path.entries()) {
    node = node[key2];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
}, "get");
var Block = class {
  constructor({ cid, bytes, value }) {
    if (!cid || !bytes || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
};
__name(Block, "Block");
var encode7 =  __name((_0) => __async(void 0, [_0], function* ({ value, codec, hasher }) {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes = codec.encode(value);
  const hash3 = yield hasher.digest(bytes);
  const cid = CID.create(1, codec.code, hash3);
  return new Block({
    value,
    bytes,
    cid
  });
}), "encode");
init_cid();
init_sha2_browser();
init_identity2();
init_base64();
var esm_exports = {};
__export(esm_exports, {
  code: () => code4,
  decode: () => decode9,
  encode: () => encode9,
  name: () => name4
});
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType2 = getObjectType(value);
  if (objectType2) {
    return objectType2;
  }
  return "Object";
}
__name(is, "is");
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
__name(isBuffer, "isBuffer");
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
__name(getObjectType, "getObjectType");
var Type = class {
  constructor(major, name5, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name5;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
__name(Type, "Type");
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};
__name(Token, "Token");
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder2 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
__name(isBuffer2, "isBuffer");
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
__name(asU8A, "asU8A");
var toString4 = useBuffer ? (bytes, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice(bytes, start, end);
} : (bytes, start, end) => {
  return end - start > 64 ? textDecoder2.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
};
var fromString3 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder2.encode(string2) : utf8ToBytes(string2);
};
var fromArray =  __name((arr) => {
  return Uint8Array.from(arr);
}, "fromArray");
var slice = useBuffer ? (bytes, start, end) => {
  if (isBuffer2(bytes)) {
    return new Uint8Array(bytes.subarray(start, end));
  }
  return bytes.slice(start, end);
} : (bytes, start, end) => {
  return bytes.slice(start, end);
};
var concat2 = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare2(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
__name(compare2, "compare");
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length2; ++i) {
    codePoint = string2.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length2) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
__name(utf8ToBytes, "utf8ToBytes");
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
__name(utf8Slice, "utf8Slice");
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
__name(decodeCodePointsArray, "decodeCodePointsArray");
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat2(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};
__name(Bl, "Bl");
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
__name(assertEnoughData, "assertEnoughData");
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint8, "readUint8");
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint16, "readUint16");
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
__name(readUint32, "readUint32");
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
__name(readUint64, "readUint64");
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
__name(decodeUint8, "decodeUint8");
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
__name(decodeUint16, "decodeUint16");
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
__name(decodeUint32, "decodeUint32");
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
__name(decodeUint64, "decodeUint64");
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
__name(encodeUint, "encodeUint");
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
__name(encodeUintValue, "encodeUintValue");
encodeUint.encodedSize =  __name(function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");
encodeUintValue.encodedSize =  __name(function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
}, "encodedSize");
encodeUint.compareTokens =  __name(function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
}, "compareTokens");
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
__name(decodeNegint8, "decodeNegint8");
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
__name(decodeNegint16, "decodeNegint16");
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
__name(decodeNegint32, "decodeNegint32");
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
__name(decodeNegint64, "decodeNegint64");
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
__name(encodeNegint, "encodeNegint");
encodeNegint.encodedSize =  __name(function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
}, "encodedSize");
encodeNegint.compareTokens =  __name(function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
}, "compareTokens");
function toToken(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf2, prefix + length2);
}
__name(toToken, "toToken");
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
__name(decodeBytesCompact, "decodeBytesCompact");
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeBytes8, "decodeBytes8");
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeBytes16, "decodeBytes16");
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeBytes32, "decodeBytes32");
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
__name(decodeBytes64, "decodeBytes64");
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString3(token.value) : token.value;
  }
  return token.encodedBytes;
}
__name(tokenBytes, "tokenBytes");
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
__name(encodeBytes, "encodeBytes");
encodeBytes.encodedSize =  __name(function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
}, "encodedSize");
encodeBytes.compareTokens =  __name(function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
}, "compareTokens");
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}
__name(compareBytes, "compareBytes");
function toToken2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString4(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
__name(toToken2, "toToken");
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
__name(decodeStringCompact, "decodeStringCompact");
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
__name(decodeString8, "decodeString8");
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
__name(decodeString16, "decodeString16");
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
__name(decodeString32, "decodeString32");
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
__name(decodeString64, "decodeString64");
var encodeString = encodeBytes;
function toToken3(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
__name(toToken3, "toToken");
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
__name(decodeArrayCompact, "decodeArrayCompact");
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeArray8, "decodeArray8");
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeArray16, "decodeArray16");
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeArray32, "decodeArray32");
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
__name(decodeArray64, "decodeArray64");
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
__name(decodeArrayIndefinite, "decodeArrayIndefinite");
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
__name(encodeArray, "encodeArray");
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize =  __name(function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");
function toToken4(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
__name(toToken4, "toToken");
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
__name(decodeMapCompact, "decodeMapCompact");
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
__name(decodeMap8, "decodeMap8");
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
__name(decodeMap16, "decodeMap16");
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
__name(decodeMap32, "decodeMap32");
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
__name(decodeMap64, "decodeMap64");
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
__name(decodeMapIndefinite, "decodeMapIndefinite");
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
__name(encodeMap, "encodeMap");
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize =  __name(function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
__name(decodeTagCompact, "decodeTagCompact");
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
__name(decodeTag8, "decodeTag8");
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
__name(decodeTag16, "decodeTag16");
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
__name(decodeTag32, "decodeTag32");
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
__name(decodeTag64, "decodeTag64");
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
__name(encodeTag, "encodeTag");
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize =  __name(function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
}, "encodedSize");
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
__name(decodeUndefined, "decodeUndefined");
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
__name(decodeBreak, "decodeBreak");
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
__name(createToken, "createToken");
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
__name(decodeFloat16, "decodeFloat16");
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
__name(decodeFloat32, "decodeFloat32");
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
__name(decodeFloat64, "decodeFloat64");
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
__name(encodeFloat, "encodeFloat");
encodeFloat.encodedSize =  __name(function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
}, "encodedSize");
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
__name(encodeFloat16, "encodeFloat16");
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * __pow(2, -24);
  } else if (exp !== 31) {
    val = (mant + 1024) * __pow(2, exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
__name(readFloat16, "readFloat16");
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
__name(encodeFloat32, "encodeFloat32");
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
__name(readFloat32, "readFloat32");
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
__name(encodeFloat64, "encodeFloat64");
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
__name(readFloat64, "readFloat64");
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
__name(invalidMinor, "invalidMinor");
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
__name(errorer, "errorer");
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
__name(quickEncodeToken, "quickEncodeToken");
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
__name(makeCborEncoders, "makeCborEncoders");
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
};
__name(Ref, "Ref");
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key2 of keys) {
      entries[i++] = [
        objectToTokens(key2, options, refStack),
        objectToTokens(isMap ? obj.get(key2) : obj[key2], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length2),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
__name(objectToTokens, "objectToTokens");
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
__name(sortMapEntries, "sortMapEntries");
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
__name(mapSorter, "mapSorter");
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
__name(tokensToEncoded, "tokensToEncoded");
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
__name(encodeCustom, "encodeCustom");
function encode8(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
__name(encode8, "encode");
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
__name(Tokeniser, "Tokeniser");
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
__name(tokenToArray, "tokenToArray");
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ?  new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key2 = tokensToObject(tokeniser, options);
    if (key2 === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key2 === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key2 !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key2})`);
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key2, value);
    } else {
      obj[key2] = value;
    }
  }
  return useMaps ? m : obj;
}
__name(tokenToMap, "tokenToMap");
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
__name(tokensToObject, "tokensToObject");
function decode8(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
__name(decode8, "decode");
init_cid();
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
__name(cidEncoder, "cidEncoder");
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
__name(undefinedEncoder, "undefinedEncoder");
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
__name(numberEncoder, "numberEncoder");
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
__name(cidDecoder, "cidDecoder");
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name4 = "dag-cbor";
var code4 = 113;
var encode9 =  __name((node) => encode8(node, encodeOptions), "encode");
var decode9 =  __name((data) => decode8(data, decodeOptions), "decode");
var ENC_BLOCK_SIZE = 24;
function encodePayload(payload) {
  return __async(this, null, function* () {
    const block = yield encode7({ value: payload, codec: esm_exports, hasher: sha256 });
    return {
      cid: block.cid,
      linkedBlock: block.bytes
    };
  });
}
__name(encodePayload, "encodePayload");
function pad(b, blockSize = ENC_BLOCK_SIZE) {
  const padLen = (blockSize - b.length % blockSize) % blockSize;
  const bytes = new Uint8Array(b.length + padLen);
  bytes.set(b, 0);
  return bytes;
}
__name(pad, "pad");
function encodeIdentityCID(obj) {
  return __async(this, null, function* () {
    const block = yield encode7({ value: obj, codec: esm_exports, hasher: identity2 });
    return block.cid;
  });
}
__name(encodeIdentityCID, "encodeIdentityCID");
function decodeIdentityCID(cid) {
  cid = CID.asCID(cid);
  if (cid.code !== code4)
    throw new Error("CID codec must be dag-cbor");
  if (cid.multihash.code !== identity2.code)
    throw new Error("CID must use identity multihash");
  return decode9(cid.multihash.digest);
}
__name(decodeIdentityCID, "decodeIdentityCID");
function prepareCleartext(cleartext, blockSize) {
  return __async(this, null, function* () {
    return pad((yield encodeIdentityCID(cleartext)).bytes, blockSize);
  });
}
__name(prepareCleartext, "prepareCleartext");
function decodeCleartext(b) {
  return decodeIdentityCID(CID.decodeFirst(b)[0]);
}
__name(decodeCleartext, "decodeCleartext");
var abortableHandlerSymbol = Symbol("abortable");
var abortedReasonSymbol = Symbol("aborted");
function abortable(source, signal) {
  if (signal.aborted) {
    return Promise.reject(abortedReasonSymbol);
  }
  let rejectAborted;
  const abortion = new Promise((_resolve, reject) => {
    rejectAborted = reject;
  });
  signal.addEventListener("abort", () => {
    rejectAborted(abortedReasonSymbol);
  });
  return Promise.race([
    source,
    abortion
  ]);
}
__name(abortable, "abortable");
var nanoid =  __name((size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, ""), "nanoid");
var ABORT_REQUEST_METHOD = "utils_abort_request";
var ERROR_CODE;
(function(ERROR_CODE2) {
  ERROR_CODE2[ERROR_CODE2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  ERROR_CODE2[ERROR_CODE2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  ERROR_CODE2[ERROR_CODE2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  ERROR_CODE2[ERROR_CODE2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  ERROR_CODE2[ERROR_CODE2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
})(ERROR_CODE || (ERROR_CODE = {}));
var ERROR_MESSAGE = {
  [ERROR_CODE.PARSE_ERROR]: "Parse error",
  [ERROR_CODE.INVALID_REQUEST]: "Invalid request",
  [ERROR_CODE.METHOD_NOT_FOUND]: "Method not found",
  [ERROR_CODE.INVALID_PARAMS]: "Invalid params",
  [ERROR_CODE.INTERNAL_ERROR]: "Internal error"
};
function isServerError(code5) {
  return -32e3 >= code5 && code5 >= -32099;
}
__name(isServerError, "isServerError");
function getErrorMessage(code5) {
  var _a;
  return (_a = ERROR_MESSAGE[code5.toString()]) != null ? _a : isServerError(code5) ? "Server error" : "Application error";
}
__name(getErrorMessage, "getErrorMessage");
var RPCError = class extends Error {
  static fromObject(err) {
    return new RPCError(err.code, err.message, err.data);
  }
  toObject() {
    return {
      code: this.code,
      data: this.data,
      message: this.message
    };
  }
  constructor(code5, message, data) {
    super();
    Object.setPrototypeOf(this, RPCError.prototype);
    this.code = code5;
    this.data = data;
    this.message = message != null ? message : getErrorMessage(code5);
  }
};
__name(RPCError, "RPCError");
function createErrorFactory(code5) {
  const message = ERROR_MESSAGE[code5];
  return  __name(function createError(data) {
    return new RPCError(code5, message, data);
  }, "createError");
}
__name(createErrorFactory, "createErrorFactory");
createErrorFactory(ERROR_CODE.PARSE_ERROR);
createErrorFactory(ERROR_CODE.INVALID_REQUEST);
createErrorFactory(ERROR_CODE.METHOD_NOT_FOUND);
createErrorFactory(ERROR_CODE.INVALID_PARAMS);
createErrorFactory(ERROR_CODE.INTERNAL_ERROR);
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet, "_classApplyDescriptorGet");
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor, "_classExtractFieldDescriptor");
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
__name(_classPrivateFieldGet, "_classPrivateFieldGet");
function _classPrivateFieldInit(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit, "_classPrivateFieldInit");
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet, "_classPrivateFieldSet");
var _connection =  new WeakMap();
var RPCClient = class {
  get connection() {
    return _classPrivateFieldGet(this, _connection);
  }
  createID() {
    return nanoid();
  }
  request(method, params = void 0, options = {}) {
    const { signal } = options;
    if (signal == null ? void 0 : signal.aborted) {
      return Promise.reject(abortedReasonSymbol);
    }
    const id = this.createID();
    const responsePromise = _classPrivateFieldGet(this, _connection).send({
      jsonrpc: "2.0",
      id,
      method,
      params
    }).then((res) => {
      if (res == null) {
        throw new Error("Missing response");
      }
      if (res.error != null) {
        throw RPCError.fromObject(res.error);
      }
      return res.result;
    });
    if (signal == null) {
      return responsePromise;
    }
    signal.addEventListener("abort", () => {
      void this.notify(ABORT_REQUEST_METHOD, {
        id
      });
    });
    return abortable(responsePromise, signal);
  }
  notify(method, params = void 0) {
    return __async(this, null, function* () {
      yield _classPrivateFieldGet(this, _connection).send({
        jsonrpc: "2.0",
        method,
        params
      });
    });
  }
  constructor(connection) {
    _classPrivateFieldInit(this, _connection, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _connection, connection);
  }
};
__name(RPCClient, "RPCClient");
function createErrorResponse(id, code5) {
  return {
    jsonrpc: "2.0",
    id,
    error: {
      code: code5,
      message: getErrorMessage(code5)
    }
  };
}
__name(createErrorResponse, "createErrorResponse");
function fallbackOnHandlerError(_ctx, msg, error) {
  console.warn("Unhandled handler error", msg, error);
}
__name(fallbackOnHandlerError, "fallbackOnHandlerError");
function fallbackOnInvalidMessage(_ctx, msg) {
  console.warn("Unhandled invalid message", msg);
}
__name(fallbackOnInvalidMessage, "fallbackOnInvalidMessage");
function fallbackOnNotification(_ctx, msg) {
  console.warn("Unhandled notification", msg);
}
__name(fallbackOnNotification, "fallbackOnNotification");
function createHandler(methods, options = {}) {
  var _a, _b, _c;
  const onHandlerError = (_a = options.onHandlerError) != null ? _a : fallbackOnHandlerError;
  const onInvalidMessage = (_b = options.onInvalidMessage) != null ? _b : fallbackOnInvalidMessage;
  const onNotification = (_c = options.onNotification) != null ? _c : fallbackOnNotification;
  const inflight = {};
  function handleNotification(ctx, msg) {
    var _a2, _b2;
    if (msg.method === ABORT_REQUEST_METHOD) {
      const requestID = (_a2 = msg.params) == null ? void 0 : _a2.id;
      if (requestID != null) {
        (_b2 = inflight[requestID]) == null ? void 0 : _b2.abort();
      }
    } else {
      onNotification(ctx, msg);
    }
  }
  __name(handleNotification, "handleNotification");
  return  __name(function handleRequest(ctx, msg) {
    return __async(this, null, function* () {
      var _a2, _b2, _c2;
      const id = msg.id;
      if (msg.jsonrpc !== "2.0" || msg.method == null) {
        if (id == null) {
          onInvalidMessage(ctx, msg);
          return null;
        }
        return createErrorResponse(id, ERROR_CODE.INVALID_REQUEST);
      }
      const handler = methods[msg.method];
      if (handler == null) {
        if (id == null) {
          handleNotification(ctx, msg);
          return null;
        }
        return createErrorResponse(id, ERROR_CODE.METHOD_NOT_FOUND);
      }
      try {
        let handled;
        if (id != null && handler[abortableHandlerSymbol]) {
          const controller = new AbortController();
          inflight[id] = controller;
          handled = handler(ctx, msg.params, {
            signal: controller.signal
          });
        } else {
          handled = handler(ctx, msg.params, {});
        }
        const result = handled == null ? handled : typeof handled.then === "function" ? yield handled : handled;
        return id == null || ((_a2 = inflight[id]) == null ? void 0 : _a2.signal.aborted) ? null : {
          jsonrpc: "2.0",
          id,
          result
        };
      } catch (err) {
        if (id == null || ((_b2 = inflight[id]) == null ? void 0 : _b2.signal.aborted)) {
          onHandlerError(ctx, msg, err);
          return null;
        }
        let error;
        if (err instanceof RPCError) {
          error = err.toObject();
        } else {
          onHandlerError(ctx, msg, err);
          const code5 = (_c2 = err.code) != null ? _c2 : -32e3;
          error = {
            code: code5,
            message: err.message || getErrorMessage(code5)
          };
        }
        return {
          jsonrpc: "2.0",
          id,
          error
        };
      } finally {
        if (id != null) {
          delete inflight[id];
        }
      }
    });
  }, "handleRequest");
}
__name(createHandler, "createHandler");
init_cid();
var import_api = __toESM(require_api(), 1);
var import_node_exports = __toESM(require_node_exports(), 1);
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");
var CAIP2 = {
  name: "chainId",
  regex: "[-:a-zA-Z0-9]{5,41}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,32}"
      }
    }
  }
};
var CAIP10 = {
  name: "accountId",
  regex: "[-:a-zA-Z0-9]{7,106}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,32}"
      },
      2: {
        name: "address",
        regex: "[a-zA-Z0-9]{1,64}"
      }
    }
  }
};
var AssetName$1 = {
  name: "assetName",
  regex: "[-:a-zA-Z0-9]{5,73}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,64}"
      }
    }
  }
};
var CAIP19AssetType = {
  name: "assetType",
  regex: "[-:a-zA-Z0-9]{11,115}",
  parameters: {
    delimiter: "/",
    values: {
      0: CAIP2,
      1: AssetName$1
    }
  }
};
var CAIP19AssetId = {
  name: "assetId",
  regex: "[-:a-zA-Z0-9]{13,148}",
  parameters: {
    delimiter: "/",
    values: {
      0: CAIP2,
      1: AssetName$1,
      2: {
        name: "tokenId",
        regex: "[-a-zA-Z0-9]{1,32}"
      }
    }
  }
};
var CAIP = {
  "2": CAIP2,
  "10": CAIP10,
  "19": {
    assetName: AssetName$1,
    assetType: CAIP19AssetType,
    assetId: CAIP19AssetId
  }
};
function splitParams(id, spec) {
  return id.split(spec.parameters.delimiter);
}
__name(splitParams, "splitParams");
function getParams(id, spec) {
  var arr = splitParams(id, spec);
  var params = {};
  arr.forEach(function(value, index) {
    params[spec.parameters.values[index].name] = value;
  });
  return params;
}
__name(getParams, "getParams");
function joinParams(params, spec) {
  return Object.values(spec.parameters.values).map(function(parameter) {
    var param = params[parameter.name];
    return typeof param === "string" ? param : joinParams(param, parameter);
  }).join(spec.parameters.delimiter);
}
__name(joinParams, "joinParams");
function isValidId(id, spec) {
  if (!new RegExp(spec.regex).test(id))
    return false;
  var params = splitParams(id, spec);
  if (params.length !== Object.keys(spec.parameters.values).length)
    return false;
  var matches = params.map(function(param, index) {
    return new RegExp(spec.parameters.values[index].regex).test(param);
  }).filter(function(x) {
    return !!x;
  });
  if (matches.length !== params.length)
    return false;
  return true;
}
__name(isValidId, "isValidId");
var ChainId =  function() {
  function ChainId2(params) {
    if (typeof params === "string") {
      params = ChainId2.parse(params);
    }
    this.namespace = params.namespace;
    this.reference = params.reference;
  }
  __name(ChainId2, "ChainId");
  ChainId2.parse =  __name(function parse2(id) {
    if (!isValidId(id, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id);
    }
    return new ChainId2(getParams(id, this.spec)).toJSON();
  }, "parse");
  ChainId2.format =  __name(function format2(params) {
    return joinParams(params, this.spec);
  }, "format");
  var _proto = ChainId2.prototype;
  _proto.toString =  __name(function toString5() {
    return ChainId2.format(this.toJSON());
  }, "toString");
  _proto.toJSON =  __name(function toJSON2() {
    return {
      namespace: this.namespace,
      reference: this.reference
    };
  }, "toJSON");
  return ChainId2;
}();
ChainId.spec = CAIP["2"];
var AccountId =  function() {
  function AccountId2(params) {
    if (typeof params === "string") {
      params = AccountId2.parse(params);
    }
    this.chainId = new ChainId(params.chainId);
    this.address = params.address;
  }
  __name(AccountId2, "AccountId");
  AccountId2.parse =  __name(function parse2(id) {
    if (!isValidId(id, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id);
    }
    var _getParams = getParams(id, this.spec), namespace = _getParams.namespace, reference = _getParams.reference, address = _getParams.address;
    var chainId = new ChainId({
      namespace,
      reference
    });
    return new AccountId2({
      chainId,
      address
    }).toJSON();
  }, "parse");
  AccountId2.format =  __name(function format2(params) {
    var chainId = new ChainId(params.chainId);
    var splitParams2 = _extends({}, chainId.toJSON(), {
      address: params.address
    });
    return joinParams(splitParams2, this.spec);
  }, "format");
  var _proto = AccountId2.prototype;
  _proto.toString =  __name(function toString5() {
    return AccountId2.format(this.toJSON());
  }, "toString");
  _proto.toJSON =  __name(function toJSON2() {
    return {
      chainId: this.chainId.toJSON(),
      address: this.address
    };
  }, "toJSON");
  return AccountId2;
}();
AccountId.spec = CAIP["10"];
var version2 = "logger/5.6.0";
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
__name(_checkNormalize, "_checkNormalize");
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version11) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version11,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code5, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code5, {});
    }
    if (!code5) {
      code5 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code5}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code5) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code5;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code5;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code5, params) {
    throw this.makeError(message, code5, params);
  }
  throwArgumentError(message, name5, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name5,
      value
    });
  }
  assert(condition, message, code5, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code5, params);
  }
  assertArgument(condition, message, name5, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name5, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version2);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version11) {
    return new Logger(version11);
  }
};
__name(Logger, "Logger");
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
var version3 = "bytes/5.6.1";
var logger = new Logger(version3);
function isHexable(value) {
  return !!value.toHexString;
}
__name(isHexable, "isHexable");
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
__name(addSlice, "addSlice");
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
__name(isBytesLike, "isBytesLike");
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
__name(isInteger, "isInteger");
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
__name(isBytes, "isBytes");
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
__name(arrayify, "arrayify");
function concat3(items) {
  const objects = items.map((item) => arrayify(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
__name(concat3, "concat");
function zeroPad(value, length2) {
  value = arrayify(value);
  if (value.length > length2) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice(result);
}
__name(zeroPad, "zeroPad");
function isHexString(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
__name(isHexString, "isHexString");
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
__name(hexlify, "hexlify");
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
__name(hexDataLength, "hexDataLength");
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
__name(hexDataSlice, "hexDataSlice");
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
__name(hexZeroPad, "hexZeroPad");
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s = hexlify(vs2);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
__name(splitSignature, "splitSignature");
var import_bn = __toESM(require_bn2());
var version4 = "bignumber/5.6.2";
var BN = import_bn.default.BN;
new Logger(version4);
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
__name(_base36To16, "_base36To16");
var import_js_sha32 = __toESM(require_sha3());
function keccak256(data) {
  return "0x" + import_js_sha32.default.keccak_256(arrayify(data));
}
__name(keccak256, "keccak256");
var version5 = "address/5.6.1";
var logger3 = new Logger(version5);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger3.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
__name(getChecksumAddress, "getChecksumAddress");
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
__name(log10, "log10");
var ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
__name(ibanChecksum, "ibanChecksum");
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger3.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger3.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger3.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger3.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
__name(getAddress, "getAddress");
var version6 = "properties/5.6.0";
new Logger(version6);
function defineReadOnly(object, name5, value) {
  Object.defineProperty(object, name5, {
    enumerable: true,
    value,
    writable: false
  });
}
__name(defineReadOnly, "defineReadOnly");
var version7 = "strings/5.6.1";
var logger5 = new Logger(version7);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger5.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
__name(errorFunc, "errorFunc");
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
__name(ignoreFunc, "ignoreFunc");
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes);
}
__name(replaceFunc, "replaceFunc");
Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger5.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify(result);
}
__name(toUtf8Bytes, "toUtf8Bytes");
var messagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat3([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
__name(hashMessage, "hashMessage");
var import_bn2 = __toESM(require_bn2());
var import_hash = __toESM(require_hash());
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base4) {
      return commonjsRequire(path, base4 === void 0 || base4 === null ? module.path : base4);
    }
  }, fn(module, module.exports), module.exports;
}
__name(createCommonjsModule, "createCommonjsModule");
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
__name(commonjsRequire, "commonjsRequire");
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
__name(assert, "assert");
assert.equal =  __name(function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || "Assertion failed: " + l + " != " + r);
}, "assertEqual");
var utils_1 = createCommonjsModule(function(module, exports) {
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  __name(toArray, "toArray");
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  __name(zero2, "zero2");
  utils.zero2 = zero2;
  function toHex2(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  __name(toHex2, "toHex");
  utils.toHex = toHex2;
  utils.encode =  __name(function encode11(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  }, "encode");
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode;
  function getNAF2(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod2 = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod2 > (ws >> 1) - 1)
          z = (ws >> 1) - mod2;
        else
          z = mod2;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  __name(getNAF2, "getNAF");
  utils.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  __name(getJSF2, "getJSF");
  utils.getJSF = getJSF2;
  function cachedProperty(obj, name5, computer) {
    var key2 = "_" + name5;
    obj.prototype[name5] =  __name(function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    }, "cachedProperty");
  }
  __name(cachedProperty, "cachedProperty");
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  __name(parseBytes, "parseBytes");
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn2.default(bytes, "hex", "le");
  }
  __name(intFromLE, "intFromLE");
  utils.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
__name(BaseCurve, "BaseCurve");
var base3 = BaseCurve;
BaseCurve.prototype.point =  __name(function point() {
  throw new Error("Not implemented");
}, "point");
BaseCurve.prototype.validate =  __name(function validate() {
  throw new Error("Not implemented");
}, "validate");
BaseCurve.prototype._fixedNafMul =  __name(function _fixedNafMul(p, k) {
  assert$1(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
}, "_fixedNafMul");
BaseCurve.prototype._wnafMul =  __name(function _wnafMul(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
}, "_wnafMul");
BaseCurve.prototype._wnafMulAdd =  __name(function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
}, "_wnafMulAdd");
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
__name(BasePoint, "BasePoint");
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq =  __name(function eq() {
  throw new Error("Not implemented");
}, "eq");
BasePoint.prototype.validate =  __name(function validate2() {
  return this.curve.validate(this);
}, "validate");
BaseCurve.prototype.decodePoint =  __name(function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
}, "decodePoint");
BasePoint.prototype.encodeCompressed =  __name(function encodeCompressed(enc) {
  return this.encode(enc, true);
}, "encodeCompressed");
BasePoint.prototype._encode =  __name(function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
}, "_encode");
BasePoint.prototype.encode =  __name(function encode10(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
}, "encode");
BasePoint.prototype.precompute =  __name(function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
}, "precompute");
BasePoint.prototype._hasDoubles =  __name(function _hasDoubles(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
}, "_hasDoubles");
BasePoint.prototype._getDoubles =  __name(function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
}, "_getDoubles");
BasePoint.prototype._getNAFPoints =  __name(function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl3 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
}, "_getNAFPoints");
BasePoint.prototype._getBeta =  __name(function _getBeta() {
  return null;
}, "_getBeta");
BasePoint.prototype.dblp =  __name(function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
}, "dblp");
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports =  __name(function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    }, "inherits");
  } else {
    module.exports =  __name(function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor =  __name(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    }, "inherits");
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base3.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
__name(ShortCurve, "ShortCurve");
inherits_browser(ShortCurve, base3);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism =  __name(function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn2.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn2.default(vec.a, 16),
        b: new import_bn2.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
}, "_getEndomorphism");
ShortCurve.prototype._getEndoRoots =  __name(function _getEndoRoots(num) {
  var red = num === this.p ? this.red : import_bn2.default.mont(num);
  var tinv = new import_bn2.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
}, "_getEndoRoots");
ShortCurve.prototype._getEndoBasis =  __name(function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new import_bn2.default(1);
  var y1 = new import_bn2.default(0);
  var x2 = new import_bn2.default(0);
  var y2 = new import_bn2.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
}, "_getEndoBasis");
ShortCurve.prototype._endoSplit =  __name(function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
}, "_endoSplit");
ShortCurve.prototype.pointFromX =  __name(function pointFromX(x, odd) {
  x = new import_bn2.default(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
}, "pointFromX");
ShortCurve.prototype.validate =  __name(function validate3(point3) {
  if (point3.inf)
    return true;
  var x = point3.x;
  var y = point3.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
}, "validate");
ShortCurve.prototype._endoWnafMulAdd =  __name(function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
}, "_endoWnafMulAdd");
function Point(curve, x, y, isRed) {
  base3.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x, 16);
    this.y = new import_bn2.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
__name(Point, "Point");
inherits_browser(Point, base3.BasePoint);
ShortCurve.prototype.point =  __name(function point2(x, y, isRed) {
  return new Point(this, x, y, isRed);
}, "point");
ShortCurve.prototype.pointFromJSON =  __name(function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
}, "pointFromJSON");
Point.prototype._getBeta =  __name(function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul =  __name(function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    }, "endoMul");
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
}, "_getBeta");
Point.prototype.toJSON =  __name(function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
}, "toJSON");
Point.fromJSON =  __name(function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  __name(obj2point, "obj2point");
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
}, "fromJSON");
Point.prototype.inspect =  __name(function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, "inspect");
Point.prototype.isInfinity =  __name(function isInfinity() {
  return this.inf;
}, "isInfinity");
Point.prototype.add =  __name(function add(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
}, "add");
Point.prototype.dbl =  __name(function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
}, "dbl");
Point.prototype.getX =  __name(function getX() {
  return this.x.fromRed();
}, "getX");
Point.prototype.getY =  __name(function getY() {
  return this.y.fromRed();
}, "getY");
Point.prototype.mul =  __name(function mul(k) {
  k = new import_bn2.default(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
}, "mul");
Point.prototype.mulAdd =  __name(function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
}, "mulAdd");
Point.prototype.jmulAdd =  __name(function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
}, "jmulAdd");
Point.prototype.eq =  __name(function eq2(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
}, "eq");
Point.prototype.neg =  __name(function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate =  __name(function(p) {
      return p.neg();
    }, "negate");
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
}, "neg");
Point.prototype.toJ =  __name(function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
}, "toJ");
function JPoint(curve, x, y, z) {
  base3.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x, 16);
    this.y = new import_bn2.default(y, 16);
    this.z = new import_bn2.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
__name(JPoint, "JPoint");
inherits_browser(JPoint, base3.BasePoint);
ShortCurve.prototype.jpoint =  __name(function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
}, "jpoint");
JPoint.prototype.toP =  __name(function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
}, "toP");
JPoint.prototype.neg =  __name(function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, "neg");
JPoint.prototype.add =  __name(function add2(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
}, "add");
JPoint.prototype.mixedAdd =  __name(function mixedAdd(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
}, "mixedAdd");
JPoint.prototype.dblp =  __name(function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
}, "dblp");
JPoint.prototype.dbl =  __name(function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
}, "dbl");
JPoint.prototype._zeroDbl =  __name(function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s).redISub(s);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
}, "_zeroDbl");
JPoint.prototype._threeDbl =  __name(function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s).redISub(s);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
}, "_threeDbl");
JPoint.prototype._dbl =  __name(function _dbl() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
}, "_dbl");
JPoint.prototype.trpl =  __name(function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
}, "trpl");
JPoint.prototype.mul =  __name(function mul2(k, kbase) {
  k = new import_bn2.default(k, kbase);
  return this.curve._wnafMul(this, k);
}, "mul");
JPoint.prototype.eq =  __name(function eq3(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
}, "eq");
JPoint.prototype.eqXToP =  __name(function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
}, "eqXToP");
JPoint.prototype.inspect =  __name(function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, "inspect");
JPoint.prototype.isInfinity =  __name(function isInfinity2() {
  return this.z.cmpn(0) === 0;
}, "isInfinity");
var curve_1 = createCommonjsModule(function(module, exports) {
  var curve = exports;
  curve.base = base3;
  curve.short = short_1;
  curve.mont = null;
  curve.edwards = null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  var curves = exports;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  __name(PresetCurve, "PresetCurve");
  curves.PresetCurve = PresetCurve;
  function defineCurve(name5, options) {
    Object.defineProperty(curves, name5, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name5, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  __name(defineCurve, "defineCurve");
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
__name(HmacDRBG, "HmacDRBG");
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init =  __name(function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
}, "init");
HmacDRBG.prototype._hmac =  __name(function hmac() {
  return new import_hash.default.hmac(this.hash, this.K);
}, "hmac");
HmacDRBG.prototype._update =  __name(function update(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
}, "update");
HmacDRBG.prototype.reseed =  __name(function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add3 = utils_1.toArray(add3, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
}, "reseed");
HmacDRBG.prototype.generate =  __name(function generate(len, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add3);
  this._reseed++;
  return utils_1.encode(res, enc);
}, "generate");
var assert$3 = utils_1$1.assert;
function KeyPair(ec3, options) {
  this.ec = ec3;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
__name(KeyPair, "KeyPair");
var key = KeyPair;
KeyPair.fromPublic =  __name(function fromPublic(ec3, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec3, {
    pub,
    pubEnc: enc
  });
}, "fromPublic");
KeyPair.fromPrivate =  __name(function fromPrivate(ec3, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec3, {
    priv,
    privEnc: enc
  });
}, "fromPrivate");
KeyPair.prototype.validate =  __name(function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
}, "validate");
KeyPair.prototype.getPublic =  __name(function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
}, "getPublic");
KeyPair.prototype.getPrivate =  __name(function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
}, "getPrivate");
KeyPair.prototype._importPrivate =  __name(function _importPrivate(key2, enc) {
  this.priv = new import_bn2.default(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
}, "_importPrivate");
KeyPair.prototype._importPublic =  __name(function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
}, "_importPublic");
KeyPair.prototype.derive =  __name(function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
}, "derive");
KeyPair.prototype.sign =  __name(function sign2(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
}, "sign");
KeyPair.prototype.verify =  __name(function verify2(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
}, "verify");
KeyPair.prototype.inspect =  __name(function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
}, "inspect");
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
__name(Signature, "Signature");
var signature = Signature;
function Position() {
  this.place = 0;
}
__name(Position, "Position");
function getLength(buf2, p) {
  var initial = buf2[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf2[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
__name(getLength, "getLength");
function rmPadding(buf2) {
  var i = 0;
  var len = buf2.length - 1;
  while (!buf2[i] && !(buf2[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf2;
  }
  return buf2.slice(i);
}
__name(rmPadding, "rmPadding");
Signature.prototype._importDER =  __name(function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 128) {
      r = r.slice(1);
    } else {
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 128) {
      s = s.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn2.default(r);
  this.s = new import_bn2.default(s);
  this.recoveryParam = null;
  return true;
}, "_importDER");
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
__name(constructLength, "constructLength");
Signature.prototype.toDER =  __name(function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();
  if (r[0] & 128)
    r = [0].concat(r);
  if (s[0] & 128)
    s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);
  while (!s[0] && !(s[1] & 128)) {
    s = s.slice(1);
  }
  var arr = [2];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(2);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
}, "toDER");
var rand =  __name(function() {
  throw new Error("unsupported");
}, "rand");
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
__name(EC, "EC");
var ec2 = EC;
EC.prototype.keyPair =  __name(function keyPair(options) {
  return new key(this, options);
}, "keyPair");
EC.prototype.keyFromPrivate =  __name(function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
}, "keyFromPrivate");
EC.prototype.keyFromPublic =  __name(function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
}, "keyFromPublic");
EC.prototype.genKeyPair =  __name(function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn2.default(2));
  for (; ; ) {
    var priv = new import_bn2.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
}, "genKeyPair");
EC.prototype._truncateToN =  __name(function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
}, "_truncateToN");
EC.prototype.sign =  __name(function sign3(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn2.default(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;
    var s = k.invm(this.n).mul(r.mul(key2.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new signature({ r, s, recoveryParam });
  }
}, "sign");
EC.prototype.verify =  __name(function verify3(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }
  p = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r);
}, "verify");
EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n = this.n;
  var e = new import_bn2.default(msg);
  var r = signature$1.r;
  var s = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec2;
  elliptic.eddsa = null;
});
var EC$1 = elliptic_1.ec;
var version8 = "signing-key/5.6.2";
var logger6 = new Logger(version8);
var _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
__name(getCurve, "getCurve");
var SigningKey = class {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger6.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest2) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest2);
    if (digestBytes.length !== 32) {
      logger6.throwArgumentError("bad digest length", "digest", digest2);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
__name(SigningKey, "SigningKey");
function recoverPublicKey(digest2, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest2), rs, sig.recoveryParam).encode("hex", false);
}
__name(recoverPublicKey, "recoverPublicKey");
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger6.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
__name(computePublicKey, "computePublicKey");
var version9 = "transactions/5.6.2";
new Logger(version9);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
__name(computeAddress, "computeAddress");
function recoverAddress(digest2, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest2), signature2));
}
__name(recoverAddress, "recoverAddress");
var version10 = "wallet/5.6.2";
new Logger(version10);
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
__name(verifyMessage, "verifyMessage");
init_sha2_browser();
var GRAMMAR = `
sign-in-with-ethereum =
    domain %s" wants you to sign in with your Ethereum account:" LF
    address LF
    LF
    [ statement LF ]
    LF
    %s"URI: " URI LF
    %s"Version: " version LF
    %s"Nonce: " nonce LF
    %s"Issued At: " issued-at
    [ LF %s"Expiration Time: " expiration-time ]
    [ LF %s"Not Before: " not-before ]
    [ LF %s"Request ID: " request-id ]
    [ LF %s"Chain ID: " chain-id ]
    [ LF %s"Resources:"
    resources ]

domain = dnsauthority

address = "0x" 40*40HEXDIG
    ; Must also conform to captilization
    ; checksum encoding specified in EIP-55
    ; where applicable (EOAs).

statement = *( reserved / unreserved / " " )
    ; The purpose is to exclude LF (line breaks).

version = "1"

nonce = 8*( ALPHA / DIGIT )

issued-at = date-time
expiration-time = date-time
not-before = date-time

request-id = *pchar

chain-id = 1*DIGIT
    ; See EIP-155 for valid CHAIN_IDs.

resources = *( LF resource )

resource = "- " URI

; ------------------------------------------------------------------------------
; RFC 3986

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

hier-part     = "//" authority path-abempty
              / path-absolute
              / path-rootless
              / path-empty

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

authority     = [ userinfo "@" ] host [ ":" port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

IPv6address   =                            6( h16 ":" ) ls32
              /                       "::" 5( h16 ":" ) ls32
              / [               h16 ] "::" 4( h16 ":" ) ls32
              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              / [ *4( h16 ":" ) h16 ] "::"              ls32
              / [ *5( h16 ":" ) h16 ] "::"              h16
              / [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims )

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-rootless = segment-nz *( "/" segment )
path-empty    = 0pchar

segment       = *pchar
segment-nz    = 1*pchar

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

query         = *( pchar / "/" / "?" )

fragment      = *( pchar / "/" / "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="

; ------------------------------------------------------------------------------
; RFC 4501

dnsauthority    = host [ ":" port ]
                             ; See RFC 3986 for the
                             ; definition of "host" and "port".

; ------------------------------------------------------------------------------
; RFC 3339

date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset

date-time       = full-date "T" full-time

; ------------------------------------------------------------------------------
; RFC 5234

ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
LF             =  %x0A
                  ; linefeed
DIGIT          =  %x30-39
                  ; 0-9
HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`;
var ParsedMessage = class {
  constructor(msg) {
    this.domain = void 0;
    this.address = void 0;
    this.statement = void 0;
    this.uri = void 0;
    this.version = void 0;
    this.nonce = void 0;
    this.issuedAt = void 0;
    this.expirationTime = void 0;
    this.notBefore = void 0;
    this.requestId = void 0;
    this.chainId = void 0;
    this.resources = void 0;
    const api = new import_api.default(GRAMMAR);
    api.generate();
    if (api.errors.length) {
      console.error(api.errorsToAscii());
      console.error(api.linesToAscii());
      console.log(api.displayAttributeErrors());
      throw new Error(`ABNF grammar has errors`);
    }
    const grammarObj = api.toObject();
    const parser = new import_node_exports.default.parser();
    parser.ast = new import_node_exports.default.ast();
    const id = import_node_exports.default.ids;
    const domain =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.domain = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "domain");
    parser.ast.callbacks.domain = domain;
    const address =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.address = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "address");
    parser.ast.callbacks.address = address;
    const statement =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.statement = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "statement");
    parser.ast.callbacks.statement = statement;
    const uri =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        if (!data.uri) {
          data.uri = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
        }
      }
      return ret;
    }, "uri");
    parser.ast.callbacks.uri = uri;
    const version11 =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.version = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "version");
    parser.ast.callbacks.version = version11;
    const chainId =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.chainId = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "chainId");
    parser.ast.callbacks["chain-id"] = chainId;
    const nonce =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.nonce = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "nonce");
    parser.ast.callbacks.nonce = nonce;
    const issuedAt =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.issuedAt = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "issuedAt");
    parser.ast.callbacks["issued-at"] = issuedAt;
    const expirationTime =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.expirationTime = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "expirationTime");
    parser.ast.callbacks["expiration-time"] = expirationTime;
    const notBefore =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.notBefore = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "notBefore");
    parser.ast.callbacks["not-before"] = notBefore;
    const requestId =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.requestId = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength);
      }
      return ret;
    }, "requestId");
    parser.ast.callbacks["request-id"] = requestId;
    const resources =  __name(function(state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;
      if (state === id.SEM_PRE) {
        data.resources = import_node_exports.default.utils.charsToString(chars, phraseIndex, phraseLength).slice(3).split("\n- ");
      }
      return ret;
    }, "resources");
    parser.ast.callbacks.resources = resources;
    const result = parser.parse(grammarObj, "sign-in-with-ethereum", msg);
    if (!result.success) {
      throw new Error(`Invalid message: ${JSON.stringify(result)}`);
    }
    const elements = {};
    parser.ast.translate(elements);
    for (const [key2, value] of Object.entries(elements)) {
      this[key2] = value;
    }
  }
};
__name(ParsedMessage, "ParsedMessage");
var ErrorTypes;
(function(ErrorTypes2) {
  ErrorTypes2["INVALID_SIGNATURE"] = "Invalid signature.";
  ErrorTypes2["EXPIRED_MESSAGE"] = "Expired message.";
  ErrorTypes2["MALFORMED_SESSION"] = "Malformed session.";
})(ErrorTypes || (ErrorTypes = {}));
var SignatureType;
(function(SignatureType2) {
  SignatureType2["PERSONAL_SIGNATURE"] = "Personal signature";
})(SignatureType || (SignatureType = {}));
var SiweMessage = class {
  constructor(param) {
    this.domain = void 0;
    this.address = void 0;
    this.statement = void 0;
    this.uri = void 0;
    this.version = void 0;
    this.nonce = void 0;
    this.issuedAt = void 0;
    this.expirationTime = void 0;
    this.notBefore = void 0;
    this.requestId = void 0;
    this.chainId = void 0;
    this.resources = void 0;
    this.signature = void 0;
    this.type = void 0;
    if (typeof param === "string") {
      const parsedMessage = new ParsedMessage(param);
      this.domain = parsedMessage.domain;
      this.address = parsedMessage.address;
      this.statement = parsedMessage.statement;
      this.uri = parsedMessage.uri;
      this.version = parsedMessage.version;
      this.nonce = parsedMessage.nonce;
      this.issuedAt = parsedMessage.issuedAt;
      this.expirationTime = parsedMessage.expirationTime;
      this.notBefore = parsedMessage.notBefore;
      this.requestId = parsedMessage.requestId;
      this.chainId = parsedMessage.chainId;
      this.resources = parsedMessage.resources;
    } else {
      Object.assign(this, param);
    }
  }
  static fromCacao(cacao) {
    const account = AccountId.parse(cacao.p.iss.replace("did:pkh:", ""));
    const siwe = new SiweMessage({
      domain: cacao.p.domain,
      address: account.address,
      uri: cacao.p.aud,
      version: cacao.p.version,
      chainId: new ChainId(account.chainId).reference
    });
    if (cacao.p.statement)
      siwe.statement = cacao.p.statement;
    if (cacao.p.nonce)
      siwe.nonce = cacao.p.nonce;
    if (cacao.p.iat)
      siwe.issuedAt = cacao.p.iat;
    if (cacao.p.exp)
      siwe.expirationTime = cacao.p.exp;
    if (cacao.p.nbf)
      siwe.notBefore = cacao.p.nbf;
    if (cacao.p.requestId)
      siwe.requestId = cacao.p.requestId;
    if (cacao.p.resources)
      siwe.resources = cacao.p.resources;
    if (cacao.s) {
      if (cacao.s.s)
        siwe.signature = cacao.s.s;
      if (cacao.s.t === "eip191")
        siwe.type = SignatureType.PERSONAL_SIGNATURE;
    }
    return siwe;
  }
  toMessage() {
    const header = `${this.domain} wants you to sign in with your Ethereum account:`;
    const uriField = `URI: ${this.uri}`;
    let prefix = [header, this.address].join("\n");
    const versionField = `Version: ${this.version}`;
    if (!this.nonce) {
      this.nonce = (Math.random() + 1).toString(36).substring(4);
    }
    const nonceField = `Nonce: ${this.nonce}`;
    const suffixArray = [uriField, versionField, nonceField];
    this.issuedAt = this.issuedAt ? this.issuedAt : new Date().toISOString();
    suffixArray.push(`Issued At: ${this.issuedAt}`);
    if (this.expirationTime) {
      const expiryField = `Expiration Time: ${this.expirationTime}`;
      suffixArray.push(expiryField);
    }
    if (this.notBefore) {
      suffixArray.push(`Not Before: ${this.notBefore}`);
    }
    if (this.requestId) {
      suffixArray.push(`Request ID: ${this.requestId}`);
    }
    if (this.chainId) {
      suffixArray.push(`Chain ID: ${this.chainId}`);
    }
    if (this.resources) {
      suffixArray.push([`Resources:`, ...this.resources.map((x) => `- ${x}`)].join("\n"));
    }
    const suffix = suffixArray.join("\n");
    if (this.statement) {
      prefix = [prefix, this.statement].join("\n\n");
    }
    return [prefix, suffix].join("\n\n");
  }
  signMessage() {
    let message;
    switch (this.type) {
      case SignatureType.PERSONAL_SIGNATURE: {
        message = this.toMessage();
        break;
      }
      default: {
        message = this.toMessage();
        break;
      }
    }
    return message;
  }
};
__name(SiweMessage, "SiweMessage");
var CLOCK_SKEW_DEFAULT_SEC = 5 * 60;
var Cacao;
(function(Cacao2) {
  function fromSiweMessage(siweMessage) {
    const cacao = {
      h: {
        t: "eip4361"
      },
      p: {
        domain: siweMessage.domain,
        iat: siweMessage.issuedAt,
        iss: `did:pkh:eip155:${siweMessage.chainId}:${siweMessage.address}`,
        aud: siweMessage.uri,
        version: siweMessage.version,
        nonce: siweMessage.nonce
      }
    };
    if (siweMessage.signature) {
      cacao.s = {
        t: "eip191",
        s: siweMessage.signature
      };
    }
    if (siweMessage.notBefore) {
      cacao.p.nbf = siweMessage.notBefore;
    }
    if (siweMessage.expirationTime) {
      cacao.p.exp = siweMessage.expirationTime;
    }
    if (siweMessage.statement) {
      cacao.p.statement = siweMessage.statement;
    }
    if (siweMessage.requestId) {
      cacao.p.requestId = siweMessage.requestId;
    }
    if (siweMessage.resources) {
      cacao.p.resources = siweMessage.resources;
    }
    return cacao;
  }
  __name(fromSiweMessage, "fromSiweMessage");
  Cacao2.fromSiweMessage = fromSiweMessage;
  function verify4(cacao, options = {}) {
    var _cacao$s;
    if (cacao.h.t === "eip4361" && ((_cacao$s = cacao.s) == null ? void 0 : _cacao$s.t) === "eip191") {
      return verifyEIP191Signature(cacao, options);
    }
    throw new Error("Unsupported CACAO signature type");
  }
  __name(verify4, "verify");
  Cacao2.verify = verify4;
  function verifyEIP191Signature(cacao, options) {
    var _a;
    if (!cacao.s) {
      throw new Error(`CACAO does not have a signature`);
    }
    const atTime = options.atTime ? options.atTime.getTime() : Date.now();
    const clockSkew = ((_a = options.clockSkewSecs) != null ? _a : CLOCK_SKEW_DEFAULT_SEC) * 1e3;
    if (Date.parse(cacao.p.iat) > atTime + clockSkew || Date.parse(cacao.p.nbf) > atTime + clockSkew) {
      throw new Error(`CACAO is not valid yet`);
    }
    const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1e3 : 0;
    if (Date.parse(cacao.p.exp) + phaseOutMS + clockSkew < atTime) {
      throw new Error(`CACAO has expired`);
    }
    const msg = SiweMessage.fromCacao(cacao);
    const sig = cacao.s.s;
    const recoveredAddress = verifyMessage(msg.toMessage(), sig);
    const issAddress = AccountId.parse(cacao.p.iss.replace("did:pkh:", "")).address;
    if (recoveredAddress.toLowerCase() !== issAddress.toLowerCase()) {
      throw new Error(`Signature does not belong to issuer`);
    }
  }
  __name(verifyEIP191Signature, "verifyEIP191Signature");
  Cacao2.verifyEIP191Signature = verifyEIP191Signature;
})(Cacao || (Cacao = {}));
var CacaoBlock;
(function(CacaoBlock2) {
  const fromCacao =  __name(function(cacao) {
    try {
      return Promise.resolve(encode7({
        value: cacao,
        codec: esm_exports,
        hasher: sha256
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }, "fromCacao");
  CacaoBlock2.fromCacao = fromCacao;
})(CacaoBlock || (CacaoBlock = {}));
init_to_string();
init_from_string();
var import_random2 = __toESM(require_random(), 1);
init_to_string();
function randomString() {
  return toString3((0, import_random2.randomBytes)(16), "base64");
}
__name(randomString, "randomString");
var B64 = "base64pad";
var B64_URL = "base64url";
function encodeBase64(bytes) {
  return toString3(bytes, B64);
}
__name(encodeBase64, "encodeBase64");
function encodeBase64Url(bytes) {
  return toString3(bytes, B64_URL);
}
__name(encodeBase64Url, "encodeBase64Url");
function decodeBase64(s) {
  return fromString2(s, B64);
}
__name(decodeBase64, "decodeBase64");
function base64urlToJSON(s) {
  return JSON.parse(toString3(fromString2(s, B64_URL)));
}
__name(base64urlToJSON, "base64urlToJSON");
function fromDagJWS(jws) {
  if (jws.signatures.length > 1)
    throw new Error("Cant convert to compact jws");
  return `${jws.signatures[0].protected}.${jws.payload}.${jws.signatures[0].signature}`;
}
__name(fromDagJWS, "fromDagJWS");
function didWithTime(did, atTime) {
  if (atTime) {
    const versionTime = atTime.toISOString().split(".")[0] + "Z";
    return `${did}?versionTime=${versionTime}`;
  } else {
    return did;
  }
}
__name(didWithTime, "didWithTime");
function extractControllers(controllerProperty) {
  if (controllerProperty) {
    if (Array.isArray(controllerProperty)) {
      return controllerProperty;
    } else {
      return [controllerProperty];
    }
  } else {
    return [];
  }
}
__name(extractControllers, "extractControllers");
function isResolver(resolver) {
  return "registry" in resolver && "cache" in resolver;
}
__name(isResolver, "isResolver");
var DID = class {
  constructor({ provider, resolver = {}, resolverOptions, capability, parent } = {}) {
    if (provider != null) {
      this._client = new RPCClient(provider);
    }
    if (capability) {
      this._capability = capability;
      this._parentId = this._capability.p.iss;
      if (parent && this._parentId !== parent)
        throw new Error("Capability issuer and parent not equal");
    } else if (parent) {
      this._parentId = parent;
    }
    this.setResolver(resolver, resolverOptions);
  }
  get capability() {
    if (!this._capability) {
      throw new Error("DID has no capability attached");
    }
    return this._capability;
  }
  get hasCapability() {
    return this._capability != null;
  }
  get parent() {
    if (!this._parentId) {
      throw new Error("DID has no parent DID");
    }
    return this._parentId;
  }
  get hasParent() {
    return this._parentId != null;
  }
  get id() {
    if (this._id == null) {
      throw new Error("DID is not authenticated");
    }
    return this._id;
  }
  get authenticated() {
    return this._id != null;
  }
  withCapability(cap) {
    var _a;
    return new DID({
      provider: (_a = this._client) == null ? void 0 : _a.connection,
      resolver: this._resolver,
      capability: cap,
      parent: this._parentId
    });
  }
  setProvider(provider) {
    if (this._client == null) {
      this._client = new RPCClient(provider);
    } else if (this._client.connection !== provider) {
      throw new Error("A different provider is already set, create a new DID instance to use another provider");
    }
  }
  setResolver(resolver, resolverOptions) {
    this._resolver = isResolver(resolver) ? resolver : new Resolver(resolver, resolverOptions);
  }
  authenticate() {
    return __async(this, arguments, function* ({ provider, paths = [], aud } = {}) {
      if (provider != null) {
        this.setProvider(provider);
      }
      if (this._client == null) {
        throw new Error("No provider available");
      }
      const nonce = randomString();
      const jws = yield this._client.request("did_authenticate", {
        nonce,
        aud,
        paths
      });
      const { kid } = yield this.verifyJWS(jws);
      const payload = base64urlToJSON(jws.payload);
      if (!kid.includes(payload.did))
        throw new Error("Invalid authencation response, kid mismatch");
      if (payload.nonce !== nonce)
        throw new Error("Invalid authencation response, wrong nonce");
      if (payload.aud !== aud)
        throw new Error("Invalid authencation response, wrong aud");
      if (payload.exp < Date.now() / 1e3)
        throw new Error("Invalid authencation response, expired");
      this._id = payload.did;
      return this._id;
    });
  }
  createJWS(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      if (this._client == null)
        throw new Error("No provider available");
      if (this._id == null)
        throw new Error("DID is not authenticated");
      if (this._capability) {
        const cacaoBlock = yield CacaoBlock.fromCacao(this._capability);
        const capCID = CID.asCID(cacaoBlock.cid);
        if (!capCID) {
          throw new Error(`Capability CID of the JWS cannot be set to the capability payload cid as they are incompatible`);
        }
        options.protected = options.protected || {};
        options.protected.cap = `ipfs://${capCID == null ? void 0 : capCID.toString()}`;
      }
      const { jws } = yield this._client.request("did_createJWS", __spreadProps(__spreadValues({
        did: this._id
      }, options), {
        payload
      }));
      return jws;
    });
  }
  createDagJWS(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      const { cid, linkedBlock } = yield encodePayload(payload);
      const payloadCid = encodeBase64Url(cid.bytes);
      Object.assign(options, { linkedBlock: encodeBase64(linkedBlock) });
      const jws = yield this.createJWS(payloadCid, options);
      const compatibleCID = CID.asCID(cid);
      if (!compatibleCID) {
        throw new Error("CID of the JWS cannot be set to the encoded payload cid as they are incompatible");
      }
      jws.link = compatibleCID;
      if (this._capability) {
        const cacaoBlock = yield CacaoBlock.fromCacao(this._capability);
        return { jws, linkedBlock, cacaoBlock: cacaoBlock.bytes };
      }
      return { jws, linkedBlock };
    });
  }
  verifyJWS(_0) {
    return __async(this, arguments, function* (jws, options = {}) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (typeof jws !== "string")
        jws = fromDagJWS(jws);
      const kid = base64urlToJSON(jws.split(".")[0]).kid;
      if (!kid)
        throw new Error('No "kid" found in jws');
      const didResolutionResult = yield this.resolve(kid);
      const timecheckEnabled = !options.disableTimecheck;
      if (timecheckEnabled) {
        const nextUpdate = (_a = didResolutionResult.didDocumentMetadata) == null ? void 0 : _a.nextUpdate;
        if (nextUpdate) {
          const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1e3 : 0;
          const revocationTime = new Date(nextUpdate).valueOf() + phaseOutMS;
          const isEarlier = options.atTime && options.atTime.getTime() < revocationTime;
          const isLater = !isEarlier;
          if (isLater) {
            throw new Error(`invalid_jws: signature authored with a revoked DID version: ${kid}`);
          }
        }
        const updated = (_b = didResolutionResult.didDocumentMetadata) == null ? void 0 : _b.updated;
        if (updated && options.atTime && options.atTime.getTime() < new Date(updated).valueOf()) {
          throw new Error(`invalid_jws: signature authored before creation of DID version: ${kid}`);
        }
      }
      const signerDid = (_c = didResolutionResult.didDocument) == null ? void 0 : _c.id;
      if (options.issuer && options.issuer === ((_d = options.capability) == null ? void 0 : _d.p.iss) && signerDid === options.capability.p.aud) {
        Cacao.verify(options.capability, {
          atTime: options.atTime ? options.atTime : void 0,
          revocationPhaseOutSecs: options.revocationPhaseOutSecs
        });
      } else if (options.issuer && options.issuer !== signerDid) {
        const issuerUrl = didWithTime(options.issuer, options.atTime);
        const issuerResolution = yield this.resolve(issuerUrl);
        const controllerProperty = (_e = issuerResolution.didDocument) == null ? void 0 : _e.controller;
        const controllers = extractControllers(controllerProperty);
        if (((_f = options.capability) == null ? void 0 : _f.s) && options.capability.p.aud === signerDid && controllers.includes(options.capability.p.iss)) {
          Cacao.verify(options.capability, {
            atTime: options.atTime ? options.atTime : void 0,
            revocationPhaseOutSecs: options.revocationPhaseOutSecs
          });
        } else {
          const signerIsController = signerDid ? controllers.includes(signerDid) : false;
          if (!signerIsController) {
            throw new Error(`invalid_jws: not a valid verificationMethod for issuer: ${kid}`);
          }
        }
      }
      const publicKeys = ((_g = didResolutionResult.didDocument) == null ? void 0 : _g.verificationMethod) || [];
      verifyJWS(jws, publicKeys);
      let payload;
      try {
        payload = base64urlToJSON(jws.split(".")[1]);
      } catch (e) {
      }
      return { kid, payload, didResolutionResult };
    });
  }
  createJWE(_0, _1) {
    return __async(this, arguments, function* (cleartext, recipients, options = {}) {
      const encrypters = yield resolveX25519Encrypters(recipients, this._resolver);
      return createJWE(cleartext, encrypters, options.protectedHeader, options.aad);
    });
  }
  createDagJWE(_0, _1) {
    return __async(this, arguments, function* (cleartext, recipients, options = {}) {
      const preparedCleartext = yield prepareCleartext(cleartext);
      return this.createJWE(preparedCleartext, recipients, options);
    });
  }
  decryptJWE(_0) {
    return __async(this, arguments, function* (jwe, options = {}) {
      if (this._client == null)
        throw new Error("No provider available");
      if (this._id == null)
        throw new Error("DID is not authenticated");
      const { cleartext } = yield this._client.request("did_decryptJWE", __spreadProps(__spreadValues({
        did: this._id
      }, options), {
        jwe
      }));
      return decodeBase64(cleartext);
    });
  }
  decryptDagJWE(jwe) {
    return __async(this, null, function* () {
      const bytes = yield this.decryptJWE(jwe);
      return decodeCleartext(bytes);
    });
  }
  resolve(didUrl) {
    return __async(this, null, function* () {
      const result = yield this._resolver.resolve(didUrl);
      if (result.didResolutionMetadata.error) {
        const { error, message } = result.didResolutionMetadata;
        const maybeMessage = message ? `, ${message}` : "";
        throw new Error(`Failed to resolve ${didUrl}: ${error}${maybeMessage}`);
      }
      return result;
    });
  }
};
__name(DID, "DID");
function toUint8Array(str) {
  var s = 0, sl = str.length, bytes = [];
  if (sl % 2) {
    throw new Error("invalid hex:" + str);
  }
  for (; s < sl; s += 2) {
    bytes.push(parseInt(str.substr(s, 2), 16));
  }
  return new Uint8Array(bytes);
}
__name(toUint8Array, "toUint8Array");
var import_key_did_resolver = __toESM(require_lib());
var import_ed255192 = __toESM(require_ed25519(), 1);
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify(), 1);
var B642 = "base64pad";
function toStableObject(obj) {
  return JSON.parse((0, import_fast_json_stable_stringify.default)(obj));
}
__name(toStableObject, "toStableObject");
function encodeDID(publicKey) {
  const bytes = new Uint8Array(publicKey.length + 2);
  bytes[0] = 237;
  bytes[1] = 1;
  bytes.set(publicKey, 2);
  return `did:key:z${toString3(bytes, "base58btc")}`;
}
__name(encodeDID, "encodeDID");
function toGeneralJWS(jws) {
  const [protectedHeader, payload, signature2] = jws.split(".");
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature: signature2 }]
  };
}
__name(toGeneralJWS, "toGeneralJWS");
var sign4 =  __name((_0, _1, _2, ..._3) => __async(void 0, [_0, _1, _2, ..._3], function* (payload, did, secretKey, protectedHeader = {}) {
  const kid = `${did}#${did.split(":")[2]}`;
  const signer = EdDSASigner(secretKey);
  const header = toStableObject(Object.assign(protectedHeader, { kid, alg: "EdDSA" }));
  return createJWS(typeof payload === "string" ? payload : toStableObject(payload), signer, header);
}), "sign");
var didMethods = {
  did_authenticate: (_0, _1) => __async(void 0, [_0, _1], function* ({ did, secretKey }, params) {
    const response = yield sign4({
      did,
      aud: params.aud,
      nonce: params.nonce,
      paths: params.paths,
      exp: Math.floor(Date.now() / 1e3) + 600
    }, did, secretKey);
    return toGeneralJWS(response);
  }),
  did_createJWS: (_0, _1) => __async(void 0, [_0, _1], function* ({ did, secretKey }, params) {
    const requestDid = params.did.split("#")[0];
    if (requestDid !== did)
      throw new RPCError(4100, `Unknown DID: ${did}`);
    const jws = yield sign4(params.payload, did, secretKey, params.protected);
    return { jws: toGeneralJWS(jws) };
  }),
  did_decryptJWE: (_0, _1) => __async(void 0, [_0, _1], function* ({ secretKey }, params) {
    const decrypter = x25519Decrypter((0, import_ed255192.convertSecretKeyToX25519)(secretKey));
    try {
      const bytes = yield decryptJWE(params.jwe, decrypter);
      return { cleartext: toString3(bytes, B642) };
    } catch (e) {
      throw new RPCError(-32e3, e.message);
    }
  })
};
var Ed25519Provider = class {
  constructor(seed) {
    const { secretKey, publicKey } = (0, import_ed255192.generateKeyPairFromSeed)(seed);
    const did = encodeDID(publicKey);
    const handler = createHandler(didMethods);
    this._handle = (msg) => __async(this, null, function* () {
      return yield handler({ did, secretKey }, msg);
    });
  }
  get isDidProvider() {
    return true;
  }
  send(msg) {
    return __async(this, null, function* () {
      return yield this._handle(msg);
    });
  }
};
__name(Ed25519Provider, "Ed25519Provider");
init_cid();
init_base36();
var registry = {
  tile: 0,
  "caip10-link": 1,
  model: 2,
  MID: 3
};
function codeByName(name5) {
  const index = registry[name5];
  if (typeof index !== "undefined") {
    return index;
  } else {
    throw new Error(`No stream type registered for name ${name5}`);
  }
}
__name(codeByName, "codeByName");
function nameByCode(index) {
  const pair = Object.entries(registry).find(([, v]) => v === index);
  if (pair) {
    return pair[0];
  } else {
    throw new Error(`No stream type registered for index ${index}`);
  }
}
__name(nameByCode, "nameByCode");
var StreamType = class {
};
__name(StreamType, "StreamType");
StreamType.nameByCode = nameByCode;
StreamType.codeByName = codeByName;
var import_varint4 = __toESM(require_varint(), 1);
function Memoize(args) {
  let hashFunction;
  let duration;
  let tags;
  if (typeof args === "object") {
    hashFunction = args.hashFunction;
    duration = args.expiring;
    tags = args.tags;
  } else {
    hashFunction = args;
  }
  return (target, propertyKey, descriptor) => {
    if (descriptor.value != null) {
      descriptor.value = getNewFunction(descriptor.value, hashFunction, duration, tags);
    } else if (descriptor.get != null) {
      descriptor.get = getNewFunction(descriptor.get, hashFunction, duration, tags);
    } else {
      throw "Only put a Memoize() decorator on a method or get accessor.";
    }
  };
}
__name(Memoize, "Memoize");
var clearCacheTagsMap =  new Map();
function getNewFunction(originalMethod, hashFunction, duration = 0, tags) {
  const propMapName = Symbol(`__memoized_map__`);
  return function(...args) {
    let returnedValue;
    if (!this.hasOwnProperty(propMapName)) {
      Object.defineProperty(this, propMapName, {
        configurable: false,
        enumerable: false,
        writable: false,
        value:  new Map()
      });
    }
    let myMap = this[propMapName];
    if (Array.isArray(tags)) {
      for (const tag of tags) {
        if (clearCacheTagsMap.has(tag)) {
          clearCacheTagsMap.get(tag).push(myMap);
        } else {
          clearCacheTagsMap.set(tag, [myMap]);
        }
      }
    }
    if (hashFunction || args.length > 0 || duration > 0) {
      let hashKey;
      if (hashFunction === true) {
        hashKey = args.map((a) => a.toString()).join("!");
      } else if (hashFunction) {
        hashKey = hashFunction.apply(this, args);
      } else {
        hashKey = args[0];
      }
      const timestampKey = `${hashKey}__timestamp`;
      let isExpired = false;
      if (duration > 0) {
        if (!myMap.has(timestampKey)) {
          isExpired = true;
        } else {
          let timestamp = myMap.get(timestampKey);
          isExpired = Date.now() - timestamp > duration;
        }
      }
      if (myMap.has(hashKey) && !isExpired) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(this, args);
        myMap.set(hashKey, returnedValue);
        if (duration > 0) {
          myMap.set(timestampKey, Date.now());
        }
      }
    } else {
      const hashKey = this;
      if (myMap.has(hashKey)) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(this, args);
        myMap.set(hashKey, returnedValue);
      }
    }
    return returnedValue;
  };
}
__name(getNewFunction, "getNewFunction");
var STREAMID_CODEC = 206;
init_cid();
var import_varint2 = __toESM(require_varint(), 1);
init_digest();
function readVarint(bytes) {
  const value = import_varint2.default.decode(bytes);
  const readLength = import_varint2.default.decode.bytes;
  const remainder = bytes.slice(readLength);
  return [value, remainder, readLength];
}
__name(readVarint, "readVarint");
function isCidVersion(input) {
  return input === 0 || input === 1;
}
__name(isCidVersion, "isCidVersion");
function readCid(bytes) {
  const result = readCidNoThrow(bytes);
  if (result instanceof Error) {
    throw result;
  }
  return result;
}
__name(readCid, "readCid");
function readCidNoThrow(bytes) {
  const [cidVersion, cidVersionRemainder] = readVarint(bytes);
  if (!isCidVersion(cidVersion)) {
    return new Error(`Unknown CID version ${cidVersion}`);
  }
  const [codec, codecRemainder] = readVarint(cidVersionRemainder);
  const [, mhCodecRemainder, mhCodecLength] = readVarint(codecRemainder);
  const [mhLength, , mhLengthLength] = readVarint(mhCodecRemainder);
  const multihashBytes = codecRemainder.slice(0, mhCodecLength + mhLengthLength + mhLength);
  const multihashBytesRemainder = codecRemainder.slice(mhCodecLength + mhLengthLength + mhLength);
  return [CID.create(cidVersion, codec, decode5(multihashBytes)), multihashBytesRemainder];
}
__name(readCidNoThrow, "readCidNoThrow");
init_cid();
init_base36();
init_sha2_browser();
var import_varint3 = __toESM(require_varint(), 1);
var __decorate = function(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
};
var __metadata = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
function fromBytes(bytes) {
  const result = fromBytesNoThrow(bytes);
  if (result instanceof Error) {
    throw result;
  }
  return result;
}
__name(fromBytes, "fromBytes");
function fromBytesNoThrow(bytes) {
  const [streamCodec, streamCodecRemainder] = readVarint(bytes);
  if (streamCodec !== STREAMID_CODEC)
    return new Error("fromBytes: invalid streamid, does not include streamid codec");
  const [type, streamTypeRemainder] = readVarint(streamCodecRemainder);
  const cidResult = readCidNoThrow(streamTypeRemainder);
  if (cidResult instanceof Error) {
    return cidResult;
  }
  const [cid, cidRemainder] = cidResult;
  if (cidRemainder.length > 0) {
    return new Error(`Invalid StreamID: contains commit`);
  }
  return new StreamID(type, cid);
}
__name(fromBytesNoThrow, "fromBytesNoThrow");
function fromString4(input) {
  const result = fromStringNoThrow(input);
  if (result instanceof Error) {
    throw result;
  }
  return result;
}
__name(fromString4, "fromString");
function fromStringNoThrow(input) {
  const protocolFree = input.replace("ceramic://", "").replace("/ceramic/", "");
  const commitFree = protocolFree.includes("commit") ? protocolFree.split("?")[0] : protocolFree;
  const bytes = base36.decode(commitFree);
  return fromBytesNoThrow(bytes);
}
__name(fromStringNoThrow, "fromStringNoThrow");
var TAG = Symbol.for("@ceramicnetwork/streamid/StreamID");
var StreamID = class {
  constructor(type, cid) {
    this._tag = TAG;
    if (!(type || type === 0))
      throw new Error("constructor: type required");
    if (!cid)
      throw new Error("constructor: cid required");
    this._type = typeof type === "string" ? StreamType.codeByName(type) : type;
    this._cid = typeof cid === "string" ? CID.parse(cid) : cid;
  }
  static isInstance(instance) {
    return typeof instance === "object" && "_tag" in instance && instance._tag === TAG;
  }
  static fromGenesis(type, genesis) {
    return __async(this, null, function* () {
      const block = yield encode7({ value: genesis, codec: esm_exports, hasher: sha256 });
      return new StreamID(type, block.cid);
    });
  }
  get type() {
    return this._type;
  }
  get typeName() {
    return StreamType.nameByCode(this._type);
  }
  get cid() {
    return this._cid;
  }
  get bytes() {
    const codec = import_varint3.default.encode(STREAMID_CODEC);
    const type = import_varint3.default.encode(this.type);
    return concat([codec, type, this.cid.bytes]);
  }
  get baseID() {
    return new StreamID(this._type, this._cid);
  }
  equals(other) {
    if (StreamID.isInstance(other)) {
      return this.type === other.type && this.cid.equals(other.cid);
    } else {
      return false;
    }
  }
  toString() {
    return base36.encode(this.bytes);
  }
  toUrl() {
    return `ceramic://${this.toString()}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `StreamID(${this.toString()})`;
  }
  [Symbol.toPrimitive]() {
    return this.toString();
  }
};
__name(StreamID, "StreamID");
StreamID.fromBytes = fromBytes;
StreamID.fromBytesNoThrow = fromBytesNoThrow;
StreamID.fromString = fromString4;
StreamID.fromStringNoThrow = fromStringNoThrow;
__decorate([
  Memoize(),
  __metadata("design:type", String),
  __metadata("design:paramtypes", [])
], StreamID.prototype, "typeName", null);
__decorate([
  Memoize(),
  __metadata("design:type", Uint8Array),
  __metadata("design:paramtypes", [])
], StreamID.prototype, "bytes", null);
__decorate([
  Memoize(),
  __metadata("design:type", StreamID),
  __metadata("design:paramtypes", [])
], StreamID.prototype, "baseID", null);
__decorate([
  Memoize(),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", String)
], StreamID.prototype, "toString", null);
__decorate([
  Memoize(),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", String)
], StreamID.prototype, "toUrl", null);
var __decorate2 = function(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
};
var __metadata2 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CommitID_type;
var _CommitID_cid;
var _CommitID_commit;
function fromBytes2(bytes) {
  const result = fromBytesNoThrow2(bytes);
  if (result instanceof Error) {
    throw result;
  }
  return result;
}
__name(fromBytes2, "fromBytes");
function fromBytesNoThrow2(bytes) {
  const [streamCodec, streamCodecRemainder] = readVarint(bytes);
  if (streamCodec !== STREAMID_CODEC)
    return new Error("fromBytes: invalid streamid, does not include streamid codec");
  const [type, streamtypeRemainder] = readVarint(streamCodecRemainder);
  const cidResult = readCid(streamtypeRemainder);
  if (cidResult instanceof Error) {
    return cidResult;
  }
  const [base4, baseRemainder] = cidResult;
  if (baseRemainder.length === 0) {
    return new Error(`No commit information provided`);
  } else if (baseRemainder.length === 1) {
    return new CommitID(type, base4, baseRemainder[0]);
  } else {
    const [commit] = readCid(baseRemainder);
    return new CommitID(type, base4, commit);
  }
}
__name(fromBytesNoThrow2, "fromBytesNoThrow");
function parseCID(input) {
  try {
    return typeof input === "string" ? CID.parse(input) : CID.asCID(input);
  } catch (e) {
    return void 0;
  }
}
__name(parseCID, "parseCID");
function parseCommit(genesis, commit = null) {
  if (!commit)
    return null;
  const commitCID = parseCID(commit);
  if (commitCID) {
    if (genesis.equals(commitCID)) {
      return null;
    } else {
      return commitCID;
    }
  } else if (String(commit) === "0") {
    return null;
  } else {
    throw new Error("Cannot specify commit as a number except to request commit 0 (the genesis commit)");
  }
}
__name(parseCommit, "parseCommit");
function fromString5(input) {
  const result = fromStringNoThrow2(input);
  if (result instanceof Error) {
    throw result;
  }
  return result;
}
__name(fromString5, "fromString");
function fromStringNoThrow2(input) {
  const protocolFree = input.replace("ceramic://", "").replace("/ceramic/", "");
  if (protocolFree.includes("commit")) {
    const commit = protocolFree.split("?")[1].split("=")[1];
    const base4 = protocolFree.split("?")[0];
    return make(StreamID.fromString(base4), commit);
  } else {
    return fromBytesNoThrow2(base36.decode(protocolFree));
  }
}
__name(fromStringNoThrow2, "fromStringNoThrow");
var TAG2 = Symbol.for("@ceramicnetwork/streamid/CommitID");
function make(stream, commit) {
  return new CommitID(stream.type, stream.cid, commit);
}
__name(make, "make");
var CommitID = class {
  constructor(type, cid, commit = null) {
    this._tag = TAG2;
    _CommitID_type.set(this, void 0);
    _CommitID_cid.set(this, void 0);
    _CommitID_commit.set(this, void 0);
    if (!type && type !== 0)
      throw new Error("constructor: type required");
    if (!cid)
      throw new Error("constructor: cid required");
    __classPrivateFieldSet(this, _CommitID_type, typeof type === "string" ? StreamType.codeByName(type) : type, "f");
    __classPrivateFieldSet(this, _CommitID_cid, typeof cid === "string" ? CID.parse(cid) : cid, "f");
    __classPrivateFieldSet(this, _CommitID_commit, parseCommit(__classPrivateFieldGet(this, _CommitID_cid, "f"), commit), "f");
  }
  static isInstance(instance) {
    return typeof instance === "object" && "_tag" in instance && instance._tag === TAG2;
  }
  get baseID() {
    return new StreamID(__classPrivateFieldGet(this, _CommitID_type, "f"), __classPrivateFieldGet(this, _CommitID_cid, "f"));
  }
  get type() {
    return __classPrivateFieldGet(this, _CommitID_type, "f");
  }
  get typeName() {
    return StreamType.nameByCode(__classPrivateFieldGet(this, _CommitID_type, "f"));
  }
  get cid() {
    return __classPrivateFieldGet(this, _CommitID_cid, "f");
  }
  get commit() {
    return __classPrivateFieldGet(this, _CommitID_commit, "f") || __classPrivateFieldGet(this, _CommitID_cid, "f");
  }
  get bytes() {
    var _a;
    const codec = import_varint4.default.encode(STREAMID_CODEC);
    const type = import_varint4.default.encode(this.type);
    const commitBytes = ((_a = __classPrivateFieldGet(this, _CommitID_commit, "f")) == null ? void 0 : _a.bytes) || new Uint8Array([0]);
    return concat([codec, type, this.cid.bytes, commitBytes]);
  }
  equals(other) {
    return this.type === other.type && this.cid.equals(other.cid) && this.commit.equals(other.commit);
  }
  toString() {
    return base36.encode(this.bytes);
  }
  toUrl() {
    return `ceramic://${this.toString()}`;
  }
  [(_CommitID_type =  new WeakMap(), _CommitID_cid =  new WeakMap(), _CommitID_commit =  new WeakMap(), Symbol.for("nodejs.util.inspect.custom"))]() {
    return `CommitID(${this.toString()})`;
  }
  [Symbol.toPrimitive]() {
    return this.toString();
  }
};
__name(CommitID, "CommitID");
CommitID.fromBytes = fromBytes2;
CommitID.fromBytesNoThrow = fromBytesNoThrow2;
CommitID.fromString = fromString5;
CommitID.fromStringNoThrow = fromStringNoThrow2;
CommitID.make = make;
__decorate2([
  Memoize(),
  __metadata2("design:type", StreamID),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "baseID", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", String),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "typeName", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", CID),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "commit", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", Uint8Array),
  __metadata2("design:paramtypes", [])
], CommitID.prototype, "bytes", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", Function),
  __metadata2("design:paramtypes", []),
  __metadata2("design:returntype", String)
], CommitID.prototype, "toString", null);
__decorate2([
  Memoize(),
  __metadata2("design:type", Function),
  __metadata2("design:paramtypes", []),
  __metadata2("design:returntype", String)
], CommitID.prototype, "toUrl", null);
var StreamRef;
(function(StreamRef2) {
  function from4(input) {
    if (StreamID.isInstance(input)) {
      return input;
    } else if (CommitID.isInstance(input)) {
      return input;
    } else if (input instanceof Uint8Array) {
      const commitId = CommitID.fromBytesNoThrow(input);
      if (commitId instanceof Error) {
        return StreamID.fromBytes(input);
      }
      return commitId;
    } else if (typeof input === "string") {
      const commitId = CommitID.fromStringNoThrow(input);
      if (commitId instanceof Error) {
        return StreamID.fromString(input);
      }
      return commitId;
    } else {
      throw new Error(`Can not build CommitID or StreamID`);
    }
  }
  __name(from4, "from");
  StreamRef2.from = from4;
})(StreamRef || (StreamRef = {}));
var CIP11_DEFINITION_SCHEMA_URL = "ceramic://k3y52l7qbv1fry1fp4s0nwdarh0vahusarpposgevy0pemiykymd2ord6swtharcw";
var CIP11_INDEX_SCHEMA_URL = "ceramic://k3y52l7qbv1fryjn62sggjh1lpn11c56qfofzmty190d62hwk1cal1c7qc5he54ow";
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate5,
  validator: () => validator
});
var __extends = function() {
  var extendStatics =  __name(function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  }, "extendStatics");
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    __name(__, "__");
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key2) {
  return _hasOwnProperty.call(obj, key2);
}
__name(hasOwnProperty, "hasOwnProperty");
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k = 0; k < keys_1.length; k++) {
      keys_1[k] = "" + k;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
__name(_objectKeys, "_objectKeys");
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
__name(_deepClone, "_deepClone");
function isInteger2(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
__name(isInteger2, "isInteger");
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
__name(escapePathComponent, "escapePathComponent");
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
__name(unescapePathComponent, "unescapePathComponent");
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
__name(hasUndefined, "hasUndefined");
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key2 in args) {
    var value = typeof args[key2] === "object" ? JSON.stringify(args[key2], null, 2) : args[key2];
    if (typeof value !== "undefined") {
      messageParts.push(key2 + ": " + value);
    }
  }
  return messageParts.join("\n");
}
__name(patchErrorMessageFormatter, "patchErrorMessageFormatter");
var PatchError = function(_super) {
  __extends(PatchError2, _super);
  function PatchError2(message, name5, index, operation, tree2) {
    var _newTarget = this.constructor;
    var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name5, index, operation, tree: tree2 })) || this;
    _this.name = name5;
    _this.index = index;
    _this.operation = operation;
    _this.tree = tree2;
    Object.setPrototypeOf(_this, _newTarget.prototype);
    _this.message = patchErrorMessageFormatter(message, { name: name5, index, operation, tree: tree2 });
    return _this;
  }
  __name(PatchError2, "PatchError");
  return PatchError2;
}(Error);
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key2, document) {
    obj[key2] = this.value;
    return { newDocument: document };
  },
  remove: function(obj, key2, document) {
    var removed = obj[key2];
    delete obj[key2];
    return { newDocument: document, removed };
  },
  replace: function(obj, key2, document) {
    var removed = obj[key2];
    obj[key2] = this.value;
    return { newDocument: document, removed };
  },
  move: function(obj, key2, document) {
    var removed = getValueByPointer(document, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
    applyOperation(document, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document, removed };
  },
  copy: function(obj, key2, document) {
    var valueToCopy = getValueByPointer(document, this.from);
    applyOperation(document, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document };
  },
  test: function(obj, key2, document) {
    return { newDocument: document, test: _areEquals(obj[key2], this.value) };
  },
  _get: function(obj, key2, document) {
    this.value = obj[key2];
    return { newDocument: document };
  }
};
var arrOps = {
  add: function(arr, i, document) {
    if (isInteger2(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document, index: i };
  },
  remove: function(arr, i, document) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document, removed: removedList[0] };
  },
  replace: function(arr, i, document) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document, pointer) {
  if (pointer == "") {
    return document;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document, getOriginalDestination);
  return getOriginalDestination.value;
}
__name(getValueByPointer, "getValueByPointer");
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index === void 0) {
    index = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
      }
      returnValue.newDocument = document;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document = _deepClone(document);
    }
    var path = operation.path || "";
    var keys = path.split("/");
    var obj = document;
    var t = 1;
    var len = keys.length;
    var existingPathFragment = void 0;
    var key2 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key2 = keys[t];
      if (key2 && key2.indexOf("~") != -1) {
        key2 = unescapePathComponent(key2);
      }
      if (banPrototypeModifications && (key2 == "__proto__" || key2 == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key2] === void 0) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key2 === "-") {
          key2 = obj.length;
        } else {
          if (validateOperation && !isInteger2(key2)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
          } else if (isInteger2(key2)) {
            key2 = ~~key2;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key2 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key2, document);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key2, document);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return returnValue;
        }
      }
      obj = obj[key2];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
__name(applyOperation, "applyOperation");
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document = _deepClone(document);
  }
  var results = new Array(patch.length);
  for (var i = 0, length_1 = patch.length; i < length_1; i++) {
    results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
    document = results[i].newDocument;
  }
  results.newDocument = document;
  return results;
}
__name(applyPatch, "applyPatch");
function applyReducer(document, operation, index) {
  var operationResult = applyOperation(document, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
  }
  return operationResult.newDocument;
}
__name(applyReducer, "applyReducer");
function validator(operation, index, document, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document);
  } else if (document) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error = validate5([existingValue], document);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
__name(validator, "validator");
function validate5(sequence, document, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document) {
      applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
__name(validate5, "validate");
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length2, key2;
    if (arrA && arrB) {
      length2 = a.length;
      if (length2 != b.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a);
    length2 = keys.length;
    if (length2 !== Object.keys(b).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!b.hasOwnProperty(keys[i]))
        return false;
    for (i = length2; i-- !== 0; ) {
      key2 = keys[i];
      if (!_areEquals(a[key2], b[key2]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
__name(_areEquals, "_areEquals");
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare3,
  generate: () => generate2,
  observe: () => observe,
  unobserve: () => unobserve
});
var beforeDict =  new WeakMap();
var Mirror = function() {
  function Mirror2(obj) {
    this.observers =  new Map();
    this.obj = obj;
  }
  __name(Mirror2, "Mirror");
  return Mirror2;
}();
var ObserverInfo = function() {
  function ObserverInfo2(callback, observer) {
    this.callback = callback;
    this.observer = observer;
  }
  __name(ObserverInfo2, "ObserverInfo");
  return ObserverInfo2;
}();
function getMirror(obj) {
  return beforeDict.get(obj);
}
__name(getMirror, "getMirror");
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
__name(getObserverFromMirror, "getObserverFromMirror");
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
__name(removeObserverFromMirror, "removeObserverFromMirror");
function unobserve(root, observer) {
  observer.unobserve();
}
__name(unobserve, "unobserve");
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck =  __name(function() {
      generate2(observer);
    }, "dirtyCheck");
    var fastCheck =  __name(function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    }, "fastCheck");
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate2(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
__name(observe, "observe");
function generate2(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp = observer.patches;
  if (temp.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp);
    }
  }
  return temp;
}
__name(generate2, "generate");
function _generate(mirror, obj, patches, path, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key2 = oldKeys[t];
    var oldVal = mirror[key2];
    if (hasOwnProperty(obj, key2) && !(obj[key2] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key2];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key2), invertible);
      } else {
        if (oldVal !== newVal) {
          if (invertible) {
            patches.push({ op: "test", path: path + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path + "/" + escapePathComponent(key2), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path + "/" + escapePathComponent(key2) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path, value: mirror });
      }
      patches.push({ op: "replace", path, value: obj });
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key2 = newKeys[t];
    if (!hasOwnProperty(mirror, key2) && obj[key2] !== void 0) {
      patches.push({ op: "add", path: path + "/" + escapePathComponent(key2), value: _deepClone(obj[key2]) });
    }
  }
}
__name(_generate, "_generate");
function compare3(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}
__name(compare3, "compare");
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});
var import_lodash3 = __toESM(require_lodash(), 1);
var import_random3 = __toESM(require_random(), 1);
var SyncOptions;
(function(SyncOptions2) {
  SyncOptions2[SyncOptions2["PREFER_CACHE"] = 0] = "PREFER_CACHE";
  SyncOptions2[SyncOptions2["SYNC_ALWAYS"] = 1] = "SYNC_ALWAYS";
  SyncOptions2[SyncOptions2["NEVER_SYNC"] = 2] = "NEVER_SYNC";
})(SyncOptions || (SyncOptions = {}));
var import_lodash = __toESM(require_lodash(), 1);
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends: __extends2,
  __assign,
  __rest,
  __decorate: __decorate3,
  __param,
  __metadata: __metadata3,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet: __classPrivateFieldGet2,
  __classPrivateFieldSet: __classPrivateFieldSet2,
  __classPrivateFieldIn
} = import_tslib.default;
function isFunction(value) {
  return typeof value === "function";
}
__name(isFunction, "isFunction");
function createErrorClass(createImpl) {
  var _super =  __name(function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  }, "_super");
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
__name(createErrorClass, "createErrorClass");
var UnsubscriptionError = createErrorClass(function(_super) {
  return  __name(function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  }, "UnsubscriptionErrorImpl");
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
__name(arrRemove, "arrRemove");
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  __name(Subscription2, "Subscription");
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
__name(isSubscription, "isSubscription");
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
__name(execFinalizer, "execFinalizer");
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    return (clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
__name(reportUnhandledError, "reportUnhandledError");
function noop() {
}
__name(noop, "noop");
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
__name(errorNotification, "errorNotification");
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
__name(nextNotification, "nextNotification");
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
__name(createNotification, "createNotification");
function errorContext(cb) {
  {
    cb();
  }
}
__name(errorContext, "errorContext");
function captureError(err) {
}
__name(captureError, "captureError");
var Subscriber = function(_super) {
  __extends2(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  __name(Subscriber2, "Subscriber");
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) ; else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) ; else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) ; else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
__name(bind, "bind");
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  __name(ConsumerObserver2, "ConsumerObserver");
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends2(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  __name(SafeSubscriber2, "SafeSubscriber");
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
__name(handleUnhandledError, "handleUnhandledError");
function defaultErrorHandler(err) {
  throw err;
}
__name(defaultErrorHandler, "defaultErrorHandler");
function handleStoppedNotification(notification, subscriber) {
}
__name(handleStoppedNotification, "handleStoppedNotification");
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity3(x) {
  return x;
}
__name(identity3, "identity");
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity3;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return  __name(function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  }, "piped");
}
__name(pipeFromArray, "pipeFromArray");
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  __name(Observable2, "Observable");
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
__name(getPromiseCtor, "getPromiseCtor");
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
__name(isObserver, "isObserver");
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
__name(isSubscriber, "isSubscriber");
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
__name(hasLift, "hasLift");
function operate(init4) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init4(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
__name(operate, "operate");
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
__name(createOperatorSubscriber, "createOperatorSubscriber");
var OperatorSubscriber = function(_super) {
  __extends2(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  __name(OperatorSubscriber2, "OperatorSubscriber");
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return  __name(function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  }, "ObjectUnsubscribedErrorImpl");
});
var Subject = function(_super) {
  __extends2(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  __name(Subject2, "Subject");
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends2(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  __name(AnonymousSubject2, "AnonymousSubject");
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var BehaviorSubject = function(_super) {
  __extends2(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  __name(BehaviorSubject2, "BehaviorSubject");
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var dateTimestampProvider = {
  now: function() {
    return (Date).now();
  },
  delegate: void 0
};
var Action = function(_super) {
  __extends2(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  __name(Action2, "Action");
  Action2.prototype.schedule = function(state, delay) {
    return this;
  };
  return Action2;
}(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    return (clearInterval)(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends2(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  __name(AsyncAction2, "AsyncAction");
  AsyncAction2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    intervalProvider.clearInterval(id);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  __name(Scheduler2, "Scheduler");
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends2(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    _this._scheduled = void 0;
    return _this;
  }
  __name(AsyncScheduler2, "AsyncScheduler");
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
__name(isScheduler, "isScheduler");
function last(arr) {
  return arr[arr.length - 1];
}
__name(last, "last");
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
__name(popScheduler, "popScheduler");
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
__name(popNumber, "popNumber");
var isArrayLike =  __name(function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
}, "isArrayLike");
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
__name(isPromise, "isPromise");
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
__name(isInteropObservable, "isInteropObservable");
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
__name(isAsyncIterable, "isAsyncIterable");
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
__name(createInvalidObservableTypeError, "createInvalidObservableTypeError");
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
__name(getSymbolIterator, "getSymbolIterator");
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
__name(isIterable, "isIterable");
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments,  __name(function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  }, "readableStreamLikeToAsyncGenerator_1"));
}
__name(readableStreamLikeToAsyncGenerator, "readableStreamLikeToAsyncGenerator");
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
__name(isReadableStreamLike, "isReadableStreamLike");
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(innerFrom, "innerFrom");
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
__name(fromInteropObservable, "fromInteropObservable");
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
__name(fromArrayLike, "fromArrayLike");
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
__name(fromPromise, "fromPromise");
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
__name(fromIterable, "fromIterable");
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
__name(fromAsyncIterable, "fromAsyncIterable");
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
__name(fromReadableStreamLike, "fromReadableStreamLike");
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
__name(process2, "process");
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
__name(executeSchedule, "executeSchedule");
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
__name(observeOn, "observeOn");
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
__name(subscribeOn, "subscribeOn");
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(scheduleObservable, "scheduleObservable");
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(schedulePromise, "schedulePromise");
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
__name(scheduleArray, "scheduleArray");
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
__name(scheduleIterable, "scheduleIterable");
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
__name(scheduleAsyncIterable, "scheduleAsyncIterable");
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
__name(scheduleReadableStreamLike, "scheduleReadableStreamLike");
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(scheduled, "scheduled");
function from3(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
__name(from3, "from");
var EmptyError = createErrorClass(function(_super) {
  return  __name(function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  }, "EmptyErrorImpl");
});
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
__name(isValidDate, "isValidDate");
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
__name(map, "map");
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
__name(callOrApply, "callOrApply");
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
__name(mapOneOrManyArgs, "mapOneOrManyArgs");
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete =  __name(function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  }, "checkComplete");
  var outerNext =  __name(function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  }, "outerNext");
  var doInnerSub =  __name(function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 =  __name(function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          }, "_loop_1");
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  }, "doInnerSub");
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
__name(mergeInternals, "mergeInternals");
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
__name(mergeMap, "mergeMap");
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity3, concurrent);
}
__name(mergeAll, "mergeAll");
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add3 = _a[0], remove = _a[1];
  if (!add3) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add3) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler =  __name(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    }, "handler");
    add3(handler);
    return function() {
      return remove(handler);
    };
  });
}
__name(fromEvent, "fromEvent");
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
__name(toCommonHandlerRegistry, "toCommonHandlerRegistry");
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
__name(isNodeStyleEventEmitter, "isNodeStyleEventEmitter");
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
__name(isJQueryStyleEventEmitter, "isJQueryStyleEventEmitter");
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
__name(isEventTarget, "isEventTarget");
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
__name(timer, "timer");
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from3(sources, scheduler));
}
__name(merge, "merge");
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
__name(filter, "filter");
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
__name(defaultIfEmpty, "defaultIfEmpty");
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
__name(take, "take");
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
__name(throwIfEmpty, "throwIfEmpty");
function defaultErrorFactory() {
  return new EmptyError();
}
__name(defaultErrorFactory, "defaultErrorFactory");
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity3, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
__name(first, "first");
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return operate(function(source, subscriber) {
    var leading = config2.leading, trailing = config2.trailing;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling =  __name(function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    }, "endThrottling");
    var cleanupThrottling =  __name(function() {
      throttled = null;
      isComplete && subscriber.complete();
    }, "cleanupThrottling");
    var startThrottle =  __name(function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    }, "startThrottle");
    var send =  __name(function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    }, "send");
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
__name(throttle, "throttle");
var SignatureStatus;
(function(SignatureStatus2) {
  SignatureStatus2[SignatureStatus2["GENESIS"] = 0] = "GENESIS";
  SignatureStatus2[SignatureStatus2["PARTIAL"] = 1] = "PARTIAL";
  SignatureStatus2[SignatureStatus2["SIGNED"] = 2] = "SIGNED";
})(SignatureStatus || (SignatureStatus = {}));
var AnchorStatus;
(function(AnchorStatus2) {
  AnchorStatus2[AnchorStatus2["NOT_REQUESTED"] = 0] = "NOT_REQUESTED";
  AnchorStatus2[AnchorStatus2["PENDING"] = 1] = "PENDING";
  AnchorStatus2[AnchorStatus2["PROCESSING"] = 2] = "PROCESSING";
  AnchorStatus2[AnchorStatus2["ANCHORED"] = 3] = "ANCHORED";
  AnchorStatus2[AnchorStatus2["FAILED"] = 4] = "FAILED";
})(AnchorStatus || (AnchorStatus = {}));
var CommitType;
(function(CommitType2) {
  CommitType2[CommitType2["GENESIS"] = 0] = "GENESIS";
  CommitType2[CommitType2["SIGNED"] = 1] = "SIGNED";
  CommitType2[CommitType2["ANCHOR"] = 2] = "ANCHOR";
})(CommitType || (CommitType = {}));
var Stream = class extends Observable {
  constructor(state$, _context) {
    super((subscriber) => {
      state$.subscribe(subscriber);
    });
    this.state$ = state$;
    this._context = _context;
  }
  get id() {
    return new StreamID(this.state$.value.type, this.state$.value.log[0].cid);
  }
  get api() {
    return this._context.api;
  }
  get content() {
    var _a;
    const { next, content } = this.state$.value;
    return (0, import_lodash.default)((_a = next == null ? void 0 : next.content) != null ? _a : content);
  }
  get controllers() {
    return this.metadata.controllers;
  }
  get tip() {
    return this.state$.value.log[this.state$.value.log.length - 1].cid;
  }
  get commitId() {
    return CommitID.make(this.id, this.tip);
  }
  get allCommitIds() {
    return this.state$.value.log.map(({ cid }) => CommitID.make(this.id, cid));
  }
  get anchorCommitIds() {
    return this.state$.value.log.filter(({ type }) => type === CommitType.ANCHOR).map(({ cid }) => CommitID.make(this.id, cid));
  }
  get state() {
    return (0, import_lodash.default)(this.state$.value);
  }
  sync() {
    return __async(this, arguments, function* (opts = {}) {
      opts = __spreadValues({ sync: SyncOptions.PREFER_CACHE }, opts);
      const stream = yield this.api.loadStream(this.id, opts);
      this.state$.next(stream.state);
    });
  }
  requestAnchor() {
    return __async(this, null, function* () {
      return this.api.requestAnchor(this.id);
    });
  }
};
__name(Stream, "Stream");
function StreamStatic() {
  return (constructor) => {
  };
}
__name(StreamStatic, "StreamStatic");
var import_cross_fetch = __toESM(require_browser_ponyfill(), 1);
function mergeAbortSignals(signals) {
  const controller = new AbortController();
  if (signals.length === 0) {
    throw Error("Need abort signals to create a merged abort signal");
  }
  if (signals.some((signal) => signal.aborted)) {
    controller.abort();
    return controller.signal;
  }
  merge(...signals.map((signal) => fromEvent(signal, "abort"))).pipe(first()).subscribe(() => {
    controller.abort();
  });
  return controller.signal;
}
__name(mergeAbortSignals, "mergeAbortSignals");
var TimedAbortSignal = class {
  constructor(timeout) {
    const controller = new AbortController();
    this.signal = controller.signal;
    if (timeout <= 0) {
      controller.abort();
      return;
    }
    this._subscription = timer(timeout).subscribe(() => {
      controller.abort();
    });
  }
  clear() {
    var _a;
    (_a = this._subscription) == null ? void 0 : _a.unsubscribe();
  }
};
__name(TimedAbortSignal, "TimedAbortSignal");
function abortable2(original, fn) {
  return __async(this, null, function* () {
    const controller = new AbortController();
    const onAbort =  __name(() => {
      controller.abort();
    }, "onAbort");
    original.addEventListener("abort", onAbort);
    if (original.aborted)
      controller.abort();
    return fn(controller.signal).finally(() => {
      original.removeEventListener("abort", onAbort);
    });
  });
}
__name(abortable2, "abortable");
var DEFAULT_FETCH_TIMEOUT = 60 * 1e3 * 3;
function fetchJson(_0) {
  return __async(this, arguments, function* (url, opts = {}) {
    if (opts.body) {
      Object.assign(opts, {
        body: JSON.stringify(opts.body),
        headers: { "Content-Type": "application/json" }
      });
    }
    const timeoutLength = opts.timeout || DEFAULT_FETCH_TIMEOUT;
    const timedAbortSignal = new TimedAbortSignal(timeoutLength);
    const signal = opts.signal ? mergeAbortSignals([opts.signal, timedAbortSignal.signal]) : timedAbortSignal.signal;
    const res = yield abortable2(signal, (abortSignal) => {
      return (0, import_cross_fetch.default)(String(url), __spreadProps(__spreadValues({}, opts), { signal: abortSignal }));
    }).finally(() => timedAbortSignal.clear());
    if (!res.ok) {
      const text = yield res.text();
      throw new Error(`HTTP request to '${url}' failed with status '${res.statusText}': ${text}`);
    }
    return res.json();
  });
}
__name(fetchJson, "fetchJson");
var import_lodash2 = __toESM(require_lodash(), 1);
init_cid();
function toCID(givenCid) {
  const cid = CID.asCID(givenCid);
  if (cid) {
    return cid;
  }
  if (typeof givenCid === "string") {
    return CID.parse(givenCid);
  }
  if (givenCid instanceof Uint8Array) {
    return CID.decode(givenCid);
  }
  throw new Error(`${givenCid} cannot be converted to a CID`);
}
__name(toCID, "toCID");
var TILE_TYPE_ID = 0;
var StreamUtils = class {
  static streamIdFromState(state) {
    return new StreamID(state.type, state.log[0].cid);
  }
  static serializeCommit(commit) {
    var _a;
    const cloned = (0, import_lodash2.default)(commit);
    if (StreamUtils.isSignedCommitContainer(cloned)) {
      cloned.jws.link = cloned.jws.link.toString();
      cloned.linkedBlock = toString3(cloned.linkedBlock, "base64");
      if (cloned.cacaoBlock) {
        cloned.cacaoBlock = toString3(cloned.cacaoBlock, "base64");
      }
      return cloned;
    }
    if (StreamUtils.isSignedCommit(commit)) {
      cloned.link = cloned.link.toString();
    }
    if (StreamUtils.isAnchorCommit(commit)) {
      cloned.proof = cloned.proof.toString();
    }
    if (cloned.id) {
      cloned.id = cloned.id.toString();
    }
    if (cloned.prev) {
      cloned.prev = cloned.prev.toString();
    }
    if ((_a = commit.header) == null ? void 0 : _a.model) {
      cloned.header.model = commit.header.model.toString();
    }
    return cloned;
  }
  static deserializeCommit(commit) {
    var _a;
    const cloned = (0, import_lodash2.default)(commit);
    if (StreamUtils.isSignedCommitContainer(cloned)) {
      cloned.jws.link = toCID(cloned.jws.link);
      cloned.linkedBlock = fromString2(cloned.linkedBlock, "base64");
      if (cloned.cacaoBlock) {
        cloned.cacaoBlock = fromString2(cloned.cacaoBlock, "base64");
      }
      return cloned;
    }
    if (StreamUtils.isSignedCommit(cloned)) {
      cloned.link = toCID(cloned.link);
    }
    if (StreamUtils.isAnchorCommit(cloned)) {
      cloned.proof = toCID(cloned.proof);
    }
    if (cloned.id) {
      cloned.id = toCID(cloned.id);
    }
    if (cloned.prev) {
      cloned.prev = toCID(cloned.prev);
    }
    if ((_a = cloned.header) == null ? void 0 : _a.model) {
      cloned.header.model = StreamID.fromString(cloned.header.model);
    }
    return cloned;
  }
  static serializeState(state) {
    var _a, _b, _c, _d;
    const cloned = (0, import_lodash2.default)(state);
    cloned.log = cloned.log.map((entry) => __spreadProps(__spreadValues({}, entry), { cid: entry.cid.toString() }));
    if (cloned.anchorStatus != null) {
      cloned.anchorStatus = AnchorStatus[cloned.anchorStatus];
    }
    if (cloned.anchorScheduledFor != null) {
      cloned.anchorScheduledFor = new Date(cloned.anchorScheduledFor).toISOString();
    }
    if (cloned.anchorProof != null) {
      cloned.anchorProof.txHash = cloned.anchorProof.txHash.toString();
      cloned.anchorProof.root = cloned.anchorProof.root.toString();
    }
    if ((_a = state.metadata) == null ? void 0 : _a.model) {
      cloned.metadata.model = state.metadata.model.toString();
    }
    if ((_c = (_b = state.next) == null ? void 0 : _b.metadata) == null ? void 0 : _c.model) {
      cloned.next.metadata.model = state.next.metadata.model.toString();
    }
    if (((_d = state.metadata) == null ? void 0 : _d.unique) && state.type != TILE_TYPE_ID) {
      cloned.metadata.unique = toString3(cloned.metadata.unique, "base64");
    }
    cloned.doctype = StreamType.nameByCode(cloned.type);
    return cloned;
  }
  static deserializeState(state) {
    var _a, _b, _c, _d;
    const cloned = (0, import_lodash2.default)(state);
    if (cloned.doctype) {
      cloned.type = StreamType.codeByName(cloned.doctype);
      delete cloned.doctype;
    }
    cloned.log = cloned.log.map((entry) => __spreadProps(__spreadValues({}, entry), { cid: toCID(entry.cid) }));
    if (cloned.anchorProof) {
      cloned.anchorProof.txHash = toCID(cloned.anchorProof.txHash);
      cloned.anchorProof.root = toCID(cloned.anchorProof.root);
    }
    let showScheduledFor = true;
    if (cloned.anchorStatus) {
      cloned.anchorStatus = AnchorStatus[cloned.anchorStatus];
      showScheduledFor = cloned.anchorStatus !== AnchorStatus.FAILED && cloned.anchorStatus !== AnchorStatus.ANCHORED;
    }
    if (cloned.anchorScheduledFor) {
      if (showScheduledFor) {
        cloned.anchorScheduledFor = Date.parse(cloned.anchorScheduledFor);
      } else {
        delete cloned.anchorScheduledFor;
      }
    }
    if ((_a = state.metadata) == null ? void 0 : _a.model) {
      cloned.metadata.model = StreamID.fromString(state.metadata.model);
    }
    if ((_c = (_b = state.next) == null ? void 0 : _b.metadata) == null ? void 0 : _c.model) {
      cloned.next.metadata.model = StreamID.fromString(state.next.metadata.model);
    }
    if (((_d = state.metadata) == null ? void 0 : _d.unique) && state.type != TILE_TYPE_ID) {
      cloned.metadata.unique = fromString2(state.metadata.unique, "base64");
    }
    return cloned;
  }
  static statesEqual(state1, state2) {
    return JSON.stringify(StreamUtils.serializeState(state1)) === JSON.stringify(StreamUtils.serializeState(state2));
  }
  static isStateSupersetOf(state, base4) {
    if (state.log.length < base4.log.length) {
      return false;
    }
    for (const i in base4.log) {
      if (!state.log[i].cid.equals(base4.log[i].cid)) {
        return false;
      }
    }
    if (state.anchorStatus != base4.anchorStatus) {
      return false;
    }
    return true;
  }
  static assertCommitLinksToState(state, commit) {
    const streamId = this.streamIdFromState(state);
    if (commit.id && !commit.id.equals(state.log[0].cid)) {
      throw new Error(`Invalid genesis CID in commit for StreamID ${streamId.toString()}. Found: ${commit.id}, expected ${state.log[0].cid}`);
    }
    const expectedPrev = state.log[state.log.length - 1].cid;
    if (!commit.prev.equals(expectedPrev)) {
      throw new Error(`Commit doesn't properly point to previous commit in log. Expected ${expectedPrev}, found 'prev' ${commit.prev}`);
    }
  }
  static convertCommitToSignedCommitContainer(commit, ipfs) {
    return __async(this, null, function* () {
      if (StreamUtils.isSignedCommit(commit)) {
        const block = yield ipfs.block.get(commit.link);
        return {
          jws: commit,
          linkedBlock: block
        };
      }
      return commit;
    });
  }
  static isSignedCommitContainer(commit) {
    return commit && commit.jws !== void 0;
  }
  static isSignedCommit(commit) {
    return commit && commit.link !== void 0;
  }
  static isAnchorCommit(commit) {
    return commit && commit.proof !== void 0;
  }
  static isSignedCommitData(commitData) {
    return commitData && commitData.envelope !== void 0;
  }
  static isAnchorCommitData(commitData) {
    return commitData && commitData.proof !== void 0;
  }
};
__name(StreamUtils, "StreamUtils");
function normalizeAccountId(accountId) {
  if (typeof accountId === "string" && accountId.includes("@")) {
    const [address, chainId] = accountId.split("@");
    if (!address || !chainId) {
      throw new Error(`Invalid accountId provided`);
    }
    return new AccountId({ address, chainId });
  }
  return new AccountId(accountId);
}
__name(normalizeAccountId, "normalizeAccountId");
var StreamStateSubject = class extends BehaviorSubject {
  next(next) {
    const current = this.value;
    if (!StreamUtils.statesEqual(current, next)) {
      super.next(next);
    }
  }
};
__name(StreamStateSubject, "StreamStateSubject");
var __decorate4 = function(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
};
var TileDocument_1;
var DEFAULT_CREATE_OPTS = {
  anchor: true,
  publish: true,
  pin: true,
  sync: SyncOptions.PREFER_CACHE
};
var DEFAULT_LOAD_OPTS = { sync: SyncOptions.PREFER_CACHE };
var DEFAULT_UPDATE_OPTS = { anchor: true, publish: true, throwOnInvalidCommit: true };
function headerFromMetadata(metadata, genesis) {
  var _a;
  if (typeof (metadata == null ? void 0 : metadata.schema) === "string") {
    try {
      CommitID.fromString(metadata.schema);
    } catch (e) {
      throw new Error("Schema must be a CommitID");
    }
  }
  const header = {
    controllers: metadata == null ? void 0 : metadata.controllers,
    family: metadata == null ? void 0 : metadata.family,
    schema: (_a = metadata == null ? void 0 : metadata.schema) == null ? void 0 : _a.toString(),
    tags: metadata == null ? void 0 : metadata.tags
  };
  if (genesis) {
    if (!(metadata == null ? void 0 : metadata.deterministic)) {
      header.unique = toString3((0, import_random3.randomBytes)(12), "base64");
    }
    if (metadata == null ? void 0 : metadata.forbidControllerChange) {
      header.forbidControllerChange = true;
    }
  } else {
    if ((metadata == null ? void 0 : metadata.deterministic) !== void 0 || (metadata == null ? void 0 : metadata.unique) !== void 0) {
      throw new Error("Cannot change 'deterministic' or 'unique' properties on existing Streams");
    }
    if ((metadata == null ? void 0 : metadata.forbidControllerChange) !== void 0) {
      throw new Error("Cannot change 'forbidControllerChange' property on existing Streams");
    }
  }
  Object.keys(header).forEach((key2) => header[key2] === void 0 && delete header[key2]);
  return header;
}
__name(headerFromMetadata, "headerFromMetadata");
function _ensureAuthenticated(signer) {
  return __async(this, null, function* () {
    if (signer.did == null) {
      throw new Error("No DID provided");
    }
    if (!signer.did.authenticated) {
      yield signer.did.authenticate();
      if (signer.loggerProvider) {
        signer.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${signer.did.id}`);
      }
    }
  });
}
__name(_ensureAuthenticated, "_ensureAuthenticated");
function throwReadOnlyError() {
  return __async(this, null, function* () {
    throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
  });
}
__name(throwReadOnlyError, "throwReadOnlyError");
var TileDocument = TileDocument_1 =  __name(class TileDocument2 extends Stream {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get content() {
    return super.content;
  }
  get metadata() {
    var _a;
    const { next, metadata } = this.state$.value;
    return (0, import_lodash3.default)((_a = next == null ? void 0 : next.metadata) != null ? _a : metadata);
  }
  static create(_0, _1, _2) {
    return __async(this, arguments, function* (ceramic, content, metadata, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_CREATE_OPTS), opts);
      if (!(metadata == null ? void 0 : metadata.deterministic) && opts.syncTimeoutSeconds == void 0) {
        opts.syncTimeoutSeconds = 0;
      }
      const signer = opts.asDID ? { did: opts.asDID } : ceramic;
      const commit = yield TileDocument_1.makeGenesis(signer, content, metadata);
      return ceramic.createStreamFromGenesis(TileDocument_1.STREAM_TYPE_ID, commit, opts);
    });
  }
  static createFromGenesis(_0, _1) {
    return __async(this, arguments, function* (ceramic, genesisCommit, opts = {}) {
      var _a;
      opts = __spreadValues(__spreadValues({}, DEFAULT_CREATE_OPTS), opts);
      if (((_a = genesisCommit.header) == null ? void 0 : _a.unique) && opts.syncTimeoutSeconds == void 0) {
        opts.syncTimeoutSeconds = 0;
      }
      const commit = genesisCommit.data ? yield TileDocument_1._signDagJWS(ceramic, genesisCommit) : genesisCommit;
      return ceramic.createStreamFromGenesis(TileDocument_1.STREAM_TYPE_ID, commit, opts);
    });
  }
  static deterministic(_0, _1) {
    return __async(this, arguments, function* (ceramic, metadata, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_CREATE_OPTS), opts);
      metadata = __spreadProps(__spreadValues({}, metadata), { deterministic: true });
      if (metadata.family == null && metadata.tags == null) {
        throw new Error("Family and/or tags are required when creating a deterministic tile document");
      }
      const commit = yield TileDocument_1.makeGenesis(ceramic, null, metadata);
      return ceramic.createStreamFromGenesis(TileDocument_1.STREAM_TYPE_ID, commit, opts);
    });
  }
  static load(_0, _1) {
    return __async(this, arguments, function* (ceramic, streamId, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_LOAD_OPTS), opts);
      const streamRef = StreamRef.from(streamId);
      if (streamRef.type != TileDocument_1.STREAM_TYPE_ID) {
        throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${TileDocument_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
      }
      return ceramic.loadStream(streamRef, opts);
    });
  }
  update(_0, _1) {
    return __async(this, arguments, function* (content, metadata, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_UPDATE_OPTS), opts);
      const signer = opts.asDID ? { did: opts.asDID } : this.api;
      const updateCommit = yield this.makeCommit(signer, content, metadata);
      const updated = yield this.api.applyCommit(this.id, updateCommit, opts);
      this.state$.next(updated.state);
    });
  }
  patch(_0) {
    return __async(this, arguments, function* (jsonPatch, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_UPDATE_OPTS), opts);
      const header = headerFromMetadata(this.metadata, false);
      const rawCommit = {
        header,
        data: jsonPatch,
        prev: this.tip,
        id: this.id.cid
      };
      const commit = yield TileDocument_1._signDagJWS(this.api, rawCommit);
      const updated = yield this.api.applyCommit(this.id, commit, opts);
      this.state$.next(updated.state);
    });
  }
  makeReadOnly() {
    this.update = throwReadOnlyError;
    this.patch = throwReadOnlyError;
    this.sync = throwReadOnlyError;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
  makeCommit(signer, newContent, newMetadata) {
    return __async(this, null, function* () {
      const commit = yield this._makeRawCommit(signer, newContent, newMetadata);
      return TileDocument_1._signDagJWS(signer, commit);
    });
  }
  _makeRawCommit(signer, newContent, newMetadata) {
    return __async(this, null, function* () {
      const header = headerFromMetadata(newMetadata, false);
      if (newContent == null) {
        newContent = this.content;
      }
      if (header.controllers) {
        if (header.controllers.length !== 1) {
          throw new Error("Exactly one controller must be specified");
        }
        if (!header.controllers[0]) {
          throw new Error("Controller cannot be updated to an undefined value.");
        }
      }
      const patch = fast_json_patch_default.compare(this.content, newContent);
      const commit = {
        header,
        data: patch,
        prev: this.tip,
        id: this.state.log[0].cid
      };
      return commit;
    });
  }
  static makeGenesis(signer, content, metadata) {
    return __async(this, null, function* () {
      var _a;
      if (!metadata) {
        metadata = {};
      }
      if (!metadata.controllers || metadata.controllers.length === 0) {
        if (signer.did) {
          yield _ensureAuthenticated(signer);
          metadata.controllers = [signer.did.hasParent ? signer.did.parent : signer.did.id];
        } else {
          throw new Error("No controllers specified");
        }
      }
      if (((_a = metadata.controllers) == null ? void 0 : _a.length) !== 1) {
        throw new Error("Exactly one controller must be specified");
      }
      const header = headerFromMetadata(metadata, true);
      if ((metadata == null ? void 0 : metadata.deterministic) && content) {
        throw new Error("Initial content must be null when creating a deterministic Tile document");
      }
      if (content == null) {
        const result = { header };
        encode9(result);
        return result;
      }
      const commit = { data: content, header };
      return TileDocument_1._signDagJWS(signer, commit);
    });
  }
  static _signDagJWS(signer, commit) {
    return __async(this, null, function* () {
      yield _ensureAuthenticated(signer);
      return signer.did.createDagJWS(commit);
    });
  }
}, "TileDocument");
TileDocument.STREAM_TYPE_NAME = "tile";
TileDocument.STREAM_TYPE_ID = 0;
TileDocument = TileDocument_1 = __decorate4([
  StreamStatic()
], TileDocument);
var import_dataloader = __toESM(require_dataloader(), 1);
function _checkPrivateRedeclaration2(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration2, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet2(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet2, "_classApplyDescriptorGet");
function _classApplyDescriptorSet2(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet2, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor2(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor2, "_classExtractFieldDescriptor");
function _classPrivateFieldGet2(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
  return _classApplyDescriptorGet2(receiver, descriptor);
}
__name(_classPrivateFieldGet2, "_classPrivateFieldGet");
function _classPrivateFieldInit2(obj, privateMap, value) {
  _checkPrivateRedeclaration2(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit2, "_classPrivateFieldInit");
function _classPrivateFieldSet2(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
  _classApplyDescriptorSet2(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet2, "_classPrivateFieldSet");
function keyToQuery(key2) {
  return typeof key2 === "string" || CommitID.isInstance(key2) || StreamID.isInstance(key2) ? {
    streamId: key2
  } : {
    streamId: key2.streamId,
    genesis: key2.genesis
  };
}
__name(keyToQuery, "keyToQuery");
function keyToString(key2) {
  if (typeof key2 === "string") {
    return StreamRef.from(key2).toString();
  }
  if (CommitID.isInstance(key2) || StreamID.isInstance(key2)) {
    return key2.toString();
  }
  return key2.streamId.toString();
}
__name(keyToString, "keyToString");
function getDeterministicQuery(metadata) {
  return __async(this, null, function* () {
    const genesis = yield TileDocument.makeGenesis({}, null, __spreadProps(__spreadValues({}, metadata), {
      deterministic: true
    }));
    const streamId = yield StreamID.fromGenesis("tile", genesis);
    return {
      genesis,
      streamId
    };
  });
}
__name(getDeterministicQuery, "getDeterministicQuery");
var tempBatchLoadFn =  __name(() => Promise.resolve([]), "tempBatchLoadFn");
var _ceramic =  new WeakMap();
var _useCache =  new WeakMap();
var TileLoader = class extends import_dataloader.default {
  cache(stream) {
    if (!_classPrivateFieldGet2(this, _useCache)) {
      return false;
    }
    const id = stream.id.toString();
    this.clear(id).prime(id, stream);
    return true;
  }
  create(content, metadata, options) {
    return __async(this, null, function* () {
      const stream = yield TileDocument.create(_classPrivateFieldGet2(this, _ceramic), content, metadata, options);
      this.cache(stream);
      return stream;
    });
  }
  deterministic(metadata, options) {
    return __async(this, null, function* () {
      const query = yield getDeterministicQuery(metadata);
      try {
        return yield __superGet(TileLoader.prototype, this, "load").call(this, query);
      } catch (err) {
        const stream = yield TileDocument.createFromGenesis(_classPrivateFieldGet2(this, _ceramic), query.genesis, options);
        this.cache(stream);
        return stream;
      }
    });
  }
  load(key2) {
    return __async(this, null, function* () {
      return yield __superGet(TileLoader.prototype, this, "load").call(this, key2);
    });
  }
  update(streamID, content, metadata, options) {
    return __async(this, null, function* () {
      const id = keyToString(streamID);
      this.clear(id);
      const stream = yield this.load({
        streamId: id
      });
      yield stream.update(content, metadata, options);
      return stream;
    });
  }
  constructor(params) {
    super(tempBatchLoadFn, {
      cache: true,
      cacheKeyFn: keyToString,
      cacheMap: params.cache != null && typeof params.cache !== "boolean" ? params.cache : void 0
    });
    _classPrivateFieldInit2(this, _ceramic, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit2(this, _useCache, {
      writable: true,
      value: void 0
    });
    this._batchLoadFn = (keys) => __async(this, null, function* () {
      if (!params.cache) {
        this.clearAll();
      }
      const results = yield params.ceramic.multiQuery(keys.map(keyToQuery), params.multiqueryTimeout);
      return keys.map((key2) => {
        const id = keyToString(key2);
        const doc = results[id];
        return doc ? doc : new Error(`Failed to load stream: ${id}`);
      });
    });
    _classPrivateFieldSet2(this, _ceramic, params.ceramic);
    _classPrivateFieldSet2(this, _useCache, !!params.cache);
  }
};
__name(TileLoader, "TileLoader");
function _checkPrivateRedeclaration3(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration3, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet3(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet3, "_classApplyDescriptorGet");
function _classApplyDescriptorSet3(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet3, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor3(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor3, "_classExtractFieldDescriptor");
function _classPrivateFieldGet3(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "get");
  return _classApplyDescriptorGet3(receiver, descriptor);
}
__name(_classPrivateFieldGet3, "_classPrivateFieldGet");
function _classPrivateFieldInit3(obj, privateMap, value) {
  _checkPrivateRedeclaration3(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit3, "_classPrivateFieldInit");
function _classPrivateFieldSet3(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "set");
  _classApplyDescriptorSet3(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet3, "_classPrivateFieldSet");
var _aliases =  new WeakMap();
var _loader =  new WeakMap();
var DataModel = class {
  get aliases() {
    return _classPrivateFieldGet3(this, _aliases);
  }
  get loader() {
    return _classPrivateFieldGet3(this, _loader);
  }
  getDefinitionID(alias) {
    var _a;
    return (_a = _classPrivateFieldGet3(this, _aliases).definitions[alias]) != null ? _a : null;
  }
  getSchemaURL(alias) {
    var _a;
    return (_a = _classPrivateFieldGet3(this, _aliases).schemas[alias]) != null ? _a : null;
  }
  getTileID(alias) {
    var _a;
    return (_a = _classPrivateFieldGet3(this, _aliases).tiles[alias]) != null ? _a : null;
  }
  loadTile(alias) {
    return __async(this, null, function* () {
      const id = this.getTileID(alias);
      if (id == null) {
        throw new Error(`Tile alias "${alias}" is not defined`);
      }
      return yield _classPrivateFieldGet3(this, _loader).load(id);
    });
  }
  createTile(_0, _1) {
    return __async(this, arguments, function* (schemaAlias, content, options = {}) {
      const schema = this.getSchemaURL(schemaAlias);
      if (schema == null) {
        throw new Error(`Schema alias "${schemaAlias}" is not defined`);
      }
      const _a = options, { controller } = _a, opts = __objRest(_a, ["controller"]);
      const metadata = {
        schema
      };
      if (controller != null) {
        metadata.controllers = [
          controller
        ];
      }
      return yield _classPrivateFieldGet3(this, _loader).create(content, metadata, opts);
    });
  }
  constructor(params) {
    _classPrivateFieldInit3(this, _aliases, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit3(this, _loader, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet3(this, _aliases, params.aliases);
    if (params.loader != null) {
      _classPrivateFieldSet3(this, _loader, params.loader);
    } else if (params.ceramic == null) {
      throw new Error("Invalid DataModel parameters: missing ceramic or loader");
    } else {
      _classPrivateFieldSet3(this, _loader, new TileLoader({
        ceramic: params.ceramic,
        cache: params.cache
      }));
    }
  }
};
__name(DataModel, "DataModel");
function _checkPrivateRedeclaration4(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration4, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet4(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet4, "_classApplyDescriptorGet");
function _classApplyDescriptorSet4(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet4, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor4(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor4, "_classExtractFieldDescriptor");
function _classPrivateFieldGet4(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "get");
  return _classApplyDescriptorGet4(receiver, descriptor);
}
__name(_classPrivateFieldGet4, "_classPrivateFieldGet");
function _classPrivateFieldInit4(obj, privateMap, value) {
  _checkPrivateRedeclaration4(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit4, "_classPrivateFieldInit");
function _classPrivateFieldSet4(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "set");
  _classApplyDescriptorSet4(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet4, "_classPrivateFieldSet");
var _getRemote =  new WeakMap();
var _queue =  new WeakMap();
var _promiseValue =  new WeakMap();
var _deferValue =  new WeakMap();
var TileProxy = class {
  _createValuePromise() {
    _classPrivateFieldSet4(this, _promiseValue, new Promise((resolve, reject) => {
      _classPrivateFieldSet4(this, _deferValue, {
        resolve,
        reject
      });
    }));
  }
  change(mutation) {
    return new Promise((resolve, reject) => {
      const run =  __name((current) => __async(this, null, function* () {
        try {
          const next = yield mutation(current);
          resolve();
          this._next(next);
        } catch (err) {
          reject(err);
          this._next(current);
        }
      }), "run");
      _classPrivateFieldGet4(this, _queue).push({
        reject,
        run
      });
      if (_classPrivateFieldGet4(this, _queue).length === 1) {
        void this._start();
      }
    });
  }
  changeContent(change) {
    return __async(this, null, function* () {
      const mutation =  __name((doc) => __async(this, null, function* () {
        yield doc.update(change(doc.content), doc.metadata);
        return doc;
      }), "mutation");
      return yield this.change(mutation);
    });
  }
  get() {
    return __async(this, null, function* () {
      return _classPrivateFieldGet4(this, _queue).length === 0 ? yield _classPrivateFieldGet4(this, _getRemote).call(this) : yield _classPrivateFieldGet4(this, _promiseValue);
    });
  }
  _start() {
    return __async(this, null, function* () {
      try {
        const value = yield _classPrivateFieldGet4(this, _getRemote).call(this);
        this._next(value);
      } catch (err) {
        _classPrivateFieldGet4(this, _queue).forEach((item) => {
          item.reject(err);
        });
        _classPrivateFieldSet4(this, _queue, []);
        _classPrivateFieldGet4(this, _deferValue).reject(err);
        this._createValuePromise();
      }
    });
  }
  _next(value) {
    const item = _classPrivateFieldGet4(this, _queue).shift();
    if (item == null) {
      this._end(value);
    } else {
      void item.run(value);
    }
  }
  _end(value) {
    _classPrivateFieldGet4(this, _deferValue).resolve(value);
    this._createValuePromise();
  }
  constructor(getRemote) {
    _classPrivateFieldInit4(this, _getRemote, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit4(this, _queue, {
      writable: true,
      value: []
    });
    _classPrivateFieldInit4(this, _promiseValue, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit4(this, _deferValue, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet4(this, _getRemote, getRemote);
    this._createValuePromise();
  }
};
__name(TileProxy, "TileProxy");
var didRegex = /^did:([A-Za-z0-9]+):([A-Za-z0-9.\-:_]+)$/;
function isDIDstring(did) {
  return didRegex.test(did);
}
__name(isDIDstring, "isDIDstring");
function assertDIDstring(did) {
  if (!isDIDstring(did)) {
    throw new Error(`Invalid DID: ${did}`);
  }
}
__name(assertDIDstring, "assertDIDstring");
function getIDXMetadata(did) {
  assertDIDstring(did);
  return {
    controllers: [
      did
    ],
    family: "IDX"
  };
}
__name(getIDXMetadata, "getIDXMetadata");
function _checkPrivateRedeclaration5(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
__name(_checkPrivateRedeclaration5, "_checkPrivateRedeclaration");
function _classApplyDescriptorGet5(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
__name(_classApplyDescriptorGet5, "_classApplyDescriptorGet");
function _classApplyDescriptorSet5(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
__name(_classApplyDescriptorSet5, "_classApplyDescriptorSet");
function _classExtractFieldDescriptor5(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
__name(_classExtractFieldDescriptor5, "_classExtractFieldDescriptor");
function _classPrivateFieldGet5(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "get");
  return _classApplyDescriptorGet5(receiver, descriptor);
}
__name(_classPrivateFieldGet5, "_classPrivateFieldGet");
function _classPrivateFieldInit5(obj, privateMap, value) {
  _checkPrivateRedeclaration5(obj, privateMap);
  privateMap.set(obj, value);
}
__name(_classPrivateFieldInit5, "_classPrivateFieldInit");
function _classPrivateFieldSet5(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "set");
  _classApplyDescriptorSet5(receiver, descriptor, value);
  return value;
}
__name(_classPrivateFieldSet5, "_classPrivateFieldSet");
var _ceramic2 =  new WeakMap();
var _id =  new WeakMap();
var _indexProxies =  new WeakMap();
var _loader2 =  new WeakMap();
var _model =  new WeakMap();
var DIDDataStore = class {
  get authenticated() {
    return _classPrivateFieldGet5(this, _ceramic2).did != null;
  }
  get ceramic() {
    return _classPrivateFieldGet5(this, _ceramic2);
  }
  get id() {
    if (_classPrivateFieldGet5(this, _id) != null) {
      return _classPrivateFieldGet5(this, _id);
    }
    if (_classPrivateFieldGet5(this, _ceramic2).did == null) {
      throw new Error("Ceramic instance is not authenticated");
    }
    return _classPrivateFieldGet5(this, _ceramic2).did.hasParent ? _classPrivateFieldGet5(this, _ceramic2).did.parent : _classPrivateFieldGet5(this, _ceramic2).did.id;
  }
  get loader() {
    return _classPrivateFieldGet5(this, _loader2);
  }
  get model() {
    return _classPrivateFieldGet5(this, _model);
  }
  has(key2, did) {
    return __async(this, null, function* () {
      const definitionID = this.getDefinitionID(key2);
      const ref = yield this.getRecordID(definitionID, did);
      return ref != null;
    });
  }
  get(key2, did) {
    return __async(this, null, function* () {
      const definitionID = this.getDefinitionID(key2);
      return yield this.getRecord(definitionID, did);
    });
  }
  getMultiple(key2, dids) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const definitionID = this.getDefinitionID(key2);
      const queries = yield Promise.all(dids.map((did) => __async(this, null, function* () {
        const { genesis, streamId } = yield getDeterministicQuery(getIDXMetadata(did));
        return {
          genesis,
          streamId: streamId.toString(),
          paths: [
            definitionID
          ]
        };
      })));
      const streams = yield _classPrivateFieldGet5(this, _ceramic2).multiQuery(queries);
      const results = [];
      for (const query of queries) {
        const recordURL = (_b = (_a = streams[query.streamId]) == null ? void 0 : _a.content) == null ? void 0 : _b[definitionID];
        const record = recordURL ? streams[StreamID.fromString(recordURL).toString()] : null;
        results.push((_c = record == null ? void 0 : record.content) != null ? _c : null);
      }
      return results;
    });
  }
  set(_0, _1) {
    return __async(this, arguments, function* (key2, content, options = {}) {
      var _a;
      const definitionID = this.getDefinitionID(key2);
      const [created, id] = yield this._setRecordOnly(definitionID, content, options);
      if (created) {
        yield this._setReference((_a = options.controller) != null ? _a : this.id, definitionID, id);
      }
      return id;
    });
  }
  merge(_0, _1) {
    return __async(this, arguments, function* (key2, content, options = {}) {
      const definitionID = this.getDefinitionID(key2);
      const existing = yield this.getRecord(definitionID);
      const newContent = existing ? __spreadValues(__spreadValues({}, existing), content) : content;
      return yield this.setRecord(definitionID, newContent, options);
    });
  }
  setAll(_0) {
    return __async(this, arguments, function* (contents, options = {}) {
      var _a;
      const updates = Object.entries(contents).map((_02) => __async(this, [_02], function* ([alias, content]) {
        const definitionID = this.getDefinitionID(alias);
        const [created, id] = yield this._setRecordOnly(definitionID, content, options);
        return [
          created,
          definitionID,
          id
        ];
      }));
      const changes = yield Promise.all(updates);
      const newReferences = changes.reduce((acc, [created, key2, id]) => {
        if (created) {
          acc[key2] = id.toUrl();
        }
        return acc;
      }, {});
      yield this._setReferences((_a = options.controller) != null ? _a : this.id, newReferences);
      return newReferences;
    });
  }
  setDefaults(_0) {
    return __async(this, arguments, function* (contents, options = {}) {
      var _a, _b;
      const index = (_a = yield this.getIndex()) != null ? _a : {};
      const updates = Object.entries(contents).map(([alias, content]) => [
        this.getDefinitionID(alias),
        content
      ]).filter((entry) => index[entry[0]] == null).map((_02) => __async(this, [_02], function* ([key2, content]) {
        const definition = yield this.getDefinition(key2);
        const id = yield this._createRecord(definition, content, options);
        return {
          [key2]: id.toUrl()
        };
      }));
      const changes = yield Promise.all(updates);
      const newReferences = changes.reduce((acc, keyToID) => {
        return Object.assign(acc, keyToID);
      }, {});
      yield this._setReferences((_b = options.controller) != null ? _b : this.id, newReferences);
      return newReferences;
    });
  }
  remove(_0) {
    return __async(this, arguments, function* (key2, controller = this.id) {
      yield this._getIndexProxy(controller).changeContent((index) => {
        if (index != null) {
          delete index[this.getDefinitionID(key2)];
        }
        return index;
      });
    });
  }
  getIndex() {
    return __async(this, arguments, function* (did = this.id) {
      const rootDoc = this.authenticated && did === this.id ? yield this._getIndexProxy(did).get() : yield this._getIDXDoc(did);
      return rootDoc ? rootDoc.content : null;
    });
  }
  iterator(did) {
    let list;
    let cursor = 0;
    return {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: () => __async(this, null, function* () {
        if (list == null) {
          const index = yield this.getIndex(did);
          list = Object.entries(index != null ? index : {});
        }
        if (cursor === list.length) {
          return {
            done: true,
            value: null
          };
        }
        const [key2, id] = list[cursor++];
        const doc = yield _classPrivateFieldGet5(this, _loader2).load(id);
        return {
          done: false,
          value: {
            key: key2,
            id,
            record: doc.content
          }
        };
      })
    };
  }
  _createIDXDoc(controller) {
    return __async(this, null, function* () {
      return yield _classPrivateFieldGet5(this, _loader2).deterministic(getIDXMetadata(controller));
    });
  }
  _getIDXDoc(did) {
    return __async(this, null, function* () {
      const doc = yield this._createIDXDoc(did);
      if (doc.content == null || doc.metadata.schema == null) {
        return null;
      }
      if (doc.metadata.schema !== CIP11_INDEX_SCHEMA_URL) {
        throw new Error("Invalid document: schema is not IdentityIndex");
      }
      return doc;
    });
  }
  _getOwnIDXDoc(did) {
    return __async(this, null, function* () {
      const doc = yield this._createIDXDoc(did);
      if (doc.content == null || doc.metadata.schema == null) {
        yield doc.update({}, {
          schema: CIP11_INDEX_SCHEMA_URL
        });
      } else if (doc.metadata.schema !== CIP11_INDEX_SCHEMA_URL) {
        throw new Error("Invalid document: schema is not IdentityIndex");
      }
      return doc;
    });
  }
  _getIndexProxy(controller) {
    let proxy = _classPrivateFieldGet5(this, _indexProxies)[controller];
    if (proxy == null) {
      proxy = new TileProxy(() => __async(this, null, function* () {
        return yield this._getOwnIDXDoc(controller);
      }));
      _classPrivateFieldGet5(this, _indexProxies)[controller] = proxy;
    }
    return proxy;
  }
  getDefinitionID(aliasOrID) {
    var _a;
    return (_a = _classPrivateFieldGet5(this, _model).getDefinitionID(aliasOrID)) != null ? _a : aliasOrID;
  }
  getDefinition(id) {
    return __async(this, null, function* () {
      const doc = yield _classPrivateFieldGet5(this, _loader2).load(id);
      if (doc.metadata.schema !== CIP11_DEFINITION_SCHEMA_URL) {
        throw new Error("Invalid document: schema is not Definition");
      }
      return __spreadProps(__spreadValues({}, doc.content), {
        id: doc.id
      });
    });
  }
  getRecordID(definitionID, did) {
    return __async(this, null, function* () {
      var _a;
      const index = yield this.getIndex(did != null ? did : this.id);
      return (_a = index == null ? void 0 : index[definitionID]) != null ? _a : null;
    });
  }
  getRecordDocument(definitionID, did) {
    return __async(this, null, function* () {
      const id = yield this.getRecordID(definitionID, did);
      return id ? yield _classPrivateFieldGet5(this, _loader2).load(id) : null;
    });
  }
  getRecord(definitionID, did) {
    return __async(this, null, function* () {
      const doc = yield this.getRecordDocument(definitionID, did);
      return doc ? doc.content : null;
    });
  }
  setRecord(_0, _1) {
    return __async(this, arguments, function* (definitionID, content, options = {}) {
      var _a;
      const [created, id] = yield this._setRecordOnly(definitionID, content, options);
      if (created) {
        yield this._setReference((_a = options.controller) != null ? _a : this.id, definitionID, id);
      }
      return id;
    });
  }
  _setRecordOnly(definitionID, content, options) {
    return __async(this, null, function* () {
      var _a;
      const existing = yield this.getRecordID(definitionID, (_a = options.controller) != null ? _a : this.id);
      if (existing == null) {
        const definition = yield this.getDefinition(definitionID);
        const ref = yield this._createRecord(definition, content, options);
        return [
          true,
          ref
        ];
      } else {
        const doc = yield _classPrivateFieldGet5(this, _loader2).update(existing, content);
        return [
          false,
          doc.id
        ];
      }
    });
  }
  _createRecord(_0, _1, _2) {
    return __async(this, arguments, function* (definition, content, { controller, pin }) {
      const doc = yield _classPrivateFieldGet5(this, _loader2).deterministic({
        controllers: [
          controller != null ? controller : this.id
        ],
        family: definition.id.toString()
      }, {
        pin
      });
      yield doc.update(content, {
        schema: definition.schema
      });
      return doc.id;
    });
  }
  _setReference(controller, definitionID, id) {
    return __async(this, null, function* () {
      yield this._getIndexProxy(controller).changeContent((index) => {
        return __spreadProps(__spreadValues({}, index), {
          [definitionID]: id.toUrl()
        });
      });
    });
  }
  _setReferences(controller, references) {
    return __async(this, null, function* () {
      if (Object.keys(references).length !== 0) {
        yield this._getIndexProxy(controller).changeContent((index) => {
          return __spreadValues(__spreadValues({}, index), references);
        });
      }
    });
  }
  constructor(params) {
    _classPrivateFieldInit5(this, _ceramic2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit5(this, _id, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit5(this, _indexProxies, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInit5(this, _loader2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInit5(this, _model, {
      writable: true,
      value: void 0
    });
    const { cache, ceramic, id, loader, model } = params;
    _classPrivateFieldSet5(this, _ceramic2, ceramic);
    _classPrivateFieldSet5(this, _id, id);
    _classPrivateFieldSet5(this, _loader2, loader != null ? loader : new TileLoader({
      ceramic,
      cache
    }));
    _classPrivateFieldSet5(this, _model, model instanceof DataModel ? model : new DataModel({
      loader: _classPrivateFieldGet5(this, _loader2),
      aliases: model
    }));
  }
};
__name(DIDDataStore, "DIDDataStore");
function typeStreamID(streamId) {
  return typeof streamId === "string" ? StreamID.fromString(streamId) : streamId;
}
__name(typeStreamID, "typeStreamID");
var Document = class extends Observable {
  constructor(initial, _apiUrl, syncInterval) {
    super((subscriber) => {
      const isFirstObserver = this.state$.observers.length === 0;
      if (isFirstObserver) {
        this.periodicSubscription = timer(0, syncInterval).pipe(throttle(() => this._syncState(this.id, { sync: SyncOptions.PREFER_CACHE }))).subscribe();
      }
      this.state$.subscribe(subscriber).add(() => {
        var _a;
        const isNoObserversLeft = this.state$.observers.length === 0;
        if (isNoObserversLeft) {
          (_a = this.periodicSubscription) == null ? void 0 : _a.unsubscribe();
        }
      });
    });
    this.state$ = new StreamStateSubject(initial);
    this._apiUrl = new URL(_apiUrl);
  }
  get value() {
    return this.state$.value;
  }
  get state() {
    return this.state$.value;
  }
  next(state) {
    this.state$.next(state);
  }
  _syncState(streamId, opts) {
    return __async(this, null, function* () {
      const state = yield Document._load(streamId, this._apiUrl, opts);
      this.state$.next(StreamUtils.deserializeState(state));
    });
  }
  get id() {
    return new StreamID(this.state$.value.type, this.state$.value.log[0].cid);
  }
  static createFromGenesis(apiUrl, type, genesis, opts, syncInterval) {
    return __async(this, null, function* () {
      const url = new URL("./streams", apiUrl);
      const { state } = yield fetchJson(url, {
        method: "post",
        body: {
          type,
          genesis: StreamUtils.serializeCommit(genesis),
          opts
        }
      });
      return new Document(StreamUtils.deserializeState(state), apiUrl, syncInterval);
    });
  }
  static applyCommit(apiUrl, streamId, commit, opts, syncInterval) {
    return __async(this, null, function* () {
      const url = new URL("./commits", apiUrl);
      const { state } = yield fetchJson(url, {
        method: "post",
        body: {
          streamId: streamId.toString(),
          commit: StreamUtils.serializeCommit(commit),
          opts
        }
      });
      return new Document(StreamUtils.deserializeState(state), apiUrl, syncInterval);
    });
  }
  static _load(streamId, apiUrl, opts) {
    return __async(this, null, function* () {
      const url = new URL(`./streams/${streamId}`, apiUrl);
      for (const key2 in opts) {
        url.searchParams.set(key2, opts[key2]);
      }
      const { state } = yield fetchJson(url);
      return state;
    });
  }
  static load(streamId, apiUrl, syncInterval, opts) {
    return __async(this, null, function* () {
      const state = yield Document._load(streamId, apiUrl, opts);
      return new Document(StreamUtils.deserializeState(state), apiUrl, syncInterval);
    });
  }
  static loadStreamCommits(streamId, apiUrl) {
    return __async(this, null, function* () {
      const url = new URL(`./commits/${streamId}`, apiUrl);
      const { commits } = yield fetchJson(url);
      return commits.map((r) => {
        return {
          cid: r.cid,
          value: StreamUtils.deserializeCommit(r.value)
        };
      });
    });
  }
  complete() {
    this.state$.complete();
  }
};
__name(Document, "Document");
var import_lodash4 = __toESM(require_lodash(), 1);
var __decorate5 = function(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
};
var Caip10Link_1;
var throwReadOnlyError2 =  __name(() => {
  throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
}, "throwReadOnlyError");
var DEFAULT_CREATE_OPTS2 = {
  anchor: false,
  publish: true,
  pin: true,
  sync: SyncOptions.PREFER_CACHE
};
var DEFAULT_UPDATE_OPTS2 = { anchor: true, publish: true, throwOnInvalidCommit: true };
var DEFAULT_LOAD_OPTS2 = { sync: SyncOptions.PREFER_CACHE };
var Caip10Link = Caip10Link_1 =  __name(class Caip10Link2 extends Stream {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get did() {
    return this.content;
  }
  get metadata() {
    var _a;
    const { next, metadata } = this.state$.value;
    return (0, import_lodash4.default)((_a = next == null ? void 0 : next.metadata) != null ? _a : metadata);
  }
  static fromAccount(_0, _1) {
    return __async(this, arguments, function* (ceramic, accountId, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_CREATE_OPTS2), opts);
      const normalizedAccountId = normalizeAccountId(accountId);
      const genesisCommit = Caip10Link_1.makeGenesis(normalizedAccountId);
      return Caip10Link_1.fromGenesis(ceramic, genesisCommit, opts);
    });
  }
  static fromGenesis(_0, _1) {
    return __async(this, arguments, function* (ceramic, genesisCommit, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_CREATE_OPTS2), opts);
      return ceramic.createStreamFromGenesis(Caip10Link_1.STREAM_TYPE_ID, genesisCommit, opts);
    });
  }
  setDid(_0, _1) {
    return __async(this, arguments, function* (did, authProvider, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_UPDATE_OPTS2), opts);
      const didStr = typeof did == "string" ? did.trim() : did.id;
      const parsedDid = parse(didStr);
      if ((parsedDid == null ? void 0 : parsedDid.did) !== didStr) {
        throw new Error(`DID is not valid: '${didStr}'`);
      }
      const linkProof = yield authProvider.createLink(didStr);
      return this.setDidProof(linkProof, opts);
    });
  }
  setDidProof(_0) {
    return __async(this, arguments, function* (proof, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_UPDATE_OPTS2), opts);
      const commit = this.makeCommit(proof);
      const updated = yield this.api.applyCommit(this.id, commit, opts);
      this.state$.next(updated.state);
    });
  }
  clearDid(_0) {
    return __async(this, arguments, function* (authProvider, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_UPDATE_OPTS2), opts);
      const linkProof = yield authProvider.createLink("");
      return this.setDidProof(linkProof, opts);
    });
  }
  static load(_0, _1) {
    return __async(this, arguments, function* (ceramic, streamId, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_LOAD_OPTS2), opts);
      const streamRef = StreamRef.from(streamId);
      if (streamRef.type != Caip10Link_1.STREAM_TYPE_ID) {
        throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${Caip10Link_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
      }
      return ceramic.loadStream(streamRef, opts);
    });
  }
  static makeGenesis(accountId) {
    if (accountId.chainId.namespace === "eip155") {
      accountId.address = accountId.address.toLowerCase();
    }
    const legacyAccountId = `${accountId.address}@${accountId.chainId.toString()}`;
    return {
      header: {
        controllers: [legacyAccountId],
        family: `caip10-${accountId.chainId.toString()}`
      }
    };
  }
  makeCommit(proof) {
    return { data: proof, prev: this.tip, id: this.id.cid };
  }
  makeReadOnly() {
    this.setDidProof = throwReadOnlyError2;
    this.setDid = throwReadOnlyError2;
    this.sync = throwReadOnlyError2;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
}, "Caip10Link");
Caip10Link.STREAM_TYPE_NAME = "caip10-link";
Caip10Link.STREAM_TYPE_ID = 1;
Caip10Link = Caip10Link_1 = __decorate5([
  StreamStatic()
], Caip10Link);
var import_random4 = __toESM(require_random(), 1);
init_cid();
init_digest();
var import_multihashes = __toESM(require_src3(), 1);
var __decorate6 = function(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
};
var Model_1;
var DEFAULT_LOAD_OPTS3 = { sync: SyncOptions.PREFER_CACHE };
function _ensureAuthenticated2(signer) {
  return __async(this, null, function* () {
    if (signer.did == null) {
      throw new Error("No DID provided");
    }
    if (!signer.did.authenticated) {
      yield signer.did.authenticate();
      if (signer.loggerProvider) {
        signer.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${signer.did.id}`);
      }
    }
  });
}
__name(_ensureAuthenticated2, "_ensureAuthenticated");
function throwReadOnlyError3() {
  return __async(this, null, function* () {
    throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
  });
}
__name(throwReadOnlyError3, "throwReadOnlyError");
var ModelAccountRelation;
(function(ModelAccountRelation2) {
  ModelAccountRelation2["LIST"] = "list";
  ModelAccountRelation2["SINGLE"] = "single";
})(ModelAccountRelation || (ModelAccountRelation = {}));
var Model = Model_1 =  __name(class Model2 extends Stream {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get content() {
    return super.content;
  }
  get metadata() {
    return { controller: this.state$.value.metadata.controllers[0], model: Model_1.MODEL };
  }
  static create(ceramic, content, metadata) {
    return __async(this, null, function* () {
      Model_1.assertComplete(content);
      const opts = {
        publish: true,
        anchor: true,
        pin: true,
        sync: SyncOptions.NEVER_SYNC,
        throwOnInvalidCommit: true
      };
      const commit = yield Model_1._makeGenesis(ceramic, content, metadata);
      const model = yield ceramic.createStreamFromGenesis(Model_1.STREAM_TYPE_ID, commit, opts);
      return model;
    });
  }
  static createPlaceholder(ceramic, content, metadata) {
    return __async(this, null, function* () {
      const opts = {
        publish: false,
        anchor: false,
        pin: false,
        sync: SyncOptions.NEVER_SYNC,
        throwOnInvalidCommit: true
      };
      const commit = yield Model_1._makeGenesis(ceramic, content, metadata);
      return ceramic.createStreamFromGenesis(Model_1.STREAM_TYPE_ID, commit, opts);
    });
  }
  replacePlaceholder(content) {
    return __async(this, null, function* () {
      Model_1.assertComplete(content, this.id);
      const opts = { publish: true, anchor: true, pin: true, throwOnInvalidCommit: true };
      const updateCommit = yield this._makeCommit(this.api, content);
      const updated = yield this.api.applyCommit(this.id, updateCommit, opts);
      this.state$.next(updated.state);
    });
  }
  static assertComplete(content, streamId) {
    if (!content.name) {
      if (streamId) {
        throw new Error(`Model with StreamID ${streamId.toString()} is missing a 'name' field`);
      } else {
        throw new Error(`Model is missing a 'name' field`);
      }
    }
    if (!content.schema) {
      if (streamId) {
        throw new Error(`Model ${content.name} (${streamId.toString()}) is missing a 'schema' field`);
      } else {
        throw new Error(`Model ${content.name} is missing a 'schema' field`);
      }
    }
    if (!content.accountRelation) {
      if (streamId) {
        throw new Error(`Model ${content.name} (${streamId.toString()}) is missing a 'accountRelation' field`);
      } else {
        throw new Error(`Model ${content.name} is missing a 'accountRelation' field`);
      }
    }
  }
  static load(_0, _1) {
    return __async(this, arguments, function* (ceramic, streamId, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_LOAD_OPTS3), opts);
      const streamRef = StreamRef.from(streamId);
      if (streamRef.type != Model_1.STREAM_TYPE_ID) {
        throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${Model_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
      }
      const model = yield ceramic.loadStream(streamRef, opts);
      try {
        Model_1.assertComplete(model.content, streamId);
      } catch (err) {
        throw new Error(`Incomplete placeholder Models cannot be loaded: ${err.message}`);
      }
      return model;
    });
  }
  _makeCommit(signer, newContent) {
    return __async(this, null, function* () {
      const commit = this._makeRawCommit(newContent);
      return Model_1._signDagJWS(signer, commit);
    });
  }
  _makeRawCommit(newContent) {
    if (newContent == null) {
      throw new Error(`Cannot set Model content to null`);
    }
    const patch = fast_json_patch_default.compare(this.content, newContent);
    return {
      data: patch,
      prev: this.tip,
      id: this.state.log[0].cid
    };
  }
  static _makeGenesis(signer, content, metadata) {
    return __async(this, null, function* () {
      const commit = yield this._makeRawGenesis(signer, content, metadata);
      return Model_1._signDagJWS(signer, commit);
    });
  }
  static _makeRawGenesis(signer, content, metadata) {
    return __async(this, null, function* () {
      if (content == null) {
        throw new Error(`Genesis content cannot be null`);
      }
      if (!metadata || !metadata.controller) {
        if (signer.did) {
          yield _ensureAuthenticated2(signer);
          metadata = { controller: signer.did.hasParent ? signer.did.parent : signer.did.id };
        } else {
          throw new Error("No controller specified");
        }
      }
      const header = {
        controllers: [metadata.controller],
        unique: (0, import_random4.randomBytes)(12),
        model: Model_1.MODEL.bytes
      };
      return { data: content, header };
    });
  }
  makeReadOnly() {
    this.replacePlaceholder = throwReadOnlyError3;
    this.sync = throwReadOnlyError3;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
  static _signDagJWS(signer, commit) {
    return __async(this, null, function* () {
      yield _ensureAuthenticated2(signer);
      return signer.did.createDagJWS(commit);
    });
  }
}, "Model");
Model.STREAM_TYPE_NAME = "model";
Model.STREAM_TYPE_ID = 2;
Model.MODEL = function() {
  const data = encode9("model-v1");
  const multihash = import_multihashes.default.encode(data, "identity");
  const digest2 = create(code4, multihash);
  const cid = CID.createV1(code4, digest2);
  return new StreamID(Model_1.STREAM_TYPE_ID, cid);
}();
Model = Model_1 = __decorate6([
  StreamStatic()
], Model);
var import_random5 = __toESM(require_random(), 1);
var __decorate7 = function(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
};
var ModelInstanceDocument_1;
var DEFAULT_CREATE_OPTS3 = {
  anchor: true,
  publish: true,
  pin: true,
  sync: SyncOptions.NEVER_SYNC,
  syncTimeoutSeconds: 0
};
var DEFAULT_LOAD_OPTS4 = { sync: SyncOptions.PREFER_CACHE };
var DEFAULT_UPDATE_OPTS3 = { anchor: true, publish: true, throwOnInvalidCommit: true };
function _ensureAuthenticated3(signer) {
  return __async(this, null, function* () {
    if (signer.did == null) {
      throw new Error("No DID provided");
    }
    if (!signer.did.authenticated) {
      yield signer.did.authenticate();
      if (signer.loggerProvider) {
        signer.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${signer.did.id}`);
      }
    }
  });
}
__name(_ensureAuthenticated3, "_ensureAuthenticated");
function throwReadOnlyError4() {
  return __async(this, null, function* () {
    throw new Error("Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.");
  });
}
__name(throwReadOnlyError4, "throwReadOnlyError");
var ModelInstanceDocument = ModelInstanceDocument_1 =  __name(class ModelInstanceDocument2 extends Stream {
  constructor() {
    super(...arguments);
    this._isReadOnly = false;
  }
  get content() {
    return super.content;
  }
  get metadata() {
    const metadata = this.state$.value.metadata;
    return { controller: metadata.controllers[0], model: metadata.model };
  }
  static create(_0, _1, _2) {
    return __async(this, arguments, function* (ceramic, content, metadata, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_CREATE_OPTS3), opts);
      const signer = opts.asDID ? { did: opts.asDID } : ceramic;
      const commit = yield ModelInstanceDocument_1._makeGenesis(signer, content, metadata);
      return ceramic.createStreamFromGenesis(ModelInstanceDocument_1.STREAM_TYPE_ID, commit, opts);
    });
  }
  static load(_0, _1) {
    return __async(this, arguments, function* (ceramic, streamId, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_LOAD_OPTS4), opts);
      const streamRef = StreamRef.from(streamId);
      if (streamRef.type != ModelInstanceDocument_1.STREAM_TYPE_ID) {
        throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${ModelInstanceDocument_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
      }
      return ceramic.loadStream(streamRef, opts);
    });
  }
  replace(_0) {
    return __async(this, arguments, function* (content, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_UPDATE_OPTS3), opts);
      const signer = opts.asDID ? { did: opts.asDID } : this.api;
      const updateCommit = yield this._makeCommit(signer, content);
      const updated = yield this.api.applyCommit(this.id, updateCommit, opts);
      this.state$.next(updated.state);
    });
  }
  patch(_0) {
    return __async(this, arguments, function* (jsonPatch, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_UPDATE_OPTS3), opts);
      const rawCommit = {
        data: jsonPatch,
        prev: this.tip,
        id: this.id.cid
      };
      const commit = yield ModelInstanceDocument_1._signDagJWS(this.api, rawCommit);
      const updated = yield this.api.applyCommit(this.id, commit, opts);
      this.state$.next(updated.state);
    });
  }
  makeReadOnly() {
    this.replace = throwReadOnlyError4;
    this.patch = throwReadOnlyError4;
    this.sync = throwReadOnlyError4;
    this._isReadOnly = true;
  }
  get isReadOnly() {
    return this._isReadOnly;
  }
  _makeCommit(signer, newContent) {
    const commit = this._makeRawCommit(newContent);
    return ModelInstanceDocument_1._signDagJWS(signer, commit);
  }
  _makeRawCommit(newContent) {
    const patch = fast_json_patch_default.compare(this.content, newContent || {});
    return {
      data: patch,
      prev: this.tip,
      id: this.state.log[0].cid
    };
  }
  static _makeGenesis(signer, content, metadata) {
    return __async(this, null, function* () {
      const commit = yield this._makeRawGenesis(signer, content, metadata);
      return ModelInstanceDocument_1._signDagJWS(signer, commit);
    });
  }
  static _makeRawGenesis(signer, content, metadata) {
    return __async(this, null, function* () {
      if (!metadata.model) {
        throw new Error(`Must specify a 'model' when creating a ModelInstanceDocument`);
      }
      if (!metadata.controller) {
        if (signer.did) {
          yield _ensureAuthenticated3(signer);
          metadata.controller = signer.did.hasParent ? signer.did.parent : signer.did.id;
        } else {
          throw new Error("No controller specified");
        }
      }
      const header = {
        controllers: [metadata.controller],
        unique: (0, import_random5.randomBytes)(12),
        model: metadata.model.bytes
      };
      return { data: content, header };
    });
  }
  static _signDagJWS(signer, commit) {
    return __async(this, null, function* () {
      yield _ensureAuthenticated3(signer);
      return signer.did.createDagJWS(commit);
    });
  }
}, "ModelInstanceDocument");
ModelInstanceDocument.STREAM_TYPE_NAME = "MID";
ModelInstanceDocument.STREAM_TYPE_ID = 3;
ModelInstanceDocument = ModelInstanceDocument_1 = __decorate7([
  StreamStatic()
], ModelInstanceDocument);
var RemotePinApi = class {
  constructor(_apiUrl) {
    this._apiUrl = _apiUrl;
  }
  add(streamId, force) {
    return __async(this, null, function* () {
      const args = {};
      if (force) {
        args.force = true;
      }
      const url = new URL(`./pins/${streamId}`, this._apiUrl);
      yield fetchJson(url, {
        method: "post",
        body: args
      });
    });
  }
  rm(streamId, opts) {
    return __async(this, null, function* () {
      const url = new URL(`./pins/${streamId}`, this._apiUrl);
      yield fetchJson(url, {
        method: "delete",
        body: { opts }
      });
    });
  }
  ls(streamId) {
    return __async(this, null, function* () {
      let url = new URL("./pins", this._apiUrl);
      if (streamId) {
        url = new URL(`./pins/${streamId.toString()}`, this._apiUrl);
      }
      const result = yield fetchJson(url);
      const { pinnedStreamIds } = result;
      return {
        [Symbol.asyncIterator]() {
          let index = 0;
          return {
            next() {
              if (index === pinnedStreamIds.length) {
                return Promise.resolve({ value: null, done: true });
              }
              return Promise.resolve({ value: pinnedStreamIds[index++], done: false });
            }
          };
        }
      };
    });
  }
};
__name(RemotePinApi, "RemotePinApi");
var RemoteIndexApi = class {
  constructor(apiUrl) {
    this._fetchJson = fetchJson;
    this._collectionURL = new URL("./collection", apiUrl);
  }
  queryIndex(query) {
    return __async(this, null, function* () {
      const queryURL = new URL(this._collectionURL);
      for (const key2 in query) {
        queryURL.searchParams.set(key2, query[key2]);
      }
      const response = yield this._fetchJson(queryURL);
      const edges = response.edges.map((e) => {
        return {
          cursor: e.cursor,
          node: StreamUtils.deserializeState(e.node)
        };
      });
      return {
        edges,
        pageInfo: response.pageInfo
      };
    });
  }
};
__name(RemoteIndexApi, "RemoteIndexApi");
var API_PATH = "/api/v0/";
var CERAMIC_HOST = "http://localhost:7007";
var DEFAULT_CLIENT_CONFIG = {
  syncInterval: 5e3
};
var DEFAULT_APPLY_COMMIT_OPTS = { anchor: true, publish: true, sync: SyncOptions.PREFER_CACHE };
var DEFAULT_CREATE_FROM_GENESIS_OPTS = {
  anchor: true,
  publish: true,
  sync: SyncOptions.PREFER_CACHE
};
var DEFAULT_LOAD_OPTS5 = { sync: SyncOptions.PREFER_CACHE };
var CeramicClient = class {
  constructor(apiHost = CERAMIC_HOST, config2 = {}) {
    this._config = __spreadValues(__spreadValues({}, DEFAULT_CLIENT_CONFIG), config2);
    this._apiUrl = new URL(API_PATH, apiHost);
    this._streamCache =  new Map();
    this.context = { api: this };
    this.pin = new RemotePinApi(this._apiUrl);
    this.index = new RemoteIndexApi(this._apiUrl);
    this._streamConstructors = {
      [Caip10Link.STREAM_TYPE_ID]: Caip10Link,
      [Model.STREAM_TYPE_ID]: Model,
      [ModelInstanceDocument.STREAM_TYPE_ID]: ModelInstanceDocument,
      [TileDocument.STREAM_TYPE_ID]: TileDocument
    };
  }
  get did() {
    return this.context.did;
  }
  set did(did) {
    this.context.did = did;
  }
  createStreamFromGenesis(_0, _1) {
    return __async(this, arguments, function* (type, genesis, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_CREATE_FROM_GENESIS_OPTS), opts);
      const stream = yield Document.createFromGenesis(this._apiUrl, type, genesis, opts, this._config.syncInterval);
      const found = this._streamCache.get(stream.id.toString());
      if (found) {
        if (!StreamUtils.statesEqual(stream.state, found.state))
          found.next(stream.state);
        return this.buildStreamFromDocument(found);
      } else {
        this._streamCache.set(stream.id.toString(), stream);
        return this.buildStreamFromDocument(stream);
      }
    });
  }
  loadStream(_0) {
    return __async(this, arguments, function* (streamId, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_LOAD_OPTS5), opts);
      const streamRef = StreamRef.from(streamId);
      let stream = this._streamCache.get(streamRef.baseID.toString());
      if (stream) {
        yield stream._syncState(streamRef, opts);
      } else {
        stream = yield Document.load(streamRef, this._apiUrl, this._config.syncInterval, opts);
        this._streamCache.set(stream.id.toString(), stream);
      }
      return this.buildStreamFromDocument(stream);
    });
  }
  multiQuery(queries, timeout) {
    return __async(this, null, function* () {
      const queriesJSON = queries.map((q) => {
        return __spreadProps(__spreadValues({}, q), {
          streamId: typeof q.streamId === "string" ? q.streamId : q.streamId.toString()
        });
      });
      const url = new URL("./multiqueries", this._apiUrl);
      const results = yield fetchJson(url, {
        method: "post",
        body: __spreadValues({
          queries: queriesJSON
        }, { timeout })
      });
      return Object.entries(results).reduce((acc, e) => {
        const [k, v] = e;
        const state = StreamUtils.deserializeState(v);
        const stream = new Document(state, this._apiUrl, this._config.syncInterval);
        acc[k] = this.buildStreamFromDocument(stream);
        return acc;
      }, {});
    });
  }
  loadStreamCommits(streamId) {
    const effectiveStreamId = typeStreamID(streamId);
    return Document.loadStreamCommits(effectiveStreamId, this._apiUrl);
  }
  applyCommit(_0, _1) {
    return __async(this, arguments, function* (streamId, commit, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_APPLY_COMMIT_OPTS), opts);
      const effectiveStreamId = typeStreamID(streamId);
      const document = yield Document.applyCommit(this._apiUrl, effectiveStreamId, commit, opts, this._config.syncInterval);
      const fromCache = this._streamCache.get(effectiveStreamId.toString());
      if (fromCache) {
        fromCache.next(document.state);
        return this.buildStreamFromDocument(document);
      } else {
        this._streamCache.set(effectiveStreamId.toString(), document);
        return this.buildStreamFromDocument(document);
      }
    });
  }
  requestAnchor(_0) {
    return __async(this, arguments, function* (streamId, opts = {}) {
      opts = __spreadValues(__spreadValues({}, DEFAULT_LOAD_OPTS5), opts);
      const { anchorStatus } = yield fetchJson(`${this._apiUrl}/streams/${streamId.toString()}/anchor`, {
        method: "post",
        body: {
          opts
        }
      });
      return anchorStatus;
    });
  }
  addStreamHandler(streamHandler) {
    this._streamConstructors[streamHandler.name] = streamHandler.stream_constructor;
  }
  buildStreamFromState(state) {
    const stream$ = new Document(state, this._apiUrl, this._config.syncInterval);
    return this.buildStreamFromDocument(stream$);
  }
  buildStreamFromDocument(stream) {
    const type = stream.state.type;
    const streamConstructor = this._streamConstructors[type];
    if (!streamConstructor)
      throw new Error(`Failed to find constructor for stream ${type}`);
    return new streamConstructor(stream, this.context);
  }
  setDID(did) {
    return __async(this, null, function* () {
      this.context.did = did;
    });
  }
  getSupportedChains() {
    return __async(this, null, function* () {
      if (this._supportedChains) {
        return this._supportedChains;
      }
      const { supportedChains } = yield fetchJson(this._apiUrl + "/node/chains");
      this._supportedChains = supportedChains;
      return supportedChains;
    });
  }
  close() {
    return __async(this, null, function* () {
      Array.from(this._streamCache).map(([, stream]) => {
        stream.complete();
      });
      this._streamCache.clear();
    });
  }
};
__name(CeramicClient, "CeramicClient");
var getCeramicClientFromWalletSuite =  __name((wallet, ceramicEndpoint) => __async(void 0, null, function* () {
  const client = new CeramicClient(ceramicEndpoint);
  const resolver = __spreadValues({}, import_key_did_resolver.default.getResolver());
  const did = new DID({ resolver });
  client.did = did;
  const key2 = wallet.pluginMethods.getKey();
  const ceramicProvider = new Ed25519Provider(toUint8Array(key2));
  client.did.setProvider(ceramicProvider);
  yield client.did.authenticate();
  return client;
}), "getCeramicClientFromWalletSuite");
var getIDXPlugin =  __name((_0, _1) => __async(void 0, [_0, _1], function* (wallet, { modelData, credentialAlias, ceramicEndpoint, defaultContentFamily }) {
  const ceramic = yield getCeramicClientFromWalletSuite(wallet, ceramicEndpoint);
  const loader = new TileLoader({ ceramic });
  const dataStore = new DIDDataStore({ ceramic, model: modelData });
  const getCredentialsListFromIndex =  __name((..._02) => __async(void 0, [..._02], function* (alias = credentialAlias) {
    return (yield dataStore.get(alias)) || { credentials: [] };
  }), "getCredentialsListFromIndex");
  const addCredentialStreamIdToIndex =  __name((record, alias) => __async(void 0, null, function* () {
    if (!record)
      throw new Error("record is required");
    if (!record.id)
      throw Error("No streamId provided");
    if (record.id.indexOf("ceramic://") === -1)
      record.id = "ceramic://" + record.id;
    if (!alias)
      alias = credentialAlias;
    const existing = yield getCredentialsListFromIndex(alias);
    existing.credentials.push(__spreadValues({ storageType: "ceramic" }, record));
    return dataStore.set(alias, existing);
  }), "addCredentialStreamIdToIndex");
  const publishContentToCeramic =  __name((_02, ..._12) => __async(void 0, [_02, ..._12], function* (content, metadata = {}, options = {}) {
    if (!content)
      throw new Error("content is required");
    if (!metadata.controllers)
      metadata.controllers = [ceramic.did.id];
    if (!metadata.family)
      metadata.family = defaultContentFamily;
    if (!("pin" in options))
      options.pin = true;
    const doc = yield TileDocument.create(ceramic, content, metadata, options);
    return doc.id.toString();
  }), "publishContentToCeramic");
  const readContentFromCeramic =  __name((streamId) => __async(void 0, null, function* () {
    var _a;
    return (_a = yield loader.load(streamId)) == null ? void 0 : _a.content;
  }), "readContentFromCeramic");
  return {
    pluginMethods: {
      getCredentialsListFromIndex: (_02, ..._12) => __async(void 0, [_02, ..._12], function* (_wallet, alias = credentialAlias) {
        return getCredentialsListFromIndex(alias);
      }),
      publishContentToCeramic: (_wallet, cred) => __async(void 0, null, function* () {
        return publishContentToCeramic(cred);
      }),
      readContentFromCeramic: (_wallet, streamId) => __async(void 0, null, function* () {
        return readContentFromCeramic(streamId);
      }),
      getVerifiableCredentialFromIndex: (_wallet, title) => __async(void 0, null, function* () {
        var _a;
        const credentialList = yield getCredentialsListFromIndex();
        const credential = (_a = credentialList == null ? void 0 : credentialList.credentials) == null ? void 0 : _a.find((cred) => (cred == null ? void 0 : cred.title) === title);
        return credential && (yield readContentFromCeramic(credential.id));
      }),
      getVerifiableCredentialsFromIndex: () => __async(void 0, null, function* () {
        var _a, _b;
        const credentialList = yield getCredentialsListFromIndex();
        const streamIds = (_b = (_a = credentialList == null ? void 0 : credentialList.credentials) == null ? void 0 : _a.map((credential) => credential == null ? void 0 : credential.id)) != null ? _b : [];
        return Promise.all(streamIds.map((streamId) => __async(void 0, null, function* () {
          return readContentFromCeramic(streamId);
        })));
      }),
      addVerifiableCredentialInIdx: (_02, _12) => __async(void 0, [_02, _12], function* (_wallet, { title, id }) {
        return addCredentialStreamIdToIndex({ title, id });
      })
    }
  };
}), "getIDXPlugin");
var isHex =  __name((str) => /^[0-9a-f]+$/i.test(str), "isHex");
var getDidKeyPlugin =  __name((wallet, key2) => __async(void 0, null, function* () {
  if (key2.length === 0)
    throw new Error("Please don't use an empty string for a key!");
  if (!isHex(key2))
    throw new Error("Key must be a hexadecimal string!");
  if (key2.length > 64)
    throw new Error("Key must be less than 64 characters");
  const keypair = wallet.pluginMethods.generateEd25519KeyFromBytes(toUint8Array(key2.padStart(64, "0")));
  return {
    pluginMethods: {
      getSubjectDid: (_wallet, type) => wallet.pluginMethods.keyToDid(type, keypair),
      getSubjectKeypair: () => keypair,
      getKey: () => key2.padStart(64, "0")
    }
  };
}), "getDidKeyPlugin");
var ExpirationPlugin =  __name((wallet) => ({
  pluginMethods: {
    verifyCredential: (_wallet, credential) => __async(void 0, null, function* () {
      const verificationCheck = yield wallet.pluginMethods.verifyCredential(credential);
      if (credential.expirationDate && new Date() > new Date(credential.expirationDate)) {
        verificationCheck.errors.push("expiration error: Credential is expired");
      } else {
        verificationCheck.checks.push("expiration");
      }
      return verificationCheck;
    })
  }
}), "ExpirationPlugin");
var recycleDependents =  __name((_methods) => ({}), "recycleDependents");
var issueCredential =  __name((initWallet) => {
  return (wallet, credential) => __async(void 0, null, function* () {
    const kp = wallet.pluginMethods.getSubjectKeypair();
    if (!kp)
      throw new Error("Cannot issue credential: Could not get subject keypair");
    const options = {
      verificationMethod: yield initWallet.pluginMethods.keyToVerificationMethod("key", kp),
      proofPurpose: "assertionMethod"
    };
    return initWallet.pluginMethods.issueCredential(credential, options, kp);
  });
}, "issueCredential");
var verifyCredential =  __name((initWallet) => {
  return (_wallet, credential) => __async(void 0, null, function* () {
    return initWallet.pluginMethods.verifyCredential(credential);
  });
}, "verifyCredential");
var issuePresentation =  __name((initWallet) => {
  return (wallet, credential) => __async(void 0, null, function* () {
    const did = wallet.pluginMethods.getSubjectDid("key");
    if (!did)
      throw new Error("Cannot create presentation: No holder key found");
    const holder = did;
    const kp = wallet.pluginMethods.getSubjectKeypair();
    if (!kp)
      throw new Error("Cannot issue credential: Could not get subject keypair");
    const options = {
      verificationMethod: yield initWallet.pluginMethods.keyToVerificationMethod("key", kp),
      proofPurpose: "assertionMethod"
    };
    const presentation = {
      "@context": ["https://www.w3.org/2018/credentials/v1"],
      type: ["VerifiablePresentation"],
      holder,
      verifiableCredential: credential
    };
    return initWallet.pluginMethods.issuePresentation(presentation, options, kp);
  });
}, "issuePresentation");
var verifyPresentation =  __name((initWallet) => {
  return (_wallet, presentation) => __async(void 0, null, function* () {
    return initWallet.pluginMethods.verifyPresentation(presentation);
  });
}, "verifyPresentation");
var getVCPlugin =  __name((wallet) => __async(void 0, null, function* () {
  return {
    pluginMethods: __spreadProps(__spreadValues({}, recycleDependents(wallet.pluginMethods)), {
      issueCredential: issueCredential(wallet),
      verifyCredential: verifyCredential(wallet),
      issuePresentation: issuePresentation(wallet),
      verifyPresentation: verifyPresentation(wallet),
      getTestVc: (_wallet, subject = "did:example:d23dd687a7dc6787646f2eb98d0") => {
        const did = _wallet.pluginMethods.getSubjectDid("key");
        return {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          id: "http://example.org/credentials/3731",
          type: ["VerifiableCredential"],
          issuer: did,
          issuanceDate: "2020-08-19T21:41:50Z",
          credentialSubject: { id: subject }
        };
      }
    })
  };
}), "getVCPlugin");
var util;
(function(util2) {
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys.push(key2);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
})(util || (util = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType =  __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of"
]);
var quotelessJson =  __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError =  __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, null, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(ZodError, "ZodError");
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var defaultErrorMap =  __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (issue.validation !== "regex")
        message = `Invalid ${issue.validation}`;
      else
        message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "defaultErrorMap");
var overrideErrorMap = defaultErrorMap;
var setErrorMap =  __name((map2) => {
  overrideErrorMap = map2;
}, "setErrorMap");
var makeIssue =  __name((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps(__spreadValues({}, issueData), {
    path: fullPath
  });
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return __spreadProps(__spreadValues({}, issueData), {
    path: fullPath,
    message: issueData.message || errorMessage
  });
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideErrorMap,
      defaultErrorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static mergeObjectAsync(status, pairs) {
    return __async(this, null, function* () {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: yield pair.key,
          value: yield pair.value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    });
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
__name(ParseStatus, "ParseStatus");
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY =  __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK =  __name((value) => ({ status: "valid", value }), "OK");
var isAborted =  __name((x) => x.status === "aborted", "isAborted");
var isDirty =  __name((x) => x.status === "dirty", "isDirty");
var isValid =  __name((x) => x.status === "valid", "isValid");
var isAsync =  __name((x) => typeof Promise !== void 0 && x instanceof Promise, "isAsync");
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key2) {
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    return this._path.concat(this._key);
  }
};
__name(ParseInputLazyPath, "ParseInputLazyPath");
var handleResult =  __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    const error = new ZodError(ctx.common.issues);
    return { success: false, error };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap =  __name((iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined" && required_error)
      return { message: required_error };
    if (params.invalid_type_error)
      return { message: params.invalid_type_error };
    return { message: ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this.superRefine = this._refinement;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.default = this.default.bind(this);
    this.describe = this.describe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  parseAsync(data, params) {
    return __async(this, null, function* () {
      const result = yield this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    });
  }
  safeParseAsync(data, params) {
    return __async(this, null, function* () {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
      const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
      return handleResult(ctx, result);
    });
  }
  refine(check, message) {
    const getIssueProperties =  __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError =  __name(() => ctx.addIssue(__spreadValues({
        code: ZodIssueCode.custom
      }, getIssueProperties(val))), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  optional() {
    return ZodOptional.create(this);
  }
  nullable() {
    return ZodNullable.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this);
  }
  or(option) {
    return ZodUnion.create([this, option]);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming);
  }
  transform(transform) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This(__spreadProps(__spreadValues({}, this._def), {
      description
    }));
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
__name(ZodType, "ZodType");
var cuidRegex = /^c[^\s-]{8,}$/i;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), __spreadValues({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message)));
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message) {
    return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
  }
  url(message) {
    return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
  }
  uuid(message) {
    return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
  }
  cuid(message) {
    return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
  }
  regex(regex, message) {
    return this._addCheck(__spreadValues({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message)));
  }
  min(minLength, message) {
    return this._addCheck(__spreadValues({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message)));
  }
  max(maxLength, message) {
    return this._addCheck(__spreadValues({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message)));
  }
  length(len, message) {
    return this.min(len, message).max(len, message);
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get minLength() {
    let min = -Infinity;
    this._def.checks.map((ch) => {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) {
          min = ch.value;
        }
      }
    });
    return min;
  }
  get maxLength() {
    let max = null;
    this._def.checks.map((ch) => {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) {
          max = ch.value;
        }
      }
    });
    return max;
  }
};
__name(ZodString, "ZodString");
ZodString.create = (params) => {
  return new ZodString(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString
  }, processCreateParams(params)));
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int");
  }
};
__name(ZodNumber, "ZodNumber");
ZodNumber.create = (params) => {
  return new ZodNumber(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber
  }, processCreateParams(params)));
};
var ZodBigInt = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodBigInt, "ZodBigInt");
ZodBigInt.create = (params) => {
  return new ZodBigInt(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodBigInt
  }, processCreateParams(params)));
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodBoolean, "ZodBoolean");
ZodBoolean.create = (params) => {
  return new ZodBoolean(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodBoolean
  }, processCreateParams(params)));
};
var ZodDate = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    return {
      status: "valid",
      value: new Date(input.data.getTime())
    };
  }
};
__name(ZodDate, "ZodDate");
ZodDate.create = (params) => {
  return new ZodDate(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodDate
  }, processCreateParams(params)));
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodUndefined, "ZodUndefined");
ZodUndefined.create = (params) => {
  return new ZodUndefined(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodUndefined
  }, processCreateParams(params)));
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodNull, "ZodNull");
ZodNull.create = (params) => {
  return new ZodNull(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNull
  }, processCreateParams(params)));
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
__name(ZodAny, "ZodAny");
ZodAny.create = (params) => {
  return new ZodAny(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodAny
  }, processCreateParams(params)));
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
__name(ZodUnknown, "ZodUnknown");
ZodUnknown.create = (params) => {
  return new ZodUnknown(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodUnknown
  }, processCreateParams(params)));
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
__name(ZodNever, "ZodNever");
ZodNever.create = (params) => {
  return new ZodNever(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNever
  }, processCreateParams(params)));
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(ZodVoid, "ZodVoid");
ZodVoid.create = (params) => {
  return new ZodVoid(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodVoid
  }, processCreateParams(params)));
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(ctx.data.map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = ctx.data.map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message) }
    }));
  }
  max(maxLength, message) {
    return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    }));
  }
  length(len, message) {
    return this.min(len, message).max(len, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
__name(ZodArray, "ZodArray");
ZodArray.create = (schema, params) => {
  return new ZodArray(__spreadValues({
    type: schema,
    minLength: null,
    maxLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray
  }, processCreateParams(params)));
};
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return __spreadValues(__spreadValues({}, first2), second);
  };
})(objectUtil || (objectUtil = {}));
var AugmentFactory =  __name((def) => (augmentation) => {
  return new ZodObject(__spreadProps(__spreadValues({}, def), {
    shape: () => __spreadValues(__spreadValues({}, def.shape()), augmentation)
  }));
}, "AugmentFactory");
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject(__spreadProps(__spreadValues({}, schema._def), {
      shape: () => newShape
    }));
  } else if (schema instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema.element));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = AugmentFactory(this._def);
    this.extend = AugmentFactory(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    for (const key2 in ctx.data) {
      if (!shapeKeys.includes(key2)) {
        extraKeys.push(key2);
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(() => __async(this, null, function* () {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = yield pair.key;
          syncPairs.push({
            key: key2,
            value: yield pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      })).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strict"
    }), message !== void 0 ? {
      errorMap: (issue, ctx) => {
        var _a, _b, _c, _d;
        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }
    } : {}));
  }
  strip() {
    return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  catchall(index) {
    return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
      catchall: index
    }));
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).map((key2) => {
      if (this.shape[key2])
        shape[key2] = this.shape[key2];
    });
    return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).map((key2) => {
      if (util.objectKeys(mask).indexOf(key2) === -1) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    if (mask) {
      util.objectKeys(this.shape).map((key2) => {
        if (util.objectKeys(mask).indexOf(key2) === -1) {
          newShape[key2] = this.shape[key2];
        } else {
          newShape[key2] = this.shape[key2].optional();
        }
      });
      return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
        shape: () => newShape
      }));
    } else {
      for (const key2 in this.shape) {
        const fieldSchema = this.shape[key2];
        newShape[key2] = fieldSchema.optional();
      }
    }
    return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  required() {
    const newShape = {};
    for (const key2 in this.shape) {
      const fieldSchema = this.shape[key2];
      let newField = fieldSchema;
      while (newField instanceof ZodOptional) {
        newField = newField._def.innerType;
      }
      newShape[key2] = newField;
    }
    return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
};
__name(ZodObject, "ZodObject");
ZodObject.create = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map((option) => __async(this, null, function* () {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        return {
          result: yield option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      }))).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
__name(ZodUnion, "ZodUnion");
ZodUnion.create = (types, params) => {
  return new ZodUnion(__spreadValues({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion
  }, processCreateParams(params)));
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.options.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: this.validDiscriminatorValues,
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this._def.options;
  }
  static create(discriminator, types, params) {
    const options =  new Map();
    try {
      types.forEach((type) => {
        const discriminatorValue = type.shape[discriminator].value;
        options.set(discriminatorValue, type);
      });
    } catch (e) {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (options.size !== types.length) {
      throw new Error("Some of the discriminator values are not unique");
    }
    return new ZodDiscriminatedUnion(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options
    }, processCreateParams(params)));
  }
};
__name(ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = __spreadValues(__spreadValues({}, a), b);
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a[key2], b[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed =  __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
__name(ZodIntersection, "ZodIntersection");
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection(__spreadValues({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection
  }, processCreateParams(params)));
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        type: "array"
      });
      status.dirty();
    }
    const items = ctx.data.map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      rest
    }));
  }
};
__name(ZodTuple, "ZodTuple");
ZodTuple.create = (schemas, params) => {
  return new ZodTuple(__spreadValues({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null
  }, processCreateParams(params)));
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord(__spreadValues({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord
      }, processCreateParams(third)));
    }
    return new ZodRecord(__spreadValues({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord
    }, processCreateParams(second)));
  }
};
__name(ZodRecord, "ZodRecord");
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap =  new Map();
      return Promise.resolve().then(() => __async(this, null, function* () {
        for (const pair of pairs) {
          const key2 = yield pair.key;
          const value = yield pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }));
    } else {
      const finalMap =  new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
__name(ZodMap, "ZodMap");
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap(__spreadValues({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap
  }, processCreateParams(params)));
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet =  new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message) }
    }));
  }
  max(maxSize, message) {
    return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    }));
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
__name(ZodSet, "ZodSet");
ZodSet.create = (valueType, params) => {
  return new ZodSet(__spreadValues({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet
  }, processCreateParams(params)));
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK((...args) => __async(this, null, function* () {
        const error = new ZodError([]);
        const parsedArgs = yield this._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = yield fn(...parsedArgs);
        const parsedReturns = yield this._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      }));
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
};
__name(ZodFunction, "ZodFunction");
ZodFunction.create = (args, returns, params) => {
  return new ZodFunction(__spreadValues({
    args: args ? args.rest(ZodUnknown.create()) : ZodTuple.create([]).rest(ZodUnknown.create()),
    returns: returns || ZodUnknown.create(),
    typeName: ZodFirstPartyTypeKind.ZodFunction
  }, processCreateParams(params)));
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
__name(ZodLazy, "ZodLazy");
ZodLazy.create = (getter, params) => {
  return new ZodLazy(__spreadValues({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy
  }, processCreateParams(params)));
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
__name(ZodLiteral, "ZodLiteral");
ZodLiteral.create = (value, params) => {
  return new ZodLiteral(__spreadValues({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral
  }, processCreateParams(params)));
};
function createZodEnum(values, params) {
  return new ZodEnum(__spreadValues({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum
  }, processCreateParams(params)));
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
};
__name(ZodEnum, "ZodEnum");
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
__name(ZodNativeEnum, "ZodNativeEnum");
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum(__spreadValues({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum
  }, processCreateParams(params)));
};
var ZodPromise = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
__name(ZodPromise, "ZodPromise");
ZodPromise.create = (schema, params) => {
  return new ZodPromise(__spreadValues({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise
  }, processCreateParams(params)));
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement =  __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base4 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base4))
          return base4;
        const result = effect.transform(base4.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base4) => {
          if (!isValid(base4))
            return base4;
          return Promise.resolve(effect.transform(base4.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
__name(ZodEffects, "ZodEffects");
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects(__spreadValues({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect
  }, processCreateParams(params)));
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects(__spreadValues({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects
  }, processCreateParams(params)));
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(ZodOptional, "ZodOptional");
ZodOptional.create = (type, params) => {
  return new ZodOptional(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional
  }, processCreateParams(params)));
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(ZodNullable, "ZodNullable");
ZodNullable.create = (type, params) => {
  return new ZodNullable(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable
  }, processCreateParams(params)));
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
__name(ZodDefault, "ZodDefault");
ZodDefault.create = (type, params) => {
  return new ZodOptional(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional
  }, processCreateParams(params)));
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
__name(ZodNaN, "ZodNaN");
ZodNaN.create = (params) => {
  return new ZodNaN(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNaN
  }, processCreateParams(params)));
};
var custom =  __name((check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : params;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal }));
      }
    });
  return ZodAny.create();
}, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType =  __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params, true), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var ostring =  __name(() => stringType().optional(), "ostring");
var onumber =  __name(() => numberType().optional(), "onumber");
var oboolean =  __name(() => booleanType().optional(), "oboolean");
var mod =  Object.freeze({
  __proto__: null,
  getParsedType,
  ZodParsedType,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  get objectUtil() {
    return objectUtil;
  },
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodNaN,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  ZodIssueCode,
  quotelessJson,
  ZodError,
  defaultErrorMap,
  get overrideErrorMap() {
    return overrideErrorMap;
  },
  setErrorMap
});
var ContextValidator = mod.string().array();
mod.object({
  type: mod.string().optional(),
  narrative: mod.string().optional()
});
var ImageValidator = mod.string().or(mod.object({
  id: mod.string(),
  type: mod.string(),
  caption: mod.string().optional()
}));
var GeoCoordinatesValidator = mod.object({
  type: mod.string().array().nonempty(),
  latitude: mod.number(),
  longitude: mod.number()
});
var AddressValidator = mod.object({
  type: mod.string().array().nonempty(),
  addressCountry: mod.string().optional(),
  addressCountryCode: mod.string().optional(),
  addressRegion: mod.string().optional(),
  addressLocality: mod.string().optional(),
  streetAddress: mod.string().optional(),
  postOfficeBoxNumber: mod.string().optional(),
  postalCode: mod.string().optional(),
  geo: GeoCoordinatesValidator.optional()
});
var IdentifierTypeValidator = mod.enum([
  "sourcedId",
  "systemId",
  "productId",
  "userName",
  "accountId",
  "emailAddress",
  "nationalIdentityNumber",
  "isbn",
  "issn",
  "lisSourcedId",
  "oneRosterSourcedId",
  "sisSourcedId",
  "ltiContextId",
  "ltiDeploymentId",
  "ltiToolId",
  "ltiPlatformId",
  "ltiUserId",
  "identifier"
]).or(mod.string());
var IdentifierEntryValidator = mod.object({
  type: mod.string().array().nonempty(),
  identifier: mod.string(),
  identifierType: IdentifierTypeValidator
});
var ProfileValidator = mod.string().or(mod.object({
  id: mod.string().optional(),
  type: mod.string().array().nonempty().optional(),
  name: mod.string().optional(),
  url: mod.string().optional(),
  phone: mod.string().optional(),
  description: mod.string().optional(),
  endorsement: mod.any().array().optional(),
  image: ImageValidator.optional(),
  email: mod.string().email().optional(),
  address: AddressValidator.optional(),
  otherIdentifier: IdentifierEntryValidator.array().optional(),
  official: mod.string().optional(),
  parentOrg: mod.any().optional(),
  familyName: mod.string().optional(),
  givenName: mod.string().optional(),
  additionalName: mod.string().optional(),
  patronymicName: mod.string().optional(),
  honorificPrefix: mod.string().optional(),
  honorificSuffix: mod.string().optional(),
  familyNamePrefix: mod.string().optional(),
  dateOfBirth: mod.string().optional()
}).catchall(mod.any()));
var CredentialSubjectValidator = mod.object({ id: mod.string().optional() }).catchall(mod.any());
var CredentialStatusValidator = mod.object({ type: mod.string(), id: mod.string() });
var CredentialSchemaValidator = mod.object({ id: mod.string(), type: mod.string() });
var RefreshServiceValidator = mod.object({ id: mod.string(), type: mod.string() }).catchall(mod.any());
var UnsignedVCValidator = mod.object({
  "@context": ContextValidator,
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  issuer: ProfileValidator,
  issuanceDate: mod.string(),
  expirationDate: mod.string().optional(),
  credentialSubject: CredentialSubjectValidator.or(CredentialSubjectValidator.array()),
  credentialStatus: CredentialStatusValidator.optional(),
  credentialSchema: CredentialSchemaValidator.array().optional(),
  refreshService: RefreshServiceValidator.optional()
}).catchall(mod.any());
var ProofValidator = mod.object({
  type: mod.string(),
  created: mod.string(),
  challenge: mod.string().optional(),
  domain: mod.string().optional(),
  nonce: mod.string().optional(),
  proofPurpose: mod.string(),
  verificationMethod: mod.string(),
  jws: mod.string().optional()
}).catchall(mod.any());
var VCValidator = UnsignedVCValidator.extend({
  proof: ProofValidator.or(ProofValidator.array())
});
var UnsignedVPValidator = mod.object({
  "@context": ContextValidator,
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  verifiableCredential: VCValidator.or(VCValidator.array()),
  holder: mod.string().optional()
}).catchall(mod.any());
UnsignedVPValidator.extend({
  proof: ProofValidator.or(ProofValidator.array())
});
var AlignmentTargetTypeValidator = mod.enum([
  "ceasn:Competency",
  "ceterms:Credential",
  "CFItem",
  "CFRubric",
  "CFRubricCriterion",
  "CFRubricCriterionLevel",
  "CTDL"
]).or(mod.string());
var AlignmentValidator = mod.object({
  type: mod.string().array().nonempty(),
  targetCode: mod.string().optional(),
  targetDescription: mod.string().optional(),
  targetName: mod.string(),
  targetFramework: mod.string().optional(),
  targetType: AlignmentTargetTypeValidator.optional(),
  targetUrl: mod.string()
});
var AchievementTypeValidator = mod.enum([
  "Achievement",
  "ApprenticeshipCertificate",
  "Assessment",
  "Assignment",
  "AssociateDegree",
  "Award",
  "Badge",
  "BachelorDegree",
  "Certificate",
  "CertificateOfCompletion",
  "Certification",
  "CommunityService",
  "Competency",
  "Course",
  "CoCurricular",
  "Degree",
  "Diploma",
  "DoctoralDegree",
  "Fieldwork",
  "GeneralEducationDevelopment",
  "JourneymanCertificate",
  "LearningProgram",
  "License",
  "Membership",
  "ProfessionalDoctorate",
  "QualityAssuranceCredential",
  "MasterCertificate",
  "MasterDegree",
  "MicroCredential",
  "ResearchDoctorate",
  "SecondarySchoolDiploma"
]).or(mod.string());
var CriteriaValidator = mod.object({ id: mod.string().optional(), narrative: mod.string().optional() }).catchall(mod.any());
var EndorsementSubjectValidator = mod.object({
  id: mod.string(),
  type: mod.string().array().nonempty(),
  endorsementComment: mod.string().optional()
});
var EndorsementCredentialValidator = UnsignedVCValidator.extend({
  credentialSubject: EndorsementSubjectValidator,
  proof: ProofValidator.or(ProofValidator.array()).optional()
});
var RelatedValidator = mod.object({
  id: mod.string(),
  "@language": mod.string().optional(),
  version: mod.string().optional()
});
var ResultTypeValidator = mod.enum([
  "GradePointAverage",
  "LetterGrade",
  "Percent",
  "PerformanceLevel",
  "PredictedScore",
  "RawScore",
  "Result",
  "RubricCriterion",
  "RubricCriterionLevel",
  "RubricScore",
  "ScaledScore",
  "Status"
]).or(mod.string());
var RubricCriterionValidator = mod.object({
  id: mod.string(),
  type: mod.string().array().nonempty(),
  alignment: AlignmentValidator.array().optional(),
  description: mod.string().optional(),
  level: mod.string().optional(),
  name: mod.string(),
  points: mod.string().optional()
}).catchall(mod.any());
var ResultDescriptionValidator = mod.object({
  id: mod.string(),
  type: mod.string().array().nonempty(),
  alignment: AlignmentValidator.array().optional(),
  allowedValue: mod.string().array().optional(),
  name: mod.string(),
  requiredLevel: mod.string().optional(),
  requiredValue: mod.string().optional(),
  resultType: ResultTypeValidator,
  rubricCriterionLevel: RubricCriterionValidator.array().optional(),
  valueMax: mod.string().optional(),
  valueMin: mod.string().optional()
}).catchall(mod.any());
var AchievementValidator = mod.object({
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  alignment: AlignmentValidator.array().optional(),
  achievementType: AchievementTypeValidator.optional(),
  creator: ProfileValidator.optional(),
  creditsAvailable: mod.number().optional(),
  criteria: CriteriaValidator,
  description: mod.string(),
  endorsement: EndorsementCredentialValidator.array().optional(),
  fieldOfStudy: mod.string().optional(),
  humanCode: mod.string().optional(),
  image: ImageValidator.optional(),
  "@language": mod.string().optional(),
  name: mod.string(),
  otherIdentifier: IdentifierEntryValidator.array().optional(),
  related: RelatedValidator.array().optional(),
  resultDescription: ResultDescriptionValidator.array().optional(),
  specialization: mod.string().optional(),
  tag: mod.string().array().optional(),
  version: mod.string().optional()
}).catchall(mod.any());
var IdentityObjectValidator = mod.object({
  type: mod.string(),
  hashed: mod.boolean(),
  identityHash: mod.string(),
  identityType: mod.string(),
  salt: mod.string().optional()
});
var ResultStatusTypeValidator = mod.enum([
  "Completed",
  "Enrolled",
  "Failed",
  "InProgress",
  "OnHold",
  "Withdrew"
]);
var ResultValidator = mod.object({
  type: mod.string().array().nonempty(),
  achievedLevel: mod.string().optional(),
  alignment: AlignmentValidator.array().optional(),
  resultDescription: mod.string().optional(),
  status: ResultStatusTypeValidator.optional(),
  value: mod.string().optional()
}).catchall(mod.any());
var AchievementSubjectValidator = mod.object({
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  activityEndDate: mod.string().optional(),
  activityStartDate: mod.string().optional(),
  creditsEarned: mod.number().optional(),
  achievement: AchievementValidator.optional(),
  identifier: IdentityObjectValidator.optional(),
  image: ImageValidator.optional(),
  licenseNumber: mod.string().optional(),
  narrative: mod.string().optional(),
  result: ResultValidator.array().optional(),
  role: mod.string().optional(),
  source: ProfileValidator.optional(),
  term: mod.string().optional()
}).catchall(mod.any());
var EvidenceValidator = mod.object({
  id: mod.string().optional(),
  type: mod.string().array().nonempty(),
  narrative: mod.string().optional(),
  name: mod.string().optional(),
  description: mod.string().optional(),
  genre: mod.string().optional(),
  audience: mod.string().optional()
}).catchall(mod.any());
var UnsignedAchievementCredentialValidator = UnsignedVCValidator.extend({
  name: mod.string().optional(),
  description: mod.string().optional(),
  image: mod.string().optional(),
  credentialSubject: AchievementSubjectValidator.or(AchievementSubjectValidator.array()),
  endorsement: UnsignedVCValidator.array().optional(),
  evidence: EvidenceValidator.array().optional()
});
UnsignedAchievementCredentialValidator.extend({
  proof: ProofValidator.or(ProofValidator.array())
});
mod.object({
  checks: mod.string().array(),
  warnings: mod.string().array(),
  errors: mod.string().array()
});
var VerificationStatusValidator = mod.enum(["Success", "Failed", "Error"]);
var VerificationStatusEnum = VerificationStatusValidator.enum;
mod.object({
  check: mod.string(),
  status: VerificationStatusValidator,
  message: mod.string().optional(),
  details: mod.string().optional()
});
mod.object({
  title: mod.string().optional(),
  createdAt: mod.string().optional(),
  issuer: ProfileValidator.optional(),
  issuee: ProfileValidator.optional(),
  credentialSubject: CredentialSubjectValidator.optional()
});
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
__name(toInteger, "toInteger");
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
__name(requiredArgs, "requiredArgs");
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
__name(toDate, "toDate");
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
__name(addMilliseconds, "addMilliseconds");
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
__name(getTimezoneOffsetInMilliseconds, "getTimezoneOffsetInMilliseconds");
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
__name(isDate, "isDate");
function isValid2(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
__name(isValid2, "isValid");
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance =  __name(function(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
}, "formatDistance");
var formatDistance_default = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
__name(buildFormatLongFn, "buildFormatLongFn");
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative =  __name(function(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}, "formatRelative");
var formatRelative_default = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context2 = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context2 === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
__name(buildLocalizeFn, "buildLocalizeFn");
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber =  __name(function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
}, "ordinalNumber");
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;
function buildMatchFn(args) {
  return function(string2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string2.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key2 = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key2) : key2;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string2.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
__name(buildMatchFn, "buildMatchFn");
function findKey(object, predicate) {
  for (var key2 in object) {
    if (object.hasOwnProperty(key2) && predicate(object[key2])) {
      return key2;
    }
  }
  return void 0;
}
__name(findKey, "findKey");
function findIndex(array, predicate) {
  for (var key2 = 0; key2 < array.length; key2++) {
    if (predicate(array[key2])) {
      return key2;
    }
  }
  return void 0;
}
__name(findIndex, "findIndex");
function buildMatchPatternFn(args) {
  return function(string2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string2.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string2.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string2.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
__name(buildMatchPatternFn, "buildMatchPatternFn");
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale;
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
__name(subMilliseconds, "subMilliseconds");
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
__name(getUTCDayOfYear, "getUTCDayOfYear");
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
__name(startOfUTCISOWeek, "startOfUTCISOWeek");
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
__name(getUTCISOWeekYear, "getUTCISOWeekYear");
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
__name(startOfUTCISOWeekYear, "startOfUTCISOWeekYear");
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
__name(getUTCISOWeek, "getUTCISOWeek");
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
__name(startOfUTCWeek, "startOfUTCWeek");
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
__name(getUTCWeekYear, "getUTCWeekYear");
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}
__name(startOfUTCWeekYear, "startOfUTCWeekYear");
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}
__name(getUTCWeek, "getUTCWeek");
function addLeadingZeros(number, targetLength) {
  var sign5 = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign5 + output;
}
__name(addLeadingZeros, "addLeadingZeros");
var formatters = {
  y: function(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters_default = formatters;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  G: function(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token);
  },
  Y: function(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token);
  },
  D: function(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token);
  },
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token);
  },
  K: function(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token);
  },
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token);
  },
  S: function(date, token) {
    return lightFormatters_default.S(date, token);
  },
  X: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign5 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign5 + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign5 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
__name(formatTimezoneShort, "formatTimezoneShort");
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign5 = offset > 0 ? "-" : "+";
    return sign5 + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
__name(formatTimezoneWithOptionalMinutes, "formatTimezoneWithOptionalMinutes");
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign5 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign5 + hours + delimiter + minutes;
}
__name(formatTimezone, "formatTimezone");
var formatters_default = formatters2;
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
__name(dateLongFormatter, "dateLongFormatter");
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
__name(timeLongFormatter, "timeLongFormatter");
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
__name(dateTimeLongFormatter, "dateTimeLongFormatter");
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
__name(isProtectedDayOfYearToken, "isProtectedDayOfYearToken");
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
__name(isProtectedWeekYearToken, "isProtectedWeekYearToken");
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}
__name(throwProtectedError, "throwProtectedError");
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale2 = options.locale || en_US_default;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid2(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
__name(format, "format");
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
__name(cleanEscapedString, "cleanEscapedString");
var transformErrorCheck =  __name((error, _credential) => {
  const prefix = error.split(" error")[0];
  return prefix || error;
}, "transformErrorCheck");
var transformErrorMessage =  __name((error, credential) => {
  if (error.startsWith("expiration")) {
    return credential.expirationDate ? `Invalid \u2022 Expired ${format(new Date(credential.expirationDate), "dd MMM yyyy").toUpperCase()}` : "Invalid \u2022 Expired";
  }
  return error;
}, "transformErrorMessage");
var transformCheckMessage =  __name((check, credential) => {
  return {
    proof: "Valid",
    expiration: credential.expirationDate ? `Valid \u2022 Expires ${format(new Date(credential.expirationDate), "dd MMM yyyy").toUpperCase()}` : "Valid \u2022 Does Not Expire"
  }[check] || check;
}, "transformCheckMessage");
var verifyCredential2 =  __name((wallet) => {
  return (credential) => __async(void 0, null, function* () {
    const rawVerificationCheck = yield wallet.pluginMethods.verifyCredential(credential);
    const verificationItems = [];
    rawVerificationCheck.errors.forEach((error) => {
      verificationItems.push({
        status: VerificationStatusEnum.Failed,
        check: transformErrorCheck(error, credential),
        details: transformErrorMessage(error, credential)
      });
    });
    rawVerificationCheck.warnings.forEach((warning) => {
      verificationItems.push({
        status: VerificationStatusEnum.Error,
        check: "hmm",
        message: warning
      });
    });
    rawVerificationCheck.checks.forEach((check) => {
      verificationItems.push({
        status: VerificationStatusEnum.Success,
        check,
        message: transformCheckMessage(check, credential)
      });
    });
    return verificationItems;
  });
}, "verifyCredential");
var defaultCeramicIDXArgs = {
  modelData: {
    definitions: {
      MyVerifiableCredentials: "kjzl6cwe1jw14am5tu5hh412s19o4zm8aq3g2lpd6s4paxj2nly2lj4drp3pun2"
    },
    schemas: {
      AchievementVerifiableCredential: "ceramic://k3y52l7qbv1frylibw2725v8gem3hxs1onoh6pvux0szdduugczh0hddxo6qsd6o0",
      VerifiableCredentialsList: "ceramic://k3y52l7qbv1frxkcwfpyauky3fyl4n44izridy3blvjjzgftis40sk9w8g3remghs"
    },
    tiles: {}
  },
  credentialAlias: "MyVerifiableCredentials",
  ceramicEndpoint: "https://ceramic-node.welibrary.io:7007",
  defaultContentFamily: "SuperSkills"
};
var wasm;
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
__name(getUint8Memory0, "getUint8Memory0");
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
__name(getStringFromWasm0, "getStringFromWasm0");
var heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
__name(addHeapObject, "addHeapObject");
function getObject(idx) {
  return heap[idx];
}
__name(getObject, "getObject");
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
__name(dropObject, "dropObject");
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
__name(takeObject, "takeObject");
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString2 = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf2 = cachedTextEncoder.encode(arg);
  view.set(buf2);
  return {
    read: arg.length,
    written: buf2.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf2 = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf2.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf2.length).set(buf2);
    WASM_VECTOR_LEN = buf2.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code5 = arg.charCodeAt(offset);
    if (code5 > 127)
      break;
    mem[ptr + offset] = code5;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
__name(passStringToWasm0, "passStringToWasm0");
function isLikeNone(x) {
  return x === void 0 || x === null;
}
__name(isLikeNone, "isLikeNone");
var cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
__name(getInt32Memory0, "getInt32Memory0");
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name5 = val.name;
    if (typeof name5 == "string" && name5.length > 0) {
      return `Function(${name5})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length2 = val.length;
    let debug = "[";
    if (length2 > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length2; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
__name(debugString, "debugString");
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real =  __name((...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
      } else {
        state.a = a;
      }
    }
  }, "real");
  real.original = state;
  return real;
}
__name(makeMutClosure, "makeMutClosure");
function __wbg_adapter_24(arg0, arg1, arg2) {
  wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h91a8814f66f14b17(arg0, arg1, addHeapObject(arg2));
}
__name(__wbg_adapter_24, "__wbg_adapter_24");
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
__name(passArray8ToWasm0, "passArray8ToWasm0");
function generateEd25519KeyFromBytes(bytes) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.generateEd25519KeyFromBytes(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(ptr1, len1);
  }
}
__name(generateEd25519KeyFromBytes, "generateEd25519KeyFromBytes");
function keyToDID(method_pattern, jwk) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(method_pattern, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(jwk, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    wasm.keyToDID(retptr, ptr0, len0, ptr1, len1);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr2 = r0;
    var len2 = r1;
    if (r3) {
      ptr2 = 0;
      len2 = 0;
      throw takeObject(r2);
    }
    return getStringFromWasm0(ptr2, len2);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(ptr2, len2);
  }
}
__name(keyToDID, "keyToDID");
function keyToVerificationMethod(method_pattern, jwk) {
  const ptr0 = passStringToWasm0(method_pattern, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(jwk, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.keyToVerificationMethod(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(keyToVerificationMethod, "keyToVerificationMethod");
function issueCredential2(credential, proof_options, key2) {
  const ptr0 = passStringToWasm0(credential, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passStringToWasm0(key2, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len2 = WASM_VECTOR_LEN;
  const ret = wasm.issueCredential(ptr0, len0, ptr1, len1, ptr2, len2);
  return takeObject(ret);
}
__name(issueCredential2, "issueCredential");
function verifyCredential3(vc, proof_options) {
  const ptr0 = passStringToWasm0(vc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.verifyCredential(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(verifyCredential3, "verifyCredential");
function issuePresentation2(presentation, proof_options, key2) {
  const ptr0 = passStringToWasm0(presentation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passStringToWasm0(key2, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len2 = WASM_VECTOR_LEN;
  const ret = wasm.issuePresentation(ptr0, len0, ptr1, len1, ptr2, len2);
  return takeObject(ret);
}
__name(issuePresentation2, "issuePresentation");
function verifyPresentation2(vp, proof_options) {
  const ptr0 = passStringToWasm0(vp, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(proof_options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.verifyPresentation(ptr0, len0, ptr1, len1);
  return takeObject(ret);
}
__name(verifyPresentation2, "verifyPresentation");
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_exn_store(addHeapObject(e));
  }
}
__name(handleError, "handleError");
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
__name(getArrayU8FromWasm0, "getArrayU8FromWasm0");
function __wbg_adapter_108(arg0, arg1, arg2, arg3) {
  wasm.wasm_bindgen__convert__closures__invoke2_mut__h3ecfeb7a01c1be81(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
__name(__wbg_adapter_108, "__wbg_adapter_108");
function load(module, imports) {
  return __async(this, null, function* () {
    if (typeof Response === "function" && module instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return yield WebAssembly.instantiateStreaming(module, imports);
        } catch (e) {
          if (module.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = yield module.arrayBuffer();
      return yield WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = yield WebAssembly.instantiate(module, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module };
      } else {
        return instance;
      }
    }
  });
}
__name(load, "load");
function init2(input) {
  return __async(this, null, function* () {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    imports.wbg.__wbindgen_cb_drop = function(arg0) {
      const obj = takeObject(arg0).original;
      if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
      }
      const ret = false;
      return ret;
    };
    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
      const ret = getObject(arg0);
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_fetch_811d43d6bdcad5b1 = function(arg0) {
      const ret = fetch(getObject(arg0));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_fetch_bf56e2a9f0644e3f = function(arg0, arg1) {
      const ret = getObject(arg0).fetch(getObject(arg1));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_89d7f088c1c45353 = function() {
      return handleError(function() {
        const ret = new Headers();
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_append_f4f93bc73c45ee3e = function() {
      return handleError(function(arg0, arg1, arg2, arg3, arg4) {
        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
      }, arguments);
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len0 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len0;
      getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    imports.wbg.__wbg_instanceof_Response_ccfeb62399355bcd = function(arg0) {
      const ret = getObject(arg0) instanceof Response;
      return ret;
    };
    imports.wbg.__wbg_url_06c0f822d68d195c = function(arg0, arg1) {
      const ret = getObject(arg1).url;
      const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len0;
      getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    imports.wbg.__wbg_status_600fd8b881393898 = function(arg0) {
      const ret = getObject(arg0).status;
      return ret;
    };
    imports.wbg.__wbg_headers_9e7f2c05a9b962ea = function(arg0) {
      const ret = getObject(arg0).headers;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_arrayBuffer_5a99283a3954c850 = function() {
      return handleError(function(arg0) {
        const ret = getObject(arg0).arrayBuffer();
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_newwithstrandinit_fd99688f189f053e = function() {
      return handleError(function(arg0, arg1, arg2) {
        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
      const val = getObject(arg0);
      const ret = typeof val === "object" && val !== null;
      return ret;
    };
    imports.wbg.__wbg_self_86b4b13392c7af56 = function() {
      return handleError(function() {
        const ret = self.self;
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_crypto_b8c92eaac23d0d80 = function(arg0) {
      const ret = getObject(arg0).crypto;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_msCrypto_9ad6677321a08dd8 = function(arg0) {
      const ret = getObject(arg0).msCrypto;
      return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
      const ret = getObject(arg0) === void 0;
      return ret;
    };
    imports.wbg.__wbg_static_accessor_MODULE_452b4680e8614c81 = function() {
      const ret = module;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_require_f5521a5b85ad2542 = function(arg0, arg1, arg2) {
      const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_getRandomValues_dd27e6b0652b3236 = function(arg0) {
      const ret = getObject(arg0).getRandomValues;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_getRandomValues_e57c9b75ddead065 = function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    };
    imports.wbg.__wbg_randomFillSync_d2ba53160aec6aba = function(arg0, arg1, arg2) {
      getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
      const ret = typeof getObject(arg0) === "function";
      return ret;
    };
    imports.wbg.__wbg_newnoargs_e23b458e372830de = function(arg0, arg1) {
      const ret = new Function(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_next_cabb70b365520721 = function(arg0) {
      const ret = getObject(arg0).next;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_next_bf3d83fc18df496e = function() {
      return handleError(function(arg0) {
        const ret = getObject(arg0).next();
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_done_040f966faa9a72b3 = function(arg0) {
      const ret = getObject(arg0).done;
      return ret;
    };
    imports.wbg.__wbg_value_419afbd9b9574c4c = function(arg0) {
      const ret = getObject(arg0).value;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_iterator_4832ef1f15b0382b = function() {
      const ret = Symbol.iterator;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_get_a9cab131e3152c49 = function() {
      return handleError(function(arg0, arg1) {
        const ret = Reflect.get(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_call_ae78342adc33730a = function() {
      return handleError(function(arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_new_36359baae5a47e27 = function() {
      const ret = new Object();
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_call_3ed288a247f13ea5 = function() {
      return handleError(function(arg0, arg1, arg2) {
        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_getTime_bffb1c09df09618b = function(arg0) {
      const ret = getObject(arg0).getTime();
      return ret;
    };
    imports.wbg.__wbg_new0_0ff7eb5c1486f3ec = function() {
      const ret = new Date();
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_37705eed627d5ed9 = function(arg0, arg1) {
      try {
        var state0 = { a: arg0, b: arg1 };
        var cb0 =  __name((arg02, arg12) => {
          const a = state0.a;
          state0.a = 0;
          try {
            return __wbg_adapter_108(a, state0.b, arg02, arg12);
          } finally {
            state0.a = a;
          }
        }, "cb0");
        const ret = new Promise(cb0);
        return addHeapObject(ret);
      } finally {
        state0.a = state0.b = 0;
      }
    };
    imports.wbg.__wbg_resolve_a9a87bdd64e9e62c = function(arg0) {
      const ret = Promise.resolve(getObject(arg0));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_then_ce526c837d07b68f = function(arg0, arg1) {
      const ret = getObject(arg0).then(getObject(arg1));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_then_842e65b843962f56 = function(arg0, arg1, arg2) {
      const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_self_99737b4dcdf6f0d8 = function() {
      return handleError(function() {
        const ret = self.self;
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_window_9b61fbbf3564c4fb = function() {
      return handleError(function() {
        const ret = window.window;
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_globalThis_8e275ef40caea3a3 = function() {
      return handleError(function() {
        const ret = globalThis.globalThis;
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_global_5de1e0f82bddcd27 = function() {
      return handleError(function() {
        const ret = global.global;
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_buffer_7af23f65f6c64548 = function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_ce1e75f0ce5f7974 = function(arg0, arg1, arg2) {
      const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_cc9018bd6f283b6f = function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_f25e869e4565d2a2 = function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    imports.wbg.__wbg_length_0acb1cf9bbaf8519 = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    imports.wbg.__wbg_newwithlength_8f0657faca9f1422 = function(arg0) {
      const ret = new Uint8Array(arg0 >>> 0);
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_subarray_da527dbd24eafb6b = function(arg0, arg1, arg2) {
      const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_has_ce995ec88636803d = function() {
      return handleError(function(arg0, arg1) {
        const ret = Reflect.has(getObject(arg0), getObject(arg1));
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_set_93b1c87ee2af852e = function() {
      return handleError(function(arg0, arg1, arg2) {
        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_stringify_c760003feffcc1f2 = function() {
      return handleError(function(arg0) {
        const ret = JSON.stringify(getObject(arg0));
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
      const ret = debugString(getObject(arg1));
      const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len0;
      getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_closure_wrapper10902 = function(arg0, arg1, arg2) {
      const ret = makeMutClosure(arg0, arg1, 3717, __wbg_adapter_24);
      return addHeapObject(ret);
    };
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
      input = fetch(input);
    }
    console.log({ input });
    const { instance, module } = yield load(yield input, imports);
    wasm = instance.exports;
    init2.__wbindgen_wasm_module = module;
    return wasm;
  });
}
__name(init2, "init");
var didkit_wasm_default = init2;
var initialized = false;
var init3 =  __name((arg = "https://cdn.filestackcontent.com/jXExSjNXSerFVDMIYOgy") => __async(void 0, null, function* () {
  if (initialized)
    return;
  initialized = true;
  console.log({ arg });
  return didkit_wasm_default(arg);
}), "init");
var didkit_default = init3;
var getDidKitPlugin =  __name((input) => __async(void 0, null, function* () {
  yield didkit_default(input);
  const memoizedDids = {};
  return {
    pluginMethods: {
      generateEd25519KeyFromBytes: (_wallet, bytes) => JSON.parse(generateEd25519KeyFromBytes(bytes)),
      keyToDid: (_wallet, type, keypair) => {
        const memoizedDid = memoizedDids[type];
        if (!memoizedDid) {
          const did = keyToDID(type, JSON.stringify(keypair));
          memoizedDids[type] = did;
          return did;
        }
        return memoizedDid;
      },
      keyToVerificationMethod: (_wallet, type, keypair) => __async(void 0, null, function* () {
        return keyToVerificationMethod(type, JSON.stringify(keypair));
      }),
      issueCredential: (_wallet, credential, options, keypair) => __async(void 0, null, function* () {
        return JSON.parse(yield issueCredential2(JSON.stringify(credential), JSON.stringify(options), JSON.stringify(keypair)));
      }),
      verifyCredential: (_wallet, credential) => __async(void 0, null, function* () {
        return JSON.parse(yield verifyCredential3(JSON.stringify(credential), "{}"));
      }),
      issuePresentation: (_wallet, presentation, options, keypair) => __async(void 0, null, function* () {
        return JSON.parse(yield issuePresentation2(JSON.stringify(presentation), JSON.stringify(options), JSON.stringify(keypair)));
      }),
      verifyPresentation: (_wallet, presentation) => __async(void 0, null, function* () {
        return JSON.parse(yield verifyPresentation2(JSON.stringify(presentation), "{}"));
      })
    }
  };
}), "getDidKitPlugin");
var walletFromKey =  __name((_0, ..._1) => __async(void 0, [_0, ..._1], function* (key2, {
  ceramicIdx = defaultCeramicIDXArgs,
  didkit,
  defaultContents = []
} = {}) {
  const didkitWallet = yield (yield generateWallet(defaultContents)).addPlugin(yield getDidKitPlugin(didkit));
  const didkeyWallet = yield didkitWallet.addPlugin(yield getDidKeyPlugin(didkitWallet, key2));
  const didkeyAndVCWallet = yield didkeyWallet.addPlugin(yield getVCPlugin(didkeyWallet));
  const idxWallet = yield didkeyAndVCWallet.addPlugin(yield getIDXPlugin(didkeyAndVCWallet, ceramicIdx));
  const wallet = yield idxWallet.addPlugin(ExpirationPlugin(idxWallet));
  return {
    _wallet: wallet,
    did: (type = "key") => wallet.pluginMethods.getSubjectDid(type),
    get keypair() {
      return wallet.pluginMethods.getSubjectKeypair();
    },
    issueCredential: wallet.pluginMethods.issueCredential,
    verifyCredential: verifyCredential2(wallet),
    issuePresentation: wallet.pluginMethods.issuePresentation,
    verifyPresentation: wallet.pluginMethods.verifyPresentation,
    getCredential: wallet.pluginMethods.getVerifiableCredentialFromIndex,
    getCredentials: wallet.pluginMethods.getVerifiableCredentialsFromIndex,
    publishCredential: wallet.pluginMethods.publishContentToCeramic,
    addCredential: (credential) => __async(void 0, null, function* () {
      yield wallet.pluginMethods.addVerifiableCredentialInIdx(credential);
    }),
    readFromCeramic: wallet.pluginMethods.readContentFromCeramic,
    getTestVc: wallet.pluginMethods.getTestVc
  };
}), "walletFromKey");

const onRpcRequest = async ({ origin, request }) => {
  console.log("SWEET");
  switch (request.method) {
    case "hello":
      console.log("Hello");
      try {
        const nice = await walletFromKey("a");
        console.log(nice.did());
      } catch (error) {
        throw new Error(error);
      }
      return wallet.request({
        method: "snap_confirm",
        params: [
          {
            prompt: `Hello, ${origin}!`,
            description: "This custom confirmation is just for display purposes.",
            textAreaContent: "Nice \u{1F60E}"
          }
        ]
      });
    default:
      throw new Error("Method not found.");
  }
};

module.exports = { onRpcRequest };
