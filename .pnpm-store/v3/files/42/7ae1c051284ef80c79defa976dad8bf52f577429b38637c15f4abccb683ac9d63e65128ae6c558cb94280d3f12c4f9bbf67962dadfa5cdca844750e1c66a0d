{"version":3,"file":"autolinking.js","sourceRoot":"","sources":["../src/autolinking.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport glob from 'fast-glob';\nimport findUp from 'find-up';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport {\n  GenerateOptions,\n  ModuleDescriptor,\n  PackageRevision,\n  ResolveOptions,\n  SearchOptions,\n  SearchResults,\n} from './types';\n\n// TODO: Rename to `expo-module.json`\nconst EXPO_MODULE_CONFIG_FILENAME = 'unimodule.json';\n\n/**\n * Resolves autolinking search paths. If none is provided, it accumulates all node_modules when\n * going up through the path components. This makes workspaces work out-of-the-box without any configs.\n */\nexport async function resolveSearchPathsAsync(\n  searchPaths: string[] | null,\n  cwd: string\n): Promise<string[]> {\n  return searchPaths && searchPaths.length > 0\n    ? searchPaths.map(searchPath => path.resolve(cwd, searchPath))\n    : await findDefaultPathsAsync(cwd);\n}\n\n/**\n * Finds project's package.json and returns its path.\n */\nexport async function findPackageJsonPathAsync(): Promise<string | null> {\n  return (await findUp('package.json', { cwd: process.cwd() })) ?? null;\n}\n\n/**\n * Looks up for workspace's `node_modules` paths.\n */\nexport async function findDefaultPathsAsync(cwd: string): Promise<string[]> {\n  const paths = [];\n  let dir = cwd;\n  let pkgJsonPath: string | undefined;\n\n  while ((pkgJsonPath = await findUp('package.json', { cwd: dir }))) {\n    dir = path.dirname(path.dirname(pkgJsonPath));\n    paths.push(path.join(pkgJsonPath, '..', 'node_modules'));\n  }\n  return paths;\n}\n\n/**\n * Searches for modules to link based on given config.\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const results: SearchResults = {};\n\n  for (const searchPath of options.searchPaths) {\n    const paths = await glob(\n      [`*/${EXPO_MODULE_CONFIG_FILENAME}`, `@*/*/${EXPO_MODULE_CONFIG_FILENAME}`],\n      {\n        cwd: searchPath,\n      }\n    );\n\n    for (const packageConfigPath of paths) {\n      const packagePath = await fs.realpath(path.join(searchPath, path.dirname(packageConfigPath)));\n      const packageConfig = require(path.join(packagePath, EXPO_MODULE_CONFIG_FILENAME));\n      const { name, version } = require(path.join(packagePath, 'package.json'));\n\n      if (options.exclude?.includes(name) || !packageConfig.platforms?.includes(options.platform)) {\n        continue;\n      }\n\n      const currentRevision: PackageRevision = {\n        path: packagePath,\n        version,\n      };\n\n      if (!results[name]) {\n        // The revision that was found first will be the main one.\n        // An array of duplicates is needed only here.\n        results[name] = { ...currentRevision, duplicates: [] };\n      } else if (\n        results[name].path !== packagePath &&\n        results[name].duplicates?.every(({ path }) => path !== packagePath)\n      ) {\n        results[name].duplicates?.push(currentRevision);\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Merges autolinking options from different sources (the later the higher priority)\n * - options defined in package.json's `expoModules` field\n * - platform-specific options from the above (e.g. `expoModules.ios`)\n * - options provided to the CLI command\n */\nexport async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions>(\n  providedOptions: OptionsType\n): Promise<OptionsType> {\n  const packageJsonPath = await findPackageJsonPathAsync();\n  const packageJson = packageJsonPath ? require(packageJsonPath) : {};\n  const baseOptions = packageJson.expo?.autolinking;\n  const platformOptions = providedOptions.platform && baseOptions?.[providedOptions.platform];\n  const finalOptions = Object.assign(\n    {},\n    baseOptions,\n    platformOptions,\n    providedOptions\n  ) as OptionsType;\n\n  // Makes provided paths absolute or falls back to default paths if none was provided.\n  finalOptions.searchPaths = await resolveSearchPathsAsync(finalOptions.searchPaths, process.cwd());\n\n  return finalOptions;\n}\n\n/**\n * Verifies the search results by checking whether there are no duplicates.\n */\nexport function verifySearchResults(searchResults: SearchResults): number {\n  const cwd = process.cwd();\n  const relativePath: (pkg: PackageRevision) => string = pkg => path.relative(cwd, pkg.path);\n  let counter = 0;\n\n  for (const moduleName in searchResults) {\n    const revision = searchResults[moduleName];\n\n    if (revision.duplicates?.length) {\n      console.warn(`⚠️  Found multiple revisions of ${chalk.green(moduleName)}`);\n      console.log(` - ${chalk.magenta(relativePath(revision))} (${chalk.cyan(revision.version)})`);\n\n      for (const duplicate of revision.duplicates) {\n        console.log(` - ${chalk.gray(relativePath(duplicate))} (${chalk.gray(duplicate.version)})`);\n      }\n      counter++;\n    }\n  }\n  if (counter > 0) {\n    console.warn(\n      '⚠️  Please get rid of multiple revisions as it may introduce some side effects or compatibility issues'\n    );\n  }\n  return counter;\n}\n\n/**\n * Resolves search results to a list of platform-specific configuration.\n */\nexport async function resolveModulesAsync(\n  searchResults: SearchResults,\n  options: ResolveOptions\n): Promise<ModuleDescriptor[]> {\n  const platformLinking = require(`./platforms/${options.platform}`);\n\n  return (\n    await Promise.all(\n      Object.entries(searchResults).map(async ([packageName, revision]) => {\n        const resolvedModule = await platformLinking.resolveModuleAsync(\n          packageName,\n          revision,\n          options\n        );\n        return resolvedModule\n          ? {\n              packageName,\n              packageVersion: revision.version,\n              ...resolvedModule,\n            }\n          : null;\n      })\n    )\n  )\n    .filter(Boolean)\n    .sort((a, b) => a.packageName.localeCompare(b.packageName));\n}\n\n/**\n * Generates a source file listing all packages to link.\n * Right know it works only for Android platform.\n */\nexport async function generatePackageListAsync(\n  modules: ModuleDescriptor[],\n  options: GenerateOptions\n) {\n  try {\n    const platformLinking = require(`./platforms/${options.platform}`);\n    await platformLinking.generatePackageListAsync(modules, options.target, options.namespace);\n  } catch (e) {\n    console.error(\n      chalk.red(`Generating package list is not available for platform: ${options.platform}`)\n    );\n  }\n}\n"]}