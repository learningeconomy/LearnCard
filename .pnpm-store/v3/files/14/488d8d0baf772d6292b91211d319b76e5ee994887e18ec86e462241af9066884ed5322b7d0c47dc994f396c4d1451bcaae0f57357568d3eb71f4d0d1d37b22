{"version":3,"sources":["index.ts"],"names":["isArray","val","Array","ArrayBuffer","isView","DataView","isObject","Date","RegExp","Error","WeakMap","WeakSet","isKnownObject","Promise","getPromiseState","promise","unique","race","then","result","e","buildAST","key","value","depth","sortKeys","isPrototype","showPrototype","astNode","type","parent","undefined","children","t","i","length","push","child","toString","keys","Object","getOwnPropertyNames","sort","safeValue","status","Map","entries","from","parsedEntries","map","entry","entryKey","entryValue","size","Set","prototype","getPrototypeOf","parse","data","includePrototypes","prototypes"],"mappings":"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","sourcesContent":["export interface AST {\n  /** Current object key */\n  key: string;\n  /** Current depth */\n  depth: number;\n\n  /** The parent node of the current one */\n  parent: AST | undefined;\n}\n\ninterface ASTChildren {\n  /** Children */\n  children: DeferredNode[];\n  /** Whether it's an Object prototype */\n  isPrototype?: true;\n}\n\n/** A type to describe objects with all deferred children loaded */\ninterface ASTResolvedChildren {\n  /** Children */\n  children: ASTNode[];\n  /** Whether it's an Object prototype */\n  isPrototype?: true;\n}\n\nexport type DeferredNode = () => Promise<ASTNode>;\n\n// Object\nexport interface ASTObject extends AST, ASTChildren {\n  /** Type */\n  type: \"object\";\n  /** Value */\n  value: object;\n}\n\nexport interface ResolvedASTObject extends AST, ASTResolvedChildren {\n  /** Type */\n  type: \"object\";\n  /** Value */\n  value: object;\n}\n\n// Array\nexport interface ASTArray extends AST, ASTChildren {\n  /** Type */\n  type: \"array\";\n  /** Value */\n  value: any[];\n}\n\nexport interface ResolvedASTArray extends AST, ASTResolvedChildren {\n  /** Type */\n  type: \"array\";\n  /** Value */\n  value: any[];\n}\n\n// Function\nexport interface ASTFunction extends AST, ASTChildren {\n  /** Type */\n  type: \"function\";\n  /** Value */\n  value: Function;\n}\n\nexport interface ResolvedASTFunction extends AST, ASTResolvedChildren {\n  /** Type */\n  type: \"function\";\n  /** Value */\n  value: Function;\n}\n\n// Promise\nexport type PromiseState = \"pending\" | \"fulfilled\" | \"rejected\";\n\nexport interface ASTPromise extends AST, ASTChildren {\n  /** Type */\n  type: \"promise\";\n  /** Value */\n  value: Promise<any>;\n}\n\nexport interface ResolvedASTPromise extends AST, ASTResolvedChildren {\n  /** Type */\n  type: \"promise\";\n  /** Value */\n  value: Promise<any>;\n}\n\n// Map\nexport interface ASTMap extends AST, ASTChildren {\n  /** Type */\n  type: \"map\";\n  /** Value */\n  value: Map<any, any>;\n}\n\nexport interface ResolvedASTMap extends AST, ASTResolvedChildren {\n  /** Type */\n  type: \"map\";\n  /** Value */\n  value: Map<any, any>;\n}\n\n// Set\nexport interface ASTSet extends AST, ASTChildren {\n  /** Type */\n  type: \"set\";\n  /** Value */\n  value: Set<any>;\n}\n\n//\nexport interface ResolvedASTSet extends AST, ASTResolvedChildren {\n  /** Type */\n  type: \"set\";\n  /** Value */\n  value: Set<any>;\n}\n\n// Leaf Values\nexport interface ASTValue extends AST {\n  /** Type */\n  type: \"value\";\n  /** Value */\n  value:\n    | boolean\n    | null\n    | number\n    | BigInt\n    | string\n    | symbol\n    | undefined\n    | Date\n    | RegExp\n    | Error\n    | WeakMap<any, any>\n    | WeakSet<any>\n    | Promise<any>;\n  /** It's not a prototype */\n  isPrototype?: false;\n}\n\nexport type SupportedTypes =\n  | boolean\n  | null\n  | number\n  | string\n  | Error\n  | symbol\n  | undefined\n  | Date\n  | RegExp\n  | object\n  | Map<any, any>\n  | WeakMap<any, any>\n  | Set<any>\n  | WeakSet<any>\n  | Promise<any>\n  | any[]\n  | Function;\n\nexport type ObjectTypes =\n  | \"object\"\n  | \"function\"\n  | \"array\"\n  | \"promise\"\n  | \"map\"\n  | \"set\";\n\nexport type ASTNode =\n  | ASTObject\n  | ASTArray\n  | ASTFunction\n  | ASTPromise\n  | ASTMap\n  | ASTSet\n  | ASTValue;\n\nexport type ResolvedASTNode =\n  | ResolvedASTObject\n  | ResolvedASTArray\n  | ResolvedASTFunction\n  | ResolvedASTPromise\n  | ResolvedASTMap\n  | ResolvedASTSet;\n\n/**\n * Determine if the current object is an array.\n */\nconst isArray = (val: object): boolean => {\n  return (\n    Array.isArray(val) ||\n    // Detect https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n    (ArrayBuffer.isView(val) && !(val instanceof DataView))\n  );\n};\n\n/**\n * Determine if a given value is a true javascript object.\n * Ignore Objects that we know how to display as values.\n *\n * @param val - The current object\n */\nexport const isObject = (val: object): boolean => {\n  return (\n    val !== null &&\n    typeof val === \"object\" &&\n    !isArray(val) &&\n    !(val instanceof Date) &&\n    !(val instanceof RegExp) &&\n    !(val instanceof Error) &&\n    !(val instanceof WeakMap) &&\n    !(val instanceof WeakSet)\n  );\n};\n\n/** Check for objects we know how to enumerate */\nexport const isKnownObject = (val: object): boolean => {\n  return (\n    isObject(val) ||\n    isArray(val) ||\n    typeof val === \"function\" ||\n    val instanceof Promise\n  );\n};\n\n/**\n * Get the current state of a promise, and return a result if fulfilled\n *\n * @param promise - A promise to inspect\n */\nexport const getPromiseState = (\n  promise: Promise<any>\n): Promise<[\"pending\"] | [\"rejected\", any] | [\"fulfilled\", any]> => {\n  // Symbols and RegExps are never content-equal\n  const unique = /unique/;\n\n  return Promise.race([promise, unique]).then(\n    (result) => (result === unique ? [\"pending\"] : [\"fulfilled\", result]),\n    (e) => [\"rejected\", e]\n  );\n};\n\n/**\n * Build the AST recursively\n *\n * @param key - Current node key\n * @param value - Current node value\n * @param depth - Current tree depth\n * @param sortKeys - Whether to sort the keys\n */\nconst buildAST = async (\n  key: string,\n  value: any,\n  depth: number,\n  sortKeys: boolean,\n  isPrototype?: true,\n  showPrototype?: boolean\n): Promise<ASTNode> => {\n  const astNode = {\n    key,\n    depth,\n    value,\n    type: \"value\",\n    parent: undefined,\n  };\n\n  if (value && isKnownObject(value) && depth < 100) {\n    const children = [];\n    let t: ObjectTypes = \"object\";\n\n    // Build Array\n    if (isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        children.push(async () => {\n          const child = await buildAST(\n            i.toString(),\n            value[i],\n            depth + 1,\n            sortKeys\n          );\n          child.parent = astNode;\n          return child;\n        });\n      }\n\n      t = \"array\";\n    } else {\n      // Get Object Properties\n      const keys = Object.getOwnPropertyNames(value);\n      if (sortKeys) keys.sort();\n      for (let i = 0; i < keys.length; i++) {\n        let safeValue: any;\n        try {\n          safeValue = value[keys[i]];\n        } catch (e) {}\n\n        children.push(async () => {\n          const child = await buildAST(keys[i], safeValue, depth + 1, sortKeys);\n          child.parent = astNode;\n          return child;\n        });\n      }\n\n      // Change Type for Function\n      if (typeof value === \"function\") {\n        t = \"function\";\n      }\n\n      // Handle Promises\n      if (value instanceof Promise) {\n        const [status, result] = await getPromiseState(value);\n        children.push(async () => {\n          const child = await buildAST(\"<state>\", status, depth + 1, sortKeys);\n          child.parent = astNode;\n          return child;\n        });\n        if (status !== \"pending\") {\n          children.push(async () => {\n            const child = await buildAST(\n              \"<value>\",\n              result,\n              depth + 1,\n              sortKeys\n            );\n            child.parent = astNode;\n            return child;\n          });\n        }\n\n        t = \"promise\";\n      }\n\n      // Handle Maps\n      if (value instanceof Map) {\n        const entries = Array.from(value.entries());\n        const parsedEntries = entries.map((entry) => {\n          const [entryKey, entryValue] = entry;\n          return {\n            \"<key>\": entryKey,\n            \"<value>\": entryValue,\n          };\n        });\n        children.push(async () => {\n          const child = await buildAST(\n            \"<entries>\",\n            parsedEntries,\n            depth + 1,\n            sortKeys\n          );\n          child.parent = astNode;\n          return child;\n        });\n        children.push(async () => {\n          const child = await buildAST(\"size\", value.size, depth + 1, sortKeys);\n          child.parent = astNode;\n          return child;\n        });\n        t = \"map\";\n      }\n\n      // Handle Sets\n      if (value instanceof Set) {\n        const entries = Array.from(value.entries());\n        const parsedEntries = entries.map((entry) => {\n          return entry[1];\n        });\n        children.push(async () => {\n          const child = await buildAST(\n            \"<entries>\",\n            parsedEntries,\n            depth + 1,\n            sortKeys\n          );\n          child.parent = astNode;\n          return child;\n        });\n        children.push(async () => {\n          const child = await buildAST(\"size\", value.size, depth + 1, sortKeys);\n          child.parent = astNode;\n          return child;\n        });\n        t = \"set\";\n      }\n    }\n\n    // Handle Object Prototypes\n    if (value !== Object.prototype && showPrototype) {\n      children.push(async () => {\n        const child = await buildAST(\n          \"<prototype>\",\n          Object.getPrototypeOf(value),\n          depth + 1,\n          sortKeys,\n          true\n        );\n        child.parent = astNode;\n        return child;\n      });\n    }\n\n    astNode.type = t;\n    ((astNode as any) as ASTChildren).children = children;\n    ((astNode as any) as ASTChildren).isPrototype = isPrototype;\n  }\n\n  return astNode as ASTNode;\n};\n\n/**\n * Parse an object in to an AST.\n *\n * @param data - Object to parse.\n */\nexport const parse = (\n  data: SupportedTypes,\n  sortKeys?: boolean,\n  includePrototypes?: boolean\n) => {\n  const keys = sortKeys === false ? sortKeys : true;\n  const prototypes = includePrototypes === false ? includePrototypes : true;\n  return buildAST(\"root\", data, 0, keys, undefined, prototypes);\n};\n\nexport default parse;\n"]}
