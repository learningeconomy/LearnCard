"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleInfo = void 0;
var path = require("path");
var node_modules_1 = require("./helpers/node-modules");
var fix_path_1 = require("./helpers/fix-path");
function getModuleInfo(fileName, criteria) {
    return getModuleInfoImpl(fileName, fileName, criteria);
}
exports.getModuleInfo = getModuleInfo;
/**
 * @param currentFilePath Current file path - can be used to override actual path of module (e.g. with `typeRoots`)
 * @param originalFileName Original file name of the module
 * @param criteria Criteria of module info
 */
function getModuleInfoImpl(currentFilePath, originalFileName, criteria) {
    var npmLibraryName = node_modules_1.getLibraryName(currentFilePath);
    if (npmLibraryName === null) {
        if (criteria.typeRoots !== undefined) {
            for (var _i = 0, _a = criteria.typeRoots; _i < _a.length; _i++) {
                var root = _a[_i];
                var relativePath = fix_path_1.fixPath(path.relative(root, originalFileName));
                if (!relativePath.startsWith('../')) {
                    // relativePath is path relative to type root
                    // so we should treat it as "library from node_modules/@types/"
                    return getModuleInfoImpl(remapToTypesFromNodeModules(relativePath), originalFileName, criteria);
                }
            }
        }
        return { type: 0 /* ShouldBeInlined */, fileName: originalFileName, isExternal: false };
    }
    var typesLibraryName = node_modules_1.getTypesLibraryName(currentFilePath);
    if (shouldLibraryBeInlined(npmLibraryName, typesLibraryName, criteria.inlinedLibraries)) {
        return { type: 0 /* ShouldBeInlined */, fileName: originalFileName, isExternal: true };
    }
    if (shouldLibraryBeImported(npmLibraryName, typesLibraryName, criteria.importedLibraries)) {
        return { type: 1 /* ShouldBeImported */, fileName: originalFileName, isExternal: true };
    }
    if (typesLibraryName !== null && isLibraryAllowed(typesLibraryName, criteria.allowedTypesLibraries)) {
        return { type: 2 /* ShouldBeReferencedAsTypes */, fileName: originalFileName, typesLibraryName: typesLibraryName, isExternal: true };
    }
    return { type: 3 /* ShouldBeUsedForModulesOnly */, fileName: originalFileName, isExternal: true };
}
function shouldLibraryBeInlined(npmLibraryName, typesLibraryName, inlinedLibraries) {
    return isLibraryAllowed(npmLibraryName, inlinedLibraries) || typesLibraryName !== null && isLibraryAllowed(typesLibraryName, inlinedLibraries);
}
function shouldLibraryBeImported(npmLibraryName, typesLibraryName, importedLibraries) {
    // npm library can be imported only when it is not from @types
    var shouldNpmLibraryBeImported = typesLibraryName === null && isLibraryAllowed(npmLibraryName, importedLibraries);
    // library from @types can be imported only when it is specified explicitly
    var shouldTypesLibraryBeImported = importedLibraries !== undefined && typesLibraryName !== null && isLibraryAllowed(typesLibraryName, importedLibraries);
    return shouldNpmLibraryBeImported || shouldTypesLibraryBeImported;
}
function isLibraryAllowed(libraryName, allowedArray) {
    return allowedArray === undefined || allowedArray.indexOf(libraryName) !== -1;
}
function remapToTypesFromNodeModules(pathRelativeToTypesRoot) {
    return "node_modules/@types/" + pathRelativeToTypesRoot;
}
