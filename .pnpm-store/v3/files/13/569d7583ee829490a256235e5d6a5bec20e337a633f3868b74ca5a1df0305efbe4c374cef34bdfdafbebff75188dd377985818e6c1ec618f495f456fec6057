{"version":3,"sources":["createSlots.tsx"],"names":["SLOT_KEY","getSlotToken","child","type","isSlotOf","identifier","token","forwardWithSlots","Component","forwarded","React","forwardRef","createSlots","props","componentMapping","omit","otherChildren","slotNames","Object","keys","components","map","slot","slots","prop","SlotComp","slotProps","Error","passThroughProps","entries","filter","key","undefined","includes","Children","forEach","children","slotName","find","propName","comp","push","length"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { fromEntries } from './fromEntries';\nimport { isReactInstanceOf } from './isReactInstanceOf';\nimport { createInstanceIfDefined } from './createInstanceIfDefined';\nimport { arrayify } from './arrayify';\n\nexport const SLOT_KEY = '_SLOT_';\n\ninterface Props {\n  // IDK how to get rid of this any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [prop: string]: any;\n  /** Children to display within the component */\n  children?: React.ReactNode;\n}\ntype AnyComponent = React.ComponentType<any>;\n\ninterface ComponentMapStrict {\n  // IDK how to get rid of this any\n  [name: string]: AnyComponent[];\n}\n\ntype SlotIdentifier = AnyComponent | AnyComponent[] | symbol;\n\ninterface ComponentMap {\n  // IDK how to get rid of this any\n  [name: string]: SlotIdentifier;\n}\n\ninterface Slots {\n  [prop: string]: React.ReactNode | React.ReactNode[];\n}\n\n/**\n * Gets the token to represent the slot on an element\n *\n * @param child - The React component or element you want to get the slot token from\n */\nexport function getSlotToken(child: any) {\n  if (!child) {\n    return;\n  }\n\n  return child.type ? child.type[SLOT_KEY] : child[SLOT_KEY];\n}\n\n/**\n * Check to see if a child component is an instance of the given slot\n *\n * @param child - The React child component instance to test\n * @param identifier - The React Component or Slot ID (Symbol) to test against\n */\nexport function isSlotOf(child: any, identifier: AnyComponent | symbol) {\n  const token =\n    typeof identifier === 'symbol' ? identifier : getSlotToken(identifier);\n  return token\n    ? getSlotToken(child) === token\n    : isReactInstanceOf(child, identifier as AnyComponent);\n}\n\n/** \n * Forward a ref and make the returned component slottable.\n * \n * @param Component - Same props you give to React.forwardRef\n * \n * @example\n * export const SlottedComponentWithRef = forwardWithSlots<\n *  HTMLDivElement,\n *  ContentCardProps,\n *  SubComponents\n * >((props, ref) => null);\n */\nexport const forwardWithSlots = <RefType, PropType, Slots>(\n  Component: React.RefForwardingComponent<RefType, PropType>\n) => {\n  const forwarded = React.forwardRef(Component);\n  return forwarded as typeof forwarded & Slots;\n};\n\n/**\n * Chunk child elements into buckets based on React components.\n * Will also return the rest of the props.\n *\n * @param props - The props to find the slots in. Either in props or children\n * @param componentMapping - A map of slot names to slot components\n * @param omit - A list of props to omit from the final returned props\n *\n * @example\n * const Example = props => {\n *   const { header, body, footer, ...html } = createSlots(props, {\n *     header: Header,\n *     body: Body,\n *     footer: Footer\n *   });\n *\n *   return (\n *     <div>\n *       {header}\n *       {body}\n *       {footer}\n *     </div>\n *   )\n * };\n *\n * // No matter what order given, it displays how we defined it!\n * const Usage = () => (\n *   <Example>\n *     <Footer>by me!</Footer>\n *     <Body>Some Text</Body>\n *     <Header>Title</Header>\n *   </Example>\n * )\n *\n * // or\n *\n * const Usage = () => (\n *   <Example>\n *     <Footer>by me!</Footer>\n *     <Body>Some Text</Body>\n *     <Header>Title</Header>\n *   </Example>\n * )\n */\nexport function createSlots<InputProps extends Props>(\n  props: InputProps,\n  componentMapping: ComponentMap,\n  omit: (keyof InputProps | string)[] = []\n): InputProps {\n  const otherChildren: React.ReactNode[] = [];\n  const slotNames = Object.keys(componentMapping);\n  const components: ComponentMapStrict = fromEntries(\n    slotNames.map(slot => [slot, arrayify(componentMapping[slot])])\n  );\n  const slots: Slots = fromEntries(\n    slotNames.map(prop => {\n      const SlotComp = components[prop][0];\n      const slotProps = props[prop];\n\n      if (typeof SlotComp === 'symbol' && slotProps) {\n        throw new Error(\n          `Cannot create instance for ${prop} when using slot tokens. Use children instead.`\n        );\n      }\n\n      return [prop, createInstanceIfDefined(slotProps, SlotComp)];\n    })\n  );\n  const passThroughProps: InputProps = fromEntries(\n    Object.entries(props).filter(\n      ([key]) => componentMapping[key] === undefined && !omit.includes(key)\n    )\n  );\n\n  React.Children.forEach(props.children, child => {\n    const slotName = slotNames.find(propName =>\n      components[propName].find(comp => isSlotOf(child, comp))\n    );\n\n    if (!slotName) {\n      return otherChildren.push(child);\n    }\n\n    const slot = slots[slotName];\n    slots[slotName] = slot ? [...arrayify(slot), ...arrayify(child)] : child;\n  });\n\n  return {\n    ...passThroughProps,\n    ...slots,\n    children: otherChildren.length ? otherChildren : undefined\n  };\n}\n"]}
