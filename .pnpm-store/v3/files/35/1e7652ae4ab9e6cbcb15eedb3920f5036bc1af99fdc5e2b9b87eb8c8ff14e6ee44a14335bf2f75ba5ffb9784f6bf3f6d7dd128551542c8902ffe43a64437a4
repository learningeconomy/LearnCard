{"version":3,"file":"index.modern.js","sources":["../src/util.ts","../src/Digest.ts","../src/signers/ES256KSigner.ts","../src/signers/SimpleSigner.ts","../src/signers/EllipticSigner.ts","../src/signers/EdDSASigner.ts","../src/signers/NaclSigner.ts","../src/SignerAlgorithm.ts","../src/VerifierAlgorithm.ts","../src/JWT.ts","../src/JWE.ts","../src/ECDH.ts","../src/xc20pEncryption.ts"],"sourcesContent":["import * as u8a from 'uint8arrays'\nimport { bases } from 'multiformats/basics'\n\n/**\n * @deprecated Signers will be expected to return base64url `string` signatures.\n */\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number | null\n}\n\nexport function bytesToBase64url(b: Uint8Array): string {\n  return u8a.toString(b, 'base64url')\n}\n\nexport function base64ToBytes(s: string): Uint8Array {\n  const inputBase64Url = s.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n  return u8a.fromString(inputBase64Url, 'base64url')\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return u8a.toString(b, 'base64pad')\n}\n\nexport function base58ToBytes(s: string): Uint8Array {\n  return u8a.fromString(s, 'base58btc')\n}\n\nexport function bytesToBase58(b: Uint8Array): string {\n  return u8a.toString(b, 'base58btc')\n}\n\nexport function bytesToMultibase(b: Uint8Array, base: keyof typeof bases): string {\n  return bases[base].encode(b)\n}\n\nexport function hexToBytes(s: string): Uint8Array {\n  const input = s.startsWith('0x') ? s.substring(2) : s\n  return u8a.fromString(input.toLowerCase(), 'base16')\n}\n\nexport function encodeBase64url(s: string): string {\n  return bytesToBase64url(u8a.fromString(s))\n}\n\nexport function decodeBase64url(s: string): string {\n  return u8a.toString(base64ToBytes(s))\n}\n\nexport function bytesToHex(b: Uint8Array): string {\n  return u8a.toString(b, 'base16')\n}\n\nexport function stringToBytes(s: string): Uint8Array {\n  return u8a.fromString(s)\n}\n\nexport function toJose({ r, s, recoveryParam }: EcdsaSignature, recoverable?: boolean): string {\n  const jose = new Uint8Array(recoverable ? 65 : 64)\n  jose.set(u8a.fromString(r, 'base16'), 0)\n  jose.set(u8a.fromString(s, 'base16'), 32)\n  if (recoverable) {\n    if (typeof recoveryParam === 'undefined') {\n      throw new Error('Signer did not return a recoveryParam')\n    }\n    jose[64] = <number>recoveryParam\n  }\n  return bytesToBase64url(jose)\n}\n\nexport function fromJose(signature: string): { r: string; s: string; recoveryParam?: number } {\n  const signatureBytes: Uint8Array = base64ToBytes(signature)\n  if (signatureBytes.length < 64 || signatureBytes.length > 65) {\n    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`)\n  }\n  const r = bytesToHex(signatureBytes.slice(0, 32))\n  const s = bytesToHex(signatureBytes.slice(32, 64))\n  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : undefined\n  return { r, s, recoveryParam }\n}\n\nexport function toSealed(ciphertext: string, tag: string): Uint8Array {\n  return u8a.concat([base64ToBytes(ciphertext), base64ToBytes(tag)])\n}\n\nconst hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/\nconst base58Matcher = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/\nconst base64Matcher = /^([0-9a-zA-Z=\\-_+/]{43}|[0-9a-zA-Z=\\-_+/]{86})(={0,2})$/\n\n/**\n * Parses a private key and returns the Uint8Array representation.\n * This method uses an heuristic to determine the key encoding to then be able to parse it into 32 or 64 bytes.\n *\n * @param input a 32 or 64 byte key presented either as a Uint8Array or as a hex, base64, or base58btc encoded string\n *\n * @throws TypeError('Invalid private key format') if the key doesn't match any of the accepted formats or length\n */\nexport function parseKey(input: string | Uint8Array): Uint8Array {\n  if (typeof input === 'string') {\n    if (hexMatcher.test(input)) {\n      return hexToBytes(input)\n    } else if (base58Matcher.test(input)) {\n      return base58ToBytes(input)\n    } else if (base64Matcher.test(input)) {\n      return base64ToBytes(input)\n    } else {\n      throw TypeError('bad_key: Invalid private key format')\n    }\n  } else if (input instanceof Uint8Array) {\n    return input\n  } else {\n    throw TypeError('bad_key: Invalid private key format')\n  }\n}\n\nexport function leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n","import { hash } from '@stablelib/sha256'\nimport * as u8a from 'uint8arrays'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\n\nexport function sha256(payload: string | Uint8Array): Uint8Array {\n  const data = typeof payload === 'string' ? u8a.fromString(payload) : payload\n  return hash(data)\n}\n\nexport function keccak(data: Uint8Array): Uint8Array {\n  return new Uint8Array(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress(hexPublicKey: string): string {\n  const hashInput = u8a.fromString(hexPublicKey.slice(2), 'base16')\n  return `0x${u8a.toString(keccak(hashInput).slice(-20), 'base16')}`\n}\n\nfunction writeUint32BE(value: number, array = new Uint8Array(4)): Uint8Array {\n  const encoded = u8a.fromString(value.toString(), 'base10')\n  array.set(encoded, 4 - encoded.length)\n  return array\n}\n\nconst lengthAndInput = (input: Uint8Array): Uint8Array => u8a.concat([writeUint32BE(input.length), input])\n\n// This implementation of concatKDF was inspired by these two implementations:\n// https://github.com/digitalbazaar/minimal-cipher/blob/master/algorithms/ecdhkdf.js\n// https://github.com/panva/jose/blob/master/lib/jwa/ecdh/derive.js\nexport function concatKDF(\n  secret: Uint8Array,\n  keyLen: number,\n  alg: string,\n  producerInfo?: Uint8Array,\n  consumerInfo?: Uint8Array\n): Uint8Array {\n  if (keyLen !== 256) throw new Error(`Unsupported key length: ${keyLen}`)\n  const value = u8a.concat([\n    lengthAndInput(u8a.fromString(alg)),\n    lengthAndInput(typeof producerInfo === 'undefined' ? new Uint8Array(0) : producerInfo), // apu\n    lengthAndInput(typeof consumerInfo === 'undefined' ? new Uint8Array(0) : consumerInfo), // apv\n    writeUint32BE(keyLen),\n  ])\n\n  // since our key lenght is 256 we only have to do one round\n  const roundNumber = 1\n  return hash(u8a.concat([writeUint32BE(roundNumber), secret, value]))\n}\n","import { parseKey, leftpad } from '../util'\nimport { toJose } from '../util'\nimport { Signer } from '../JWT'\nimport { sha256 } from '../Digest'\n\nimport { ec as EC, ec } from 'elliptic'\nconst secp256k1: EC = new EC('secp256k1')\n\n/**\n *  Creates a configured signer function for signing data using the ES256K (secp256k1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    privateKey   a private key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\n *  @param    {Boolean}   recoverable  an optional flag to add the recovery param to the generated signatures\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function ES256KSigner(privateKey: string | Uint8Array, recoverable = false): Signer {\n  const privateKeyBytes: Uint8Array = parseKey(privateKey)\n  if (privateKeyBytes.length !== 32) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${privateKeyBytes.length}`)\n  }\n  const keyPair: ec.KeyPair = secp256k1.keyFromPrivate(privateKeyBytes)\n\n  return async (data: string | Uint8Array): Promise<string> => {\n    const { r, s, recoveryParam }: EC.Signature = keyPair.sign(sha256(data))\n    return toJose(\n      {\n        r: leftpad(r.toString('hex')),\n        s: leftpad(s.toString('hex')),\n        recoveryParam,\n      },\n      recoverable\n    )\n  }\n}\n","import { fromJose } from '../util'\nimport { Signer } from '../JWT'\nimport { ES256KSigner } from './ES256KSigner'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The SimpleSigner returns a configured function for signing data.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  const signer = ES256KSigner(hexPrivateKey, true)\n  return async (data) => {\n    const signature = (await signer(data)) as string\n    return fromJose(signature)\n  }\n}\n\nexport default SimpleSigner\n","import { Signer } from '../JWT'\nimport { ES256KSigner } from './ES256KSigner'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The EllipticSigner returns a configured function for signing data.\n *\n *  @example\n *  ```typescript\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *  ```\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                        a configured signer function\n */\nfunction EllipticSigner(hexPrivateKey: string): Signer {\n  return ES256KSigner(hexPrivateKey)\n}\n\nexport default EllipticSigner\n","import { sign } from '@stablelib/ed25519'\nimport { Signer } from '../JWT'\nimport { bytesToBase64url, parseKey, stringToBytes } from '../util'\n\n/**\n *  Creates a configured signer function for signing data using the EdDSA (Ed25519) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = EdDSASigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    secretKey   a 64 byte secret key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\n *  @return   {Function}              a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function EdDSASigner(secretKey: string | Uint8Array): Signer {\n  const privateKeyBytes: Uint8Array = parseKey(secretKey)\n  if (privateKeyBytes.length !== 64) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 64 bytes, but got ${privateKeyBytes.length}`)\n  }\n  return async (data: string | Uint8Array): Promise<string> => {\n    const dataBytes: Uint8Array = typeof data === 'string' ? stringToBytes(data) : data\n    const sig: Uint8Array = sign(privateKeyBytes, dataBytes)\n    return bytesToBase64url(sig)\n  }\n}\n","import { EdDSASigner as EdDSASigner } from './EdDSASigner'\nimport { Signer } from '../JWT'\n\n/**\n * @deprecated Please use EdDSASigner\n *\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm.\n *\n *  The signing function itself takes the data as a `string` or `Uint8Array` parameter and returns a `base64Url`-encoded signature.\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  const data: string = '...'\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *\n *  @param    {String}   base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  return EdDSASigner(base64PrivateKey)\n}\n\nexport default NaclSigner\n","import { Signer, SignerAlgorithm } from './JWT'\nimport { EcdsaSignature, fromJose, toJose } from './util'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSignerAlg(recoverable?: boolean): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature, recoverable)\n    } else {\n      if (recoverable && typeof fromJose(signature).recoveryParam === 'undefined') {\n        throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`)\n      }\n      return signature\n    }\n  }\n}\n\nexport function Ed25519SignerAlg(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error('invalid_config: expected a signer function that returns a string instead of signature object')\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSignerAlg(),\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': ES256KSignerAlg(true),\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: Ed25519SignerAlg(),\n  EdDSA: Ed25519SignerAlg(),\n}\n\nfunction SignerAlg(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlg\n","import { ec as EC, SignatureInput } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport { verify } from '@stablelib/ed25519'\nimport type { VerificationMethod } from 'did-resolver'\nimport { bases } from 'multiformats/basics'\nimport { hexToBytes, base58ToBytes, base64ToBytes, bytesToHex, EcdsaSignature, stringToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(signature: string, recoverable = false): EcdsaSignature {\n  const rawSig: Uint8Array = base64ToBytes(signature)\n  if (rawSig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = bytesToHex(rawSig.slice(0, 32))\n  const s: string = bytesToHex(rawSig.slice(32, 64))\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawSig[64]\n  }\n  return sigObj\n}\n\ninterface LegacyVerificationMethod extends VerificationMethod {\n  publicKeyBase64: string\n}\n\nfunction extractPublicKeyBytes(pk: VerificationMethod): Uint8Array {\n  if (pk.publicKeyBase58) {\n    return base58ToBytes(pk.publicKeyBase58)\n  } else if ((<LegacyVerificationMethod>pk).publicKeyBase64) {\n    return base64ToBytes((<LegacyVerificationMethod>pk).publicKeyBase64)\n  } else if (pk.publicKeyHex) {\n    return hexToBytes(pk.publicKeyHex)\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'secp256k1' && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {\n    return hexToBytes(\n      secp256k1\n        .keyFromPublic({\n          x: bytesToHex(base64ToBytes(pk.publicKeyJwk.x)),\n          y: bytesToHex(base64ToBytes(pk.publicKeyJwk.y)),\n        })\n        .getPublic('hex')\n    )\n  } else if (pk.publicKeyMultibase) {\n    const { base16, base58btc, base64, base64url } = bases\n    const baseDecoder = base16.decoder.or(base58btc.decoder.or(base64.decoder.or(base64url.decoder)))\n    return baseDecoder.decode(pk.publicKeyMultibase)\n  }\n  return new Uint8Array()\n}\n\nexport function verifyES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const hash: Uint8Array = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const fullPublicKeys = authenticators.filter(({ ethereumAddress, blockchainAccountId }) => {\n    return typeof ethereumAddress === 'undefined' && typeof blockchainAccountId === 'undefined'\n  })\n  const ethAddressKeys = authenticators.filter(({ ethereumAddress, blockchainAccountId }) => {\n    return typeof ethereumAddress !== 'undefined' || typeof blockchainAccountId !== undefined\n  })\n\n  let signer: VerificationMethod | undefined = fullPublicKeys.find((pk: VerificationMethod) => {\n    try {\n      const pubBytes = extractPublicKeyBytes(pk)\n      return secp256k1.keyFromPublic(pubBytes).verify(hash, <SignatureInput>sigObj)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer && ethAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, ethAddressKeys)\n  }\n\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  let signatures: EcdsaSignature[]\n  if (signature.length > 86) {\n    signatures = [toSignatureObject(signature, true)]\n  } else {\n    const so = toSignatureObject(signature, false)\n    signatures = [\n      { ...so, recoveryParam: 0 },\n      { ...so, recoveryParam: 1 },\n    ]\n  }\n\n  const checkSignatureAgainstSigner = (sigObj: EcdsaSignature): VerificationMethod | undefined => {\n    const hash: Uint8Array = sha256(data)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const recoveredKey: any = secp256k1.recoverPubKey(hash, <SignatureInput>sigObj, <number>sigObj.recoveryParam)\n    const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n    const recoveredCompressedPublicKeyHex: string = recoveredKey.encode('hex', true)\n    const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n\n    const signer: VerificationMethod | undefined = authenticators.find((pk: VerificationMethod) => {\n      const keyHex = bytesToHex(extractPublicKeyBytes(pk))\n      return (\n        keyHex === recoveredPublicKeyHex ||\n        keyHex === recoveredCompressedPublicKeyHex ||\n        pk.ethereumAddress?.toLowerCase() === recoveredAddress ||\n        pk.blockchainAccountId?.split('@eip155')?.[0].toLowerCase() === recoveredAddress\n      )\n    })\n\n    return signer\n  }\n\n  const signer: VerificationMethod[] = signatures\n    .map(checkSignatureAgainstSigner)\n    .filter((key) => typeof key !== 'undefined') as VerificationMethod[]\n\n  if (signer.length === 0) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer[0]\n}\n\nexport function verifyEd25519(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const clear: Uint8Array = stringToBytes(data)\n  const sig: Uint8Array = base64ToBytes(signature)\n  const signer = authenticators.find((pk: VerificationMethod) => {\n    return verify(extractPublicKeyBytes(pk), clear, sig)\n  })\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (data: string, signature: string, authenticators: VerificationMethod[]) => VerificationMethod\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': verifyRecoverableES256K,\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: verifyEd25519,\n  EdDSA: verifyEd25519,\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import canonicalizeData from 'canonicalize'\nimport type { DIDDocument, DIDResolutionResult, Resolvable, VerificationMethod } from 'did-resolver'\nimport SignerAlg from './SignerAlgorithm'\nimport { decodeBase64url, EcdsaSignature, encodeBase64url } from './util'\nimport VerifierAlgorithm from './VerifierAlgorithm'\n\nexport type Signer = (data: string | Uint8Array) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (payload: string, signer: Signer) => Promise<string>\n\nexport type ProofPurposeTypes =\n  | 'assertionMethod'\n  | 'authentication'\n  // | 'keyAgreement' // keyAgreement VerificationMethod should not be used for signing\n  | 'capabilityDelegation'\n  | 'capabilityInvocation'\n\nexport interface JWTOptions {\n  issuer: string\n  signer: Signer\n  /**\n   * @deprecated Please use `header.alg` to specify the JWT algorithm.\n   */\n  alg?: string\n  expiresIn?: number\n  canonicalize?: boolean\n}\n\nexport interface JWTVerifyOptions {\n  /** @deprecated Please use `proofPurpose: 'authentication' instead` */\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n  resolver?: Resolvable\n  skewTime?: number\n  /** See https://www.w3.org/TR/did-spec-registries/#verification-relationships */\n  proofPurpose?: ProofPurposeTypes\n}\n\nexport interface JWSCreationOptions {\n  canonicalize?: boolean\n}\n\nexport interface DIDAuthenticator {\n  authenticators: VerificationMethod[]\n  issuer: string\n  didResolutionResult: DIDResolutionResult\n}\n\nexport interface JWTHeader {\n  typ: 'JWT'\n  alg: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport interface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string | string[]\n  iat?: number\n  nbf?: number\n  exp?: number\n  rexp?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport interface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\nexport interface JWSDecoded {\n  header: JWTHeader\n  payload: string\n  signature: string\n  data: string\n}\n\nexport interface JWTVerified {\n  payload: Partial<JWTPayload>\n  didResolutionResult: DIDResolutionResult\n  issuer: string\n  signer: VerificationMethod\n  jwt: string\n}\n\nexport interface PublicKeyTypes {\n  [name: string]: string[]\n}\nexport const SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1',\n  ],\n  'ES256K-R': [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1',\n  ],\n  Ed25519: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018'],\n  EdDSA: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018'],\n}\n\nexport const SELF_ISSUED_V2 = 'https://self-issued.me/v2'\nexport const SELF_ISSUED_V0_1 = 'https://self-issued.me'\n\ntype LegacyVerificationMethod = { publicKey?: string }\n\nconst defaultAlg = 'ES256K'\nconst DID_JSON = 'application/did+json'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction encodeSection(data: any, shouldCanonicalize = false): string {\n  if (shouldCanonicalize) {\n    return encodeBase64url(<string>canonicalizeData(data))\n  } else {\n    return encodeBase64url(JSON.stringify(data))\n  }\n}\n\nexport const NBF_SKEW = 300\n\nfunction decodeJWS(jws: string): JWSDecoded {\n  const parts = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/)\n  if (parts) {\n    return {\n      header: JSON.parse(decodeBase64url(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`,\n    }\n  }\n  throw new Error('invalid_argument: Incorrect format JWS')\n}\n\n/**  @module did-jwt/JWT */\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('invalid_argument: no JWT passed into decodeJWT')\n  try {\n    const jws = decodeJWS(jwt)\n    const decodedJwt: JWTDecoded = Object.assign(jws, { payload: JSON.parse(decodeBase64url(jws.payload)) })\n    return decodedJwt\n  } catch (e) {\n    throw new Error('invalid_argument: Incorrect format JWT')\n  }\n}\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {Signer}            signer            a signer, see `ES256KSigner or `EdDSASigner`\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @param    {Object}            options           can be used to trigger automatic canonicalization of header and\n *                                                    payload properties\n *  @return   {Promise<string>}                     a Promise which resolves to a JWS string or rejects with an error\n */\nexport async function createJWS(\n  payload: string | Partial<JWTPayload>,\n  signer: Signer,\n  header: Partial<JWTHeader> = {},\n  options: JWSCreationOptions = {}\n): Promise<string> {\n  if (!header.alg) header.alg = defaultAlg\n  const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize)\n  const signingInput: string = [encodeSection(header, options.canonicalize), encodedPayload].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlg(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload               payload object\n *  @param    {Object}            [options]             an unsigned credential object\n *  @param    {String}            options.issuer        The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg           [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K.\n *                                                      Please use `header.alg` to specify the algorithm\n *  @param    {Signer}            options.signer        a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\n *  @param    {Object}            header                optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or rejects with an error\n */\nexport async function createJWT(\n  payload: Partial<JWTPayload>,\n  { issuer, signer, alg, expiresIn, canonicalize }: JWTOptions,\n  header: Partial<JWTHeader> = {}\n): Promise<string> {\n  if (!signer) throw new Error('missing_signer: No Signer functionality has been configured')\n  if (!issuer) throw new Error('missing_issuer: No issuing DID has been configured')\n  if (!header.typ) header.typ = 'JWT'\n  if (!header.alg) header.alg = alg\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined,\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = <number>(payload.nbf || timestamps.iat) + Math.floor(expiresIn)\n    } else {\n      throw new Error('invalid_argument: JWT expiresIn is not a number')\n    }\n  }\n  const fullPayload = { ...timestamps, ...payload, iss: issuer }\n  return createJWS(fullPayload, signer, header, { canonicalize })\n}\n\nfunction verifyJWSDecoded(\n  { header, data, signature }: JWSDecoded,\n  pubKeys: VerificationMethod | VerificationMethod[]\n): VerificationMethod {\n  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys]\n  const signer: VerificationMethod = VerifierAlgorithm(header.alg)(data, signature, pubKeys)\n  return signer\n}\n\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubKeys` match.\n *\n *  @example\n *  const pubKey = verifyJWS('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<VerificationMethod> | VerificationMethod}    pubKeys     The public keys used to verify the JWS\n *  @return   {VerificationMethod}                       The public key used to sign the JWS\n */\nexport function verifyJWS(jws: string, pubKeys: VerificationMethod | VerificationMethod[]): VerificationMethod {\n  const jwsDecoded: JWSDecoded = decodeJWS(jws)\n  return verifyJWSDecoded(jwsDecoded, pubKeys)\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = {\n    resolver: undefined,\n    auth: undefined,\n    audience: undefined,\n    callbackUrl: undefined,\n    skewTime: undefined,\n    proofPurpose: undefined,\n  }\n): Promise<JWTVerified> {\n  if (!options.resolver) throw new Error('missing_resolver: No DID resolver has been configured')\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const proofPurpose: ProofPurposeTypes | undefined = Object.prototype.hasOwnProperty.call(options, 'auth')\n    ? options.auth\n      ? 'authentication'\n      : undefined\n    : options.proofPurpose\n  if (!payload.iss) {\n    throw new Error('invalid_jwt: JWT iss is required')\n  }\n  let did = ''\n  if (payload.iss === SELF_ISSUED_V2) {\n    if (!payload.sub) {\n      throw new Error('invalid_jwt: JWT sub is required')\n    }\n    if (typeof payload.sub_jwk === 'undefined') {\n      did = payload.sub\n    } else {\n      did = (header.kid || '').split('#')[0]\n    }\n  } else if (payload.iss === SELF_ISSUED_V0_1) {\n    if (!payload.did) {\n      throw new Error('invalid_jwt: JWT did is required')\n    }\n    did = payload.did\n  } else {\n    did = payload.iss\n  }\n  if (!did) {\n    throw new Error(`invalid_jwt: No DID has been found in the JWT`)\n  }\n  const { didResolutionResult, authenticators, issuer }: DIDAuthenticator = await resolveAuthenticator(\n    options.resolver,\n    header.alg,\n    did,\n    proofPurpose\n  )\n  const signer: VerificationMethod = await verifyJWSDecoded({ header, data, signature } as JWSDecoded, authenticators)\n  const now: number = Math.floor(Date.now() / 1000)\n  const skewTime = typeof options.skewTime !== 'undefined' && options.skewTime >= 0 ? options.skewTime : NBF_SKEW\n  if (signer) {\n    const nowSkewed = now + skewTime\n    if (payload.nbf) {\n      if (payload.nbf > nowSkewed) {\n        throw new Error(`invalid_jwt: JWT not valid before nbf: ${payload.nbf}`)\n      }\n    } else if (payload.iat && payload.iat > nowSkewed) {\n      throw new Error(`invalid_jwt: JWT not valid yet (issued in the future) iat: ${payload.iat}`)\n    }\n    if (payload.exp && payload.exp <= now - skewTime) {\n      throw new Error(`invalid_jwt: JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (!options.audience && !options.callbackUrl) {\n        throw new Error('invalid_config: JWT audience is required but your app address has not been configured')\n      }\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      const matchedAudience = audArray.find((item) => options.audience === item || options.callbackUrl === item)\n\n      if (typeof matchedAudience === 'undefined') {\n        throw new Error(`invalid_config: JWT audience does not match your DID or callback url`)\n      }\n    }\n    return { payload, didResolutionResult, issuer, signer, jwt }\n  }\n  throw new Error(\n    `invalid_signature: JWT not valid. issuer DID document does not contain a verificationMethod that matches the signature.`\n  )\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<DIDAuthenticator>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  resolver: Resolvable,\n  alg: string,\n  issuer: string,\n  proofPurpose?: ProofPurposeTypes\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`not_supported: No supported signature types for algorithm ${alg}`)\n  }\n  let didResult: DIDResolutionResult\n\n  const result = (await resolver.resolve(issuer, { accept: DID_JSON })) as unknown\n  // support legacy resolvers that do not produce DIDResolutionResult\n  if (Object.getOwnPropertyNames(result).indexOf('didDocument') === -1) {\n    didResult = {\n      didDocument: result as DIDDocument,\n      didDocumentMetadata: {},\n      didResolutionMetadata: { contentType: DID_JSON },\n    }\n  } else {\n    didResult = result as DIDResolutionResult\n  }\n\n  if (didResult.didResolutionMetadata?.error || didResult.didDocument == null) {\n    const { error, message } = didResult.didResolutionMetadata\n    throw new Error(`resolver_error: Unable to resolve DID document for ${issuer}: ${error}, ${message || ''}`)\n  }\n\n  const getPublicKeyById = (verificationMethods: VerificationMethod[], pubid?: string): VerificationMethod | null => {\n    const filtered = verificationMethods.filter(({ id }) => pubid === id)\n    return filtered.length > 0 ? filtered[0] : null\n  }\n\n  let publicKeysToCheck: VerificationMethod[] = [\n    ...(didResult?.didDocument?.verificationMethod || []),\n    ...(didResult?.didDocument?.publicKey || []),\n  ]\n  if (typeof proofPurpose === 'string') {\n    // support legacy DID Documents that do not list assertionMethod\n    if (\n      proofPurpose.startsWith('assertion') &&\n      !Object.getOwnPropertyNames(didResult?.didDocument).includes('assertionMethod')\n    ) {\n      didResult.didDocument = { ...(<DIDDocument>didResult.didDocument) }\n      didResult.didDocument.assertionMethod = [...publicKeysToCheck.map((pk) => pk.id)]\n    }\n\n    publicKeysToCheck = (didResult.didDocument[proofPurpose] || [])\n      .map((verificationMethod) => {\n        if (typeof verificationMethod === 'string') {\n          return getPublicKeyById(publicKeysToCheck, verificationMethod)\n        } else if (typeof (<LegacyVerificationMethod>verificationMethod).publicKey === 'string') {\n          // this is a legacy format\n          return getPublicKeyById(publicKeysToCheck, (<LegacyVerificationMethod>verificationMethod).publicKey)\n        } else {\n          return <VerificationMethod>verificationMethod\n        }\n      })\n      .filter((key) => key != null) as VerificationMethod[]\n  }\n\n  const authenticators: VerificationMethod[] = publicKeysToCheck.filter(({ type }) =>\n    types.find((supported) => supported === type)\n  )\n\n  if (typeof proofPurpose === 'string' && (!authenticators || authenticators.length === 0)) {\n    throw new Error(\n      `no_suitable_keys: DID document for ${issuer} does not have public keys suitable for ${alg} with ${proofPurpose} purpose`\n    )\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(`no_suitable_keys: DID document for ${issuer} does not have public keys for ${alg}`)\n  }\n  return { authenticators, issuer, didResolutionResult: didResult }\n}\n","import { base64ToBytes, bytesToBase64url, decodeBase64url, toSealed } from './util'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ProtectedHeader = Record<string, any> & Partial<RecipientHeader>\n\n/**\n * The JWK representation of an ephemeral public key.\n * See https://www.rfc-editor.org/rfc/rfc7518.html#section-6\n */\ninterface EphemeralPublicKey {\n  kty?: string\n  //ECC\n  crv?: string\n  x?: string\n  y?: string\n  //RSA\n  n?: string\n  e?: string\n}\n\nexport interface RecipientHeader {\n  alg: string\n  iv: string\n  tag: string\n  epk?: EphemeralPublicKey\n  kid?: string\n  apv?: string\n  apu?: string\n}\n\nexport interface Recipient {\n  header: RecipientHeader\n  encrypted_key: string\n}\n\nexport interface JWE {\n  protected: string\n  iv: string\n  ciphertext: string\n  tag: string\n  aad?: string\n  recipients?: Recipient[]\n}\n\nexport interface EncryptionResult {\n  ciphertext: Uint8Array\n  tag: Uint8Array\n  iv: Uint8Array\n  protectedHeader?: string\n  recipient?: Recipient\n  cek?: Uint8Array\n}\n\nexport interface Encrypter {\n  alg: string\n  enc: string\n  encrypt: (cleartext: Uint8Array, protectedHeader: ProtectedHeader, aad?: Uint8Array) => Promise<EncryptionResult>\n  encryptCek?: (cek: Uint8Array) => Promise<Recipient>\n}\n\nexport interface Decrypter {\n  alg: string\n  enc: string\n  decrypt: (sealed: Uint8Array, iv: Uint8Array, aad?: Uint8Array, recipient?: Recipient) => Promise<Uint8Array | null>\n}\n\nfunction validateJWE(jwe: JWE) {\n  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {\n    throw new Error('bad_jwe: missing properties')\n  }\n  if (jwe.recipients) {\n    jwe.recipients.map((rec) => {\n      if (!(rec.header && rec.encrypted_key)) {\n        throw new Error('bad_jwe: malformed recipients')\n      }\n    })\n  }\n}\n\nfunction encodeJWE({ ciphertext, tag, iv, protectedHeader, recipient }: EncryptionResult, aad?: Uint8Array): JWE {\n  const jwe: JWE = {\n    protected: <string>protectedHeader,\n    iv: bytesToBase64url(iv),\n    ciphertext: bytesToBase64url(ciphertext),\n    tag: bytesToBase64url(tag),\n  }\n  if (aad) jwe.aad = bytesToBase64url(aad)\n  if (recipient) jwe.recipients = [recipient]\n  return jwe\n}\n\nexport async function createJWE(\n  cleartext: Uint8Array,\n  encrypters: Encrypter[],\n  protectedHeader = {},\n  aad?: Uint8Array\n): Promise<JWE> {\n  if (encrypters[0].alg === 'dir') {\n    if (encrypters.length > 1) throw new Error('not_supported: Can only do \"dir\" encryption to one key.')\n    const encryptionResult = await encrypters[0].encrypt(cleartext, protectedHeader, aad)\n    return encodeJWE(encryptionResult, aad)\n  } else {\n    const tmpEnc = encrypters[0].enc\n    if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {\n      throw new Error('invalid_argument: Incompatible encrypters passed')\n    }\n    let cek\n    let jwe\n    for (const encrypter of encrypters) {\n      if (!cek) {\n        const encryptionResult = await encrypter.encrypt(cleartext, protectedHeader, aad)\n        cek = encryptionResult.cek\n        jwe = encodeJWE(encryptionResult, aad)\n      } else {\n        const recipient = await encrypter.encryptCek?.(cek)\n        if (recipient) {\n          jwe?.recipients?.push(recipient)\n        }\n      }\n    }\n    return <JWE>jwe\n  }\n}\n\nexport async function decryptJWE(jwe: JWE, decrypter: Decrypter): Promise<Uint8Array> {\n  validateJWE(jwe)\n  const protHeader = JSON.parse(decodeBase64url(jwe.protected))\n  if (protHeader.enc !== decrypter.enc)\n    throw new Error(`not_supported: Decrypter does not supported: '${protHeader.enc}'`)\n  const sealed = toSealed(jwe.ciphertext, jwe.tag)\n  const aad = new Uint8Array(Buffer.from(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected))\n  let cleartext = null\n  if (protHeader.alg === 'dir' && decrypter.alg === 'dir') {\n    cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)\n  } else if (!jwe.recipients || jwe.recipients.length === 0) {\n    throw new Error('bad_jwe: missing recipients')\n  } else {\n    for (let i = 0; !cleartext && i < jwe.recipients.length; i++) {\n      const recipient = jwe.recipients[i]\n      Object.assign(recipient.header, protHeader)\n      if (recipient.header.alg === decrypter.alg) {\n        cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)\n      }\n    }\n  }\n  if (cleartext === null) throw new Error('failure: Failed to decrypt')\n  return cleartext\n}\n","import { sharedKey } from '@stablelib/x25519'\n\n/**\n * A wrapper around `mySecretKey` that can compute a shared secret using `theirPublicKey`.\n * The promise should resolve to a `Uint8Array` containing the raw shared secret.\n *\n * This method is meant to be used when direct access to a secret key is impossible or not desired.\n *\n * @param theirPublicKey `Uint8Array` the other party's public key\n * @returns a `Promise` that resolves to a `Uint8Array` representing the computed shared secret\n */\nexport type ECDH = (theirPublicKey: Uint8Array) => Promise<Uint8Array>\n\n/**\n * Wraps an X25519 secret key into an ECDH method that can be used to compute a shared secret with a public key.\n * @param mySecretKey A `Uint8Array` of length 32 representing the bytes of my secret key\n * @returns an `ECDH` method with the signature `(theirPublicKey: Uint8Array) => Promise<Uint8Array>`\n *\n * @throws 'invalid_argument:...' if the secret key size is wrong\n */\nexport function createX25519ECDH(mySecretKey: Uint8Array): ECDH {\n  if (mySecretKey.length !== 32) {\n    throw new Error('invalid_argument: incorrect secret key length for X25519')\n  }\n  return async (theirPublicKey: Uint8Array): Promise<Uint8Array> => {\n    if (theirPublicKey.length !== 32) {\n      throw new Error('invalid_argument: incorrect publicKey key length for X25519')\n    }\n    return sharedKey(mySecretKey, theirPublicKey)\n  }\n}\n","import { XChaCha20Poly1305 } from '@stablelib/xchacha20poly1305'\nimport { generateKeyPair, sharedKey } from '@stablelib/x25519'\nimport { randomBytes } from '@stablelib/random'\nimport { concatKDF } from './Digest'\nimport { bytesToBase64url, base58ToBytes, encodeBase64url, toSealed, base64ToBytes } from './util'\nimport { Recipient, EncryptionResult, Encrypter, Decrypter, ProtectedHeader } from './JWE'\nimport type { VerificationMethod, Resolvable } from 'did-resolver'\nimport { ECDH } from './ECDH'\n\n/**\n * Extra parameters for JWE using authenticated encryption\n */\nexport type AuthEncryptParams = {\n  /**\n   * recipient key ID\n   */\n  kid?: string\n\n  /**\n   * See {@link https://datatracker.ietf.org/doc/html/rfc7518#section-4.6.1.2}\n   * base64url encoded\n   */\n  apu?: string\n\n  /**\n   * See {@link https://datatracker.ietf.org/doc/html/rfc7518#section-4.6.1.3}\n   * base64url encoded\n   */\n  apv?: string\n}\n\n/**\n * Extra parameters for JWE using anonymous encryption\n */\nexport type AnonEncryptParams = {\n  /**\n   * recipient key ID\n   */\n  kid?: string\n}\n\n/**\n * Recommended encrypter for authenticated encryption (i.e. sender authentication and requires\n * sender private key to encrypt the data).\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n * @param recipientPublicKey the byte array representing the recipient public key\n * @param senderSecret either a Uint8Array representing the sender secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n * @param options {@link AuthEncryptParams} used to specify extra header parameters\n *\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the official CFRG specification are released.\n *\n * @beta\n */\nexport function createAuthEncrypter(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  return xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecret, options)\n}\n\n/**\n * Recommended encrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2}.\n *\n * @param publicKey the byte array representing the recipient public key\n * @param options {@link AnonEncryptParams} used to specify the recipient key ID (`kid`)\n *\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n *\n * @beta\n */\nexport function createAnonEncrypter(publicKey: Uint8Array, options: Partial<AnonEncryptParams> = {}): Encrypter {\n  return x25519Encrypter(publicKey, options?.kid)\n}\n\n/**\n * Recommended decrypter for authenticated encryption (i.e. sender authentication and requires\n * sender public key to decrypt the data).\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n * @param recipientSecret either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n * @param senderPublicKey the byte array representing the sender public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the official CFRG specification are released.\n *\n * @beta\n */\nexport function createAuthDecrypter(recipientSecret: Uint8Array | ECDH, senderPublicKey: Uint8Array): Decrypter {\n  return xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecret, senderPublicKey)\n}\n\n/**\n * Recommended decrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2 }.\n *\n * @param recipientSecret either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n *\n * @beta\n */\nexport function createAnonDecrypter(recipientSecret: Uint8Array | ECDH): Decrypter {\n  return x25519Decrypter(recipientSecret)\n}\n\nfunction xc20pEncrypter(key: Uint8Array): (cleartext: Uint8Array, aad?: Uint8Array) => EncryptionResult {\n  const cipher = new XChaCha20Poly1305(key)\n  return (cleartext: Uint8Array, aad?: Uint8Array) => {\n    const iv = randomBytes(cipher.nonceLength)\n    const sealed = cipher.seal(iv, cleartext, aad)\n    return {\n      ciphertext: sealed.subarray(0, sealed.length - cipher.tagLength),\n      tag: sealed.subarray(sealed.length - cipher.tagLength),\n      iv,\n    }\n  }\n}\n\nexport function xc20pDirEncrypter(key: Uint8Array): Encrypter {\n  const xc20pEncrypt = xc20pEncrypter(key)\n  const enc = 'XC20P'\n  const alg = 'dir'\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array\n  ): Promise<EncryptionResult> {\n    const protHeader = encodeBase64url(JSON.stringify(Object.assign({ alg }, protectedHeader, { enc })))\n    const encodedAad = new Uint8Array(Buffer.from(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader))\n    return {\n      ...xc20pEncrypt(cleartext, encodedAad),\n      protectedHeader: protHeader,\n    }\n  }\n  return { alg, enc, encrypt }\n}\n\nexport function xc20pDirDecrypter(key: Uint8Array): Decrypter {\n  const cipher = new XChaCha20Poly1305(key)\n  async function decrypt(sealed: Uint8Array, iv: Uint8Array, aad?: Uint8Array): Promise<Uint8Array | null> {\n    return cipher.open(iv, sealed, aad)\n  }\n  return { alg: 'dir', enc: 'XC20P', decrypt }\n}\n\nexport function x25519Encrypter(publicKey: Uint8Array, kid?: string): Encrypter {\n  const alg = 'ECDH-ES+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function encryptCek(cek: Uint8Array): Promise<Recipient> {\n    const epk = generateKeyPair()\n    const sharedSecret = sharedKey(epk.secretKey, publicKey)\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg)\n    const res = xc20pEncrypter(kek)(cek)\n    const recipient: Recipient = {\n      encrypted_key: bytesToBase64url(res.ciphertext),\n      header: {\n        alg,\n        iv: bytesToBase64url(res.iv),\n        tag: bytesToBase64url(res.tag),\n        epk: { kty: 'OKP', crv, x: bytesToBase64url(epk.publicKey) },\n      },\n    }\n    if (kid) recipient.header.kid = kid\n    return recipient\n  }\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array\n  ): Promise<EncryptionResult> {\n    // we won't want alg to be set to dir from xc20pDirEncrypter\n    Object.assign(protectedHeader, { alg: undefined })\n    // Content Encryption Key\n    const cek = randomBytes(32)\n    return {\n      ...(await xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)),\n      recipient: await encryptCek(cek),\n      cek,\n    }\n  }\n  return { alg, enc: 'XC20P', encrypt, encryptCek }\n}\n\n/**\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\nexport function xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  const alg = 'ECDH-1PU+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n\n  let partyUInfo: Uint8Array\n  let partyVInfo: Uint8Array\n  if (options.apu !== undefined) partyUInfo = base64ToBytes(options.apu)\n  if (options.apv !== undefined) partyVInfo = base64ToBytes(options.apv)\n\n  async function encryptCek(cek: Uint8Array): Promise<Recipient> {\n    const epk = generateKeyPair()\n    const zE = sharedKey(epk.secretKey, recipientPublicKey)\n\n    // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n    let zS\n    if (senderSecret instanceof Uint8Array) {\n      zS = sharedKey(senderSecret, recipientPublicKey)\n    } else {\n      zS = await senderSecret(recipientPublicKey)\n    }\n\n    const sharedSecret = new Uint8Array(zE.length + zS.length)\n    sharedSecret.set(zE)\n    sharedSecret.set(zS, zE.length)\n\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg, partyUInfo, partyVInfo)\n\n    const res = xc20pEncrypter(kek)(cek)\n    const recipient: Recipient = {\n      encrypted_key: bytesToBase64url(res.ciphertext),\n      header: {\n        alg,\n        iv: bytesToBase64url(res.iv),\n        tag: bytesToBase64url(res.tag),\n        epk: { kty: 'OKP', crv, x: bytesToBase64url(epk.publicKey) },\n      },\n    }\n    if (options.kid) recipient.header.kid = options.kid\n    if (options.apu) recipient.header.apu = options.apu\n    if (options.apv) recipient.header.apv = options.apv\n\n    return recipient\n  }\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array\n  ): Promise<EncryptionResult> {\n    // we won't want alg to be set to dir from xc20pDirEncrypter\n    Object.assign(protectedHeader, { alg: undefined })\n    // Content Encryption Key\n    const cek = randomBytes(32)\n    return {\n      ...(await xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)),\n      recipient: await encryptCek(cek),\n      cek,\n    }\n  }\n  return { alg, enc: 'XC20P', encrypt, encryptCek }\n}\n\nexport async function resolveX25519Encrypters(dids: string[], resolver: Resolvable): Promise<Encrypter[]> {\n  const encryptersForDID = async (did: string): Promise<Encrypter[]> => {\n    const { didResolutionMetadata, didDocument } = await resolver.resolve(did)\n    if (didResolutionMetadata?.error || didDocument == null) {\n      throw new Error(\n        `resolver_error: Could not resolve ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`\n      )\n    }\n    if (!didDocument.keyAgreement) throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`)\n    const agreementKeys: VerificationMethod[] = didDocument.keyAgreement\n      ?.map((key) => {\n        if (typeof key === 'string') {\n          return [...(didDocument.publicKey || []), ...(didDocument.verificationMethod || [])].find(\n            (pk) => pk.id === key\n          )\n        }\n        return key\n      })\n      .filter((key) => typeof key !== 'undefined') as VerificationMethod[]\n    const pks = agreementKeys.filter((key) => {\n      // TODO: should be able to use non base58 keys too\n      return key.type === 'X25519KeyAgreementKey2019' && Boolean(key.publicKeyBase58)\n    })\n    if (!pks.length) throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`)\n    return pks.map((pk) => x25519Encrypter(base58ToBytes(<string>pk.publicKeyBase58), pk.id))\n  }\n\n  const encrypterPromises = dids.map((did) => encryptersForDID(did))\n  const encrypterArrays = await Promise.all(encrypterPromises)\n  const flattenedArray = ([] as Encrypter[]).concat(...encrypterArrays)\n  return flattenedArray\n}\n\nfunction validateHeader(header?: ProtectedHeader) {\n  if (!(header && header.epk && header.iv && header.tag)) {\n    throw new Error('bad_jwe: malformed header')\n  }\n}\n\nexport function x25519Decrypter(receiverSecret: Uint8Array | ECDH): Decrypter {\n  const alg = 'ECDH-ES+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function decrypt(\n    sealed: Uint8Array,\n    iv: Uint8Array,\n    aad?: Uint8Array,\n    recipient?: Recipient\n  ): Promise<Uint8Array | null> {\n    validateHeader(recipient?.header)\n    recipient = <Recipient>recipient\n    if (recipient.header.epk?.crv !== crv || typeof recipient.header.epk.x == 'undefined') return null\n    const publicKey = base64ToBytes(recipient.header.epk.x)\n    let sharedSecret\n    if (receiverSecret instanceof Uint8Array) {\n      sharedSecret = sharedKey(receiverSecret, publicKey)\n    } else {\n      sharedSecret = await receiverSecret(publicKey)\n    }\n\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg)\n    // Content Encryption Key\n    const sealedCek = toSealed(<string>recipient.encrypted_key, recipient.header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n  return { alg, enc: 'XC20P', decrypt }\n}\n\n/**\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\nexport function xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientSecret: Uint8Array | ECDH,\n  senderPublicKey: Uint8Array\n): Decrypter {\n  const alg = 'ECDH-1PU+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function decrypt(\n    sealed: Uint8Array,\n    iv: Uint8Array,\n    aad?: Uint8Array,\n    recipient?: Recipient\n  ): Promise<Uint8Array | null> {\n    recipient = <Recipient>recipient\n    validateHeader(recipient.header)\n    if (recipient.header.epk?.crv !== crv || typeof recipient.header.epk.x == 'undefined') return null\n    // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n    const publicKey = base64ToBytes(recipient.header.epk.x)\n    let zE: Uint8Array\n    let zS: Uint8Array\n\n    if (recipientSecret instanceof Uint8Array) {\n      zE = sharedKey(recipientSecret, publicKey)\n      zS = sharedKey(recipientSecret, senderPublicKey)\n    } else {\n      zE = await recipientSecret(publicKey)\n      zS = await recipientSecret(senderPublicKey)\n    }\n\n    const sharedSecret = new Uint8Array(zE.length + zS.length)\n    sharedSecret.set(zE)\n    sharedSecret.set(zS, zE.length)\n\n    // Key Encryption Key\n    let producerInfo\n    let consumerInfo\n    if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu)\n    if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv)\n\n    const kek = concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo)\n    // Content Encryption Key\n    const sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n  return { alg, enc: 'XC20P', decrypt }\n}\n"],"names":["bytesToBase64url","b","u8a","toString","base64ToBytes","s","inputBase64Url","replace","fromString","base58ToBytes","hexToBytes","input","startsWith","substring","toLowerCase","encodeBase64url","decodeBase64url","bytesToHex","stringToBytes","toJose","r","recoveryParam","recoverable","jose","Uint8Array","set","Error","fromJose","signature","signatureBytes","length","TypeError","slice","undefined","toSealed","ciphertext","tag","concat","hexMatcher","base58Matcher","base64Matcher","parseKey","test","leftpad","data","size","repeat","sha256","payload","hash","keccak","keccak_256","arrayBuffer","toEthereumAddress","hexPublicKey","hashInput","writeUint32BE","value","array","encoded","lengthAndInput","concatKDF","secret","keyLen","alg","producerInfo","consumerInfo","roundNumber","secp256k1","EC","ES256KSigner","privateKey","privateKeyBytes","keyPair","keyFromPrivate","sign","SimpleSigner","hexPrivateKey","signer","EllipticSigner","EdDSASigner","secretKey","dataBytes","sig","NaclSigner","base64PrivateKey","instanceOfEcdsaSignature","object","ES256KSignerAlg","Ed25519SignerAlg","algorithms","ES256K","Ed25519","EdDSA","SignerAlg","impl","toSignatureObject","rawSig","sigObj","extractPublicKeyBytes","pk","publicKeyBase58","publicKeyBase64","publicKeyHex","publicKeyJwk","crv","x","y","keyFromPublic","getPublic","publicKeyMultibase","base16","base58btc","base64","base64url","bases","baseDecoder","decoder","or","decode","verifyES256K","authenticators","fullPublicKeys","filter","ethereumAddress","blockchainAccountId","ethAddressKeys","find","pubBytes","verify","err","verifyRecoverableES256K","signatures","so","checkSignatureAgainstSigner","recoveredKey","recoverPubKey","recoveredPublicKeyHex","encode","recoveredCompressedPublicKeyHex","recoveredAddress","keyHex","split","map","key","verifyEd25519","clear","VerifierAlgorithm","SUPPORTED_PUBLIC_KEY_TYPES","SELF_ISSUED_V2","SELF_ISSUED_V0_1","defaultAlg","DID_JSON","encodeSection","shouldCanonicalize","canonicalizeData","JSON","stringify","NBF_SKEW","decodeJWS","jws","parts","match","header","parse","decodeJWT","jwt","decodedJwt","Object","assign","e","createJWS","options","encodedPayload","canonicalize","signingInput","join","jwtSigner","createJWT","issuer","expiresIn","typ","timestamps","iat","Math","floor","Date","now","exp","nbf","fullPayload","iss","verifyJWSDecoded","pubKeys","Array","isArray","verifyJWS","jwsDecoded","verifyJWT","resolver","auth","audience","callbackUrl","skewTime","proofPurpose","prototype","hasOwnProperty","call","did","sub","sub_jwk","kid","didResolutionResult","resolveAuthenticator","nowSkewed","aud","audArray","matchedAudience","item","types","didResult","result","resolve","accept","getOwnPropertyNames","indexOf","didDocument","didDocumentMetadata","didResolutionMetadata","contentType","error","message","getPublicKeyById","verificationMethods","pubid","filtered","id","publicKeysToCheck","verificationMethod","publicKey","includes","assertionMethod","type","supported","validateJWE","jwe","protected","iv","recipients","rec","encrypted_key","encodeJWE","protectedHeader","recipient","aad","createJWE","cleartext","encrypters","encryptionResult","encrypt","tmpEnc","enc","reduce","acc","encrypter","cek","encryptCek","push","decryptJWE","decrypter","protHeader","sealed","Buffer","from","decrypt","i","createX25519ECDH","mySecretKey","theirPublicKey","sharedKey","createAuthEncrypter","recipientPublicKey","senderSecret","xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonEncrypter","x25519Encrypter","createAuthDecrypter","recipientSecret","senderPublicKey","xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonDecrypter","x25519Decrypter","xc20pEncrypter","cipher","XChaCha20Poly1305","randomBytes","nonceLength","seal","subarray","tagLength","xc20pDirEncrypter","xc20pEncrypt","encodedAad","xc20pDirDecrypter","open","epk","generateKeyPair","sharedSecret","kek","res","kty","partyUInfo","partyVInfo","apu","apv","zE","zS","resolveX25519Encrypters","dids","encryptersForDID","keyAgreement","agreementKeys","pks","Boolean","encrypterPromises","encrypterArrays","Promise","all","flattenedArray","validateHeader","receiverSecret","sealedCek"],"mappings":"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"}