"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateOutput = void 0;
var ts = require("typescript");
var typescript_1 = require("./helpers/typescript");
var package_version_1 = require("./helpers/package-version");
function generateOutput(params, options) {
    if (options === void 0) { options = {}; }
    var resultOutput = '';
    if (!options.noBanner) {
        resultOutput += "// Generated by dts-bundle-generator v".concat((0, package_version_1.packageVersion)(), "\n\n");
    }
    if (params.typesReferences.size !== 0) {
        var header = generateReferenceTypesDirective(Array.from(params.typesReferences));
        resultOutput += "".concat(header, "\n\n");
    }
    if (params.imports.size !== 0) {
        // we need to have sorted imports of libraries to have more "stable" output
        var sortedEntries = Array.from(params.imports.entries()).sort(function (firstEntry, secondEntry) {
            return firstEntry[0].localeCompare(secondEntry[0]);
        });
        var importsArray = [];
        for (var _i = 0, sortedEntries_1 = sortedEntries; _i < sortedEntries_1.length; _i++) {
            var _a = sortedEntries_1[_i], libraryName = _a[0], libraryImports = _a[1];
            importsArray.push.apply(importsArray, generateImports(libraryName, libraryImports));
        }
        if (importsArray.length !== 0) {
            resultOutput += "".concat(importsArray.join('\n'), "\n\n");
        }
    }
    var statements = params.statements.map(function (statement) { return getStatementText(statement, params); });
    if (options.sortStatements) {
        statements.sort(compareStatementText);
    }
    resultOutput += statementsTextToString(statements, params);
    if (params.renamedExports.length !== 0) {
        resultOutput += "\n\nexport {\n\t".concat(params.renamedExports.sort().join(',\n\t'), ",\n};");
    }
    if (options.umdModuleName !== undefined) {
        resultOutput += "\n\nexport as namespace ".concat(options.umdModuleName, ";");
    }
    // this is used to prevent importing non-exported nodes
    // see https://stackoverflow.com/questions/52583603/intentional-that-export-shuts-off-automatic-export-of-all-symbols-from-a-ty
    resultOutput += "\n\nexport {};\n";
    return resultOutput;
}
exports.generateOutput = generateOutput;
function statementTextToString(s) {
    if (s.leadingComment === undefined) {
        return s.text;
    }
    return "".concat(s.leadingComment, "\n").concat(s.text);
}
function statementsTextToString(statements, helpers) {
    var statementsText = statements.map(statementTextToString).join('\n');
    return spacesToTabs(prettifyStatementsText(statementsText, helpers));
}
function prettifyStatementsText(statementsText, helpers) {
    var sourceFile = ts.createSourceFile('output.d.ts', statementsText, ts.ScriptTarget.Latest, false, ts.ScriptKind.TS);
    var printer = ts.createPrinter({
        newLine: ts.NewLineKind.LineFeed,
        removeComments: false,
    }, {
        substituteNode: function (hint, node) {
            // `import('module').Qualifier` or `typeof import('module').Qualifier`
            if (ts.isImportTypeNode(node) && node.qualifier !== undefined && helpers.needStripImportFromImportTypeNode(node)) {
                if (node.isTypeOf) {
                    // I personally don't like this solution because it spreads the logic of modifying nodes in the code
                    // I'd prefer to have it somewhere near getStatementText or so
                    // but at the moment it seems that it's the fastest and most easiest way to remove `import('./module').` form the code
                    // if you read this and know how to make it better - feel free to share your ideas/PR with fixes
                    // tslint:disable-next-line:deprecation
                    return ts.createTypeQueryNode(node.qualifier);
                }
                return ts.createTypeReferenceNode(node.qualifier, node.typeArguments);
            }
            return node;
        },
    });
    return printer.printFile(sourceFile).trim();
}
function compareStatementText(a, b) {
    if (a.text > b.text) {
        return 1;
    }
    else if (a.text < b.text) {
        return -1;
    }
    return 0;
}
function needAddDeclareKeyword(statement, nodeText) {
    // for some reason TypeScript allows to not write `declare` keyword for ClassDeclaration, FunctionDeclaration and VariableDeclaration
    // if it already has `export` keyword - so we need to add it
    // to avoid TS1046: Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier.
    if (ts.isClassDeclaration(statement) && (/^class\b/.test(nodeText) || /^abstract\b/.test(nodeText))) {
        return true;
    }
    if (ts.isFunctionDeclaration(statement) && /^function\b/.test(nodeText)) {
        return true;
    }
    if (ts.isVariableStatement(statement) && /^(const|let|var)\b/.test(nodeText)) {
        return true;
    }
    if (ts.isEnumDeclaration(statement) && (/^(const)\b/.test(nodeText) || /^(enum)\b/.test(nodeText))) {
        return true;
    }
    return false;
}
function getStatementText(statement, helpers) {
    var shouldStatementHasExportKeyword = helpers.shouldStatementHasExportKeyword(statement);
    var needStripDefaultKeyword = helpers.needStripDefaultKeywordForStatement(statement);
    var hasStatementExportKeyword = ts.isExportAssignment(statement) || (0, typescript_1.hasNodeModifier)(statement, ts.SyntaxKind.ExportKeyword);
    var nodeText = getTextAccordingExport(statement.getText(), hasStatementExportKeyword, shouldStatementHasExportKeyword);
    if (ts.isEnumDeclaration(statement)
        && (0, typescript_1.hasNodeModifier)(statement, ts.SyntaxKind.ConstKeyword)
        && helpers.needStripConstFromConstEnum(statement)) {
        nodeText = nodeText.replace(/\bconst\s/, '');
    }
    // strip the `default` keyword from node
    if ((0, typescript_1.hasNodeModifier)(statement, ts.SyntaxKind.DefaultKeyword) && needStripDefaultKeyword) {
        // we need just to remove `default` from any node except class node
        // for classes we need to replace `default` with `declare` instead
        nodeText = nodeText.replace(/\bdefault\s/, ts.isClassDeclaration(statement) ? 'declare ' : '');
    }
    if (needAddDeclareKeyword(statement, nodeText)) {
        nodeText = "declare ".concat(nodeText);
    }
    var result = {
        text: nodeText,
    };
    // add jsdoc for exported nodes only
    if (shouldStatementHasExportKeyword) {
        var start = statement.getStart();
        var jsDocStart = statement.getStart(undefined, true);
        var nodeJSDoc = statement.getSourceFile().getFullText().substring(jsDocStart, start).trim();
        if (nodeJSDoc.length !== 0) {
            result.leadingComment = nodeJSDoc;
        }
    }
    return result;
}
function generateImports(libraryName, imports) {
    var fromEnding = "from '".concat(libraryName, "';");
    var result = [];
    // sort to make output more "stable"
    Array.from(imports.starImports).sort().forEach(function (importName) { return result.push("import * as ".concat(importName, " ").concat(fromEnding)); });
    Array.from(imports.requireImports).sort().forEach(function (importName) { return result.push("import ".concat(importName, " = require('").concat(libraryName, "');")); });
    Array.from(imports.defaultImports).sort().forEach(function (importName) { return result.push("import ".concat(importName, " ").concat(fromEnding)); });
    if (imports.namedImports.size !== 0) {
        result.push("import { ".concat(Array.from(imports.namedImports).sort().join(', '), " } ").concat(fromEnding));
    }
    return result;
}
function generateReferenceTypesDirective(libraries) {
    return libraries.sort().map(function (library) {
        return "/// <reference types=\"".concat(library, "\" />");
    }).join('\n');
}
function getTextAccordingExport(nodeText, isNodeExported, shouldNodeBeExported) {
    if (shouldNodeBeExported && !isNodeExported) {
        return 'export ' + nodeText;
    }
    else if (isNodeExported && !shouldNodeBeExported) {
        return nodeText.slice('export '.length);
    }
    return nodeText;
}
function spacesToTabs(text) {
    // eslint-disable-next-line no-regex-spaces
    return text.replace(/^(    )+/gm, function (substring) {
        return '\t'.repeat(substring.length / 4);
    });
}
