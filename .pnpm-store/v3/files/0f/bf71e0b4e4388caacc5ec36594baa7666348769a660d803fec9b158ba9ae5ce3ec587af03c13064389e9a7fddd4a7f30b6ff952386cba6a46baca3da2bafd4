{"version":3,"file":"Histogram.js","sourceRoot":"","sources":["../../../src/aggregator/Histogram.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  Histogram,\n} from './types';\nimport { HistogramMetricData, DataPointType } from '../export/MetricData';\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\n\nfunction createNewEmptyCheckpoint(boundaries: number[]): Histogram {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts,\n    },\n    sum: 0,\n    count: 0,\n  };\n}\n\nexport class HistogramAccumulation implements Accumulation {\n  constructor(\n    private readonly _boundaries: number[],\n    private _current: Histogram = createNewEmptyCheckpoint(_boundaries)\n  ) {}\n\n  record(value: number): void {\n    this._current.count += 1;\n    this._current.sum += value;\n\n    for (let i = 0; i < this._boundaries.length; i++) {\n      if (value < this._boundaries[i]) {\n        this._current.buckets.counts[i] += 1;\n        return;\n      }\n    }\n    // value is above all observed boundaries\n    this._current.buckets.counts[this._boundaries.length] += 1;\n  }\n\n  toPointValue(): Histogram {\n    return this._current;\n  }\n}\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements Aggregator<HistogramAccumulation> {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n\n  /**\n   * @param _boundaries upper bounds of recorded values.\n   */\n  constructor(private readonly _boundaries: number[]) {}\n\n  createAccumulation() {\n    return new HistogramAccumulation(this._boundaries);\n  }\n\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(previous: HistogramAccumulation, delta: HistogramAccumulation): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    return new HistogramAccumulation(previousValue.buckets.boundaries, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: mergedCounts,\n      },\n      count: previousValue.count + deltaValue.count,\n      sum: previousValue.sum + deltaValue.sum,\n    });\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous: HistogramAccumulation, current: HistogramAccumulation): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(previousValue.buckets.boundaries, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: diffedCounts,\n      },\n      count: currentValue.count - previousValue.count,\n      sum: currentValue.sum - previousValue.sum,\n    });\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    accumulationByAttributes: AccumulationRecord<HistogramAccumulation>[],\n    startTime: HrTime,\n    endTime: HrTime): Maybe<HistogramMetricData> {\n    return {\n      descriptor,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      })\n    };\n  }\n}\n"]}