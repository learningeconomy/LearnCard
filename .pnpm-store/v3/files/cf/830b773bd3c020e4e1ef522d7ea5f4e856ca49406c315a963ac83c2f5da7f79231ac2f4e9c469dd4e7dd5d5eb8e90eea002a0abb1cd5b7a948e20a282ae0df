{"version":3,"sources":["index.tsx"],"names":[],"mappings":"AAEA,WAAc,kBAAd,CACA,WAAc,cAAd,CACA,WAAc,iBAAd,CACA,WAAc,qBAAd,CACA,WAAc,oBAAd,CACA,WAAc,2BAAd,CACA,WAAc,gBAAd,CACA,WAAc,gBAAd,CACA,WAAc,iCAAd,CACA,WAAc,qBAAd,CACA,WAAc,kBAAd,CACA,WAAc,qBAAd,CACA,WAAc,gBAAd","sourcesContent":["import * as React from 'react';\n\nexport * from './utils/arrayify';\nexport * from './utils/omit';\nexport * from './utils/getProp';\nexport * from './utils/displayName';\nexport * from './utils/focus-lock';\nexport * from './utils/isReactInstanceOf';\nexport * from './utils/styled';\nexport * from './utils/portal';\nexport * from './utils/createInstanceIfDefined';\nexport * from './utils/createSlots';\nexport * from './utils/debounce';\nexport * from './utils/fromEntries';\nexport * from './utils/logger';\n\n/* Utility Types */\n\n/** Mark some keys of an interface as required\n *\n * @property T - interface to augment\n * @property K - keys to convert to required\n *\n * @example\n * type Example = { foo?: string; bar?: string };\n * type WithFooRequired = Require<Example, 'foo'>;\n */\nexport declare type Require<T, K extends keyof T> = T & Required<Pick<T, K>>;\n\n/**\n * Get all of the props for an HTML element. Used to easily type\n * the rest props of a component.\n *\n * @property T - element to extend\n *\n * @example\n * interface CardProps extends Element<'div'> {\n *   isRound?: boolean;\n * }\n *\n * const Card: React.FC<CardProps> = ({ isRound, children, ...html }) => (\n *  <div {...html} style={{ borderRadius: isRound ? '4px' : 0 }}>\n *    {children}\n *  </div>\n * )\n * @example\n * const Card: React.FC<Element<'div'>> = ({ children, ...html }) => (\n *  <div {...html}>\n *    {children}\n *  </div>\n * )\n */\nexport type Element<\n  T extends keyof JSX.IntrinsicElements\n> = React.PropsWithoutRef<JSX.IntrinsicElements[T]>;\n\n/**\n * Create an interface that has all the properties of the input\n * interface set to 'never'.\n *\n * @property T - The input interface\n *\n * @example\n * type A = { a: string };\n * type B = { b: string };\n * type C = A & Never<B>;\n *\n * const test: C = {\n *   a: 'foo',\n *   b: 'bar' // <- This line will create an error\n * }\n */\nexport type Never<T> = { [P in keyof T]?: never };\n\n/**\n * Create an interface that only accepts one of the two provided interface\n *\n * @example\n * type A = { a: string };\n * type B = { b: string };\n * type C = OneOf<A, B>;\n *\n * const test: C = {\n *   a: 'foo',\n *   b: 'bar', // <- This line will create an error\n * }\n */\nexport type OneOf<T1, T2> = (T1 & Never<T2>) | (T2 & Never<T1>);\n\n/**\n * Create an interface that only accepts one of the three provided interface\n *\n * @example\n * type A = { a: string };\n * type B = { b: string };\n * type C = { c: string };\n * type D = OneOf<A, B, C>;\n *\n * const test: D = {\n *   a: 'foo',\n *   c: 'bar', // <- This line will create an error\n * }\n */\nexport type OneOf3<\n  T1,\n  T2,\n  T3,\n  NT1 = Never<T1>,\n  NT2 = Never<T2>,\n  NT3 = Never<T3>\n> = (T1 & NT2 & NT3) | (T2 & NT1 & NT3) | (T3 & NT1 & NT2);\n"]}
