{"version":3,"sources":["createSlots.tsx"],"names":["React","fromEntries","isReactInstanceOf","createInstanceIfDefined","arrayify","SLOT_KEY","getSlotToken","child","type","isSlotOf","identifier","token","forwardWithSlots","Component","forwarded","forwardRef","createSlots","props","componentMapping","omit","otherChildren","slotNames","Object","keys","components","map","slot","slots","prop","SlotComp","slotProps","Error","passThroughProps","entries","filter","key","undefined","includes","Children","forEach","children","slotName","find","propName","comp","push","length"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { fromEntries } from './fromEntries';\nimport { isReactInstanceOf } from './isReactInstanceOf';\nimport { createInstanceIfDefined } from './createInstanceIfDefined';\nimport { arrayify } from './arrayify';\n\nexport const SLOT_KEY = '_SLOT_';\n\ninterface Props {\n  // IDK how to get rid of this any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [prop: string]: any;\n  /** Children to display within the component */\n  children?: React.ReactNode;\n}\ntype AnyComponent = React.ComponentType<any>;\n\ninterface ComponentMapStrict {\n  // IDK how to get rid of this any\n  [name: string]: AnyComponent[];\n}\n\ntype SlotIdentifier = AnyComponent | AnyComponent[] | symbol;\n\ninterface ComponentMap {\n  // IDK how to get rid of this any\n  [name: string]: SlotIdentifier;\n}\n\ninterface Slots {\n  [prop: string]: React.ReactNode | React.ReactNode[];\n}\n\n/**\n * Gets the token to represent the slot on an element\n *\n * @param child - The React component or element you want to get the slot token from\n */\nexport function getSlotToken(child: any) {\n  if (!child) {\n    return;\n  }\n\n  return child.type ? child.type[SLOT_KEY] : child[SLOT_KEY];\n}\n\n/**\n * Check to see if a child component is an instance of the given slot\n *\n * @param child - The React child component instance to test\n * @param identifier - The React Component or Slot ID (Symbol) to test against\n */\nexport function isSlotOf(child: any, identifier: AnyComponent | symbol) {\n  const token =\n    typeof identifier === 'symbol' ? identifier : getSlotToken(identifier);\n  return token\n    ? getSlotToken(child) === token\n    : isReactInstanceOf(child, identifier as AnyComponent);\n}\n\n/** \n * Forward a ref and make the returned component slottable.\n * \n * @param Component - Same props you give to React.forwardRef\n * \n * @example\n * export const SlottedComponentWithRef = forwardWithSlots<\n *  HTMLDivElement,\n *  ContentCardProps,\n *  SubComponents\n * >((props, ref) => null);\n */\nexport const forwardWithSlots = <RefType, PropType, Slots>(\n  Component: React.RefForwardingComponent<RefType, PropType>\n) => {\n  const forwarded = React.forwardRef(Component);\n  return forwarded as typeof forwarded & Slots;\n};\n\n/**\n * Chunk child elements into buckets based on React components.\n * Will also return the rest of the props.\n *\n * @param props - The props to find the slots in. Either in props or children\n * @param componentMapping - A map of slot names to slot components\n * @param omit - A list of props to omit from the final returned props\n *\n * @example\n * const Example = props => {\n *   const { header, body, footer, ...html } = createSlots(props, {\n *     header: Header,\n *     body: Body,\n *     footer: Footer\n *   });\n *\n *   return (\n *     <div>\n *       {header}\n *       {body}\n *       {footer}\n *     </div>\n *   )\n * };\n *\n * // No matter what order given, it displays how we defined it!\n * const Usage = () => (\n *   <Example>\n *     <Footer>by me!</Footer>\n *     <Body>Some Text</Body>\n *     <Header>Title</Header>\n *   </Example>\n * )\n *\n * // or\n *\n * const Usage = () => (\n *   <Example>\n *     <Footer>by me!</Footer>\n *     <Body>Some Text</Body>\n *     <Header>Title</Header>\n *   </Example>\n * )\n */\nexport function createSlots<InputProps extends Props>(\n  props: InputProps,\n  componentMapping: ComponentMap,\n  omit: (keyof InputProps | string)[] = []\n): InputProps {\n  const otherChildren: React.ReactNode[] = [];\n  const slotNames = Object.keys(componentMapping);\n  const components: ComponentMapStrict = fromEntries(\n    slotNames.map(slot => [slot, arrayify(componentMapping[slot])])\n  );\n  const slots: Slots = fromEntries(\n    slotNames.map(prop => {\n      const SlotComp = components[prop][0];\n      const slotProps = props[prop];\n\n      if (typeof SlotComp === 'symbol' && slotProps) {\n        throw new Error(\n          `Cannot create instance for ${prop} when using slot tokens. Use children instead.`\n        );\n      }\n\n      return [prop, createInstanceIfDefined(slotProps, SlotComp)];\n    })\n  );\n  const passThroughProps: InputProps = fromEntries(\n    Object.entries(props).filter(\n      ([key]) => componentMapping[key] === undefined && !omit.includes(key)\n    )\n  );\n\n  React.Children.forEach(props.children, child => {\n    const slotName = slotNames.find(propName =>\n      components[propName].find(comp => isSlotOf(child, comp))\n    );\n\n    if (!slotName) {\n      return otherChildren.push(child);\n    }\n\n    const slot = slots[slotName];\n    slots[slotName] = slot ? [...arrayify(slot), ...arrayify(child)] : child;\n  });\n\n  return {\n    ...passThroughProps,\n    ...slots,\n    children: otherChildren.length ? otherChildren : undefined\n  };\n}\n"]}
